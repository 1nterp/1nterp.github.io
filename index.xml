<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>InterP Blog</title><link>https://1nterp.github.io/</link><description>Recent content on InterP Blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 17 Oct 2022 18:47:14 +0900</lastBuildDate><atom:link href="https://1nterp.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Tistory 에서 다시 Hugo 로</title><link>https://1nterp.github.io/essay/2022-10-17-tistory-%EC%97%90%EC%84%9C-%EB%8B%A4%EC%8B%9C-hugo-%EB%A1%9C/</link><pubDate>Mon, 17 Oct 2022 18:47:14 +0900</pubDate><guid>https://1nterp.github.io/essay/2022-10-17-tistory-%EC%97%90%EC%84%9C-%EB%8B%A4%EC%8B%9C-hugo-%EB%A1%9C/</guid><description>&lt;img src="https://1nterp.github.io/images/2022-10-17-tistory-hugo-blog.jpeg" alt="Featured image of post Tistory 에서 다시 Hugo 로" />&lt;h2 id="티스토리로-갔던-이유">티스토리로 갔던 이유&lt;/h2>
&lt;p>휴고에서 티스토리로 옮긴 지 두 달 밖에 되지 않았었다.&lt;/p>
&lt;p>이유는 여러 가지가 있었다. Forestry 나 VSCode 를 열어두고 글인지 코드인지 모를 포스트를 쓰는 것이 귀찮아졌고, 하나부터 열까지 내가 조정해 줘야 하는 것 보다는 쉽게 글을 쓰고 싶어서였다. 주로 한글로 된 포스팅을 올릴 거라, 휴고에서 구축해 둔 다국어 기능을 전부 활용할 수 없겠단 생각도 들었다. 그리고 티스토리에 올려두면 적어도 다음이나 카카오에서는 검색이 좀 더 활발하지 않을까 하는, 더 많은 유입을 고려한 결정도 있었다.&lt;/p>
&lt;h2 id="다시-휴고로-돌아온-이유">다시 휴고로 돌아온 이유&lt;/h2>
&lt;p>그러나, 이번에는 확실히 휴고로 돌아왔다.&lt;/p>
&lt;p>이유는 너무나 단순하고 어이없게도, &lt;a class="link" href="https://cs.kakao.com/helps?service=102&amp;amp;category=286&amp;amp;locale=ko&amp;amp;device=3136&amp;amp;articleId=1073204770" target="_blank" rel="noopener"
>10월 15일 카카오가 사용하는 데이터센터에 화재가 발생&lt;/a>하면서 티스토리도 같이 서비스가 중단되었기 때문이다. 현재는 로그인도 되고 글도 살릴 수는 있지만, 모바일 보기만 지원되고 다른 스킨으로 적용도 되지 않는다.&lt;/p>
&lt;p>구글 애널리틱스는 너의 사이트가 이상하다며, 조치를 취하라는 이메일을 일요일에 발송했었다. 지금은 구글 검색에 다 빠져 있을 것이다. 대부분의 티스토리 포스트가 구글 검색에서 썰물처럼 빠지고 있기 때문이다.&lt;/p>
&lt;p>물론 복구가 된다면, 다시 포스트가 검색되고 아무렇지 않게 지나갈 수 있을 것이다. 그런데 그 이틀 동안, 나 뿐만 아니라 다른 포스팅까지 정전이 일어났다는 사실이 나에겐 너무 크게 느껴졌다. 어떻게 보면 별 것 아닐 수 있다. 서비스라는 것이 장애도 있고 종료도 있을 거니까. 그렇다면 이 질문을 하지 않을 수 없다.&lt;/p>
&lt;blockquote>
&lt;p>장애나 종료 이후에, 내가 쓴 글을 쉽게 백업받을 수 있을까? &lt;br/>
백업 받은 걸 다른 곳에 쉽게 올릴 수 있을까?&lt;/p>
&lt;/blockquote>
&lt;p>네이버 블로그에서는 포스트를 PDF 로 떨궈준다. Confluence 백업을 받아둬도 그걸 파싱해 가는 데 한 세월이다. 결국 마크다운 만큼 기본 내용만큼은 쉽게 다른 곳에 옮길 수 있는 포맷이 없다.&lt;/p>
&lt;p>물론 티스토리도 마크다운을 지원한다. 지금도 잘 옮겨뒀다. 하지만 장애가 이렇게 나 버리면, 옮길 수가 없다. Github Pages 에 올려 둔 Hugo 는 다르다. 일단 내 컴퓨터에 로컬 저장소가 있다. 적어도 거기서 출발하면 된다. 장애가 나면 서버를 열고, 거기에 소스를 부어서 시작해도 된다. 티스토리는 그게 안 된다.&lt;/p>
&lt;p>서비스형 블로그의 한계를 너무 꼬집는다 생각할 수 있다. 이번에 그 한계가 진짜구나, 어쩔 수 없겠다 싶으니 다시 가지 않을 것이다.&lt;/p>
&lt;h2 id="다시-처음-이유를-돌아보자">다시 처음 이유를 돌아보자&lt;/h2>
&lt;p>글인지 코드인지 모를 포스트를 쓰는 것은 극복해야 할 문제 같다. 다양한 자동화 기능과 snippet 을 동원해야 한다. 포스트 마다 설정 가능한 옵션 파라메터를 확보해야 한다. 다국어 기능은 쓸 수 있을 때 쓰면 된다. 너무 욕심낼 필요는 없다. 유입을 더 많이 바라보기 보다는, 포트폴리오 성격으로 꾸준히 쓰는 게 중요한 것 같다. 괜찮은 글은 한 번 봐주십사 요청도 하고 다니면 어떨까 싶다.&lt;/p>
&lt;p>플랫폼이 중요한 게 아니었다. 사실 디자인도 우선순위가 높은 작업이 아니다.&lt;/p>
&lt;p>결국 무슨 내용이 살고 있는지가 중요한 것 같다.&lt;/p></description></item><item><title>그럴 땐 바로 토끼시죠 (2019)</title><link>https://1nterp.github.io/rabbit-run-away-in-this-case/</link><pubDate>Mon, 08 Aug 2022 00:48:00 +0000</pubDate><guid>https://1nterp.github.io/rabbit-run-away-in-this-case/</guid><description>&lt;img src="https://1nterp.github.io/images/2022-10-16-toki-cover.png" alt="Featured image of post 그럴 땐 바로 토끼시죠 (2019)" />&lt;p>인스타툰으로 (나를 포함한) 많은 팔로워를 둔 지수 작가의 첫 번째 에세이. 인스타그램에선 몇 장의 사진으로 하나의 포스트를 이루는데, 다양한 관계와 이따금씩 드는 기분에 대하여 친근하면서도 진솔한 해석을 남긴다. 독자에게 공감을 남기면서도, 따뜻한 위로를 건네주는 것 같다.&lt;/p>
&lt;p>책은 주로 작가의 일상에서 출발해 어떤 생각에 도달했는지를 풀어나가지만, 비단 작가 개인만이 느꼈던 것은 아니었을 보편적인 감정이기 때문에 공감하기 쉬운 주제들로 엮었다. &lt;em>너도 이런 비슷한 경험을 해보지 않았을까?&lt;/em> 그런 질문이 결코 강압적이지 않고, 너가 무슨 생각이 들던 나는 그랬다며 미소짓는 듯하다. 이 책은 마치 김토끼의 얼굴을 닮았다.&lt;/p>
&lt;h2 id="기억나는-문구">기억나는 문구&lt;/h2>
&lt;p>몇 가지 기억나는 부분을 표시했는데, 필사를 해 보니 다음이 남았다. (허락받고 발췌해야 하나?!)&lt;/p>
&lt;blockquote>
&lt;p>나를 찾아가는 여정에 지름길은 없다. 누구도 명쾌하게 답해 주지 않는다.&lt;br>
&lt;strong>인생에는 긴지 짧은지 대 볼 수 있는 명확한 줄자가 없기 때문이다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>다른 사람이 이뤄낸 것을 내가 꼭 이뤄야 할 필요는 없다. 모든 분야를 잘 하는 사람은 현실적으로 존재하지 않는데도, 우리는 예전보다 남들과 비교하기 좋은 세상에 살고 있다. 유튜브, 인스타그램, 페이스북, 블로그, 연예 기사를 보면서 우리보다 잘난 사람들의 이야기를 끊임없이 듣는다. 때로는 그 이야기 속에 &amp;lsquo;여러분도 저 처럼 될 수 있어요!&amp;rsquo; 라며 그들만의 줄자를 나에게 들이밀 때도 있다. 잠시 그 소음을 내려놓고, 내가 정말 원하는 것은 무엇인지 나만의 줄자를 만들어야 한다. 중요한 건, 그게 다른 사람의 것보다 하찮고 짧아도 아무런 상관이 없다는 것!&lt;/p>
&lt;blockquote>
&lt;p>볼링 내기할 때만 그러면 좋으련만 나는 평소에도 내 손을 떠난 일에 시간과 정신을 쏟곤 한다.&lt;br>
&lt;strong>할 수 있는게 아무것도 없어졌을 때 오히려 더 악착같이 집착할 때도 있다.&lt;/strong>&lt;br>
볼링공을 던져놓고 허공에다 대고 허우적거리는 것처럼 말이다.&lt;/p>
&lt;/blockquote>
&lt;p>나 또한 어쩔 수 없는 일에 걱정이 많은 타입인데, 비유가 너무나도 찰지다. 내 손에서 떠난 볼링공을 손짓 발짓을 해가며 기다리는 것. 기우제가 따로 없다.&lt;/p>
&lt;blockquote>
&lt;p>(구독자들에게) 고마운 것은 그뿐이 아니다.&lt;br>
&lt;strong>그들은 콘텐츠를 소비하는 사람이기에 앞서 나와 공감대를 형성하는 사람들이다.&lt;/strong>&lt;br>
그 존재 덕에 큰 위로를 받는다.&lt;/p>
&lt;/blockquote>
&lt;p>내 이야기를 들어주는 사람, 내 생각에 반응해주는 사람이 있다는 것은 얼마나 고마운가. 작가가 다른 사람들에게 영향을 줄 수 있는 것만큼이나, 구독자들도 작가에게 응원을 보내주는 것이라 여긴다면, 글을 쓰거나 그림을 그리면서 내가 가는 방향이 틀리진 않았다는 뜻이지 않을까.&lt;/p>
&lt;blockquote>
&lt;p>세계 여행 경비 마련을 위해 단기로 일거리를 구한 프리랜서, 사직서 한 장을 늘 품고 다니는 마케터, 꿈의 회사로 이직할 작정으로 경력을 쌓는 회사원, 자기가 만든 아이스크림을 먹지 않는 아이스크림 회사 사장, 책보다는 커피를 좋아하는 서점 주인, 틈틈이 쓴 소설로 매해 신춘문예에 응모하는 독서실 아르바이트생 등등…&lt;/p>
&lt;/blockquote>
&lt;p>기가막힌 플로우를 타고 흐르는 래핑 같아서, 가장 애정하는 문구이다. 특히 ‘&lt;em>아이스크림 안 먹는 사장&lt;/em>’ 에서 머리가 뎅- 울렸다. 우리는 회사 이름 뒤에, 직함 뒤에, 직업 뒤에 숨어서 우리 삶을 과하게 일반화시키고 있는 건 아닐까? 그 안에서 우리는 반짝반짝 다른 사람과 전혀 다른 빛깔을 때깔나게 발산할 수 있는데, 그 뒤에 숨어버려서 남들 하는 만큼만 하고 말아버리는 것일지도.&lt;/p>
&lt;h2 id="에세이의-힘">에세이의 힘&lt;/h2>
&lt;p>이 책을 읽으면서, 때때로 내 과거는 다른 사람의 과거와 ‘똑’ 같을 수가 없더라도, 그 안에서 내가 생각한 것들을 이렇게 남들에게 공유하는 것만으로도 쉽게 공감을 이끌어 낼 수 있을 것 같은 용기를 얻었다. 물론 이렇게 잘 할 순 없겠지만, 누구나 처음부터 잘 하는 것은 아니었을 테니까. 책에서 이야기하는 마지막 구절. &lt;strong>의무적으로 꿈을 꾸는, 노력하는 시간을 들여야 언젠간 꿈에 닿을 수 있다고 한다.&lt;/strong> 이렇게 공돌이 한 명은, 전공과 전혀 다른 기묘한 꿈을 꾸어 본다. 나는 이제부터 토끼지 않을 거니까.&lt;/p></description></item><item><title>그레이 맨 (The Gray Man, 2022)</title><link>https://1nterp.github.io/the-gray-man-2022/</link><pubDate>Sat, 06 Aug 2022 23:38:00 +0000</pubDate><guid>https://1nterp.github.io/the-gray-man-2022/</guid><description>&lt;img src="https://1nterp.github.io/images/2022-10-16-grey-man-poster.jpeg" alt="Featured image of post 그레이 맨 (The Gray Man, 2022)" />&lt;p>살인 혐의로 수감된 범죄자가, CIA 가 주도하는 프로그램에 참여한다. 정보가 없기 때문에, 죽어도 기록이 남지 않는 비밀 요원이 된다. 코드네임은 &amp;lsquo;&lt;em>식스&lt;/em>&amp;rsquo;. 몇년 뒤, 누군가가 CIA 의 극비 정보를 넘긴다는 첩보를 입수하고, 그를 제거하기 위해 식스가 나선다. 잡고 보니 그 역시 같은 프로그램 소속이었고 식스를 알아본다. 극비 정보가 담긴 칩은 사실 CIA 의 치부라며 식스에게 넘겨주고, 식스는 이 칩을 숨기게 된다. 센터장은 그가 숨기고 있다고 확신하며, 소시오패스 프리랜서 킬러인 &amp;lsquo;&lt;em>로이드&lt;/em>&amp;rsquo; 에게 그를 제거하라고 지시한다.&lt;/p>
&lt;h2 id="주연들">주연들&lt;/h2>
&lt;ul>
&lt;li>마블 시네마틱 유니버스를 주도한 루소 형제의 넷플릭스 영화이다. 그래서 크리스 에반스라는 이름이 있는 것이 자연스러워 보인다. 그런데, 막상 영화를 보고 있으면 &amp;lsquo;그래서 캡틴 아메리카는 어디 있나요?&amp;rsquo; 같은 생각이 든다. 그보다는 &amp;lsquo;나이브스 아웃&amp;rsquo; 의 랜섬이 콧수염 붙이고 포마드를 더 씨게 발라 나왔다고 보는 편이 맞다. 이마저도 틀린 비유일 정도로, 유니크한 소시오패스 연기를 잘 했다고 생각한다.&lt;/li>
&lt;li>&amp;lsquo;나이브스 아웃&amp;rsquo; 영화 이야기가 나왔으니 또 언급해야 할 사람이 아나 데 아르마스이다. 같은 영화에서 이민자 가정부 역할로 나왔던 순진한 소녀는 어디로 가고, 여기서는 단발에 액션도 불사하는 요원으로 분했다. &amp;lsquo;블레이드 러너 2049&amp;rsquo; 에서도 출연한 걸 보니, 다른 주연들간의 연결고리가 제법 있는 편.&lt;/li>
&lt;li>라이언 고슬링이 저렇게 벌크업을 했던 영화가.. 있구나, 블레이드 러너. 그래도 여기서는 육탄 액션을 마음껏 선보인다. 특유의 능글맞음이 영화에도 녹아있지만, 그것이 라이언 레이놀즈의 깨방정보다는 훨씬 진지하다. ~그리고 이런 농담따먹기는 로이드가 더 많이 한다.~&lt;/li>
&lt;/ul>
&lt;h2 id="본-시리즈-를-생각하고-왔는데">&amp;lsquo;본 시리즈&amp;rsquo; 를 생각하고 왔는데?&lt;/h2>
&lt;p>일단 &lt;em>여러 도시를 누빈다는 설정 + 정보기관이 버린 먼치킨 주인공 + 싸이코 빌런&lt;/em> 설정은 제이슨 본 시리즈의 공식을 따라했다고 생각한다. 맨몸 액션도 다수 섞은 걸 보면 거의 계승한 듯 싶다. 하지만 차이점은 분명한데, 일단 ~카 체이싱 장면이 없잖아!~ 식스가 탈출하거나 진입하는데 개연성이 심히 떨어진다. 그냥 목표에 접근하거나 목적을 이루는 과정은 생략되었다. 이런 사이다를 좋아할 사람들도 있겠지만, 나는 잘 모르겠다.&lt;/p>
&lt;p>그리고 긴장을 가하거나 해소하는 과정에서 왜 저래? 싶은 장면이 한 두개가 아니다. 지나보니 로이드 편에 선 사람은 없었던 게 되고, 프로그램을 주도했던 &amp;lsquo;피츠&amp;rsquo; 의 퇴장은 너무 뻔했다. 일단 다 차치하고, 잔인한 소시오패스라고 하면서, 난 이대로 못 간다며 식스와 1:1 맞짱을 뜬다고? 아니, 이 장면은 &amp;lsquo;강력3반&amp;rsquo; 엔딩 생각나는데&amp;hellip; 맙소사. &lt;del>저기서도 윤태영이 사이코패스 악역이잖아&lt;/del>&lt;/p>
&lt;p>그렇다면 액션은 좋은지? 볼 당시에 피곤해서 그런건지는 모르겠는데, 잠이 솔솔 왔다는 점만 이야기하고 싶다. 딱 넷플릭스 용 킬링 타임 블록버스터 느낌이다. &amp;lsquo;레드 노티스&amp;rsquo; 보다는 스케일이 크고 더욱 짜임새가 좋기는 한데, 재미 면에선 별반 차이는 없는 듯 하다.&lt;/p>
&lt;p>★★★&lt;/p></description></item><item><title>아메리칸 셰프</title><link>https://1nterp.github.io/chef-2014/</link><pubDate>Sun, 17 Jul 2022 17:41:57 +0000</pubDate><guid>https://1nterp.github.io/chef-2014/</guid><description>&lt;img src="https://1nterp.github.io/images/2022-07-18-untitled.png" alt="Featured image of post 아메리칸 셰프" />&lt;h2 id="줄거리">줄거리&lt;/h2>
&lt;p>셰프라는 직업에 자부심이 강한 주인공 칼은, 파워 블로거 평론가를 맞이하기 위해 자신만의 코스 요리를 준비하지만, 레스토랑에서 늘 만들던 대로 하라는 사장의 만류에 막히고 만다. 평론가에게 혹평을 받게 되고, 트위터를 통해 많은 사람들의 입방아에 오르내리고 만다.&lt;/p>
&lt;p>사업가 아내와 이혼한 뒤, 10살 아들을 주기적으로 돌보던 어느 날, 트위터가 뭔지 몰랐던 칼은 아들을 통해 사용하는 방법을 배우고 계정을 만들게 된다. 그리고 평론가에게 욕설과 함께 다시 와서 먹어보라는 &amp;lsquo;답글&amp;rsquo; 을 남긴다. 이 스레드는 공개되어 세간의 관심을 모으게 되고, 평론가 역시 재도전을 흥미진진하게 받아들이며 레스토랑으로 향한다.&lt;/p>
&lt;p>하지만 다시 한 번, 칼은 만들던 메뉴를 대접하라는 사장의 압박을 받았고, 이 레스토랑은 내 것이지 네 것이 아니란 말과 함께 만들던지 나가던지 선택을 하라고 한다. 결국 칼은 다 집어던지고 나갔다가, &amp;ldquo;이 셰프는 쫄아서 안 나왔네&amp;rdquo; 라는 평론가의 트윗을 보고 다시 찾아가 면전에 욕설을 토해낸다.&lt;/p>
&lt;p>그리고 깔끔하게 망했다. 칼을 불러주는 사람은 없었다. 그 때 마침, 전 아내가 처갓집이 있는 곳에 아들 보모 역할로 같이 가자며, 가면 좋은 수가 생기지 않겠냐고 제안했다. 사실 아내는 그의 독단적인 기질을 살리려면 푸드트럭을 하는게 차라리 낫겠다고 제안한 적이 있었고, 실제로 아내는 전 남편 (칼 말고)에게 부탁해 둬서 푸드트럭을 하나 인계하게끔 말을 다 맞춰둔 상태.&lt;/p>
&lt;p>물론 그렇게 받은 트럭은 고물이었지만, 레스토랑에서 자기만 보고 그만두고 따라나온 마틴과 함께 트럭을 치우고 새 출발을 한다. 그리고 아들 역시 큰 도움을 준다. 요리도 하고, 트위터로 홍보도 하면서. 그렇게 집으로 가는 동안 푸드트럭은 가는 곳 마다 성행했고, 세 사람 특히 칼과 아들의 우정도 돈독해진다.&lt;/p>
&lt;h2 id="대사">대사&lt;/h2>
&lt;blockquote>
&lt;p>“그렇다 치고 음식이나 문화 말이야, 베녜 같은거”&lt;br>
”여기서도 팔잖아”&lt;br>
&lt;strong>”완전히 달라. 여기서도 맛있는 건, 거기서 먹었던 기억이 떠오르는 거야”&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>주인공인 칼은 유독 음식의 본고장에서 먹는 것이 진짜 맛이라고 말하는데, 너무 마음에 드는 표현이다. 정말 음식 자체만 놓고 보면 한국에서 똑같이 만들면 맛은 똑같이 나겠지만 지역의 공기, 환경에 크게 좌우한다고 생각한다. 극단적으로 그 때의 기분, 날씨같은 우연의 요소까지 머리가 기억하고, 단지 그 음식이 그 때의 기억을 당기는 방아쇠가 되는 것이라고 믿기 때문이다.&lt;/p>
&lt;p>결국 둘은 뉴올리언스에 가서 베녜를 먹으러 갔다.&lt;/p>
&lt;h2 id="여담">여담&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>존 파브로가 아이언맨 1,2 감독&lt;/strong>이었다니, 영화보기 직전까지 몰랐다. 그래서 로다주와 스칼렛 요한슨이 나온 걸지도 모르겠다. (다른 배우도 쟁쟁하다, 사장님이 더스틴 호프만이라고요?)&lt;/li>
&lt;li>전처로 나온 소피아 베르가라가 정말 예쁘다. 만날 때 마다 입고 있는 옷이 바뀌는데, 패션쇼인가? 스칼렛 요한슨도 물론 예쁘다. 파스타 기다리는데, 왜 어께 다 흘러내리게 누워 계세요?&lt;/li>
&lt;li>로다주가 맡은 캐릭터는 결벽증에 의심병 환자에 전남편끼리 만나서 한다는 소리부터 저질이다. 물론 캐릭터가 그렇다는 것이다.&lt;/li>
&lt;li>결국 영화는 해피엔딩으로 끝난다. 평론가 아조씨는 ‘내가 알던 그 칼이 돌아왔다’ 며 사업제안을 하고, 셰프 전권을 보장해주는 조건으로 레스토랑으로 칼을 스카웃 해간다.&lt;/li>
&lt;/ul></description></item><item><title>A tour of Go: Pointer, Struct, Array, Slice</title><link>https://1nterp.github.io/tour-of-go-pointer-struct-array-slice/</link><pubDate>Sun, 03 Jul 2022 17:06:37 +0000</pubDate><guid>https://1nterp.github.io/tour-of-go-pointer-struct-array-slice/</guid><description>&lt;p>Go 여행 세 번째 시간이다. &lt;a class="link" href="https://interp.blog/tour-of-go-flow-control-stmts/" target="_blank" rel="noopener"
>지난 시간&lt;/a>에는 flow control statement 에 대해서 알아봤다. 이번에는 Go 언어의 다양한 자료형에 대해 정리해 봤다.&lt;/p>
&lt;h2 id="a-tour-of-go">A tour of Go&lt;/h2>
&lt;ul>
&lt;li>English: &lt;a class="link" href="https://go.dev/tour/" title="https://go.dev/tour/"
target="_blank" rel="noopener"
>https://go.dev/tour/&lt;/a>&lt;/li>
&lt;li>한국어판: &lt;a class="link" href="https://go-tour-ko.appspot.com/" title="https://go-tour-ko.appspot.com/"
target="_blank" rel="noopener"
>https://go-tour-ko.appspot.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="pointer">Pointer&lt;/h2>
&lt;ul>
&lt;li>C/C++ 처럼, golang 에도 포인터가 있다.&lt;/li>
&lt;li>NULL 표현은 &lt;code>nil&lt;/code> 이다.&lt;/li>
&lt;li>그 외엔.. 뭐 C pointer 쓰는 거랑 별로 다를게 없다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">42&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2701&lt;/span>
&lt;span class="nx">p&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">i&lt;/span> &lt;span class="c1">// point to i
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// read i through the pointer = 42
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">21&lt;/span> &lt;span class="c1">// set i through the pointer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// see the new value of i = 21
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">j&lt;/span> &lt;span class="c1">// point to j
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">37&lt;/span> &lt;span class="c1">// divide j through the pointer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// see the new value of j = 73
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="struct">Struct&lt;/h2>
&lt;p>C 의 struct 와 동일한, field 들의 모음이다.&lt;/p>
&lt;p>C 였다면 &lt;code>typedef type struct Vertex { ... } Vertex;&lt;/code> 이라고 typedef 를 곁들여야 하지만, 여기서는 &lt;code>type&lt;/code> 만 써도 된다. 사실상 &lt;code>type&lt;/code> 하나가 위의 &lt;code>typedef ...&lt;/code> 전체를 모두 커버한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>var [변수명] [타입]&lt;/code> 처럼 &lt;code>type [타입명] struct&lt;/code> 인 것을 잘 기억해 두자.&lt;/li>
&lt;li>struct 형 변수를 초기화할 때는 &lt;code>{ }&lt;/code> 로 써야 한다.&lt;/li>
&lt;li>각 field 는 &lt;code>.&lt;/code> 을 사용해서 참조할 수 있다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">type&lt;/span> &lt;span class="nx">Vertex&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">X&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="nx">Y&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Vertex&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">})&lt;/span> &lt;span class="c1">// {1, 2} 라고 표시된다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="struct-pointer">Struct Pointer&lt;/h3>
&lt;p>원래 C 같았으면 struct pointer 변수에서 특정 필드를 참조하려면 &lt;code>(*p).X&lt;/code> 이런 식으로, 포인터의 struct 값을 dereference 한 다음에 참조하거나, &lt;code>p-&amp;gt;X&lt;/code> 같은 식으로 &amp;lsquo;포인터 변수&amp;rsquo; 라는 걸 나타내서 참조하는데.. 여기서는 둘 다 귀찮으니까 &lt;code>p&lt;/code> 가 struct pointer 라도 &lt;code>p.X&lt;/code> 로 참조가 가능하게 했다.&lt;/p>
&lt;pre>&lt;code>func main() {
v := Vertex{1, 2}
p := &amp;amp;v
p.X = 1e9 // 이렇게만 참조하고 값까지 할당하는데, 아무런 문제가 없다.
fmt.Println(v) // {1000000000 2}
}
&lt;/code>&lt;/pre>
&lt;h3 id="struct-literals">Struct Literals&lt;/h3>
&lt;p>Struct 형 변수 초기화할 때 취할 수 있는 방법을 소개한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>보통 unnamed list 를 할 것이다. &lt;code>Vertex{1,2}&lt;/code> 처럼&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>named list 도 가능한데, &lt;code>[field name]:&lt;/code> 으로 쓴다. function 의 default parameter 와는 달리, 여기선 순서는 상관없다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>값을 넣지 않으면, 각 필드의 기본값이 들어간다. (여기서는 int 니까 0)&lt;/p>
&lt;p>var (
v1 = Vertex{1, 2} // has type Vertex
v2 = Vertex{X: 1} // Y:0 is implicit
v3 = Vertex{} // X:0 and Y:0
p = &amp;amp;Vertex{1, 2} // has type *Vertex
)&lt;/p>
&lt;p>func main() {
fmt.Println(v1, v2, v3, p) // {12} {1 0} {0 0} &amp;amp;{1 2}
}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="array">Array&lt;/h2>
&lt;p>Slice 와는 달리, 사이즈가 고정된다.&lt;/p>
&lt;ul>
&lt;li>C 처럼 length 가 뒤에 오지 않고, 앞에 온다.&lt;/li>
&lt;li>출력하면 struct 와는 달리 꺽쇠 &lt;code>[ ]&lt;/code> 로 출력된다.&lt;/li>
&lt;li>&lt;strong>하지만 literal 선언은 (slice 와 마찬가지로) &lt;code>{ }&lt;/code> 안에서 원소를 나열해야 한다.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="slice">Slice&lt;/h2>
&lt;p>Array 에서 length number 만 지우면, slice 가 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>array 또는 slice 에서 index range 를 지정할 수 있는데, C array index 를 생각해도 헷갈릴 수 있는 부분이다.
&lt;ul>
&lt;li>수학적으로 정확한 range 표현은 &lt;code>[n:m)&lt;/code> 이다. 마지막 인덱스에 해당하는 원소는 &lt;strong>포함이 안 된다&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">primes&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">13&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">primes&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 3, 5, 7, 11 인가?
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [3 5 7] 만 출력된다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>Slice 는 단독으로 쓰이기도 하지만, 보통은 array 의 특정 구간을 나타내기 위해서도 쓰인다. 주의할 점은, Slice 가 바뀌면 연결된 array 도 같이 바뀐다는 것이다 (&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">names&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span> &lt;span class="c1">// 어.. 비틀즈 성님덜?
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="s">&amp;#34;John&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;Paul&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;George&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;Ringo&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">names&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">names&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// [John Paul]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">b&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">names&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// [Paul George]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;XXX&amp;#34;&lt;/span> &lt;span class="c1">// 아니 왜 폴 메카트니 성님을 지워여;;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 폴의 이름이 다 바뀌어 있음.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">names&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 그리고 원래 array 에도 영향이..
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>[n:m]&lt;/code> 으로 구간을 나눌 때 양쪽 end 를 생략할 수도 있고, 둘 다 생략할 수도 있다.
&lt;ul>
&lt;li>왼쪽 생략 = 0&lt;/li>
&lt;li>오른쪽 생략 = 끝까지&lt;/li>
&lt;li>양쪽 생략 = 그냥 그 array/slice 전체 (&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>slice 안에 당연히 struct 를 쓸 수 있다. 그래서 이런 괴상망측한 하지만 자주 보게 될 선언도 있다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="c1">// 이런게 가능합니다...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 이렇게 typed value 를 바로 선언하는 걸 literal 이라고 하는데,
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// slice 건 struct 건 간에 literal 은 [] 가 아니라 {} 로 해야 한다.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="nx">b&lt;/span> &lt;span class="kt">bool&lt;/span>
&lt;span class="p">}{&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>slice 는 length &lt;code>len()&lt;/code> 과 와 capacity &lt;code>cap()&lt;/code> 을 지원한다.
&lt;ul>
&lt;li>&lt;code>len()&lt;/code> : 실제 원소들의 개수&lt;/li>
&lt;li>&lt;code>cap()&lt;/code> : 하위 array 의 개수 (array 는 fixed-width 라고 했다)
&lt;ul>
&lt;li>이게 언제 필요하냐면, slicing 할 수 있는 길이를 가늠할 때 (만약 cap 이 6인데 &lt;code>[:7]&lt;/code> 이렇게 쓰면 에러가 나버린다.&lt;/li>
&lt;li>중요한 건, underlying array 에서, slice 의 first element 가 가리키는 위치 부터 끝까지의 길이이다 (끝 인덱스는 상관없는게 또 헷갈린다..)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">13&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Slice the slice to give it zero length.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 끝이 지정되어 있지 않으니 cap 은 6임. length 는 당연히 0이고.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Extend its length.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 0~4 까지니까 length 는 5이고, 역시 끝이 지정되어 있지 않아서 cap 은 6임.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Drop its first two values.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">:]&lt;/span> &lt;span class="c1">// 마지막 slice 를 또 slicing 하지만, &amp;#39;처음 array&amp;#39; 에서 2번째 element 부터의 array 길이가 cap 이므로
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 5,7,11,13 -&amp;gt; 4임. ㄱ-
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 그런데 또 length 는 &amp;#39;마지막 slice&amp;#39; 에서의 2번째부터니까 5,7,11 만 있어서 3임 (...)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>slice 에 아무 값도 없으면, 그 값은 &lt;code>nil&lt;/code> 과 같다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;nil!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>make()&lt;/code> 로 slice 를 만들 수 있다. 직접 값을 입력하는게 아니라, 변수를 통해 slice 를 선언할 수 있다는 차이가 있다.
&lt;ul>
&lt;li>length, capacity 를 별도로 입력할 수 있는 정도?&lt;/li>
&lt;li>length 가 0이면 비어 있는데, 그걸 잘라내면 0이 채워진다?? ㄱ-&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">b&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;b&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">d&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">d&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> b len=0 cap=5 []
&lt;/span>&lt;span class="cm"> c len=2 cap=5 [0 0]
&lt;/span>&lt;span class="cm"> d len=3 cap=3 [0 0 0]
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>slice 안에 slice 를 담을 수 있음. 이러면 2차원 배열이 됨. 이 때는 &lt;code>[][]string&lt;/code> 처럼 slice type 앞에 slice 를 쓰겠다고 선언하면 됨. (&lt;strong>2차원 배열이 된다&lt;/strong>)
&lt;ul>
&lt;li>그리고 각 원소도 slice literal 임을 명시해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아래는 2차원 배열 예제 프로그램인데, 주목할 건 for 문이 1개만 쓰였단 거다.
&lt;ul>
&lt;li>대신 &lt;code>strings.Join()&lt;/code> 을 써서 내부 원소 (&lt;code>board[i]&lt;/code>) 를 String 으로 만들어 출력했다는 점..&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Create a tic-tac-toe board.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">board&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[][]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// The players take turns.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;X&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;O&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;X&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;O&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;X&amp;#34;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">board&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s\\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">strings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>익히 알겠지만, slice 는 &lt;code>append()&lt;/code> 가 가능하다. 첫 번째 파라메터는 소스 slice, 나머지는 쭉 원소(들) 을/를 입력하면 된다.
&lt;ul>
&lt;li>그럼 cap 은 어떻게 되나요? 직접 실험해보자 (&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// append works on nil slices.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// The slice grows as needed.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// We can add more than one element at a time.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 여기서 재밌는 건 cap 이 5가 아니라 6이 된다는 거다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> len=0 cap=0 []
&lt;/span>&lt;span class="cm"> len=1 cap=1 [0]
&lt;/span>&lt;span class="cm"> len=2 cap=2 [0 1]
&lt;/span>&lt;span class="cm"> len=5 cap=6 [0 1 2 3 4]
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>마지막 줄이 왜 cap 이 6이 되는지는, go blog 에 있는 &lt;a class="link" href="https://go.dev/blog/slices-intro" target="_blank" rel="noopener"
>Slices-intro&lt;/a> 를 살펴보자. 특히 ‘&lt;strong>Growing slices (the copy and append functions)&lt;/strong>’ 처음에 make 하는 부분을 보면 된다.&lt;/p>
&lt;ul>
&lt;li>Slice 에서의 for 는 &lt;code>for each&lt;/code> 같은 구문을 사용할 수 있다.
&lt;ul>
&lt;li>&lt;code>range [slice]&lt;/code> 로 initialize 를 하게 되는데, 리턴되는 게 2개다. 인덱스와 실제 값.&lt;/li>
&lt;li>※ 인덱스를 안 쓰게 되면 (어차피 compile 에서 에러를 내겠지만) &lt;code>_&lt;/code> 처리해야 한다.&lt;/li>
&lt;li>value 를 안 쓰려면, value 자리를 &lt;code>_&lt;/code> 로 감싸도 되지만, 단순히 인덱스’만’ 받아도 된다.
&lt;ul>
&lt;li>인덱스만 받아서 슬라이스를 인덱스+1 로 참조할 용도로 쓰는.. 뭐 그런?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="k">for&lt;/span> &lt;span class="nx">idx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">value&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">slice_var&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// 인덱스만 쓰고 싶으면
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">idx&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">slice_var&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Golang JSON struct tag: omitempty</title><link>https://1nterp.github.io/golang-json-struct-tag/</link><pubDate>Tue, 21 Jun 2022 16:19:07 +0000</pubDate><guid>https://1nterp.github.io/golang-json-struct-tag/</guid><description>&lt;h2 id="태그">태그?&lt;/h2>
&lt;p>Go 언어의 &lt;code>struct&lt;/code> 타입에는 각 필드마다 태그를 붙일 수 있다. (struct tag 라고도 불린다) 이렇게 아무렇게나 태그를 붙여둘 수 있다. 물론 다른 함수나 패키지에서 이런 태그를 파싱해서 다룰 수 있어야 하겠지만.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`mandatory`&lt;/span>
&lt;span class="nx">ID&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="s">`mandatory`&lt;/span>
&lt;span class="nx">Phone&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`optional`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>encoding/json&lt;/code> 은 &lt;code>json&lt;/code> 으로 시작하는 태그를 지원하는데, 아래와 같이 흔히들 볼 수 있는 것들이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;span class="nx">ID&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="s">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;span class="nx">Phone&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;phone_number&amp;#34;`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 태그를 가지고 있으면, &lt;code>json.Marshal()&lt;/code> 을 할 때 구조체 필드 값을 자동으로 JSON 문서로 변환해준다. 또는 &lt;code>json.Unmarshal()&lt;/code> 을 통해, 입력된 JSON 문서 바이트 배열을 해당 구조체의 각 필드에 맞춰 알아서 변환해 준다.&lt;/p>
&lt;h2 id="omitempty-옵션">omitempty 옵션&lt;/h2>
&lt;p>오늘 알아볼 것은, 이런 태그 뒤에 붙는 옵션들 중에서 &lt;code>omitempty&lt;/code> 에 대한 내용이다. 이 옵션은 말 그대로 &amp;lsquo;비어있는 필드 값은 생략하겠다&amp;rsquo; 라는 뜻이다.&lt;/p>
&lt;p>&lt;strong>결론만 말하면, 이 옵션은 Marshalling 할 때만 효과가 있다.&lt;/strong> &lt;a class="link" href="https://go.dev/play/p/EhzLmox7CYN" target="_blank" rel="noopener"
>Go Playground Link&lt;/a> 에 아래 예제 코드를 넣어뒀으니, 직접 실행해보고 확인해보는 것을 추천한다.&lt;/p>
&lt;h3 id="값이-비어있다">값이 비어있다?&lt;/h3>
&lt;p>Go 언어의 자료형 기본값이 들어가 있으면 값이 비어 있다고 간주한다. 이 부분은 이전 포스팅인 &lt;a class="link" href="https://1nterp.github.io/tour-of-go-package-function-variable/" >Go Tour 문서&lt;/a>에 더욱 자세한 내용이 들어있다.&lt;/p>
&lt;ul>
&lt;li>실수형 = 0&lt;/li>
&lt;li>문자형 = &amp;quot;&amp;quot;&lt;/li>
&lt;li>boolean 형 = false&lt;/li>
&lt;li>포인터형 = nil&lt;/li>
&lt;/ul>
&lt;h3 id="unmarshalling-json---struct">Unmarshalling (JSON -&amp;gt; struct)&lt;/h3>
&lt;p>안 해도 되는데, 일단 의심을 거두기 위해 Unmarshalling 부터 테스트 해보자. 위의 &lt;code>Employee&lt;/code> struct type 에다가, 다음 JSON String 을 Unmarshalling 해보려고 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;John Doe&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">e&lt;/span> &lt;span class="nx">Employee&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unmarshal&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">jsonString&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nb">panic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;[%s]\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Phone&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>그 결과는, 뻔하긴 하지만 대괄호만 나올 것이다. (&lt;code>[]&lt;/code>) 그럼 여기서 &lt;code>e.Phone&lt;/code> 에 값이 있었다면 어떻게 될까? 이 &amp;ldquo;010-&amp;rdquo; 값은 Unmarshalling 을 해도 그대로 남는다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">e&lt;/span> &lt;span class="nx">Employee&lt;/span>
&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Phone&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;010-&amp;#34;&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>그렇다면, 이번에는 &lt;code>omitempty&lt;/code> 를 &lt;code>Employee.Phone&lt;/code> 에 붙이고 위의 두 실험을 해보자. 결과는 같은가? &lt;strong>그렇다.&lt;/strong> 값이 없으면 없는대로, 있으면 있는대로 출력된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;span class="nx">ID&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="s">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;span class="nx">Phone&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;phone_number,omitempty&amp;#34;`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="marshalling-struct---json">Marshalling (struct -&amp;gt; JSON)&lt;/h3>
&lt;p>이번에는 저장된 값을 JSON 으로 나눠보자. 우선, &lt;code>omitempty&lt;/code> 옵션을 다시 빼고, &lt;code>e.Phone&lt;/code> 에는 아무런 값을 넣어보지 않았다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">e&lt;/span> &lt;span class="nx">Employee&lt;/span>
&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;John Doe&amp;#34;&lt;/span>
&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">jsonReturned&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Marshal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nb">panic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">jsonReturned&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;pre>&lt;code>{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;id&amp;quot;:1,&amp;quot;phone_number&amp;quot;:&amp;quot;&amp;quot;}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>phone_number&lt;/code> 라는 필드가 생겼다. struct 필드 값이 비어 있어도 JSON 에는 필드가 보인다는 것이다.&lt;/p>
&lt;p>이걸 방지하기 위해 &lt;code>omitempty&lt;/code> 가 필요하다. 해당 옵션을 다시 &lt;code>Employee.Phone&lt;/code> 에 넣고 동일한 코드를 돌려보면 다음과 같이 출력된다.&lt;/p>
&lt;pre>&lt;code>{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;id&amp;quot;:1}
&lt;/code>&lt;/pre>
&lt;h2 id="사소한-문제">사소한 문제?&lt;/h2>
&lt;p>아까 Go 언어 기본값이 들어있는 필드는 JSON encoding package 에서 비어있는 필드로 간주한다는 말을 했었다. 그런데, 이 값들이 유의미한 값이라면 어떻게 해야 할까? 이 때는 &lt;code>omitempty&lt;/code> 옵션 사용을 자제해야 한다.&lt;/p>
&lt;p>예를 들면, 통장 내역을 나타내는 struct type 에서, 잔고를 나타내는 &lt;code>balance&lt;/code> 필드가 있다고 가정하자. 만약, 이 필드가 정확히 0을 가진다면 이 0이란 숫자는 유효한 숫자다. 그런데 이 필드에 대고 &lt;code>omitempty&lt;/code> 를 붙이게 되면, 사용자가 반환받을 JSON 문서에 &lt;code>balance&lt;/code> 자체가 없게 되고 큰 혼란 (?) 이 올 수 있다. 잔고라는 필드는 프로그램에서 필수적으로 있을 것이라 가정하기 때문에 일종의 &lt;em>AssertionError&lt;/em> 에 빠질 수 있다는 뜻이다.&lt;/p>
&lt;p>Marshalling 할 때 JSON 문서의 다이어트 목적으로 이 옵션을 종종 쓸 텐데, 항상 주의해서 써야 한다는 것으로 끝맺는다.&lt;/p></description></item><item><title>A tour of Go: Flow control statements</title><link>https://1nterp.github.io/tour-of-go-flow-control-stmts/</link><pubDate>Mon, 20 Jun 2022 02:36:25 +0000</pubDate><guid>https://1nterp.github.io/tour-of-go-flow-control-stmts/</guid><description>&lt;p>&lt;a class="link" href="https://interp.blog/tour-of-go-package-function-variable/" target="_blank" rel="noopener"
>지난 시간&lt;/a>에 이어서, 여기서는 Flow Control Statement 에 대해 정리해 보았다.&lt;/p>
&lt;h2 id="a-tour-of-go">A tour of Go&lt;/h2>
&lt;ul>
&lt;li>English: &lt;a class="link" href="https://go.dev/tour/" title="https://go.dev/tour/"
target="_blank" rel="noopener"
>https://go.dev/tour/&lt;/a>&lt;/li>
&lt;li>한국어판: &lt;a class="link" href="https://go-tour-ko.appspot.com/" title="https://go-tour-ko.appspot.com/"
target="_blank" rel="noopener"
>https://go-tour-ko.appspot.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="if-else">If, else&lt;/h2>
&lt;p>조건문은 다른 프로그래밍 언어와 마찬가지로 &lt;code>if&lt;/code>, &lt;code>else&lt;/code> 그리고 &lt;code>else if&lt;/code> 의 조합으로 구성된다. 조건 절 (condition clause) 에 있는 수식을 검증 (evaluation 이라고도 한다) 한 결과가 참이면 해당 블록이 수행된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nf">funcTrue&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>여러 개의 수식들을 넣어도 되고, 마지막 수식이 boolean 으로 검증되거나 반환되어야 한다. 수식 간에는 세미콜론(&lt;code>;&lt;/code>)으로 구분한다. 이 부분에서 가장 널리 쓰이는 패턴이 바로 &lt;code>error&lt;/code> 객체가 반환되었는지 검증하는 구문이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">funcTest&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// error handling with `err` object
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>참고로 저기 &lt;code>err&lt;/code> 는 조건 블록 안에서만 사용할 수 있다. 바깥에서는 참조할 수 없고, 대신 다른 &lt;code>else if&lt;/code> 나 &lt;code>else&lt;/code> 블록에서는 참조가 가능하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">if&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">testStr&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ok
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ok
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ok
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// error
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>심지어는 &lt;code>else if&lt;/code> 에서 선언된 변수가 있는데 &lt;code>if&lt;/code> 에서 쓸 수 있을까? 된다! hoisting 해서 쓴다. 이 쯤 생각해보니, &lt;strong>if block 전체에 선언된 변수들에 대해 evaluation 을 먼저 하는 것으로 보인다&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">pow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">lim&lt;/span> &lt;span class="kt">float64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">float64&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">lim&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">v&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%g &amp;gt;= %g\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">lim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 여기선 가능
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">lim&lt;/span> &lt;span class="c1">// 여기서 v 를 참조할 수 없다.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>performance 를 중요시한다면 필요한 변수는 inner-block 에서 선언해 쓰는게 좋을 거 같긴 한데.. 아직 언어에 대해 잘 모르겠으니 참고만 하자.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="for">For&lt;/h2>
&lt;h3 id="basic-for">basic for&lt;/h3>
&lt;p>다른 프로그래밍 늘 그렇듯, &lt;code>init; condition; post&lt;/code> 로 이루어져 있다. init 에는 마치 지역 변수 선언과 같은 모양을 한다 (bash 를 떠올리면 된다) 그리고 여타 다른 언어와 달리 (C, Java, &amp;hellip;) 괄호가 없다는 점을 주목하자. 그러나 반드시 브라켓 &lt;code>{ }&lt;/code> 은 필요하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="nx">sum&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="nx">i&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="continued-for">Continued for&lt;/h3>
&lt;p>init 과 post 은 optional 이다. 이게 비어 있으면 condition 만 남아 while 과 같은 기능을 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> sum := 0
for ; sum &amp;lt; 10; {
// for sum &amp;lt; 10 { // 둘 중 아무거나 써도 똑같다.
// 그리고 위 처럼 쓴 뒤 go fmt 를 돌리면 세미콜론이 알아서 빠진다.
sum += sum
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>리스트나 맵을 순회할 때도 continued for 의 일종이라고 보면 된다. 이 때는 &lt;code>range&lt;/code> 를 사용한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">myMap&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>
&lt;span class="nx">myMap&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="nx">myKey&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myValue&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">myMap&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="while">While&lt;/h2>
&lt;p>다른 말로, &lt;strong>golang 은 while 이 없다&lt;/strong>&amp;hellip; 대신 &lt;code>for&lt;/code> 만 적으면 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="switch">Switch&lt;/h2>
&lt;p>C/C++, Java 의 switch 라고 생각하면 된다. 차이점은,&lt;/p>
&lt;ul>
&lt;li>C 처럼 단일 값 (e.g. int, character) 이 아니라 &lt;strong>string 도 사용이 가능&lt;/strong>하고&lt;/li>
&lt;li>&lt;code>case&lt;/code> 에 &lt;strong>variable 을 넣어도&lt;/strong> 된다.&lt;/li>
&lt;li>각 case 마다 break 를 다 집어넣지 않아도 된다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Go runs on &amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">darwin_os&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;darwin&amp;#34;&lt;/span> &lt;span class="c1">// 이걸 타겟으로 써도.. 된다고?
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="nx">os&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">GOOS&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">os&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">darwin_os&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1">// ㅇㅇ 되네
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;OS X.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;linux&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Linux.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s.\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>참고로 &lt;code>case:&lt;/code> 만 쓰면 &lt;code>case True:&lt;/code> 와 같은 의미가 된다.&lt;/p>
&lt;p>위의 차이점을 생각해보면, 마치 기다란 &lt;code>if-else&lt;/code> 를 &lt;code>switch&lt;/code> 로 치환할 수 있을 것 처럼 보이지만 사실 두 가지 제약을 고려해서 선택해야 한다.&lt;/p>
&lt;ol>
&lt;li>가독성 문제를 고려해야 한다.&lt;/li>
&lt;li>if 안에서 변수 선언/할당이 가능하지만, case 에서는 변수 선언이 안 된다.&lt;/li>
&lt;/ol>
&lt;h2 id="defer">defer&lt;/h2>
&lt;p>이 키워드로 시작하는 구문은 &lt;strong>해당 함수가 끝날 때 까지 실행이 유예된다&lt;/strong>. 이 키워드는 블록에 종속된 개념이 아니라 &lt;em>함수에 종속&lt;/em>된 개념이다. 따라서, 어느 inner block 에서 쓰이건 간에 이 구문을 지난다면, 함수가 끝날 때에야 구문이 수행된다.&lt;/p>
&lt;p>&lt;code>defer&lt;/code> 뒤에 오는 구문은 &lt;strong>반드시 함수 호출이어야 한다&lt;/strong>. 변수 선언이거나 변수 값 할당같은 식은 안 된다. (&lt;code>+=&lt;/code> 도 안 됨)&lt;/p>
&lt;p>재미있는 건, &lt;code>defer&lt;/code> 줄을 만나는 시점에 argument 값이 결정된다. 이후에 argument 로 들어간 variable 이 바뀌더라도, &lt;code>defer&lt;/code> 의 실제 수행 시점에서는 영향이 없는 것을 아래 코드로 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">abc&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>
&lt;span class="c1">// 아래 세 줄을 브라켓으로 감싸 블록으로 만든다 한 들, 결과는 동일함 (함수 레벨이기 때문)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">abc&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="s">&amp;#34; world&amp;#34;&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">abc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 뒤에 느낌표는 여기서 평가가 안 되지만, 출력은 마지막에 된다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">abc&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="s">&amp;#34; !!&amp;#34;&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">abc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 여기서는 전부 출력된다.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm">hello world !!
&lt;/span>&lt;span class="cm">hello world
&lt;/span>&lt;span class="cm">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>defer&lt;/code> 를 하나의 함수 안에서 여러 개 선언할 수 있다. 실행 순서는 LIFO, 즉 먼저 들어간 수식이 나중에 실행된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 맞춰보자. 0이 먼저 나올까 9가 먼저 나올까?
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>A tour of Go: Package, Function, Variable</title><link>https://1nterp.github.io/tour-of-go-package-function-variable/</link><pubDate>Thu, 16 Jun 2022 10:26:18 +0900</pubDate><guid>https://1nterp.github.io/tour-of-go-package-function-variable/</guid><description>&lt;p>A tour of Go 시리즈를 두 번씩 돌아보고, 나름 배운 것들을 연이어 적어보려 한다. 첫 번째로 패키지, 변수, 함수 정의와 사용에 대한 내용이다. 이 문서는 번역이 아니라서, 개인적으로 중요했던 부분만 있을 수도 있고 투어 예제에서 다루지 않은 부분이 섞여있을 수 있으니 편하게 봐주셨으면 한다. &lt;del>화면 안 넘기고 스크롤만으로 볼 수 있다는 장점 정도?&lt;/del>&lt;/p>
&lt;h2 id="a-tour-of-go">A tour of Go&lt;/h2>
&lt;p>Go 언어의 튜토리얼 페이지라고 보면 된다. 다양한 언어로 번역되어 있으니 영어 원문으로 봐도 좋고 한국어판으로 봐도 좋다.&lt;/p>
&lt;ul>
&lt;li>English: &lt;a class="link" href="https://go.dev/tour/" title="https://go.dev/tour/"
target="_blank" rel="noopener"
>https://go.dev/tour/&lt;/a>&lt;/li>
&lt;li>한국어판: &lt;a class="link" href="https://go-tour-ko.appspot.com/" title="https://go-tour-ko.appspot.com/"
target="_blank" rel="noopener"
>https://go-tour-ko.appspot.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="package">Package&lt;/h2>
&lt;p>모든 &lt;code>*.go&lt;/code> 파일의 첫 줄에는, 이 파일이 속한 &amp;lsquo;패키지&amp;rsquo; 이름을 작성한다. &lt;code>main.go&lt;/code> 는 이렇게 패키지 이름이 지정될 것이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>다음 줄에는, 이 파일에서 사용할 다른 패키지들을 작성할 수 있다. 이렇게 각각 패키지 이름과 함께 &lt;code>import&lt;/code> 를 해도 되지만,&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// separated
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;math&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이렇게 뭉쳐서 선언하는게 보통이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// factored (better)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;math&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="function-declaration">Function declaration&lt;/h2>
&lt;p>다양한 방식으로 함수 시그니처를 선언할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// 기본적인 형태. return type 까지 적어야 함.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// input 타입이 다 같으면 이렇게 typing 을 몰아서 할 수도 있음 (가독성은 좀 떨어짐)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// return 도 여러 개 가능함.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// return 에 변수명을 입력해도 됨. 이 때는 변수명이 함수 내부에서 사용되고, naked return 으로 리턴함 (&amp;#39;return&amp;#39; 만 씀)
&lt;/span>&lt;span class="c1">// &amp;lt;&amp;lt; 가독성이 심하게 떨어지므로 짧은 함수일 때만 쓰는걸 추천함.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sum&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="variable-declaration">Variable declaration&lt;/h2>
&lt;p>변수 또한 다양한 방식으로 선언이 가능한데, 크게 두 가지 방법으로 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>var&lt;/code> 키워드를 통한 선언&lt;/li>
&lt;li>&lt;code>:=&lt;/code> 를 사용해 선언+할당 동시에 하기&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="c1">// 여러 변수가 전부 같은 타입이면 이렇게 변수명 리스트와 마지막 타입 한 번만 적어서 정의해도 됨.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 이건 패키지 레벨, 즉, 다른 함수도 c, python, java 를 모두 접근할 수 있다.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 순서는 var [변수명] [타입] 이다. 이건 함수 레벨이다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>변수 선언과 함께 값을 할당하는 initializer 방법도 다양하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="c1">// 지정된 타입에 맞춰 넣는다. 여러 개를 이렇게 동시에 넣어도 된다. (이 경우에 j = &amp;#34;str&amp;#34; 하면 에러 난다)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;no!&amp;#34;&lt;/span> &lt;span class="c1">// 타입 지정이 되어 있지 않아도, 값에 따라 개별로 설정된다. 앞부터 bool, bool, string 이 된다.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 이렇게 factored 방식으로 지정할 수도 있고, 가독성 역시 좋아진다~
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="nx">ToBe&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="nx">MaxInt&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1">// bit-wise operator 조심
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>:=&lt;/code> 도 알아보자. 단, 이 방법은 전역 변수 (=패키지 레벨 변수) 에서는 사용이 불가능하다. 이 때는 &lt;code>var&lt;/code> 로만 선언이 가능하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">blahblah&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">k&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="c1">// var k = 3 과 같다. var == : 라는 뜻.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;no!&amp;#34;&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="exported-variablefunction">Exported variable/function&lt;/h2>
&lt;p>첫 문자가 &lt;strong>대문자&lt;/strong>인 함수나 전역 변수 이름은, &lt;code>패키지 이름.이름&lt;/code> 형식으로 다른 패키지에서 참조가 가능하다. 아래와 같이 쓰고 &lt;code>custommath_pi.go&lt;/code> 라고 저장했다고 하면, &lt;code>custommath.hiddenPi&lt;/code> 로는 참조가 안 되고 &lt;code>custommath.Pi()&lt;/code> 는 참조가 가능하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">custommath&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">hiddenPi&lt;/span> &lt;span class="kt">float64&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">Pi&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">float64&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="o">...&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>주목할 부분은,&lt;/p>
&lt;ul>
&lt;li>파일 이름이 아니라 패키지 이름으로 참조한다는 것이다.&lt;/li>
&lt;li>다른 말로, 같은 패키지 안이기만 하면, 다른 파일에서도 모든 변수/함수 참조가 가능하다는 것이다. (같은 패키지에서 중복된 변수/함수 이름은 허용되지 않는 이유..)&lt;/li>
&lt;/ul>
&lt;h2 id="variable-types-default-values">Variable types, default values&lt;/h2>
&lt;pre>&lt;code>bool
string
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
byte // alias for uint8
rune // alias for int32
// represents a Unicode code point
float32 float64
complex64 complex128 // 복소수임.. e.g. 3+2i
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>C/C++ 개발자들에겐 &lt;code>uintptr&lt;/code>, &lt;code>rune&lt;/code>, &lt;code>complex&lt;/code> 타입이 좀 생소할 수 있다. 주석으로 설명해 뒀으니 이해해주면 좋겠다.&lt;/li>
&lt;li>&lt;code>int&lt;/code>, &lt;code>uint&lt;/code>, &lt;code>uintptr&lt;/code> 은 물론, 32-bit system 에서는 4바이트, 64-bit system 에서는 8바이트이다.&lt;/li>
&lt;/ul>
&lt;p>이제 각 타입의 기본값을 알아보자.&lt;/p>
&lt;ul>
&lt;li>정수/실수형은 전부 &lt;strong>0&lt;/strong> (float 역시 0.0 이 아니라 0)&lt;/li>
&lt;li>boolean 은 &lt;strong>false&lt;/strong>&lt;/li>
&lt;li>string 은 &lt;strong>“”&lt;/strong> (empty) (formatting 에서 주목할 부분은 &lt;code>%q&lt;/code> 로 하면 quota 가 붙는다는 거다 (&amp;hellip;))&lt;/li>
&lt;li>포인터형은 전부 &lt;strong>nil&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="variable-type-casting">Variable type-casting&lt;/h2>
&lt;p>Go 언어에서 type casting 은 &lt;em>type conversion&lt;/em> 이라고 불린다. 그냥 캐스팅 하듯 type 을 앞에 쓰고 괄호로 감싸면 형변환이 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">42&lt;/span>
&lt;span class="nx">f&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">float64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">u&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>다른 대부분의 언어에서는 암묵적 캐스팅이 가능한데, Go 언어는 이 부분에서 엄격하다. 따라서 이 구문은 안 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">f&lt;/span> &lt;span class="kt">float64&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="c1">// i 가 int 여서 안 됨. 1.0 으로 들어가지 않음
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="constant">Constant&lt;/h2>
&lt;p>&lt;code>const&lt;/code> 키워드를 쓰면 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">const&lt;/span> &lt;span class="nx">Pi&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mf">3.14&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">const&lt;/span> &lt;span class="nx">world&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;세계&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>다음의 특징을 가진다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>패키지 레벨, 함수 레벨 둘 다 가능하다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>var&lt;/code> 이나 &lt;code>:=&lt;/code> 로 선언할 수 없다. 이 말은, &lt;strong>별도의 타입 선언을 하지 않고&lt;/strong> 상수 값과 함께 선언한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>별도 타입 선언이 안 되므로, 정수형 상수 (numeric constant) 를 넣을 때는 내부적으로 필요한 type 을 (마음대로) 결정한다. 예를 들어,&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">const&lt;/span> &lt;span class="nx">Big&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">100&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이렇게 선언하면 Big 은 &lt;code>int&lt;/code> 형이 아니라 &lt;code>float64&lt;/code> 쯤 될 것이다. 이 말은 &lt;code>Big&lt;/code> 을 int 처럼 쓰려고 들면 type conversion error 를 만날 수 있다는 것이다.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>슈퍼 개발자만 쓸모가 있을까</title><link>https://1nterp.github.io/you-are-not-a-genius-programmer/</link><pubDate>Fri, 03 Jun 2022 06:36:33 +0900</pubDate><guid>https://1nterp.github.io/you-are-not-a-genius-programmer/</guid><description>&lt;p>커뮤니티 글에서 최근 꾸준글로 보이는 한 친구가 있다. 자신을 컴퓨터공학과 학생으로 소개하면서, 알고리즘 문제를 풀다보니 너무 어려워서 전공을 바꿀까, 자신은 보잘것 없는 개발자가 될 것이라며 자학을 꾸준히 하고 있었다. 무슨 문제를 못 풀어서 저러는 건지는 모르겠지만, 갑자기 내 대학원 때 생각이 나서, 주저리 적어본다.&lt;/p>
&lt;h2 id="슈퍼-개발자의-존재">슈퍼 개발자의 존재&lt;/h2>
&lt;p>개발조직 사이에서, &amp;lsquo;100명의 개발자 중 1-2명의 슈퍼 개발자들이 나머지 개발자들보다 일을 잘 한다&amp;rsquo; 라는 말을 흔히들 한다. 이런 슈퍼 개발자를 모셔 와야 조직의 퍼포먼스가 올라간다는 것이다. 그러면 이 &amp;lsquo;나머지 개발자&amp;rsquo; 들의 운명은 어떻게 되는 것인가? 조직의 입장에서, 슈퍼 개발자를 모셔 왔으면, 나머지 중 하위 10명 정도는 잘라내도 괜찮을가? 개인의 입장에서, 내가 슈퍼 개발자가 아니면, 모가지를 내놓고 회사를 다녀야 할까?&lt;/p>
&lt;p>내 생각엔, 이런 뛰어난 개발자는 축구로 치면 스타 플레이어의 크랙 (crack) 이다. 대치 상태를 뒤집고 돌파할 수 있는 천재적인 능력이나 역량을 지닌 선수를 말한다. 프로그래머는 문제를 해결하는 사람들이므로, 어떤 문제에 부딪혔을 때, 누구보다도 문제를 빠르게 해결하거나 그 방법을 제시할 수 있는 사람들이 슈퍼 개발자라면, 괜찮은 비유인 듯 하다. (어렵지만) 축구에서도 스타 플레이어 혼자 끝까지 달려 수비수를 제끼고 골을 넣을 수 있다. 프로그래머도 혼자 끝까지 코딩해서 문제를 풀 수 있다. 이 부분도 어느 정도 맞다.&lt;/p>
&lt;p>하지만 한 골이 아니라 경기 전체, 한 문제가 아니라 조직 비즈니스 전체에서는 실패할 확률을 줄이면서 성공으로 이끌어야 하는 책임이 있다. 한 두번이면 몰라도, 축구선수가 크래킹을 시도 때도 없이 한다던지 독단적으로 볼키핑을 하거나 요구한다면, 상대방이 수비 전술을 바꿔 꽁꽁 묶어버릴 수도 있고, 다른 선수의 사기를 떨어뜨릴 수 있다. 감독은, 그 선수의 뒤에서 볼을 주고 받아 줄 다른 선수들과 긴밀한 유대를 가지도록 독려해야 하며, 스타 플레이어의 역량과 조직 운용에 균형을 맞춰야 한다.&lt;/p>
&lt;p>혼자 하는 프로그래밍도 마찬가지인데, 뒤에서 따라가며 이해하고 테스트를 하거나 리뷰를 해 줄 다른 개발자가 필요하다. 그렇지 않으면, 문제 해결에 혈안이 된 나머지 다른 버그를 놓치거나 코드 품질의 저하, 조직 문화 저하를 가져올 수 있다. &amp;lsquo;혼자 가면 빨리 가고, 함께 가면 멀리 간다&amp;rsquo; 라는 말이 괜히 있는 게 아니다.&lt;/p>
&lt;h2 id="사람은-떠나고-시스템만-남는다">사람은 떠나고, 시스템만 남는다&lt;/h2>
&lt;p>하지만 현실적으로, 슈퍼 개발자, 스타 플레이어가 물론 경기를, 비즈니스를 성공적으로 이끄는 모습은 그렇게 놀랄만한 일이 아니다. 그들은 비단 한 골이 아니라, 아예 제품을 일신시켜줄 그런 멋진 도약을 해내곤 한다. 인정한다. 하지만 조직 입장에서는 이럴 때 일 수록 경계해야 한다. 매니저는 항상 &amp;ldquo;저 선수/개발자가 떠나면 우린 어떡하지?&amp;rdquo; 라는 고민을 해야 한다.&lt;/p>
&lt;p>조직은 그 자리에 머문다. 스타 플레이어 뿐만 아니라 일반 개발자, 매니저까지 모조리 떠날 수 &amp;lsquo;있다&amp;rsquo;. &lt;strong>남는 건 바로 제품(코드)와 시스템이다. 이것들이 스타 플레이어에 의존한다면, 떠나고 나서도 제대로 작동할 가능성은 제로에 가깝다.&lt;/strong> 조직 입장에서는, 이 부분이 핵심이다. 그래서 잘 하는 개발자를 모셔오는 것도 좋지만, 이렇게 영입하고서도 조직 시스템을 해치진 않는지 고민해야 한다.&lt;/p>
&lt;h2 id="일반-개발자의-역할">일반 개발자의 역할&lt;/h2>
&lt;p>이제 개발자 개인의 관점에서 생각해보자. 사실 &amp;lsquo;나는 슈퍼 개발자가 아니구나&amp;rsquo; 라는 생각을 늘 하고 있었는데, 이런 고민을 이렇게 글로 풀어보고 싶었다.&lt;/p>
&lt;p>앞서 말했듯이 조직은 슈퍼 개발자에 의존하지 않아도 작동할 시스템과 제품 코드를 유지하고자 한다. 내 결론은, 이 시스템을 &lt;strong>잘&lt;/strong> 이해하고 따르기만 해도, 내부 코드를 &lt;strong>잘&lt;/strong> 이해하고 있기만 해도 조직에서의 가치는 올라갈 수 있다. 더 나아가면, 조직을 너무 잘 이해한 나머지, 문제 해결을 할 수 있는 슈퍼 플레이어에게 패스를 잘 할 수 있는, 플레이메이킹을 할 수 있다. 이런 개발자를, 사일로 (silo) 를 연결해 주는 브릿지 (bridge) 역할을 한다고 한다. 조직에서는 정말 보배같은 존재다.&lt;/p>
&lt;p>그런데 이 부분에서도 경쟁력이 필요하다. 시스템을 잘 이해한다는 것은, 시스템 안에서 정보를 누구보다 빨리 찾아낼 줄 알아야 하고 다른 팀과 소통을 빠르게 할 수 있어야 한다는 뜻이다. 내부 코드를 잘 이해하고 있다는 것은, 자기가 담당하거나 담당했던 부분에 대해서는 누구보다 자신있게 대답할 준비가 되어 있어야 한다는 것이다. 그냥 이해하면 그냥 임금노동자일 뿐이다.&lt;/p>
&lt;p>만약 시스템이 정말 안 맞는다, 코드가 정말 어렵다면 방법은 두 가지다. (야근을 강요하는 것으로 들렸다면 미안하지만) 자투리 시간에 공부를 더 해서 경쟁력을 올리거나, 그렇게 해도 안 되겠으면 자기에게 더 잘 맞을 것 같은 조직으로 이직해야 한다.&lt;/p>
&lt;h2 id="개발도-사람이-한다">개발도 사람이 한다&lt;/h2>
&lt;p>결론은, 개발도 결국 사람이 하는 것이다. (물론 기본은 해야겠지만) 개발 능력이 슈퍼 개발자에 비해 부족하다고 좌절할 필요는 없다. 나도 그런 벽은 꽤나 많이 경험해 봤고, 좌절도 해 보고 노력도 해 봤지만 큰 소용이 없다. 그보다는, 다른 방면으로 조직에 기여할 수 있는 부분이 있는지 찾아보는 편이 훨씬 빠르다.&lt;/p>
&lt;p>나는 개인적으로 문서화하는 걸 즐겨해서 보고 들은 것, 경험한 것을 사내 위키에 정리해 둔다. 한 가지 원칙은 &amp;lsquo;이 문서는 반드시 남들이 볼 것이다&amp;rsquo; 라는 생각으로 탈고해야 한다. 그렇게 하지 않으면 미래의 나 조차 문서를 이해하지 못하기 때문이다. 이런 습관이 커리어에 많은 도움이 되었다.&lt;/p>
&lt;p>회사에 취직하지 않았다고 하더라도, 똑같은 공식을 오픈소스 프로젝트나 동아리, 하다못해 개인 토이 프로젝트에 적용하면 어떨까. 개발조직 세상에는, 코딩 외에 할 일이 너무나도 많다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/></description></item><item><title>VSCodeVim: 분리된 줄 위/아래로 커서 이동하기</title><link>https://1nterp.github.io/vim-wrapping-line-cursor-up-down/</link><pubDate>Fri, 15 Apr 2022 02:45:00 +0900</pubDate><guid>https://1nterp.github.io/vim-wrapping-line-cursor-up-down/</guid><description>&lt;p>VSCode 에서도 Vim 환경을 쓰고 싶어서 &lt;a class="link" href="https://github.com/VSCodeVim/Vim" target="_blank" rel="noopener"
>VSCodeVim&lt;/a> 을 설치해서 쓰고 있다.&lt;/p>
&lt;p>&lt;img src="https://1nterp.github.io/images/2022-04-15-vscodevim.png"
loading="lazy"
>&lt;/p>
&lt;p>그런데 위와 같이 markdown 편집을 할 때 처럼 줄 분리가 이뤄져서 (line wrapping) 사실 한 줄인데 여러 줄로 보여지는 경우에는, 커서를 아래로 내릴 경우에 &lt;em>실제&lt;/em> 다음 줄 로 이동한다. &lt;strong>화면에 보이는 줄이 아니라, 실제 줄로 이동하기 때문에&lt;/strong>, 커서를 옮길 때 여간 불편한 게 아니다.&lt;/p>
&lt;h2 id="해결-방법">해결 방법&lt;/h2>
&lt;p>Vim 도 사실 line wrapping 이 되었을 때 같은 문제가 있고, (문제라기 보다는 특성인데) 원하는 방법대로 우회할 수 있는 방법을 &lt;a class="link" href="https://vim.fandom.com/wiki/Move_cursor_by_display_lines_when_wrapping" target="_blank" rel="noopener"
>여기&lt;/a>서 찾았다. 이 방법을 그대로 VSCode 에도 적용한 것이다.&lt;/p>
&lt;p>먼저 Settings 를 열어서 &lt;strong>Vim: Normal Mode Key Bindings&lt;/strong> 로 이동하면, Edit in settings.json 링크가 있다. 이걸 눌러서 다음을 추가하자.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;vim.normalModeKeyBindings&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;Up&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;g&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;k&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;Down&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;g&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;j&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>적용하고 곧바로 편집 중인 파일로 돌아오면 적용이 되어 있는 걸 볼 수 있다. 이제 커서를 위/아래로 움직여도 화면에 보이는 윗줄/아랫줄로 이동한다!&lt;/p></description></item><item><title>k8s Operator vs. Controller</title><link>https://1nterp.github.io/kubernetes-operator-vs-controller/</link><pubDate>Tue, 15 Mar 2022 02:44:57 +0000</pubDate><guid>https://1nterp.github.io/kubernetes-operator-vs-controller/</guid><description>&lt;p>쿠버네티스에서 서비스를 개발하거나 운영하다 보면 자주 접하게 될 개념 중 하나가, 바로 이 Controller 와 Operator 일 것이다. 어떤 경우에는, 동일한 서비스를 두고 &amp;lsquo;이건 Controller 야&amp;rsquo; 라고 말 할 때도 있고 &amp;lsquo;이 Operator 는&amp;hellip;&amp;rsquo; 이라고 불릴 때도 있어서 헷갈릴 수 있다. 심지어 공식 문서에서도 두 개념에 대한 비교는 하지 않고 있어서 명확한 구분이 필요한 것 같다.&lt;/p>
&lt;p>와중에 &lt;a class="link" href="https://blog.marcnuri.com/kubernetes-operator-vs-controller" target="_blank" rel="noopener"
>이 문서&lt;/a>를 발견했는데, 요약하자면 이렇다.&lt;/p>
&lt;h3 id="controller">Controller&lt;/h3>
&lt;blockquote>
&lt;p>So in the Kubernetes world, a controller will basically &lt;strong>monitor and measure the cluster resources state to adjust those resources that diverge from the desired state&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>더 줄여보면, Controller 는 (1) K8s 리소스 (중 일부) 의 상태를 체크하고 (2) 이 리소스들의 상태를 &amp;lsquo;목표 상태 (desired state)&amp;rsquo; 로 조정하는 역할을 한다.&lt;/p>
&lt;p>&lt;code>ReplicaSet&lt;/code>, &lt;code>StatefulSet&lt;/code>, &lt;code>DaemonSet&lt;/code> 이 대표적인 Controller 들이다. 속해 있는 Pod 들의 상태를 &amp;lsquo;목표한 상태&amp;rsquo; 로 조정하려고, Pod 을 추가하거나 삭제한다.&lt;/p>
&lt;h3 id="operator">Operator&lt;/h3>
&lt;p>CoreOS 에서 정의하는 Operator 는 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>An Operator is &lt;strong>a method of packaging, deploying and managing a Kubernetes application.&lt;/strong>&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>그런데 이 개념을 구현하기 위해서는 필연적으로 Controller 가 들어가게 된다. 그렇다면 Controller 와 비교했을 때 Operator 의 차이점은 무엇일까?&lt;/p>
&lt;p>저 &amp;lsquo;Kubernetes application&amp;rsquo; 에서 말하는 것은, 사용자가 직접 지정할 수 있는 CRD (Custom Resource Definition) 과 거기서 파생된 CR (Custom Resource) 까지 포함하고 있는 것이다. 아니면 정말 bare application 형태로 특정 microservice 를 관리할 때도 Operator 라고 부를 수 있겠다.&lt;/p>
&lt;p>예를 들면, Orange 라는 CRD 를 하나 만들었고, 이 Orange CR 에는 1개의 &lt;code>Service&lt;/code> 와 1개의 &lt;code>Pod&lt;/code> 이 만들어져야 한다고 해보자. 그러면 Orange CR 을 관리하는 application 을 가리킬 때는 Orange *&lt;strong>Operator*&lt;/strong> 라고 부를 수 있다. 하지만 내부에 구현된 Reconcile Loop Code 는 일종의 Orange *&lt;strong>Controller*&lt;/strong> 라고도 부를 수 있는 것이다. 실제로 Service 와 Pod 을 만드는 역할은 이 Controller 에서 이뤄지지만, 전체적으로 Orange CR 의 명세를 관리하는 것은 전체 Operator 가 담당하는 것이다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h3 id="정리하면">정리하면&lt;/h3>
&lt;p>나에게 Controller 는 기술적인 개념이고, Operator 는 좀 더 포괄적이면서 논리적인 개념으로 받아들여진다. &lt;a class="link" href="https://blog.marcnuri.com/kubernetes-operator-vs-controller" target="_blank" rel="noopener"
>문서&lt;/a>에서도 &amp;lsquo;모든 Operator 는 CR 을 관리하기 위해 쓰이는 Controller 라고 부를 수 있다.&amp;rsquo; 라고 하고 있으니까 말이다.&lt;/p>
&lt;p>그리고 Controller 나 Operator 모두 어떤 프레임워크일 뿐이지, 언어에 국한된 것은 아니라고 언급한다. Go 언어와 Python 으로 모두 구현해 본 경험이 있는 나 역시, 이 부분에 동의한다.&lt;/p>
&lt;p>다만 용어를 선택하거나 접할 때 좀 더 이해를 확실히 할 목적으로 정리하는게 더욱 낫지 않을까 하는 마음에, 이 비교글을 마친다.&lt;/p></description></item><item><title>Archives</title><link>https://1nterp.github.io/archives/</link><pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate><guid>https://1nterp.github.io/archives/</guid><description/></item><item><title>나의 부모님이 이 책을 읽었더라면</title><link>https://1nterp.github.io/the-book-you-wish-your-parents-had-read/</link><pubDate>Wed, 02 Mar 2022 00:00:06 +0000</pubDate><guid>https://1nterp.github.io/the-book-you-wish-your-parents-had-read/</guid><description>&lt;img src="https://1nterp.github.io/images/featured/the-book-you-wish-your-parents-had-read.jpg" alt="Featured image of post 나의 부모님이 이 책을 읽었더라면" />&lt;p>책 제목이 나에겐 조금 자극적이었는데, 마치 이렇게 지내는 내가 나의 부모님 때문이라는 일종의 책임전가 같은 느낌이 들어서였다. 물론 실제 내용은 그렇진 않고 무던하면서도 세세하게 양육법에 대한 상담 내용이나 저자의 생각을 공유한다.&lt;/p>
&lt;p>당장 생각나는 것은 이 정도이다.&lt;/p>
&lt;ul>
&lt;li>(전부는 아니지만) &lt;strong>대개 양육에서 어려움을 느끼는 부분은, 내가 자라면서 겪은 부분이 반영된 것이다.&lt;/strong> 그 부분이 나의 부모님의 잘못일 수도 있고, 환경적인 문제일 수도 있고, 시대 또는 집안에서 요구한 (혹은 묵인한) 양육법의 문제일 수도 있다.&lt;/li>
&lt;li>사람은 누구나 실수를 하고, 상대방에게 (의도했건 의도치 않았건 간에) 상처를 줄 수 있다. 그것은 자연스러운 것이니, 과거를 후회하며 좌절하면 안 된다. 중요한 것은, &lt;strong>상처를 줄 수 있다는 사실을 인정하고 상처를 치유할 노력을 지속적으로 하는 것이다.&lt;/strong> 치유는 당장 될 수도, 오랜 시간이 걸릴 수도 있지만, 중요한 건 그 노력 자체다.&lt;/li>
&lt;li>&lt;strong>아이는 감정의 동물이다.&lt;/strong> 성인은 이성적으로 감정을 제한할 능력이 어느 정도 있어도, 아이는 그렇지 못하기 때문에 이해를 구하거나 동일한 사고로 문제를 판단하면 안 된다.&lt;/li>
&lt;li>&lt;strong>부모는 아이의 감정을 받아줄 그릇이 되려고 노력해야 한다.&lt;/strong> 당연히 모든 감정을 받아줄 수는 없겠지만, 그렇게 노력을 해야 한다. 그래야 아이가 불안해하지 않는다.&lt;/li>
&lt;li>&lt;strong>부모 역시 부모의 감정을 공유하고 나눌 수 있는 사람이 반드시 필요하다.&lt;/strong> 배우자가 되면 가장 좋고, 여건이 안 된다면 보모나 양육자의 부모가 그 역할을 해야 한다. 여기에서 중요한 건, 상대방을 감정 쓰레기통으로 만들면 안 된다는 점이다. 서로 감정을 쪼개 환원할 수 있는 관계를 반드시 구축해야 한다.&lt;/li>
&lt;li>&lt;strong>아이에게 놀이나 배움의 선택지를 제한하는 방법은 좋다.&lt;/strong> 선택지가 많아지면 더욱 산만해진다.&lt;/li>
&lt;li>&lt;strong>갓난 아이를 울리면서까지 방치하는, 그러다 이내 잠들게 만드는 소위 &amp;lsquo;수면 교육&amp;rsquo; 은 반대한다.&lt;/strong> 아이는 그 동안 느꼈던 외롭고 두려운 감정을 체념해 버리기 때문에 대개 자라면서 문제가 불거지게 된다. 정 하고 싶다면 대신 &amp;lsquo;수면 유도&amp;rsquo; 를 추천한다.&lt;/li>
&lt;li>&lt;strong>아이가 원하는 것이 있다면 최대한 들어주자.&lt;/strong> 집안일을 해야 하는데 놀아달라고 하면, 정말 급한 게 아닌 이상 놀아주자. 아이가 부모와 같이 잠들고 싶다면 잠을 자도록 하자.&lt;/li>
&lt;li>&lt;strong>아이가 이상한 집착을 할 때가 있는데, 그 집착은 평생 가지 않는다.&lt;/strong> 그런 버릇을 일부러 고치려 들지 말고, 아이가 불안하지 않은 상태로 유지해주는 게 중요하다. (실제로 공감이 많이 가는 내용이었다)&lt;/li>
&lt;/ul>
&lt;p>저자가 여성이라 임신 과정에서 느낀 심경의 변화를 잘 묘사한 부분도 있는데, 임산부를 도와주는 남편 입장에서 참고할 부분이 많기 때문에 허투루 봐선 안 된다는 생각도 든다. 나는 가족계획상 더 이상 참고할 일은 없지만, 그 때 그랬지 하기도 하고, 어루만져주지 못한 감정에 대해선 반성도 할 수 있었다.&lt;/p>
&lt;p>아이는 감정을 언어화할 능력이 매우 부족하기 때문에, &amp;lsquo;왜 그랬니&amp;rsquo; 나 &amp;lsquo;무슨 생각으로 그랬니&amp;rsquo; 같은 주관식에 답을 하지 못한다. (대개 딴청을 피운다) 그래서 양육하는 사람이 너는 이런 감정일지도 모른다고 언어로 묘사해 줘야 한다. 그래야 아이가 이 감정과 그 문장을 일치시켜서 배우게 되는 것이다. 울거나 떼 쓰는 감정을 명확히 해 주면, 아이가 이해하고 악용하거나 해서 상황이 악화되진 않을까 생각할 순 있다. 하지만, 앞서 말했듯 다 한 때인 데다가 오히려 감정을 이해하면 최소한 울거나 떼를 쓰지는 않는다.&lt;/p>
&lt;p>그리고 아이는 미래를 염두에 두는 능력 또한 부족하기 때문에, 무작정 혼을 내거나 &amp;lsquo;이렇게 되면 이렇게 할거야&amp;rsquo; 같은 협박에 무신경하다. 부모의 목소리와 기분만 상할 뿐이다. 따라서 현재의 감정 상태를 이해하려 노력하고 어루만져주는 게 훨씬 낫다고 조언한다.&lt;/p></description></item><item><title>엘든 링, 10시간 리뷰</title><link>https://1nterp.github.io/elden-ring-10h-review/</link><pubDate>Mon, 28 Feb 2022 08:53:20 +0000</pubDate><guid>https://1nterp.github.io/elden-ring-10h-review/</guid><description>&lt;img src="https://1nterp.github.io/images/2022-02-28-elden-ring/featured.jpg" alt="Featured image of post 엘든 링, 10시간 리뷰" />&lt;p>메타크리틱과 오픈크리틱에서 GOTY 급 평점을 받은 그 게임, 그 때문인지 모든 스트리머와 게이머의 기대를 한 몸에 받아 수 많은 이슈를 한 몸에 받아내고 있는 &amp;lsquo;프롬 소프트웨어&amp;rsquo; 의 2022년 신작 &amp;lsquo;엘든 링&amp;rsquo; 을 10시간 가량 해 보고 난 소감을 적어본다.&lt;/p>
&lt;p>10시간 가량 했지만, 이제 겨우 멀기트를 잡았다. 새로운 지역을 싸돌아 다니면서 맵 아이템만 줍줍하고 보이는 축복들만 밝혔더니 스톰빌 전은 거진 다 밝혔다. (보스 잡은게 몇 없어서 그렇지&amp;hellip;)&lt;/p>
&lt;h2 id="스카이림--블러드본">스카이림 + 블러드본&lt;/h2>
&lt;p>인생 게임에 대한 이야기를 시작하게 되면, &amp;lsquo;엘더 스크롤 5: 스카이림&amp;rsquo; 과 &amp;lsquo;블러드본&amp;rsquo; 은 항상 나에게 두 손가락 안에 드는 게임으로 꼽힌다. 이 두 개를 합친 듯하다. 혹자는 &amp;lsquo;젤다:야생의 숨결&amp;rsquo; 의 오픈월드가 느껴진다고도 하고, &amp;lsquo;베르세르크&amp;rsquo; 에서 모티브를 따온 만큼 그 느낌이 잘 살아있다고도 하던데&amp;hellip; 둘 다 접해보지 않아서 잘 모르겠다. 그보다는, 북유럽 풍의 디자인을 공유하면서 오픈월드였던 스카이림이 개인적으로 먼저 떠올랐다.&lt;/p>
&lt;p>블러드본은 좀 늦게 시작했는데, PS4 구입 자체가 늦어서 발매된지 2년 좀 안되어서 했던 기억이 난다. 그런데도 나는 잠을 줄여가면서 필드와 보스를 하나씩 넘겼다. (출근은 해야 하니까) 신혼 초에 그 때는 아이도 없어서 가능했던 것 같다.&lt;/p>
&lt;p>갑자기 블러드본 한 이야기를 꺼낸 이유는, 그 때의 느낌을 엘든 링에도 받고 있기 때문이다. 지금은 두 아이가 있어 육아도 신경써야 하고 집안일의 양도 월등히 많고 해야 할 다른 일들이 많은데도 말이다. 다크소울 3나 세키로는 정해진 시간에 하고 종료 버튼을 누르기가 수월했는데, 왜 그럴까&amp;hellip;&lt;/p>
&lt;figure>&lt;img src="https://1nterp.github.io/images/2022-02-28-elden-ring/image.png"
alt="임의로 생성할 수 있는 성배 던전은, 블러드본 고유의 특징이다."/>&lt;figcaption>
&lt;p>임의로 생성할 수 있는 성배 던전은, 블러드본 고유의 특징이다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>블러드본은 회차를 넘기고 나면 할 수 있는 일이 좀 더 많은데, 바로 성배던전으로 파밍하는 것이다. 물론 초회차 유저에게는, 이렇게 무수히 많은 비석이 부담으로 다가올 수 있다. 나도 그랬으니까. 이것이 다크 소울과 세키로와 다른 점인데, 아무리 화톳불/불상을 넘나들며 스토리를 진행한다 하더라도 일종의 선형적 구조를 지닐 수 밖에 없는 점보다는, 사이드 퀘스트인 성배 던전으로 추가 업그레이드와 모험을 할 수 있는 선택지를 넓혔다는 것이다.&lt;/p>
&lt;p>엘든 링이 딱 이런 식인데, 더 이상 스토리 진행이 안 되겠거든 &amp;lsquo;강해져서 돌아와라&amp;rsquo; 식의 진행이 가능하다는 것이다. 그러다 새로운 이벤트를 마주하기도 하고, 또 다른 보스를 만나기도 하고, 탐험을 진행하다가 돌아와서 다시 말을 걸면 전혀 다른 정보를 주기도 하고, 아이템을 줍고 만들고 모험을 계속 하는 것이다.&lt;/p>
&lt;p>하나 더 곁들이자면, 엘든 링 지하 던전 중에 &amp;lsquo;시프라 강&amp;rsquo; 이란 곳이 있다. 여기 엘리베이터 타고 내려가면 첫 인상은 마치 스카이림의 &amp;lsquo;블랙 리치&amp;rsquo; 에 다다른 듯한 인상을 준다.&lt;/p>
&lt;figure>&lt;img src="https://1nterp.github.io/images/2022-02-28-elden-ring/Untitled-2.jpg"
alt="왼쪽이 시프라 강, 오른쪽이 블랙 리치. 그야말로 지하의 몽환세계&amp;amp;hellip;"/>&lt;figcaption>
&lt;p>왼쪽이 시프라 강, 오른쪽이 블랙 리치. 그야말로 지하의 몽환세계&amp;hellip;&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="지적되는-단점들에-대해서">지적되는 단점들에 대해서&lt;/h2>
&lt;p>이렇게 흡인력이 강하지만 최초 스팀 평가는 &amp;lsquo;복합적&amp;rsquo; 이었다. 기대에 대비해 실망한 사용자가 많았다는 것이다. 물론 PC 판에서 특히 심한 &amp;lsquo;스터터링&amp;rsquo; 문제는 무조건 고쳐야 하는 문제이고 백번 까여야 한다. (다행히 나는 보스전에서 그런 문제를 마주하지 않아서 덜 화나긴 하지만)&lt;/p>
&lt;p>그런데 그 외의 논란거리에 대해선 &amp;lsquo;글쎄&amp;rsquo; 다. 너무 큰 관심을 한 몸에 받아서 그런지, 엄청나게 높은 평론가 평점과 별개로 퍼포먼스 부분에서 심각하게 까이고 있다고 생각한다.&lt;/p>
&lt;p>대표적으로 그래픽이 다른 AAA 게임에 비해 낮다는 것은, 마치 &amp;lsquo;포켓몬스터 : 아르세우스&amp;rsquo; 와 &amp;lsquo;야숨&amp;rsquo; 의 필드 배경을 비교하는 것 같은 느낌이 강하게 들었다. 내부 사정이야 잘 모르겠지만, 알음알음 공개된 개발사 규모를 생각해 보면, 제한된 자원으로 선택과 집중을 했다고 너그러이 봐줄 수도 있지 않을까.&lt;/p>
&lt;p>물론 이런 건 있겠지. 소위 &amp;lsquo;&lt;strong>망자들&lt;/strong>&amp;rsquo; 로 지칭되는 다크소울 시리즈를 즐겨하는 게이머 풀의 외연 확장을 위해, &amp;lsquo;엘든 링은 좀 더 쉬울거가, 오픈월드 같은 느낌으로다가 발매합니다&amp;rsquo; 라고 홍보를 했으니 말이다. 마치 메타크리틱에서 붙이는 &lt;em>MUST PLAY&lt;/em> 딱지를 꼭 받고, 너도 나도 이 게임을 안 사고는 못 배기는 킬러 타이틀로 부상시키려는 노력이 없었다고는 말 못하겠다. 그래서 일반 게이머들이 보니까 &amp;lsquo;뭐야, 이거 평점은 그렇게 높더니 버그도 있고 그래픽도 별로고 게임은 어렵고 불친절하고&amp;hellip;&amp;rsquo; 가 되는 것일 수도?&lt;/p>
&lt;center>
&lt;figure>&lt;img src="https://1nterp.github.io/images/2022-02-28-elden-ring/mustplay222.png"
alt="이게 붙으면, 너도나도 찍먹하게 되는데 문제는&amp;amp;hellip;"/>&lt;figcaption>
&lt;p>이게 붙으면, 너도나도 찍먹하게 되는데 문제는&amp;hellip;&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/center>
&lt;p>문제는, 아직도 이 게임은 다크소울 시리즈를 즐겨하는 게이머만 좋아할 법하다는 것이다. 그러니까, 실제 홍보와 게임 진행은 좀 다른 양상이라는 것이다.&lt;/p>
&lt;p>그런데 돌이켜보면, 이게 정말 문제일까? 몬스터 헌터가 일반 게이머도 손쉽게 접근할 수 있는 게임이 아니듯이, 다크소울 시리즈 역시 그렇다고 생각한다. 그런 테이스트 강한 게임을 하나 더 출시했는데, 좀 더 다양한 선택지를 줘서 게이머가 도전할 수 있는 옵션을 많이 제공해 준 것만으로도 게임 자체는 일신했다고 생각한다. 평론가들은 아마 (게임을 많이 하다보니) 대부분 &amp;lsquo;망자&amp;rsquo; 일 가능성이 크고, 거기에 비춰서 &amp;lsquo;그래픽이 후져도 졸잼이네요&amp;rsquo; 하고 평점을 높게 주진 않았을지.&lt;/p>
&lt;p>그런데 정말 스터터링은 문제다. 주변에서 들어보니 1060에서도 발생하고 3080ti 에서도 발생하는데 이게 대체 뭐람?&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>결론은 예약 구매는 하면 안 된다 (&amp;hellip;) 취향에 맞는지는 출시 직후 실황이나 클립을 통해서 얼마든지 확인할 수 있다. 정 찍먹을 하고 싶다면, 스팀에서 구매한 다음 한 시간만 빡세게 돌리고 아니다 싶으면 환불을 하는 방법이 있다. 농담이 아니라 정말이다.&lt;/p>
&lt;p>다크소울 시리즈를 (잘 못해도) 좋아한다면, 이 게임은 최적의 선택이 될 것이다. 나름대로 친절하고 돌아다닐 구석이 너무 많고, 의외의 발견에 희열을 느낄 수 있을 것이니.&lt;/p>
&lt;p>시리즈 전문 공략 유튜버/방송인 &amp;lsquo;이클리피아&amp;rsquo; 님의 첫날 실황 방송을 아주 잠깐 봤는데, 그 때 들었던 이 게임의 평이 다음과 같았다. 딱 열시간 하면서 이 평론이 뇌리에서 떠나질 않아서 붙여둔다.&lt;/p>
&lt;blockquote>
&lt;p>이거, &lt;strong>다크소울 올스타&lt;/strong> 같아요.&lt;/p>
&lt;/blockquote>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="6929871144"
data-ad-format="auto"
data-full-width-responsive="true">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/></description></item><item><title>카카오/네이버 메일 아이폰 연동</title><link>https://1nterp.github.io/kakao-naver-email-iphone-connect/</link><pubDate>Fri, 04 Feb 2022 16:35:37 +0000</pubDate><guid>https://1nterp.github.io/kakao-naver-email-iphone-connect/</guid><description>&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/feature-image.jpg" alt="Featured image of post 카카오/네이버 메일 아이폰 연동" />&lt;h2 id="요약">요약&lt;/h2>
&lt;ul>
&lt;li>원래는 홈페이지에서 하라는 대로 하면 된다.&lt;/li>
&lt;li>비밀번호를 잘 입력했는데 서버 접속이 안 된다면, 혹시 2단계 인증을 쓰고 있지는 않은지?&lt;/li>
&lt;li>2단계 인증을 쓰는 경우라면, &lt;strong>앱 비밀번호&lt;/strong>를 별도로 발급받는다.&lt;/li>
&lt;/ul>
&lt;h2 id="참고">참고&lt;/h2>
&lt;p>카카오 메일 뿐만 아니라 네이버 메일이나 네이버 캘린더 동기화도 비슷하다. 아래에 ‘부록’ 으로 달아뒀으니 참고하면 된다.&lt;/p>
&lt;h2 id="설정-방법">설정 방법&lt;/h2>
&lt;ol>
&lt;li>PC 에서 브라우저를 열고, 카카오 메일을 접속한다.
&lt;ul>
&lt;li>모바일 브라우저에서 카카오 메일을 접속하면 카카오톡으로 리다이렉트 되는데, 카카오톡에서는 해당 설정을 진행할 수 없다. 반드시 PC 로 접속한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>환경설정 &amp;gt; IMAP/POP3&lt;/strong> 을 클릭해서, IMAP 사용을 체크하고 저장한다.&lt;/li>
&lt;li>설정 앱으로 가서 ‘메일 &amp;gt; 계정’ 을 차례대로 누른다.&lt;/li>
&lt;/ol>
&lt;p>
&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/iphone-1.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/iphone-2.jpeg" width="200px" style="display: inline;"/>
&lt;/p>
4. 그 다음 ‘계정 추가’ 를 누른 다음 ‘기타’ 를 선택한다. 이후에 'Mail 계정 추가' 를 선택한다.
&lt;p>
&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/iphone-3.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/iphone-4.jpeg" width="200px" style="display: inline;" />
&lt;/p>
5. 기본 정보를 입력한다. 이메일과 암호는 쓰던 걸 쓰면 되고 이름이나 설명은 자유롭게 입력한다.
&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/iphone-5.png" width="300px" />
6. IMAP 또는 POP 을 선택하는 탭이 있는데, 어느 것을 선택하던 상관없지만 IMAP 으로 진행한다.
&lt;br/> &lt;br/>
&lt;p>이제 안내된 대로 주소를 설정한다. &lt;a class="link" href="https://cs.kakao.com/helps?articleId=1073195244&amp;amp;service=156&amp;amp;category=519&amp;amp;device=&amp;amp;locale=ko" target="_blank" rel="noopener"
>공식 FAQ 문서&lt;/a>, 7번 항목)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">- 아이디 : 카카오메일 아이디 (ooooo@kakao.com 에서 앞 부분)
- 비밀번호 : 카카오 계정 비밀번호
- IMAP (받는서버) : imap.kakao.com:993 (SSL)
- SMTP (보내는서버) : smtp.kakao.com:465 (SSL)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>SSL 은 아마 처음 설정할 때 바로 시도할 것이다. 포트 번호는 당장 신경 쓰지 않아도 되는데, 나중에 계정 저장을 한 다음에 포트 세부설정이 가능한 곳이 있긴 하다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="비밀번호가-맞는데-되지-않아요">비밀번호가 맞는데 되지 않아요&lt;/h2>
&lt;p>혹시 2단계 인증을 쓰고 있지 않은지? 그렇다면 기존 비밀번호로는 인증을 할 수 없다. 사람이 로그인을 했다면 카카오톡에 들어가서 인증하기를 눌러줬겠지만, 이건 아이폰이니까.&lt;/p>
&lt;p>그래서 ‘앱 비밀번호’ 라는 걸 발급받아야 한다. PC 에서도 발급이 가능하지만, 어차피 아이폰에서 복사해서 바로 붙여넣을 예정이니, 모바일로 해 보자.&lt;/p>
&lt;ol>
&lt;li>이번에는 모바일 기기에서 ‘카카오톡’ 앱을 실행한다.&lt;/li>
&lt;li>‘&amp;hellip;’ 버튼을 누르고, 오른쪽 위에 있는 톱니바퀴를 누른다.
&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/kakao-1.jpeg" width="300px" />&lt;/li>
&lt;li>개인/보안 → ‘카카오 계정’을 누르고, 나오는 화면에서 ‘2단계 인증’ 을 누른다.&lt;/li>
&lt;/ol>
&lt;p>
&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/kakao-2.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/kakao-3.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/kakao-4.jpeg" width="200px" style="display: inline;"/>
&lt;/p>
4. 비밀번호를 입력한 뒤, ‘앱 비밀번호’를 누른다.
&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/kakao-5.jpeg" width="300px" />
5. 앱 이름을 원하는 대로 입력하고, ‘생성’ 을 누르면 앱 비밀번호가 뜬다. 앱 비밀번호는 다시 볼 수 없기 때문에, 복사해 두거나 메모해 둬야 한다. 비밀번호를 놓쳤다면, 삭제했다가 다시 만들면 되니까 걱정하지 말자.
&lt;br/> &lt;br/>
&lt;p>이 앱 비밀번호를, 원래 비밀번호 대신 입력하면 서버 접속이 가능하다.&lt;/p>
&lt;h2 id="네이버는-어디서">네이버는 어디서?&lt;/h2>
&lt;p>이번에도 모바일 환경에서 해 볼 것이다. 네이버 앱으로 해도 되고, 일반 브라우저 에서 해도 상관없다.&lt;/p>
&lt;ol>
&lt;li>네이버에 로그인 한다.&lt;/li>
&lt;li>오른쪽 위에 있는 프로필 아이콘을 누른 뒤, 다시 왼쪽 위에 있는 프로필 아이콘을 누른다.&lt;/li>
&lt;li>&amp;lsquo;내 정보 및 프로필 관리&amp;rsquo; 에 있는 본인 계정을 누른다.&lt;/li>
&lt;li>보안 설정 및 비밀번호 변경을 클릭한다.
&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/naver-3.jpeg" width="300px" />&lt;/li>
&lt;li>2단계 인증 항목에서 관리하기를 클릭한다.
&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/naver-4.jpeg" width="300px" />&lt;/li>
&lt;li>조금 스크롤을 내리면, 애플리케이션 비밀번호 관리 항목이 보인다.
&lt;img src="https://1nterp.github.io/images/2022-02-04-kakao-email/naver-5.jpeg" width="300px" />
&lt;ul>
&lt;li>종류에서 아이폰을 선택해도 되지만, 카카오에서의 이름 설정에 지나지 않기 때문에, 아무거나 입력해도 된다.&lt;/li>
&lt;li>생성하기 버튼을 누르면 비밀번호가 보인다. 마찬가지로, 지금 복사하거나 메모해두지 않으면 나중에 다시 볼 수 있는 방법이 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Hugo SCSS Rebuild</title><link>https://1nterp.github.io/tech/2020-01-31-hugo-scss-rebuild/</link><pubDate>Fri, 31 Jan 2020 00:35:23 +0900</pubDate><guid>https://1nterp.github.io/tech/2020-01-31-hugo-scss-rebuild/</guid><description>&lt;p>Tale 테마로 블로그를 처음 시작하려고 보고 있는데, 여기서 SCSS 내용을 변경해도 &lt;code>hugo server -D&lt;/code> 를 하니까 변경 내용이 적용이 되지 않았다. &lt;a class="link" href="https://gohugo.io/hugo-pipes/scss-sass/" target="_blank" rel="noopener"
>여기선&lt;/a> 잘 된다고 나와 있는데, 어떻게 해결했는지 자세히 적어본다.&lt;/p>
&lt;ul>
&lt;li>자세히 보니 이미 컴파일이 완료된 CSS 파일이 &lt;code>resources/_gen/assets/scss/scss/&lt;/code> 에 존재하고 있었다.&lt;/li>
&lt;li>설마 이것 때문인가? 삭제를 하고 다시 &lt;code>hugo server -D&lt;/code> 를 해보면 다음 문구가 반겨준다.
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">Building sites … ERROR 2020/01/31 00:27:39 Transformation failed: TOCSS: failed to transform &amp;#34;scss/tale.scss&amp;#34; (text/x-scss): this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information
Built in 16 ms
Error: Error building site: logged 1 error(s)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>그렇다, &lt;strong>extension version 이 아닌 일반 hugo 를 설치한 것이었다!&lt;/strong> &lt;a class="link" href="https://gohugo.io/getting-started/installing" target="_blank" rel="noopener"
>Install Hugo&lt;/a> 페이지에 다시 들어가 재설치하니 잘 되었다.&lt;/p></description></item><item><title>바보가 되고 있다</title><link>https://1nterp.github.io/%EB%B0%94%EB%B3%B4%EA%B0%80-%EB%90%98%EA%B3%A0-%EC%9E%88%EB%8B%A4/</link><pubDate>Thu, 29 Aug 2019 22:41:30 +0000</pubDate><guid>https://1nterp.github.io/%EB%B0%94%EB%B3%B4%EA%B0%80-%EB%90%98%EA%B3%A0-%EC%9E%88%EB%8B%A4/</guid><description>&lt;p>생각이 글이 되고 글이 정제된 다른 글이 되는 연계를 계속 해야 하는데. 어느 샌가 단편적인 이미지, 몇 분짜리 동영상, 흘러가는 명언에 시간을 소비하고 있는 것은 아닌지, 양심의 가책을 느낀다. 생각의 소스가 되는 것들이 저급한 것이라고 할 순 없겠지만, 그게 내 손에서 일궈진 것이 아니라서 값지지 않게 느껴진다. 유망주 투수의 현란한 로케이션이 담긴 GIF, 대중 매체를 알지 못하면 이해할 수 없는 드립, 당신을 움직이게 만들 것이라고 광고하는 몇 컷 짜리 자기계발서 요약 슬라이드들이 그런 것이다.&lt;/p>
&lt;p>이전에 내가 후배들에게 이런 말을 한 적이 있다.&lt;/p>
&lt;blockquote>
&lt;p>시장의 궁극적인 목적은 너의 돈을 소비하게 만드는 것이다. 그러려면 먼저 너의 시간을 사들이는 것에 혈안이 되어 있다. 그것이 바겐 세일, 심지어 공짜라 할 지라도. 한번 소비하기 시작하면, 너의 의지와 방향은 돈을 쓰지 않으면 안 될 지경으로 만든다. 와닿지 않는다고? 조금 완곡하게 말하자면, 조금의 불편함을 느끼게 만든다는 것이고, 마치 내가 이런 소비를 해서 내 인생에 도움이 될 것이라고 착각하게 만든다. 이전에는 없이도 잘 살았는데. 마치 욕구가 개방된 것 처럼.&lt;/p>
&lt;/blockquote>
&lt;p>사실 전혀 다른 주제 같아 보이는데, 인터넷과 유튜브는 정말이지 이런 자유시장에서 더욱 첨예하게 사람의 욕구를 개방하기 시작했다는 점에서 이어진다. 인터넷이란 것이 없었을 때, 집전화를 먹통으로 만들고 PC통신에 접속했을 때, ADSL 이 개통되었을 때, 지식인으로 모든 것을 묻고 답할 때, 싸이월드에서 일촌평을 남길 때, 그리고 지금 모든 인플루언서들과 모든 개인들이 저마다의 소리를 내며 자유시장에서 자리를 잡으려고 할 때. 시간의 흐름은 생산자와 소비자의 간격을 무너뜨리고, 정보 독점 체제를 무력화시킨 것 처럼 느껴지게 한다. 모두가 생산자이며 모두가 소비자가 되는 &lt;strong>더욱 복잡하고 현란하고 귀찮은 세상이 되었다.&lt;/strong>&lt;/p>
&lt;p>AI 와 로봇이 결합된 4차 산업혁명에 우려를 나타내는 많은 학자와 저자들이 한 목소리로 이야기하는 대안이 &amp;lsquo;&lt;span style="text-decoration: underline;">자아성찰&lt;/span>&amp;rsquo; 이라고 하는데, 나는 이게 이미 필수라고 생각한다. 나를 아는 방법 역시 쉽지 않고, 그런 걸 찾기 위한 수단으로 기술을 쓰는 것에 결코 반대하지 않는다. 하지만, 여기서 이야기하고 싶은 것은, 기술이 수단을 집어삼켜 나를 휘두르게 놔두지 말자는 것일 뿐. 그런 바보가 되지 말자.&lt;/p></description></item><item><title>Visual Studio Code Remote Deployment</title><link>https://1nterp.github.io/visual-studio-code-remote-deployment/</link><pubDate>Wed, 26 Jun 2019 05:11:21 +0000</pubDate><guid>https://1nterp.github.io/visual-studio-code-remote-deployment/</guid><description>&lt;p>Vim 과 SSH 에 찌들어 있었는데, 이번 Visual Studio Code 의 베타 기능인 Remote Deployment 를 연결해 보고 나서, 학생 때 쓰던 IDE 로 돌아간 것 같아 너무 좋았다. 언제까지고 구식 도구를 쓰며 부심을 부릴 수만은 없다. 설치 과정이 조금 험난했지만, 간단히 요약해서 써본다.&lt;/p>
&lt;p>클라이언트 OS 는 윈도우 10 (빌드 1809), 서버 OS 는 Cent OS 7 기준으로 작성한다.&lt;/p>
&lt;h2 id="클라이언트-윈도우-준비">클라이언트 (윈도우) 준비&lt;/h2>
&lt;p>처음에 준비할 때는 &lt;a class="link" href="https://code.visualstudio.com/insiders/" target="_blank" rel="noopener"
>Visual Studio Code Insider&lt;/a> 버전을 설치하라고 되어 있었는데, 이제는 꼭 그럴 필요 없는 것 같다. 일반 &lt;a class="link" href="https://code.visualstudio.com/Download" target="_blank" rel="noopener"
>Visual Studio Code&lt;/a> 를 설치해도 된다.&lt;/p>
&lt;p>다음으로, SSH 클라이언트를 설치한다. &lt;strong>윈도우 10 빌드 1807 이상 버전&lt;/strong>의 윈도우 OS 라면 &lt;a class="link" href="https://docs.microsoft.com/ko-kr/windows-server/administration/openssh/openssh_install_firstuse" target="_blank" rel="noopener"
>여기 링크&lt;/a> 안내를 따르거나, 아래 요약된 스크린샷을 보면 된다.&lt;/p>
&lt;p>시작 &amp;gt; 설정 앱에서, &amp;lsquo;앱&amp;rsquo; 을 클릭한 뒤 &amp;lsquo;앱 및 기능&amp;rsquo; 탭의 &amp;lsquo;선택적 기능 관리&amp;rsquo; 를 클릭한다. 그 다음 아래 &amp;lsquo;OpenSSH 클라이언트&amp;rsquo; 를 찾아 설치한다. OpenSSH 서버는 설치할 필요가 없다.&lt;/p>
&lt;p>&lt;img src="https://1nterp.github.io/uploads/2019/06/img_5d11df55e7f29.png"
loading="lazy"
>
&lt;img src="https://1nterp.github.io/uploads/2019/06/img_5d11df39e0722.png"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>만약에 여러분이 윈도우 10 빌드 1807 이하 버전의 윈도우 OS 라면… 조금 귀찮아진다. &lt;a class="link" href="%22https://code.visualstudio.com/docs/remote/troubleshooting#_installing-a-supported-ssh-client%22" >이 문서&lt;/a> 에 따르면, &lt;a class="link" href="%22https://git-scm.com/download/win%22" >Git for windows&lt;/a> 를 설치하면서 옵션에서 &lt;strong>Use Git and optional Unix tools from the Command Prompt &lt;/strong>를 선택하면 된다.&lt;br>
그러면, 같이 설치된 mingw 내부의 SSH 를 클라이언트로 사용한다고 한다. 물론 난 테스트해 보진 않았다! 권한 문제 등등으로 생각보다 꼬일 가능성이 있으므로, 조심해야 한다.&lt;/p>
&lt;/blockquote>
&lt;p>이제 ssh key 를 만들어야 한다. 비대칭 키에 대한 지식이 없다면 &lt;a class="link" href="https://arsviator.blogspot.com/2015/04/ssh-ssh-key.html" target="_blank" rel="noopener"
>암호 대신 SSH Key 로 인증하기&lt;/a> 포스팅을 참고하면 된다. 혹시 PuTTY 에서 생성한 비공개 키를 등록하고 쓰고 있으니 이걸로 충분하지 않을까? 그렇게 준비하면.. 실제 접속할 때 아마 잘 안 될 것이다.&lt;/p>
&lt;p>Visual Studio Code 는 OpenSSH (또는 Git 의 ssh) 클라이언트를 쓰기 때문에, Key 호환성 문제로 &amp;lsquo;invalid format&amp;rsquo; 에러를 발생시킬 수 있다. 그러니 순순히 (?) &lt;strong>실행 명령 창 (cmd) 을 열어서&lt;/strong> 다음을 입력하자. 기존에 쓰던 키 저장 경로가 존재한다면, 다른 경로로 설정하는 것을 추천한다. 이 방법은 &lt;a class="link" href="https://code.visualstudio.com/docs/remote/troubleshooting#_quick-start-ssh-key" target="_blank" rel="noopener"
>Visual Studio Code 페이지의 Troubleshooting&lt;/a> 에 등록된 내용이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">ssh-keygen -t rsa -b  &lt;span class="m">4096&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="서버-리눅스-준비">서버 (리눅스) 준비&lt;/h2>
&lt;p>원활한 서비스가 가능한 리눅스 OS 목록은 &lt;a class="link" href="https://code.visualstudio.com/docs/remote/linux" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하면 된다. Cent OS 7 은 잘 되므로 별 다른 설정 없이 가능하다. 지원이 안 되는 리눅스들은 workaround 가 있는데 (특시 Cent OS 6) 생각보다 까다롭고 원치 않는 상황이 발생할 수 있기 때문에 신중해야 한다.&lt;/p>
&lt;p>접속하고자 하는 계정의 &lt;code>~/.ssh/authorized_keys&lt;/code> 파일에다가, 아까 만들었던 Key Pair 중 &amp;lsquo;공개 키&amp;rsquo; 정보를 입력해야 한다. 해당 파일이 없으면 만들면 되고, 있으면 파일 끝에 추가 (append) 해주면 된다.&lt;/p>
&lt;p>&lt;code>~/.ssh/authorized_keys&lt;/code> 파일의 권한이 600 (계정에서만 읽기/쓰기가 가능) 인지 반드시 체크하고, 아니라면 &lt;code>chmod&lt;/code> 명령으로 바꿔주도록 한다. (이건 SSH 일반 접속 때문에 하는 작업이지, Visual Studio Code 라서 하는 것이 아니다.)&lt;/p>
&lt;h2 id="visual-studio-code-준비">Visual Studio Code 준비&lt;/h2>
&lt;p>우여곡절 끝에 준비를 다 했으면, Visual Studio Code 를 열어서 &lt;a class="link" href="https://aka.ms/vscode-remote/download/extension" target="_blank" rel="noopener"
>Remote Deployment&lt;/a> 를 설치하자. 그 다음, 명령 팔레트를 열어서 (Shift + Ctrl + P) &lt;strong>Remote-SSH: Open Configuration File…&lt;/strong> 을 선택한다. 설정 파일 경로는 수정하거나 기존에 잡아주는 경로를 쓰건 상관없다.&lt;/p>
&lt;p id="KhDFgvb">
&lt;img class="alignnone size-full wp-image-1524 " src="https://interp.blog/uploads/2019/06/img_5d12fc88e148b.png" alt="" srcset="https://interp.blog/uploads/2019/06/img_5d12fc88e148b.png 622w, https://interp.blog/uploads/2019/06/img_5d12fc88e148b-300x45.png 300w" sizes="(max-width: 622px) 100vw, 622px" />
&lt;/p>
&lt;p>예시는 이렇다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Host 192.168.0.10
HostName 192.168.0.10
User interp
IdentityFile &amp;#34;C:\Users\interp\ssh_key\id_rsa&amp;#34;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>Host : 목록에 나올 이름이다. 보통은 HostName 과 같이 지정해주거나 Username@HostName 으로 지정한다.&lt;/li>
&lt;li>HostName : 실제 접속할 호스트 주소&lt;/li>
&lt;li>User : 접속할 사용자 계정 이름&lt;/li>
&lt;li>IdentifyFile : 생성한 Key Pair 중 &amp;lsquo;비공개 키&amp;rsquo; 경로&lt;/li>
&lt;/ul>
&lt;h2 id="remote-로-접속">Remote 로 접속!&lt;/h2>
&lt;p>이제 설정 파일을 저장하고, 명령 팔레트를 열어서 (Shift + Ctrl + P) &lt;strong>Remote-SSH: Connect to Host…&lt;/strong> 을 선택한다. 아까 저장한 Host 가 1개만 떠 있을텐데, 접속하면 아예 새로운 Visual Studio Code 창이 하나 더 뜨게 된다.&lt;/p>
&lt;p>이것저것 하는 것 같으니 잠시 기다리면, 접속이 되었다는 메시지와 함께 &amp;lsquo;절대로 저 작은 터미널을 닫지 말아주세요&amp;rsquo; 라는 경고문이 뜬다. 최소화시키고 작업을 하면 된다!&lt;/p></description></item><item><title>경력직 면접의 단상</title><link>https://1nterp.github.io/%EA%B2%BD%EB%A0%A5%EC%A7%81-%EB%A9%B4%EC%A0%91-%EB%8B%A8%EC%83%81/</link><pubDate>Sun, 12 May 2019 12:40:26 +0000</pubDate><guid>https://1nterp.github.io/%EA%B2%BD%EB%A0%A5%EC%A7%81-%EB%A9%B4%EC%A0%91-%EB%8B%A8%EC%83%81/</guid><description>&lt;p>처음에는 경력직을 선호했고, 나도 그랬다.&lt;/p>
&lt;p>개발자를 충원하자는 계획에 맞춰, 공고를 등록하고 경력직 이력서를 받으면서 이 정도 커리어면 뭐든지 붙을 수 있을거라고 생각했을 것이다. 하지만 그 때의 실패들이 쌓여 이제는 경력직이나 신입이나 동일 선상에 놓고 평가하고 있다.&lt;/p>
&lt;p>내가 몸 담고 있는 필드는 국내에서 잘 하지 않는 분야다. 없진 않지만, 사용자 경험과 컴퓨터 구조를 동시에 신경 써야 하는 조직이다. (물론 개발자 1인이 모두 신경 쓰는 것은 아니다.) 그런데, 소위 SI 업체나 프리랜서 개발자들의 면접을 보면 괜히 미안해진다. 면접이 매끄럽지 못해서 미안한게 아니고, 이미 그들의 표정에서 &amp;lsquo;이걸 대체 왜 물어보는 건지&amp;rsquo; 싶은 느낌이 표정에 드러나기 때문이다.&lt;/p>
&lt;p>이야기를 나눠보면, 지원자 중 절반은 말 그대로 &amp;lsquo;잘못 왔다&amp;rsquo;. 그냥 솔루션 개발 쯤으로 알고 왔는데, 열어보니 이건 이상하다 싶었겠지. 나머지 반은 본인 실력을 다 못 보여준다. 왜냐하면 전혀 새로운 분야에서 요구되는 능력들이 자기가 일궈온 것과 좀 다르니까 거부감이 드는 것이다. 그래서 나도, 그들도 같이 지친다.&lt;/p>
&lt;p>어느 대기업 연구원 관리직의 댓글을 봤다. 오히려 박사/포닥 후 입사한 친구들이 너무 협소한 시각으로 보고서를 작성하기 때문에 설득력이 떨어진다는 것이다. 자기 분야에서만 논거를 찾아서 주장하거나, 다른 분야 사람이 오펜스라도 할라 치면 &amp;lsquo;당신이 뭘 알아&amp;rsquo; 라는 스탠스를 취한 경우를 많이 봤단다. 학교에서는 비즈니스나 의사소통을 가르쳐주지 않기 때문이라고 하면서. 차라리 회사에서 신나게 구르던 동일 경력의 친구들이 더 뛰어난 경우를 많이 봐왔다고 한다.&lt;/p>
&lt;p>이 이야기를 왜 꺼냈을까. 박사과정을 마친 사람들을, 하이 커리어를 쌓으신 많은 경력 개발자를 폄훼하기 위해서인가. 아니다. 그냥, 좋은 능력을 가지신 분들이 보인 부적응 현상들이 안타까워서 그랬다. 이제는 경력과 신입을 동일선상에 놓고 보고 있다. 기술 질문도 차이가 거의 없어졌다. 다만 한 가지, 소통하는 능력이 있는지를 본다. 달리 말하면 배우고자 하는 열의가 있는지 반드시 보고 다음 면접으로 올린다.&lt;/p>
&lt;p>나는 꼬리에 꼬리를 무는 질문을 좋아한다. 그래야 이 사람의 대응 방식을 볼 수 있다. 꼬리를 물렸을 때 대개는 따가워한다. 싫은 거다. 그래도 답하고 되물어봐야 한다. 힌트를 달라고 해도 좋다. 시험이 아니라 면접인데, 좀 물어보면 어떤가. 나와 논쟁을 한 지원자도 있었다. 내용이 좀 틀려도 괜찮았다. 둘 모두 기술면접을 통과했다.&lt;/p>
&lt;p>비즈니스는, 의사소통은 학교에서 가르쳐주지 않는다. 그런데… 경력은 이미 경험한 것들이다. 경력을 뽑는 가장 큰 이유는, 적응력이 신입보다 좋을 거라 기대하기 때문이다. 그것이 기술적이건 의사소통 능력이건 간에 말이다. 둘 다 못하면, 지금처럼 동일 선상에 세울 수 밖에 없을 것이다.&lt;/p>
&lt;p>최소한  자신이 가진 아집 정도는 벗어주면 좋겠다. 그래야 저런 소리 안 듣고 귀한 평가를 받을 것이다.&lt;/p></description></item><item><title>리더의 1원칙</title><link>https://1nterp.github.io/%EB%A6%AC%EB%8D%94%EC%9D%98-1%EC%9B%90%EC%B9%99/</link><pubDate>Thu, 09 May 2019 06:29:40 +0000</pubDate><guid>https://1nterp.github.io/%EB%A6%AC%EB%8D%94%EC%9D%98-1%EC%9B%90%EC%B9%99/</guid><description>&lt;p>메모로 남긴다.&lt;/p>
&lt;ul>
&lt;li>사람은 모두 다르다. 아주 많이.&lt;/li>
&lt;li>각자의 장점이 드러나도록 경험하게 해주고 발전하게 하라. 그리고, 장점과 그 성과를 열심히 칭찬해줘라.&lt;/li>
&lt;li>&lt;strong>무언가를 잘하는 사람은 결국 그걸 좋아하게 되어 있다.&lt;/strong>&lt;/li>
&lt;li>무언가를 잘하고 좋아하게 되면, 자신의 자존감이 올라간다.&lt;/li>
&lt;li>자존감이 올라간 후엔, 자존감을 지키지 위해서 알아서 움직인다.&lt;/li>
&lt;/ul>
&lt;p>이 말을 관통하는 TODO 는 딱 하나. &lt;strong>장점이 드러나도록 밀어주고, 칭찬해줘라.&lt;/strong>&lt;/p>
&lt;p>철칙처럼 지켜야 한다는 생각이 들었다. 여기에 내 생각을 덧붙인다.&lt;/p>
&lt;ul>
&lt;li>뭘 잘하는지 찾는 건 굉장히 어렵다. 잘 한다고 생각했는데 통수맞을 확률이 생각보다 높다.&lt;/li>
&lt;li>잘 하는데 하기 싫어하는 경우에 대한 과정도 중요하다.&lt;/li>
&lt;li>일이란게 늘 그렇듯, 그 사람이 잘 하는 것만 시킬 수 없다. 이에 대한 과정 역시 중요하다.&lt;/li>
&lt;li>사람이 늘 그렇듯, 단점이 크게 보인다. 못 본 척 하려고 노력하는 것도 쉽지 않을 정도로.&lt;/li>
&lt;/ul>
&lt;p>결론은, 이 철칙을 쉽게 지킬 수 없지만 지키기 위해 노력해야 된다는 것.&lt;/p>
&lt;p>참고로, 이 원칙은 육아에도 적용된다고 한다. 덧붙인 내 생각도 육아에 적용되겠단 생각을 해 본다.&lt;/p></description></item><item><title>공측도와 무리수</title><link>https://1nterp.github.io/%EA%B3%B5%EC%B8%A1%EB%8F%84%EC%99%80-%EB%AC%B4%EB%A6%AC%EC%88%98/</link><pubDate>Sat, 27 Apr 2019 11:32:38 +0000</pubDate><guid>https://1nterp.github.io/%EA%B3%B5%EC%B8%A1%EB%8F%84%EC%99%80-%EB%AC%B4%EB%A6%AC%EC%88%98/</guid><description>&lt;p>&amp;lsquo;알고리즘 산책&amp;rsquo; 책 요약이다. 공측도라는 개념이나, 귀류법을 사용한 증명 등의 내용을 까먹지 않으려고 정리한다. 물론 이미 다 어릴 적 배웠겠지만, 다시 공부한다는 마음으로 정리하는 것이다.&lt;/p>
&lt;p>최대공측도는 최대공약수 같은 개념이다. 선분 A와 B가 특정한 길이로 측정이 가능할 때, 이 길이 중 가장 긴 길이를 최대공측도라고 하는 것이다. 이 값을 코딩으로 구하려면, 최대공약수를 계산하는 방법과 다르지 않을 것이다. (여기서 공측도 값이 되는 선분 길이는 자연수여야 한다.)&lt;/p>
&lt;p>그런데 19세기 조지 크리스털이 증명한 것은, 정사각형의 변과 대각선의 변을 동시에 측정할 수 있는 선분은 &lt;strong>없다&lt;/strong>는 것이다. 왜일까? (다시 말하지만 공측도는 자연수이다.)&lt;/p>
&lt;p>귀류법을 통해, 정사각형의 변과 대각선의 변을 동시에 측정할 수 있는 선분이 있다고 가정해보자. 요약하자면, 이 선분으로 정사각형을 그리고, 또 그 정사각형에서 한 변과 대각선을 측정할 수 있는 선분 (공측도) 이 있고, 계속 이런 식으로 정사각형을 그려나가다 보면, 어느 순간 &lt;span style="text-decoration: underline;">가장 작은 정사각형&lt;/span>이 나올 것이다. 하지만 가정에 따르면, 이 경우에도 대각선과 공측도가 되는 선분이 존재할 수 있게 된다. 그렇다면 더 작은 정사각형을 그릴 수 있게 되므로 모순이 생긴다.&lt;/p>
&lt;p>그래서 대각선은 자연수가 아니라는 단서가 되었고, 이로 인해 무리수 $\sqrt{2}$ 를 발견할 수 있게 되었다고 한다.&lt;/p></description></item><item><title>예쁜 낙서장을 원했던 걸까</title><link>https://1nterp.github.io/%EC%98%88%EC%81%9C-%EB%82%99%EC%84%9C%EC%9E%A5%EC%9D%84-%EC%9B%90%ED%96%88%EB%8D%98-%EA%B1%B8%EA%B9%8C/</link><pubDate>Tue, 23 Apr 2019 21:46:13 +0000</pubDate><guid>https://1nterp.github.io/%EC%98%88%EC%81%9C-%EB%82%99%EC%84%9C%EC%9E%A5%EC%9D%84-%EC%9B%90%ED%96%88%EB%8D%98-%EA%B1%B8%EA%B9%8C/</guid><description>&lt;p>정갈한 한정식도 아니고, 욕쟁이 할머니가 내어 주는 재미있는 맛이 담긴 한 끼도 아니고, 그냥 쓱쓱 싹싹 콩나물과 보리밥에 눈물 참기름 한 방울, 매운 인생 맛 큰 숟갈 넣어 아구와구 비벼먹을 건데. 일기장은 이뻐봤자 나만 만족하는 것이다. 그런데 난 그게 중요하다고 보거든.&lt;/p>
&lt;p>개인적인 이야기와 바깥의 이야기를 구분했으면 해서 만든 것이 블로그였는데, 이제는 그 경계가 모호해진 것 같다. 그 외줄타기를 잘 해야 내 아이덴티티가 쇼윈도에 걸리는 것이긴 하지만, 난 양산형 마네킹이 아니니까 으레 생각하는 사람들과는 다른 기괴한 포즈를 취할 수 있다. 혐오감을 줄 수도 있고, 저놈 저거 노력하네 같은 행인들의 빈말 몇 마디 정도는 듣겠지.&lt;/p>
&lt;p>어릴 적에 그림을 그리거나 글을 쓰면 반 친구들 몇몇이 우루루 와선 돌려보곤 했다. 별 것 없는 내용, 뻔한 전개지만 내 나름 가장 활발한 리뷰어 (Reviewer) 들이었노라고 자부할 수 있다. 칭찬과 비난이 뚜렷이 섞인 말들은 이내 비난도 지쳐버린 자들의 과거속으로 숨어버렸다. 나도 그랬으니까. 그리고 내 글도 숨었다.&lt;/p>
&lt;p>숨기 싫어서 나온건데, 아직도 예쁜 일기장을 고르려 핫트랙스를 기웃거리는 중학생의 심정에서 벗어나질 못했다. 플랫폼은 뭘 하지? NAS 를 사서 내 개인 서버를 꾸며볼까? 책을 읽으려면 아이패드를 사야지? (글 쓰는데 왜 갑자기 아이패드야) 정신을 차려보니, 고민은 목적을 한참 벗어나서 멋대로 날뛰고 있었다.&lt;/p>
&lt;p>이제 이런 고민 다 필요가 없다. 묵묵히 쓰는게 짱이다. 예쁜 낙서장은 이제 그만 골라야겠다.&lt;/p></description></item><item><title>더욱 오늘을 의미있게 살자</title><link>https://1nterp.github.io/%EB%8D%94%EC%9A%B1-%EC%98%A4%EB%8A%98%EC%9D%84-%EC%9D%98%EB%AF%B8%EC%9E%88%EA%B2%8C-%EC%82%B4%EC%9E%90/</link><pubDate>Thu, 18 Apr 2019 01:33:12 +0000</pubDate><guid>https://1nterp.github.io/%EB%8D%94%EC%9A%B1-%EC%98%A4%EB%8A%98%EC%9D%84-%EC%9D%98%EB%AF%B8%EC%9E%88%EA%B2%8C-%EC%82%B4%EC%9E%90/</guid><description>&lt;img src="https://1nterp.github.io/uploads/flying_bg.jpg" alt="Featured image of post 더욱 오늘을 의미있게 살자" />&lt;p>좌우명이 뭐냐고 물으신다면, 곁에 두고 보는 말 같은 진부한 설명 대신에 &amp;lsquo;예상치 못한 상황에서 생각이나 행동의 근거가 되는 첫 번째 기준이나 신념을 말로 표현한 것&amp;rsquo; 이라고 하고 싶다. 우리는 모든 상황을 가정하고 살 수도 없고, 모든 것을 경험하며 살 수도 없다. 모든 것이라는 집합 자체가 유한하지 않은 것이 첫번째고, 우리의 생 또한 무한하지 않은 것이 그 다음이다.&lt;/p>
&lt;p>그래서 내 좌우명은 무어냐고 또 물으신다면, 조금 생각을 해 봐야겠다. 내 초등학교 시절은 으레 다른 친구들이 그랬듯 위인전에서 나온 명언 중 마음에 드는 하나를 골라 좌우명이라고 정하고 다녔기 때문에, 당시 내 좌우명도 &amp;lsquo;시간을 금 같이 보라&amp;rsquo; 였다. 어, 이거 최영 장군은 조금 다르게 이야기한 것 같은데, 아무튼 난 이게 마음에 들었다. 시간은 소중히 써야 한다. 지나간 시간은 저축할 수 없기 때문에 매 순간 의미가 있어야 한다고 생각했나보다. 일기를 읽어보면 그런 것 같다.&lt;/p>
&lt;p>어린 시절의 어떤 치기로 선택받은 이 좌우명에 기름칠을 조금 해서, 지금의 내 좌우명을 정해본다. &amp;lsquo;더욱 오늘을 의미있게 살자&amp;rsquo;. 너무 달라졌는데? 하지만 의미는 확실히 살았다고 말하고 싶다. 시간이라는 단어는 단위로 설명할 수 없는 추상화된 개념이다. 시간을 소중히 써야 한다면, 특정 시간 단위를 집중해서 살자고 말하는게 더 설득력있어 보였다. 매 초 열심히 살자? 그렇다면 이미 성공한 횟수보다 실패한 횟수가 더 많다. 좌절 느끼기 딱 좋은 말이구만. 단위를 넓게 잡아 &amp;lsquo;하루&amp;rsquo; 라고 지었다.&lt;/p>
&lt;p>그냥 의미있게 살면 되지, 더욱은 뭘까. &amp;lsquo;어제의 나&amp;rsquo;를 통해 반성하고 칭찬하면서 &amp;lsquo;오늘의 나&amp;rsquo;를 더 의미있게 살게 할 수는 없을까? 하는 뜻이다. 이 말 대로 엄밀히 구분하자면, 어제와 오늘은 연속성이 없다. 하지만 인생이라는 끈 위에서는 모두 이어져있으니까. 그 위에서 줄타기를 해야 한다면 어제의 내가 했던 의미를 발전시켜 갈 수도 있고 잘못된 방향을 바로 잡아 앞으로 나아갈 수 있지 않을까.&lt;/p>
&lt;p>뜬금없지만, 영화 &amp;lsquo;아저씨&amp;rsquo; 에서 차태식 대사 중 유명한 것이 있다. &amp;lsquo;너흰 내일만 보고 살지.. 난 오늘만 보고 살아..&amp;rsquo; (뒷 말은 욕이니까 생략하고) 내일을 보고 사는 것은 오늘을 희생해서 내일의 불확실한 나에게 짐을 덜어주는 의미도 되겠지만, 오늘을 소비하고 내일의 나에게 책임을 떠넘긴다는 이중적인 의미로도 해석할 수 있다. 나는 둘 다 마음에 들지 않는다. 오늘의 내가 내일의 나에게 방향을 제시하고 이뤄놓은 것에 대한 설명은 해 줄 수 있겠지만, (계획에 없는데 의도적으로) 내일 해야 할 일을 오늘 몰아 하는게 과연 맞는가? 신용 카드를 긁으면서 내일의 내가 좌절해 줄 거라고 충동적으로 결정하는 게 과연 맞는가 말이다.&lt;/p>
&lt;p>그래서, 미래의 내가 덜 부끄럽게 과거의 내가 제시한 방향이 헛되지 않게 오늘은 의미있게 살아야 한다. 그 의미가 뭐냐? 글쎄, 그건 매일 달라질 수 있겠다. 위기를 극복하고, 성취를 만끽하고, 사고에 대처하고, 기쁠 때 기쁘고 슬플 때 슬퍼하고…&lt;/p>
&lt;p>물론 의미없는 날을 보낼 수도 있다. 내 의지와 다르게 흘러가는 날이 있을 것이고, 아니 오히려 그런 날들이 한 해에 더 많이 일어날 것이다. 그래도 지켜야 하는 것은, 그렇지 않은 날까지 내 의지와 무관하게 흘러가는 것 처럼 간주해서는 안 되는 소중한 시간들이기 때문이다. 지금 이 시간도 그렇다.&lt;/p>
&lt;p> &lt;/p>
&lt;p>덧. 이걸 하려면 반드시 해야 할 일이 있다. &lt;strong>일기를 써야 한다.&lt;/strong> 무슨 내용이든 좋지만, 칭찬 6에 반성 3, 감상 1 정도의 비율로 적어주면 가장 좋다. 기분에 따라 감상 10이 될 수도 반성 10이 될 수도 있지만 너무 한 쪽으로 치우쳐 적으면 나중에 읽을 때 좀 오글거리고 읽기 싫어진다.&lt;/p></description></item><item><title>Windows SSH RSA Key 문제 해결</title><link>https://1nterp.github.io/windows-ssh-rsa-key-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/</link><pubDate>Mon, 18 Mar 2019 04:50:30 +0000</pubDate><guid>https://1nterp.github.io/windows-ssh-rsa-key-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/</guid><description>&lt;img src="https://1nterp.github.io/images/featured/ssh-rsa.jpg" alt="Featured image of post Windows SSH RSA Key 문제 해결" />&lt;p>Windows Server 2016에서 OpenSSH 를 설치하고, cmd 에서 다음과 같이 RSA 키를 생성한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ ssh-keygen -t rsa
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>그러고 Public Key 를 SSH Server 에 위치한 authorized_keys 파일에 추가하고 접속을 시도하면?&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: UNPROTECTED PRIVATE KEY FILE! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Permissions &lt;span class="k">for&lt;/span> &lt;span class="s1">&amp;#39;C:\\Users\\interp/.ssh/id_rsa&amp;#39;&lt;/span> are too open.
It is required that your private key files are NOT accessible by others.
This private key will be ignored.
Load key &lt;span class="s2">&amp;#34;C:\\Users\\interp/.ssh/id_rsa&amp;#34;&lt;/span>: bad permissions
interp@192.168.0.30&lt;span class="err">&amp;#39;&lt;/span>s password:
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>오잉? 내 파일이 맞는데 이게 뭘까. Private Key 파일에 마우스 우클릭을 하고 봤더니 여러 사용자가 읽기 권한으로 걸려 있는 것을 확인할 수 있었다. 이건 아니다… 등록된 사용자를 전부 지우고 현재 사용자에게 모든 권한을 준 다음에, 확인을 눌러 권한 변경을 해 준다.&lt;/p>
&lt;p id="euLmFtS">
&lt;img class="alignnone size-full wp-image-1518 " src="https://interp.blog/uploads/2019/06/img_5d11dcea1b41a.png" alt="" srcset="https://interp.blog/uploads/2019/06/img_5d11dcea1b41a.png 421w, https://interp.blog/uploads/2019/06/img_5d11dcea1b41a-218x300.png 218w" sizes="(max-width: 421px) 100vw, 421px" />
&lt;/p>
&lt;p>&amp;lsquo;편집&amp;rsquo; 에 가서 등록된 사용자를 지우려고 하면, 상속으로 인해 지울 수 없다는 괴상한 에러가 뜰 것이다. 그러니까 위 화면에서 &amp;lsquo;고급&amp;rsquo; 으로 간 다음, 아래 캡처에 있는 &amp;lsquo;상속 사용 안 함&amp;rsquo; 을 클릭하면 자동으로 지워진다. 그 다음 시도하면, 잘 된다!&lt;/p>
&lt;p id="bzFxOJb">
&lt;img class="alignnone size-full wp-image-1519 " src="https://interp.blog/uploads/2019/06/img_5d11dd707fe99.png" alt="" srcset="https://interp.blog/uploads/2019/06/img_5d11dd707fe99.png 293w, https://interp.blog/uploads/2019/06/img_5d11dd707fe99-216x300.png 216w" sizes="(max-width: 293px) 100vw, 293px" />
&lt;/p>
&lt;p>출처 : https://superuser.com/questions/1296024/windows-ssh-permissions-for-private-key-are-too-open&lt;/p></description></item><item><title>우리의 이상적인 순간</title><link>https://1nterp.github.io/%EC%9A%B0%EB%A6%AC%EC%9D%98-%EC%9D%B4%EC%83%81%EC%A0%81%EC%9D%B8-%EC%88%9C%EA%B0%84/</link><pubDate>Mon, 11 Feb 2019 06:44:30 +0000</pubDate><guid>https://1nterp.github.io/%EC%9A%B0%EB%A6%AC%EC%9D%98-%EC%9D%B4%EC%83%81%EC%A0%81%EC%9D%B8-%EC%88%9C%EA%B0%84/</guid><description>&lt;p>햇살이 드리우는 책상 앞에 따뜻한 아메리카노 한 잔을 두고, 논문을 집어들어 책갈피 너머의 페이지로 넘겨 보는 나 자신을 상상하는 모습을 그려본 적이 있다. 학창 시절 때는, 집중해서 공부하는 지금 이 순간의 내 모습을 내가 본다면 어떤 기분일지 상상한 적도 있다. 그러면 이내 흐트러지고, 방금 전 몰두하던 이는 찾아볼 수 없게 되었다.&lt;/p>
&lt;p>자신이 그리는 이상을 직접 행하고 있을 때는, 그 상황을 자신이 그려왔던 것인지 알 수 없는 경우가 많다. 왜냐하면, 실제로는 그 장면이 아름답거나 만족하는 순간이 될 수 없기 때문이다. 바로 이런 장면을 보려고 하는 나 자신이 잠시 사라지는 순간이다. 숙제를 하거나, 일을 하거나, 연습을 하거나, 게임을 하거나, 그 장면 자체는 멋져보일 수 있겠지만 그 속에 있는 정신은 이루 말할 수 없는 수 많은 것들에 신경을 쓴다. 그것들은, 안에 들어있는 것들은 결코 아름답거나 원한 것이 아니다. 물론 이 과정, 이 결과를 상상하는 사람이 돌리는 쳇바퀴일 수 있다. 하지만 이 순간을 바라보는 사람은 동시에 존재하지 않는다.&lt;/p>
&lt;p>알아차리게 되더라도, 그 순간의 심적 평화는 깨지기 마련이다. 마치 유체이탈이라도 한 양, 관찰자로 빠져나간 빈 껍데기 같은 정신은 그 순간을 유지할 힘을 잃어버린다.&lt;/p>
&lt;p>우리는 사실 뒹굴거리고 싶고, 닥치는 대로 먹고 마시고 싶다. 그러나 우리가 계속 &amp;lsquo;우리의 이상적인 순간&amp;rsquo;을 그려야 하는 이유는, 객관화라고 착각하지만 사실 사회에서 배워 온 &amp;lsquo;편견&amp;rsquo; 속에서 우리를 가두고자 하는 희미한 의지 때문이다. 그 편견의 이미지를 지키는 이유는, 바로 주위 사람들 때문이다. 내 시선이 아닌 다른 시선에 의존한다. 왜? 우리는 언제나 외롭기 때문이다.&lt;/p>
&lt;p>외로움을 선택한 사람들이 있다. 햇살도 없는 바로 그 곳에서.&lt;/p></description></item><item><title>V.I.P.</title><link>https://1nterp.github.io/v-i-p-2017/</link><pubDate>Sat, 12 Jan 2019 22:17:19 +0000</pubDate><guid>https://1nterp.github.io/v-i-p-2017/</guid><description>&lt;img src="https://1nterp.github.io/images/featured/vip.jpg" alt="Featured image of post V.I.P." />&lt;p>신세계 이후로 박훈정 감독의 작품이 3편 나온 것으로 안다. 「대호」, 「마녀」, 그리고 「V.I.P.」  이다. 대호는 시놉시스부터 끌리지 않아서 앞으로도 안 볼 생각이고, 나머지 두 편은 시간이 난 김에 몰아서 봤다. (그래서 다음 리뷰는 마녀를 할 것이다.)&lt;/p>
&lt;p>박훈정 감독이 각본에만 참여한 다른 두 영화에서 느꼈던 것과 달리, 각본/감독을 병행한 이후에는 찰진 대사도 줄어들고 스토리도 힘이 점점 빠지는 것 같아 보인다. 여기서 「악마를 보았다」 가 얼마나 잔인했니, 「부당거래」 와 「신세계」가 가지는 힘은 어디서 있는지를 다 이야기하는 건 주제를 많이 벗어나지만, 오늘 이야기할 &lt;strong>「V.I.P.&lt;/strong>」 와 비교될 선배격 작품들로 써먹을 예정이다.&lt;/p>
&lt;p style="text-align: center;">
&lt;span style="color: #ff6600; font-size: 0.8em;">※ 대놓고 언급하진 않겠지만, 스포일러가 소량 있을 수 있습니다. 감독의 전작품에 대한 언급도 있습니다.&lt;/span>
&lt;/p>
&lt;h2 id="논란이-될-만한-악행">논란이 될 만한 악행&lt;/h2>
&lt;p>사실 여성 범죄는 「악마를 보았다」 에서도 나온다. 규모는 작지만, 디테일은 더 끔찍하다. 하지만 그 때는 조용하고 지금은 왜 시끄러웠냐고? 악인으로 분한 배우가 최민식이 아니라 이종석이어서, 라고 이야기하는건 아니다. 전자의 묘사가 필요했다고 느껴진다면, 여기서는 낭비했기 때문에 논란이 된 것이라 생각한다.&lt;/p>
&lt;p>필모그래피 동일 선상에 있는 다른 악행을 보면, 설명에 군더더기가 작다. 수현은 자신의 아내를 강간살해한 악마같은 놈에게 가하는 폭력과, 의혹의 소용돌이에서 범인을 조작한 조폭과 경찰이 빠져나오려 하는 발버둥과, 권력 다툼에서 의리와 자기보전을 해야 하는 정청의 선택이 설명이 된다는 것이다. 지나고 보면 세 영화에 모두 장황한 설명은 없다. 그나마 가장 많다고 생각하는게 「악마를 보았다」 정도이고, 나머지는 씬 몇 개로 주인공의 처지를 대변한다.&lt;/p>
&lt;p>그런데 이 영화는, 김광일이 얼마나 나쁜 놈인지 너무 많이 설명하고, 이제 그만 됐다고 하는데도 너무 보여준다. 한편으로는, 이 정도 잔인해야 리대범이 탈북해서 잡아 죽이려고 하고 채이도가 꼭 잡으려고 했을 것이라고 하지만, 리대범은 어차피 복권해야 하는 명분이 있었고 국내 범죄만 규모로 설명했어도 채이도 역시 명분을 줄 수 있었다.&lt;/p>
&lt;p>감독이 노린 건 김광일의 약점을 노출하기 위한 것이었을까. 그마저도 어차피 극 중반에 언급될 것이였다. 김광일이 분노할 수 있는 유일한 포인트로 대비되기 때문에, 그렇게 초반을 롱테이크로 관객 고문을 했어야 했는지는 아직도 의문이다.&lt;/p>
&lt;h2 id="일단-스토리">일단, 스토리&lt;/h2>
&lt;p>강간 살해 묘사를 하는 것은 어차피 전례 (?)를 밟은 영화가 있어서 사실상 깔 거리는 못 된다. 그냥 보기 역해서 그런 것 뿐이다. 만약 이것 &amp;lsquo;만&amp;rsquo; 문제였다면 어차피 상관없었다.&lt;/p>
&lt;p>이 영화의 진짜 목적은, 이런 또라이 김광일을 어떻게 처리할 것인지에 따라  CIA (피터 스토메어, 폴 그레이 役), 국정원 (장동건, 박재혁 役), 대한민국 경찰 (김명민, 채이도 役), 북한 보위부 (박희순, 리대범 役) 의 눈치게임을 열심히 하다가, 점점 악행 자체에 초점이 모이는 것이었다. 영화는 여기서 실패했다.&lt;/p>
&lt;p>김광일이 저렇게 미친 짓을 하고 다녀도 눈감아주는 것은, 장성택의 계좌를 관리하는 간부의 아들이었기 때문이다. 그래서 북한에서는 눈감아주고, 되려 수사를 지휘하던 리대범을 좌천시켜버린다. 그런데 갑자기 장성택이 실권되면서 김광일은 북한 밖으로 탈출하게 되는데, 이걸 CIA 에서 &amp;lsquo;국정원이 보호하고 있으라&amp;rsquo; 고 했고 박재혁의 선배 (박성웅 扮) 이 관리하면서 국내에서도 사건이 발생하게 된다… 는 전개다.&lt;/p>
&lt;p>국정원이 몰랐다면 한심한거고, 국정원이 알았다면 도덕적 해이다. 숨은 묘사에서는 국정원 관리팀 여직원도 당했다는 말도 있다. &lt;strong>아마도 김광일이 악인일 줄 몰라서 데려왔는데&lt;/strong> 사건이 터졌고, 자기 얼굴에 똥칠하기 싫어서 적당히 수습하고 나몰라라 했다고 추측해야 맞겠다. 이런 추측이 스토리 라인에 별로 도움도 안 되고, 설명을 해 줘도 똑같은 취급 당했을 테다.&lt;/p>
&lt;p>&lt;strong>김광일이 비호를 받는 이유를, 북한의 권력 구조가 바뀌는 과정에서 이해해야 한다&lt;/strong>는 점도 관객들에게 불친절하다. &lt;del>&lt;span style="color: #999999;">총 4단계인데, 적고 보니 스포일러라 못 적겠다.&lt;/span>&lt;/del> 이 과정을 이야기해주는 포인트가 존재하긴 하지만, 굉장히 빠르게 지나간다. 북한 사정을 잘 모르는 사람은 &amp;lsquo;&lt;em>장성택이 뭐 어쩌라고&lt;/em>&amp;rsquo; 라는 식으로 영화를 볼 수 밖에 없다. 그러니까 김광일을 가지고 배구놀이를 하는 이유가 부실해진다. 결국 남는 명분은 돈(계좌)인데, 이 맥거핀이 결말에 가면 힘이 엄청 떨어진다. 이젠 그런거 다 소용없다고 관객이 이미 느껴버리니까, 엔딩이 전혀 와닿지 않는 것이다.&lt;/p>
&lt;p>&lt;strong>박재혁도 그렇지만, 채이도와 리대범은 더욱 개성없는 캐릭터로 전락했다.&lt;/strong> 채이도는 계속 욕만 하고 범인 잡아야 한다는 사명감으로 전진만 한다. 뭐? 못하는게 어딨어, 범인 잡아와. 뭐? 북에서 왔어? 탈북자 꺼져. 뭐? 수사거래? 니들 지금 장난하냐. 죽은 수사반장과의 연민이나 하다못해 안타까운 과거사를 끼웠어도 극적이었을 것 같은데. 그런 건 김광일에게 죽을 뻔 한 리대범이 차라리 낫지만, 왜 그렇게 쫓았는지에 대한 건 역시 별로 없다.&lt;/p>
&lt;p>감독의 시나리오는 각 인물을 설명하는 챕터가 별개로 있는데, 영화에 넣기 너무 길어서 제외했다고 한다. 채이도와 리대범은 추가 설명이 반드시 필요한 인물이었는데, 놓친게 아쉽다.&lt;/p>
&lt;p>반대로, &lt;strong>피해자 또는 유족에게는 냉혈한인 사람들이 이해적대관계에 있는 사람들과 너무 정을 나누기 때문에 불합리&lt;/strong>하다고 말하는 평에는 동의하지 않는다. 이 영화는 그런 장면이 없더라도, 무드는 충분히 깔렸다. 리대범은 사실상 당이 쫒지 마라면 하지 말아야 되는데, 피칠갑이 된 일가를 보고는 수사 의지를 내비친다. 너무 잔인하니까. 채이도 역시 &amp;lsquo;미국에는 사람 안 사냐&amp;rsquo; 며 추가 범죄를 우려한다. 박재혁은 그 사이에서 갈등하는 인물로 그려진다.&lt;/p>
&lt;p>오히려 세 명의 처지들이 너무 박해서 (복권을 바라는 탈북자, 수습을 원하는 풍전등화의 국정원 요원, 극한 사명감에 시달리는 &lt;span style="color: #999999;">&lt;del>욕쟁이&lt;/del>&lt;/span> 형사) 앞만 보고 뛰어가도 모자라는 압박에 시달리는데, 그 같은 터널을 지나는 사람들이었으니 사고가 났을 때 더 와닿은 것 뿐이다. 그 감정이 주입되는 순간 영화의 장르가 달라진다.&lt;/p>
&lt;h2 id="연기는">연기는?&lt;/h2>
&lt;p>그래도 장르적인 영화로 소기의 성과를 달성했다고 생각하는 건, 나는 &lt;strong>스토리가 말이 되면 영화나 드라마가 지루해지니까 적당히 상상해서 맞춰 봐야한다&lt;/strong> 라는 입장이기 때문이다. 드라마는 설명할 수 있는 여지가 많지만 영화는 절대적으로 부족하다. 그리고 여기에 네임드 배우들의 호연이 있기 때문이기도 했다. 스토리가 연기 폭을 좁혔다는 이야기는 이미 했으니 넘어가고.&lt;/p>
&lt;p>가장 눈여겨 본 사람은 장동건과 이종석인데, 장동건은 불안해서, 이종석은 호기심으로 본 것 같다. 내가 일전에 「우는 남자」 리뷰를 하면서 왜 이렇게 찌질남처럼 연기했냐고 말한 적이 있는데, 그 뒤에 「신사의 품격」 을 보면 아, 이 아저씨는 차도남 연기를 해야 한다는 생각이 들었다. (물론 드라마에는 귀여운 구석이 참으로 많았으나, 기본 베이스는 쿨내나는 도시남자였잖나) 그런 표현이 이번 영화와 잘 맞아떨어진 것 같다. 본인이 주도적으로 극을 이끌어 갈 때엔 빛을 발하고, 대립관계에서 짜져 있거나 물론 잘 봐줘서.. 그렇단 이야기고, 기대 이상이라고만 하자.&lt;/p>
&lt;p>이종석의 경우는 &amp;lsquo;아니 이 친구가 북한 사투리를? 악역으로?&amp;rsquo; 라고 놀랬기 때문이다. 실제 대사는 채이도와 첫 대질심문할 때 나와서 인내심을 갖고 그의 입을 봐야 한다. 결론적으로 나쁘지 않았지만, 거슬리는 부분도 많았다. 하지만 포스터에도 보이지만, 저 빙긋이 웃는 미소가 여심을 흔들 수도 있고 세 남자를 빡돌게 만들수도 있다는 걸 잘 보여줬다. 무엇보다, 「너의 목소리가 보여」 전후로 시작된 이종석 특유의 스테레오타입을 벗으려고 노력한 점은 인정. 하지만 성공적이었는지는 글쎄.&lt;/p>
&lt;h2 id="평가">평가&lt;/h2>
&lt;p>생각없이 본다면 큰 불만이 없는 영화지만, 찾아볼 정도로 매력이 있는지는 잘 모르겠다. 국정원이나 경찰이 서로 잇속을 챙기려 으르렁거리는 상황이 신선하다고 느끼거나, 이종석의 연기가 궁금하다면 볼 정도고, 나머지는 사실상 평범했거나 기대에 못 미쳤다고 봐야 한다. 그래도 소위 말하는 &amp;lsquo;망작&amp;rsquo; 수준은 절대 아니다. 그냥 내 기대가 높았을 뿐.&lt;/p>
&lt;p>★★★☆&lt;/p></description></item><item><title>나쁜 건 당연한게 아니다</title><link>https://1nterp.github.io/%EB%82%98%EC%81%9C-%EA%B1%B4-%EB%8B%B9%EC%97%B0%ED%95%9C%EA%B2%8C-%EC%95%84%EB%8B%88%EB%8B%A4/</link><pubDate>Thu, 15 Nov 2018 04:15:23 +0000</pubDate><guid>https://1nterp.github.io/%EB%82%98%EC%81%9C-%EA%B1%B4-%EB%8B%B9%EC%97%B0%ED%95%9C%EA%B2%8C-%EC%95%84%EB%8B%88%EB%8B%A4/</guid><description>&lt;blockquote>
&lt;p>The world will not be destroyed by those who do evil but by those who watch and do nothing.
세상은 악당들 때문에 망하는 게 아니라, 악한을 보고도 아무것도 하지 않는 자들 때문에 망한다.&lt;/p>
&lt;p>– Albert Einstein&lt;/p>
&lt;/blockquote>
&lt;p>이 말을 선거철에 쓰면 투표를 독려하는 것이고, 경찰서 앞에 붙어있으면 투철한 신고정신을 고취시키는 것이다. 책상 앞에 붙인다면 어떻게 될까. 나쁜 습관이나 언행, 과오를 그냥 보고 넘기면 내가 망한다. The life will not be destroyed by wrong things I did but  by me who watch and do nothing afterward.&lt;/p>
&lt;p>이게 내 천성이고 고치기 힘든 것이라서 쉽게 포기하는 것이다. 악당은 원래 더 똑똑하고 힘 세다. 하지만 우리는 힘을 모아서 신고도 하고 투표도 한다. 그 과정이 하루 아침에 이뤄지지도 않는다. 뜻을 모으고, 힘을 모으고, 계획을 세운다. 결과가 잘 안될 수도 있다. 하지만 노력한다. 만약 성공하면, 통제 불가능해 보였던 악한이 사라지고 평화를 맞을 수 있다는 그 기대감으로.&lt;/p>
&lt;p>인생도 마찬가지다. 끊임없이 나와 투쟁해야 한다. 사실 힘든 것도 잘 안다. 하지만 우리는 기대한다. 통제 불가능한 내 약점이 사라지고 좀 더 멋진, 그리고 더 나은 인간으로서 인정받으면서, 나에게도 다음 과업을 처리할 수 있는 시간을 주는 것.&lt;/p>
&lt;p>이 스트레스는 필연적으로 부여받은 하나의 업보일 뿐이다. 피하려 하면 할수록 절대로 피할 수 없다는 사실을 깨닫게 될 것이다. 가만히 지켜보고 아무것도 하지 않는 자는 인생을 망친다.&lt;/p></description></item><item><title>Gitlab merge request 옵션 기본으로 두기</title><link>https://1nterp.github.io/set-gitlab-merge-request-checked/</link><pubDate>Tue, 13 Nov 2018 05:03:22 +0000</pubDate><guid>https://1nterp.github.io/set-gitlab-merge-request-checked/</guid><description>&lt;p>Gitlab Community 에서 필요로 하는 기능인데, 이렇게 수동으로 할 수 있어서 간단히 남긴다. Gitlab 에 있는 merge request 에 보면 다음 옵션이 있는데, 전부 체크가 해제되어 있다.&lt;/p>
&lt;p>&lt;img src="https://1nterp.github.io/uploads/2018/11/%ec%a0%9c%eb%aa%a9-%ec%97%86%ec%9d%8c.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>Merge Request 에 성공한 Source Branch 를 삭제&lt;/li>
&lt;li>Merge Request 할 때 Commit 을 하나로 뭉쳐서 Merge (=Squash Merge)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>이 체크박스를 개발자가 일일해 해 줘야 하는 문제&lt;/strong>가 있다. 그래서 어떤 개발자는 체크하는 것을 까먹었다가 master branch 의 commit tree 를 엉망으로 만들기도 한다. 이 문제를 그냥 없애기 위해, 체크박스 표시를 그대로 두도록 하면 어떨까 고민하던 차에, 해결방법을 알아냈다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>/opt/gitlab/embedded/service/gitlab-rails/app/views/shared/issuable/form/_merge_params.html.haml&lt;/code> 을 편집기로 연다.&lt;/li>
&lt;li>&lt;code>check_box_tag&lt;/code> 항목으로 시작하는 줄이 &lt;span style="text-decoration: underline;">두 군데&lt;/span> 있는데, 아래와 같이 다음 내용을 &amp;lsquo;추가&amp;rsquo; 한다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">= check_box_tag &amp;#39;merge_request[force_remove_source_branch]&amp;#39;, &amp;#39;1&amp;#39;, issuable.force_remove_source_branch?, class: &amp;#39;form-check-input&amp;#39;&amp;lt;span style=&amp;#34;color: #ff0000;&amp;#34;&amp;gt;, checked: &amp;#39;checked&amp;#39;&amp;lt;/span&amp;gt;
&amp;lt;span style=&amp;#34;color: #0000ff;&amp;#34;&amp;gt;# ... blahblah&amp;lt;/span&amp;gt;
= check_box_tag &amp;#39;merge_request[squash]&amp;#39;, &amp;#39;1&amp;#39;, issuable.squash, class: &amp;#39;form-check-input&amp;#39;&amp;lt;span style=&amp;#34;color: #ff0000;&amp;#34;&amp;gt;, checked: &amp;#39;checked&amp;#39;&amp;lt;/span&amp;gt;```
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>다 했다면 &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 로 Gitlab 서버를 재시작한다.&lt;/p></description></item><item><title>무더운 낮과 밤</title><link>https://1nterp.github.io/%EB%AC%B4%EB%8D%94%EC%9A%B4-%EB%82%AE%EA%B3%BC-%EB%B0%A4/</link><pubDate>Wed, 15 Aug 2018 04:06:31 +0000</pubDate><guid>https://1nterp.github.io/%EB%AC%B4%EB%8D%94%EC%9A%B4-%EB%82%AE%EA%B3%BC-%EB%B0%A4/</guid><description>&lt;p>무더위가 찾아온 일상, 낮과 밤의 하늘은 여전히 아름답다.&lt;/p>
&lt;p>&lt;img src="https://1nterp.github.io/uploads/2018/08/20180730_125354.jpg"
loading="lazy"
alt="Daylight"
>
낮 / 구로디지털단지&lt;/p>
&lt;p>&lt;img src="https://1nterp.github.io/uploads/2018/08/20180730_215032.jpg"
loading="lazy"
alt="Night"
>
밤 / 온수역&lt;/p></description></item><item><title>고요한 마음에 조약돌 하나</title><link>https://1nterp.github.io/%EA%B3%A0%EC%9A%94%ED%95%9C-%EB%A7%88%EC%9D%8C%EC%97%90-%EC%A1%B0%EC%95%BD%EB%8F%8C-%ED%95%98%EB%82%98/</link><pubDate>Mon, 16 Jul 2018 02:46:58 +0000</pubDate><guid>https://1nterp.github.io/%EA%B3%A0%EC%9A%94%ED%95%9C-%EB%A7%88%EC%9D%8C%EC%97%90-%EC%A1%B0%EC%95%BD%EB%8F%8C-%ED%95%98%EB%82%98/</guid><description>&lt;img src="https://1nterp.github.io/uploads/2018/07/lake.jpg" alt="Featured image of post 고요한 마음에 조약돌 하나" />&lt;p>고요한 호숫가에 조약돌을 던지면, 주위에서 파장이 일어나지만 이내 움직이지 않는 수심 속으로 들어간다. 작은 물웅덩이에 조약돌을 던지면, 존재를 잃어버릴 만큼 가지고 있던 흙탕물을 사방으로 튀겨낸다. 물웅덩이의 입장에서는 날아오는 돌의 의미를 알 수 없다. 자신의 존재가 부정당하기 직전인데 그럴 여유가 없을 것이다. 하지만 호수는 여유가 있다. 일단 의미를 파악하는데 약간의 시간이 걸리긴 하겠지만, 어느샌가 돌을 받아주고는 깊숙한 어딘가에 넣어둔다.&lt;/p>
&lt;p>자신에게 잔소리하지 않았으면 하는 태도로 일관하는 사람이 있다. 필요한 커뮤니케이션도 잔소리로 받아서 문제다. 마치 그 지적을 받아들면 자신의 과업이 부정당하는 것 처럼. 그냥 문제가 있으면 그런가보다 하고 받아들이면 되고, 오해하고 있다면 해명해주면 된다. 그게 전부다. 화내고, 우울해하고, 보복할 준비를 하는 등의 불필요한 행동은 에너지 낭비다.&lt;/p>
&lt;p>조직 생활에서는 하나의 목표를 위해 지적도 당하고 지적도 하며 살아야 한다. 동상이몽라고 할 만큼 사람은 생각하는 바가 전혀 다르다. 그 사이를 메꾸기 위한 고통스런 의사소통은 피할 수 없다. 예민하게 굴거나, 아예 기만하는 행동은 의사소통에 도움이 되지 않는다. 지적을 받을 때는 최대한 고요하게, 필요한 대응만 하고 묻어두는 것이 차라리 좋다.&lt;/p></description></item><item><title>설명할 수 없으면, 아는 것이 아니다</title><link>https://1nterp.github.io/if-you-cannot-explain/</link><pubDate>Sun, 15 Jul 2018 05:30:47 +0000</pubDate><guid>https://1nterp.github.io/if-you-cannot-explain/</guid><description>&lt;img src="https://1nterp.github.io/uploads/2018/07/einstein.jpg" alt="Featured image of post 설명할 수 없으면, 아는 것이 아니다" />&lt;p>다른 사람을 지적하기 위한 것이 아니라 그저 내가 답답해서 페북에도 두번이나 올렸던 건데, 아인슈타인이 이미 한 말이었다. 역시 범인인 내가 생각한 것들은, 누군가가 이미 생각한 것이리라.&lt;/p>
&lt;blockquote>
&lt;p>쉽게 설명할 수 없으면, 아는 것이 아니다.&lt;br>
(혹은, &amp;lsquo;6살 꼬마에게 설명할 수 없으면 아는 것이 아니다&amp;rsquo; 라고도 한다)&lt;/p>
&lt;/blockquote>
&lt;p>이건 뭐죠? 라고 물어봤을 때 금방 생각나지 않으면서 &amp;lsquo;아, 이거 몇년 전에는 알았는데&amp;rsquo; 라고 탄식하게 되는 상황을 종종 마주한다. 그러면 쿨하게 &lt;strong>&amp;lsquo;모릅니다&amp;rsquo;&lt;/strong> 라고 대답하는 게 최선이다.&lt;/p>
&lt;p>&amp;lsquo;그거 해 봤는데 왜 기억이 안날까요? 😅&amp;rsquo; 라거나 &amp;lsquo;&amp;hellip;이런 것 같았는데 말이죠&amp;rsquo; 라고 대답하는 건, 아는 체를 하려다 되려 신뢰를 깎아먹는 역효과를 불러일으킬 뿐이다.&lt;/p>
&lt;p>그렇다면 어떤 개념의 정의나 역사를 항상 기억하고 외우고 있어야 할까? 원칙적으로는 그래야 한다고 생각한다. 중요한 건 어떻게 그 목표에 접근하냐는 것일텐데, 오랫동안 기억하려면 무작정 외워서는 안 될 것이다. &lt;strong>그 속에 담긴 원리는 무엇인지, 왜 이런 개념이 필요했는지&lt;/strong>를 이해하지 않고 외우기만 한다면, 금세 기억 저편으로 사라질 것이다.&lt;/p>
&lt;p>머릿속에 다 집어넣을 필요는 없을 테니, 여러 색인 기법을 써서 정리해두는 습관을 들이는 것이 더 중요할 수 있다. 시간은 걸리더라도 언젠간 찾아줄 수 있고, 당장 설명을 못 해도 다시 찾아볼 기회를 빠르게 얻을 수 있으니까. 제텔카스텐이 여기에 적합한지는 잘 모르겠지만, 중요한 건 잘 이해하고 잘 모아두는 습관이 필요하다는 것이겠다.&lt;/p></description></item><item><title>돌이킬 수 없는 약속</title><link>https://1nterp.github.io/%EB%8F%8C%EC%9D%B4%ED%82%AC-%EC%88%98-%EC%97%86%EB%8A%94-%EC%95%BD%EC%86%8D/</link><pubDate>Sat, 14 Jul 2018 15:16:15 +0000</pubDate><guid>https://1nterp.github.io/%EB%8F%8C%EC%9D%B4%ED%82%AC-%EC%88%98-%EC%97%86%EB%8A%94-%EC%95%BD%EC%86%8D/</guid><description>&lt;img src="https://1nterp.github.io/uploads/inevitablepromise.jpg" alt="Featured image of post 돌이킬 수 없는 약속" />&lt;p>이 책은, 접근부터 굉장히 쉬웠다. 리디북스&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>에서 무료 대여 기간이 있었고, 동시에 많은 북 큐레이션 페이지에서 이 줄거리를 카드 뉴스나 동영상&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>으로 홍보했기 때문이다. 그리고 줄거리가 충분히 구미가 당길 만한 내용이었다. 과거를 버리고 평범한 삶을 살아가는 남자에게 들이닥친 불행한 과거로부터의 편지 한 통. 악한을 죽여달라는 그 때의 약속을 반드시 지켜달라는 내용이란다. 이 남자의 과거는? 편지의 발신인은? 궁금한 나머지 빠르게 읽어내려갔다.&lt;/p>
&lt;h2 id="줄거리">줄거리&lt;/h2>
&lt;p>도입부는 주인공의 평범한 일상을 소개한다. 레스토랑과 바를 겸하는 식당의 공동 창업자이자 바텐더로, 사랑하는 아내와 초등학교를 다니는 귀여운 딸을 둔 가장으로. 하지만 그는 어두운 과거를 꽁꽁 숨겨둔 채 살아간다.&lt;/p>
&lt;p>그는 사실 &lt;strong>얼굴에 다 드러날 정도의 큰 멍을 가진 사내&lt;/strong>로, 어릴적 멸시와 동정을 이기지 못하고 강도짓을 일삼는다. 그러다 시비가 붙어 야쿠자에게 쫓기는 신세가 되었고, 그 와중에 한 노인을 만난다.&lt;/p>
&lt;p>노인은, 자신의 딸이 파렴치한 두 남성에게 납치되어 겁탈당한 뒤 살해당했다고 한다. 그런데 그 두 피의자에게 사형 선고가 아닌 15년형이 내려진 것에 분노하며, 자신은 이제 기력이 다 했으니 &lt;span style="color: #0000ff;">원하는 대로 돈을 받고 두 사람을 죽여달라는 약속을 하나 해줄 수 없겠느냐고 한다. 주인공은 심하게 갈등하지만, 야쿠자에게 붙잡혀 송장이 되기 싫었던 주인공은 &amp;lsquo;지키지 않아도 될 약속&amp;rsquo; 쯤으로 생각하고 약속을 한 뒤 돈을 받는다.&lt;/p>
&lt;p>그 뒤 성형수술과 무연고자의 호적을 통해, 가족이 생기고 전혀 다른 삶을 이어나가고 있었는데&amp;hellip; 15년 후 집으로 편지 한 통. 바로 &lt;strong>그들이 출소했다는 소식.&lt;/strong> 약속을 지키지 않으면 가족을 해치고 똑같은 고통을 느끼게 해주겠다고 협박한다. 주인공은 어떻게 해야 할까.&lt;/p>
&lt;h2 id="복선-회수">복선 회수&lt;/h2>
&lt;p>드라마를 즐겨 본다면, 책에서 다발성 &lt;strong>복선&lt;/strong>을 느낄 수 있다. 이런 장면들은 자체로는 별 의미가 없거나 생뚱맞은 장면들이 많지만, 전개 과정에서 이 숨겨둔 힘이 마치 콤보처럼 터진다. &lt;em>아니 왜 갑자기 생판 남의 자식과 남자 주인공을 오버랩 시키지?  남자가 사귀자는데 여자의 저 오묘한 표정은 뭐지?&lt;/em>&lt;/p>
&lt;p>&lt;strong>그런데 역으로, 누가 봐도 복선같이 보이는 장면들이 사실은 아무런 의미없는 장면이 되는 경우가 간혹 있다.&lt;/strong> 메인 커플을 훼방놓기 위해 유학길에서 돌아온 남자 주인공의 소꿉동생이, 질투 몇 번 하더니만 둘 사이를 축하해주는 들러리로 전락한다든지.&lt;/p>
&lt;p>아무튼, 이 책은 복선 회수라는 점에선 소홀히 하려 들진 않는다. 결말에 도착하면 뭔가 &amp;lsquo;아, 잠깐만. 그래서 그때?!&amp;rsquo; 라는 느낌표가 계속 뜬다. 아쉬운 것은,  갑자기 이 모든 원흉이 된 &lt;span style="text-decoration: underline;">숨겨진 과거사를 드러내는 시점이 갑작스럽다&lt;/span>는 것이다. 마치 (작가는 절대 그렇게 쓰지 않았겠지만) &lt;strong>&amp;lsquo;자, 이 사건으로 내가 결말을 다 설명할건데, 사실은 앞에 뿌려둔 복선을 회수하고 싶어서 ㅎㅎ&amp;rsquo;&lt;/strong> 라고 하는 것 같았다.&lt;/p>
&lt;h2 id="몰입도">몰입도&lt;/h2>
&lt;p>그렇다고 이게 &amp;lsquo;결말을 이끄는 힘이 부족하다&amp;rsquo; 라고는 할 수 없다. 다음 내용이 사실 궁금해질 수 밖에 없도록 만들었으니까.&lt;/p>
&lt;p>주인공은 편지를 받고 편지의 발신인을 찾기 위해 (밤에 일을 하니까) 낮에 돌아다니다가 와이프에게도 의심받고 동업자에게도 의심받는 상황에 처한다. 그런데 편지를 보낸 사람은, &amp;lsquo;나는 영혼이다. 너가 뭘 하는지 다 보고 있다. 뭐하냐, 출소했다니까 그때 했던 약속대로 죽여달라&amp;rsquo; 라고 한다. 그러면서 (그 영혼은) 회사에도 전화를 하고, 안 받으니까 스마트폰을 배달해서 지시를 하고, 상황은 점점 더 옥죄어 오는데 누가 이러는지는 전혀 갈피를 못 잡는 것이다.&lt;/p>
&lt;p>&lt;span style="color: #800000;">&lt;strong>스포일러&lt;/strong> : &lt;/span>&lt;span style="color: #fefefe;"> : 정말 영혼인가? 날 쫓던 야쿠자인가? 같이 나쁜 짓을 했던 녀석 중 한명의 짓인가? 그 노인이 자주 간다던 &amp;lsquo;억울한 피해자 모임&amp;rsquo; 의 사람 중 한명인가? 그 와중에 타겟 두 명 중 한명에게 찾아가지만 차마 죽이지 못했는데, 다음날 타겟은 살해당하고 자신은 누명을 썼다.&lt;/span>&lt;/p>
&lt;p>이제 정말 끝인가, 벼랑 끝으로 내모는 속도가 빠르다. 결말에 다다르면 전부 ta-da 하고 보여주지만, 그 전까지는 독자들도 끝자락으로 내몬다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>교보문고에 갔더니 이 책이 소설 베스트셀러 4위더라. 솔직히 많이 놀랐다. 절박한 주인공으로 만들어버리면서 동시에 주인공의 기민한 위기대응을 보여주는 빠른 전개, 주인공 주변에 흩뿌려진 많은 주변인들 사이에서 벌어지는 복선들의 철저한 회수에는 점수를 후하게 주지만 스토리 전체를 놓고 봤을 때는 끝에서 힘을 다 빼버리는 느낌이 강했기 때문이다. 좀&amp;hellip; 실소가 나올 정도로.&lt;/p>
&lt;p>마치기 전에, 나는 엉뚱한 곳에 시선이 갔다. 주인공이 동료에게 돈을 주고 새로운 호적을 받는 장면이 있다. 주인공이 &amp;lsquo;이 사람은 누구야?&amp;rsquo; 라고 묻자, &amp;lsquo;그 사람은 연고도 없고, 지금 어떻게 됐는지는 묻지마&amp;rsquo; 라고 답한다. &lt;strong>이 호적의 원래 주인이 범인이었으면 어땠을까.&lt;/strong> 너무 뻔했을까. 나는 결말을 알기 전에는 이 장면이 보이지 않았으니, 나에겐 꽤나 신선했을 것 같다.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://ridibooks.com/v2/Detail?id=1013000004" target="_blank" rel="noopener"
>https://ridibooks.com/v2/Detail?id=1013000004&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://www.youtube.com/watch?v=2AZjY5PGPhg" target="_blank" rel="noopener"
>https://www.youtube.com/watch?v=2AZjY5PGPhg&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>중독적 습관</title><link>https://1nterp.github.io/%EC%A4%91%EB%8F%85%EC%A0%81-%EC%8A%B5%EA%B4%80/</link><pubDate>Sun, 03 Jun 2018 15:18:03 +0000</pubDate><guid>https://1nterp.github.io/%EC%A4%91%EB%8F%85%EC%A0%81-%EC%8A%B5%EA%B4%80/</guid><description>&lt;p>요즘 말하는 욜로(YOLO) 에 가까운 삶을 사는 친구가 있다. 일단 불안한 계약직인데다 계약 텀도 굉장히 짧은 직종에 근무한다. 그런데도 잘 놀러 다닌다. 너무나도. 그러면서 늘 걱정을 늘어놓는다. 좋은 남자 만나 결혼해야지, 정규직도 되면 좋겠지, 계속 놀러 다니고는 싶지… 이런, 쓰고 보니 이 친구는 욜로가 아니다. 내일 살 걱정을 하기는 하니까. 아무튼, 이 친구의 문제는 뭘까, 혹시 쾌락의 끝자락에서 내려오기 싫은 발버둥을 치는 것은 아닐까, 아니면 더 큰 것을 좆을 수 없는 공허함을 느낀 걸까.&lt;/p>
&lt;p>술을 마시던 게임을 하던, 그 때만 즐거을 뿐이다. 숙취에 고통받을 때, 게임 종료 버튼 앞에 있을 때, 우리는 다시 비어있음을 느낀다. &lt;strong>쾌락의 순간에는 더 큰 역치를 넘어서지 못하는 한계에 부딪히며 파열을 발생시키는 게 아닐까.&lt;/strong> 그것이 허무감인지, 어떤건지 잘 모르겠다.&lt;/p>
&lt;p>더 큰 보상을 바라는 뇌의 요구와, 중독적인 일 외에 할 수 있는 일을 하나씩 배제시키는 습관의 힘이 합쳐진 것을 우리는 중독이라고 한다. 올바른 (적어도 사회적으로 올바르다고 여겨지는) &amp;lsquo;성취&amp;rsquo;의 대부분은, 즉각적인 보상으로 이어지지 않는다. 그래서 상벌이 바로 튀어나오는 행위에 우리는 열광한다. 시간을 들여 보상이 주어지는 성취에 점점 관심을 잃는 것이다. 하는 방법도, 버틸 힘도 잃어버린다.&lt;/p>
&lt;p>습관은 더 무서운데, 뇌의 보상기제가 작동하건 말건 이 녀석은 항상 LRU (Least Recently Used) 리스트처럼 행위를 관리한다는 것이다. 자주 한 일일수록 쉽게 선택되고, 전혀 해보지 않은 일 (하지만 한번 쯤 해봐야지 하며 버킷리스트에 채워넣었던 일) 은 선택되기 힘들게 한다. 즉, 새로운 도전은 그만큼의 비용이 들지만, 곁에 둔 습관은 그렇지 않다는 것이다. 반복적인 행동은, 그것이 나쁘건 좋건 간에, 여유 시간에 &amp;lsquo;그냥 할 만한 것들&amp;rsquo;의 유력한 후보로 항상 존재할 것이다. 그 후보는 2선, 3선을 밥먹듯이 할테고, 질 나쁜 행동이 고착화되면 언젠가는 부패할 것이다.&lt;/p>
&lt;p>&lt;span style="text-decoration: underline;">잘못된&lt;/span> 습관과 보상기제로 인해 정해진 중독적 행위가 과연 현재를 즐기자라는 다소 낙관적인 말로만 포장될 수 있는지에 대해 숙고해 봐야 한다는 것이다. (잘못됐다는 말을 쓰는걸 별로 좋아하지 않지만, 뭔가 내가 하는 일이 이상하다고 생각된다면 그건 잘못된 거다. 애석하게도. )&lt;/p>
&lt;p>&lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.nhn?code=71509" target="_blank" rel="noopener"
>소미의 옆집 아저씨&lt;/a>도 &amp;lsquo;오늘만 산다&amp;rsquo;고 말하지만, 욜로라고 하지 않는다. 다음을 걱정을 하는 자에게, 중독을 이어가는 이 허무함은 더 고통스럽지 않을까? 그래서 이 신조어는, 실제로 그런 극단적인 허무감을 회피하지 못한 비웃음의 단어는 아닌지, 아니면 정말 해탈했다고 자랑하고 싶은건지 의심스럽기만 하다.&lt;/p></description></item><item><title>암보스 (ambos)</title><link>https://1nterp.github.io/%EC%95%94%EB%B3%B4%EC%8A%A4-ambos/</link><pubDate>Tue, 24 Apr 2018 13:44:54 +0000</pubDate><guid>https://1nterp.github.io/%EC%95%94%EB%B3%B4%EC%8A%A4-ambos/</guid><description>&lt;img src="https://1nterp.github.io/uploads/2018/04/010-2.jpg" alt="Featured image of post 암보스 (ambos)" />&lt;p>두 여자가 서로 다른 방향을 보고 있지만, 그 얼굴 안에서는 마주보기도 하는 듯, 흑심을 품고 있는 듯한 이미지가 프랙탈처럼 나타나 있는 기괴한 표지에 담긴 내용은 대체 어떤 사연일까?&lt;/p>
&lt;p>출판사 &amp;lsquo;황금가지&amp;rsquo;에서 만든 새로운 라인업 &amp;lsquo;수상한 서재&amp;rsquo; 시리즈의 첫 작품인 김수안 작가의 암보스&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>를 읽어봤다. 시간이 없어 서울-대구를 오가는 KTX 안에서 읽었는데, 다소 두꺼운 외형과는 달리 꽤나 빨리 따라갈 수 있었다.&lt;/p>
&lt;p>암보스 (ambos)&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 는 스페인어로 &amp;lsquo;양쪽, 두 사람&amp;rsquo; 이란 뜻이다. 두 여자가 주인공인 것을 표현하고자 했겠으나, 실제로 스페인어는 남성형/여성형 명사가 따로 존재한다. 그래서 표지만 보고는 왜 암바스 (ambas) 라는 여성형 명사를 채택하지 않았을까 자뭇 궁금해졌다. &lt;del>arm boss 같은 느낌도 있어서&lt;/del> 나중에 &lt;a class="link" href="%22http://ch.yes24.com/Article/View/35770%22" >작가 인터뷰&lt;/a>를 보니, 두 주인공만을 위한 제목이 아닌 여러 인물들의 관계 자체를 암보스로 봤기 때문이라고 한다.&lt;/p>
&lt;h2 id="줄거리">줄거리&lt;/h2>
&lt;p>신문 기자 &lt;strong>이한나&lt;/strong>는 어느 날 방화사건 현장에 있었고, 목격한 모든 정보를 회사에 전달한 뒤 의식을 잃었다. 이대로 죽는건가? 아니, 죽는 것도 나쁘지 않겠지. 무능하고 철면피인 아버지가 진 빚이며, 헤어진 남자친구며, 내가 잘못 굴린 펜으로 사람이 곤란에 겪었으니까. 깨어나보니, 이한나는 다른 사람이 되어 있었다. 같은 날 옥상에서 뛰어내렸지만 가까스로 목숨을 건졌던 강유진이란 사람으로. 이한나는 퇴원하자 마자 강유진의 집을 찾아갔는데, 별안간 이한나의 모습을 한 누군가가 뒤따라 찾아왔다. 그는 &lt;strong>강유진&lt;/strong>이었다. 몸이 뒤바뀐 것이다. 어떻게 된 일일까.&lt;/p>
&lt;h2 id="초자연은-중요한-게-아니다">초자연은 중요한 게 아니다&lt;/h2>
&lt;p>하지만 책은 &lt;strong>왜 이들의 몸이 바뀌었는지는 독자들에게 이야기해주지 않는다.&lt;/strong> 누군가가 상대방의 몸을 원했다면, 영화 &amp;lsquo;더 게임&amp;rsquo;&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> 의 강회장 (변희봉 扮) 같은 캐릭터가 나와야 하겠지만, 여기선 어느 누구도 그런 역을 자처하지 않는다. 그보다는, 서로의 삶에서 느끼는 &amp;lsquo;잃은 것과 얻은 것의 의미&amp;rsquo;를 알아가고 행동하는 데에 많은 부분을 할애한다. 강유진은 비만에 집에 틀어박혀 지내기 일쑤지만 돈이 많았고, 이한나는 예쁜데다 활기차고 자기주관이 강했지만 안하무인 아버지로 인해 많은 빚을 졌다.&lt;/p>
&lt;p>설마 강유진의 모습을 한 이한나가 &amp;lsquo;나는 열심히 운동해서 살을 빼야지&amp;rsquo; 라거나 &amp;lsquo;이제부터 사람들과 잘 어울려야지&amp;rsquo; 같은 뭐 이런 희망적인 스토리를 기대하지는 말자. 그들은 언젠가 다시 본래의 상태로 돌아갈 것이라고 확신하고 있었다. 정확히 말하자면 강유진이 &amp;lsquo;그렇게 될 것&amp;rsquo;이라고 이야기했지만. 아무튼 그렇게 돌아가버린다고 가정했을 때 이들은 어떤 행동을 하게 될 것인가. 상대방의 미스터리한 행적이 서로의 시선을 통해 서술되기 시작한다.&lt;/p>
&lt;h2 id="갑자기-교차되는-사건">갑자기 교차되는 사건&lt;/h2>
&lt;p>시간이 지나면서 연쇄살인사건, 그리고 그 범인을 찾는 형사가 교차되어 나타난다. 일면 관련없어 보이는 사건 이야기가 갑자기 주인공 일행의 서사와 겹치면서 충돌하기 시작한다. 그것도 아주 빠르게. 파열음은 의외로 강하고, 당사자들의 추리 게임은 꼬리에 꼬리를 문다.&lt;/p>
&lt;p>이 시점에서 가장 눈에 띄는 것은 단연 박선호 형사일 것이다. 우락부락한 체격과 어울리지 않게 집요하리만치 파고드는 집중력이 소설 내내 돋보인다. 그 옆을 따르는 부사수 칠범 역시 파트너 역할에 충실한다. 이한나의 가족과 주변인, 그리고 강유진의 증언 등을 토대로, 사건 이후 사람이 뭔가 달라졌다는 의혹을 끝까지 물고 늘어지는데, 이 부분에서 주인공 일행과의 긴박한 밀당이 계속 이뤄진다. 결국 살인사건은 실마리를 찾고 해결되지만, 이게 정말 끝일까?&lt;/p>
&lt;h2 id="소설이-이야기-하는-방식">소설이 이야기 하는 방식&lt;/h2>
&lt;p>소설이 가지는 강점은 심리 묘사와 비유에 많은 에너지를 쏟았고 그걸 고스란히 전달하려고 노력했단 점이다. 사건의 진위가 아니라, 사건에 휘말린 인물의 세세한 면면을 나타내려고 애를 썼다. 그래서 스토리 자체에 태클을 걸면서 본다면 자칫 넘어지기 쉬울 것 같아 보이긴 하지만, 그런 세세한 부분을 너그러이 이해해준다면 재밌게 읽힐 소설이 될 것이다.&lt;/p>
&lt;p>작중 이한나의 시점, 박선호 (를 포함한 외부)의 시점에서는 이한나와 강유진을 지칭하는 자아가 서로 다른 것이 신선했다. 이한나의 시점에서 서술될 때는 &amp;lsquo;나&amp;rsquo; 와 &amp;lsquo;(내 모습을 한) 강유진&amp;rsquo; 이지만, 그 외에는 외모대로 &amp;lsquo;강유진&amp;rsquo; 과 &amp;lsquo;이한나&amp;rsquo; 로 서술된다. 박선호가 이를 눈치챈 종반부에서는 서술이 다시 뒤바뀌긴 하지만. 그래서 이 부분을 따라가기가 조금 피곤해 질 수는 있겠다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>독자에게 추리할 여지를 많이 주는 것 같지만, 사실 복선은 야속하게 정류장을 지나치는 시내버스 같이 지나간다. 어느샌가 소설 속 인물들의 추리보다 한발 앞서 나간게 아닐까, 그랬던 거였어! 라고 생각하고 있다면, 조심해야 한다. 끈적한 손으로 뒤통수를 후려갈겨서 뒷맛이 찜찜하다. 이게 뭐야, 꼭 그렇게 했어야만 했냐! 같은 느낌. 하지만, 역으로 생각해보면 책을 한번 더 돌려보게 만드는 매력을 지니고는 있다고 볼 수 있다.&lt;/p>
&lt;p>소설 중에 이런 내용이 있다. &lt;strong>강유진의 모습을 한 이한나가 창문을 바라본다. 창문에는 강유진이 보인다. 내가 정말 나인지, 상대방이 내 모습을 하고 유리창에 나타난건지, 정말로 상대방이 내가 된건지. 나는 누구일까.&lt;/strong>&lt;/p>
&lt;p>사람의 몸이 뒤바뀐다는 초자연적인 전개에만 관심을 가지면 이 소설은 거기서 끝난다. 상대방의 거죽을 쓰고 자신도 몰랐던 민낯이 드러나는 것을 보고 나면 다른 생각이 들 것이다.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://www.yes24.com/24/goods/59681102" target="_blank" rel="noopener"
>http://www.yes24.com/24/goods/59681102&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://spdic.naver.com/#/entry/esko/2890825" target="_blank" rel="noopener"
>http://spdic.naver.com/#/entry/esko/2890825&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.nhn?code=66617" target="_blank" rel="noopener"
>https://movie.naver.com/movie/bi/mi/basic.nhn?code=66617&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Atomic Operation 으로 하는 동시성 제어</title><link>https://1nterp.github.io/atomic-operation-%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/</link><pubDate>Tue, 24 Apr 2018 02:31:38 +0000</pubDate><guid>https://1nterp.github.io/atomic-operation-%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/</guid><description>&lt;h2 id="test-and-set-tas">Test-And-Set (TAS)&lt;/h2>
&lt;p>TAS 를 이용해서 간단한 동시성 제어를 할 수 있다. testAndSet 이라는 function 을 가지고 아래의 &lt;code>do...while&lt;/code> 문을 쓰레드 A, B 에서 동시에 호출한다고 해 보자. 이 때 lock 은 같은 변수이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">function&lt;/span> &lt;span class="nf">TestAndSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">boolean_ref&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">boolean&lt;/span> &lt;span class="n">initial&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">lock&lt;/span>
&lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">initial&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TestAndSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">amp&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">;&lt;/span> &lt;span class="c1">// do nothing
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// critical section
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// remainder section
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>우선 TestAndSet() 은 다음과 같은 일을 한다. 말 그대로 &amp;lsquo;지금 값이 무엇인지 검사하고, 값을 바꾼다&amp;rsquo; 는 것이다.&lt;/p>
&lt;ol>
&lt;li>lock의 현재 값을 저장해 둔다.&lt;/li>
&lt;li>lock의 값을 true 로 설정한다.&lt;/li>
&lt;li>저장한 lock 의 값을 반환한다.&lt;/li>
&lt;/ol>
&lt;p>그럼 이걸로 어떻게 아래 block 의 critical section 에 대한 동시성 제어를 할 수 있을까? Thread A 가 먼저 실행했다고 가정하면, 이런 시나리오가 된다.&lt;/p>
&lt;ol>
&lt;li>A : TestAndSet() 의 반환값이 false 이다. while 문을 빠져나온다.&lt;/li>
&lt;li>B : TestAndSet() 의 반환값이 true 이다. (A가 true로 두고 나왔기 때문에) while 문에서 계속 돈다.&lt;/li>
&lt;li>A : Critical Section 수행 후, lock 을 false 로 바꾼다.&lt;/li>
&lt;li>B : 여러 번의 TestAndSet() 호출 후에, 드디어 반환값이 false 가 되었다&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>(A가 false 로 두고 나왔기 때문에) while 문을 빠져나온다.
&lt;/code>&lt;/pre>
&lt;p>자, 그런데 뭔가 이상하다. 이렇게 이상적으로 동작하지 않을 것 같다. TestAndSet() 함수를 라인별로 동시에 실행한다고 하면 이런 사단이 날 수 있다.&lt;/p>
&lt;ol>
&lt;li>A : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다.&lt;/li>
&lt;li>B : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다.&lt;/li>
&lt;li>A : TestAndSet() 에서 lock 값을 true 로 바꾼다.&lt;/li>
&lt;li>B : TestAndSet() 에서 lock 값을 true 로 바꾼다.&lt;/li>
&lt;li>A : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다.&lt;/li>
&lt;li>B : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다.&lt;/li>
&lt;li>A &amp;amp; B : 모두 동시에 critical section 을 수행한다.&lt;/li>
&lt;/ol>
&lt;p>그럼 어떡하나? TestAndSet() 은 그래서 저런 함수만으로는 안 되고 Test-And-Set 의 연산이 일관되도록 조정해야 한다. 함수 안에 spinlock 을 쓰면 되겠네요? 싶겠지만 lock 구현하자고 lock 을 또 만드는 건 아닌 것 같다. 그래서 Test-And-Set 은 CPU에서 지원하는 Atomic Instruction 을 사용한다.&lt;/p>
&lt;h2 id="fetch-and-add--ticket-lock">Fetch-And-Add : Ticket Lock&lt;/h2>
&lt;p>Atomic Operation 으로 구현할 수 있는 Lock 중에 Ticket Lock 이 있는데, Fetch-And-Add 로 구현할 수 있는 방법을 알아보자.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">ticketLock_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next_ticket&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next_ticket&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">ticketLock_acquire&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next_ticket&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">my_ticket&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fetch_and_inc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">next_ticket&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">my_ticket&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">ticketLock_release&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">now_serving&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>TAS 의 케이스를 이해하고 본다면 별 다른 설명이 필요 없을 것 같다.&lt;/p>
&lt;ol>
&lt;li>Table Lock 초기화를 한다.&lt;/li>
&lt;li>A : Table Lock 을 얻으려 한다. 이미 얻었던 &lt;code>my_ticket (0)&lt;/code> 과 &lt;code>now_serving (0)&lt;/code> 이 같은 값이므로 곧바로 빠져나온다.&lt;/li>
&lt;li>B : Table Lock 을 얻으려 한다. 이미 얻었던 &lt;code>my_ticket (1)&lt;/code> 과 &lt;code>now_serving (0)&lt;/code> 이 다른 값이므로 while 문에서 대기한다.&lt;/li>
&lt;li>C : Table Lock 을 얻으려 한다. 이미 얻었던 &lt;code>my_ticket (2)&lt;/code> 과 &lt;code>now_serving (0)&lt;/code> 이 다른 값이므로 while 문에서 대기한다.&lt;/li>
&lt;li>A : Table Lock 을 해제한다. &lt;code>now_serving (0)&lt;/code> 을 증가시켜 &lt;code>now_serving (1)&lt;/code> 을 만든다.&lt;/li>
&lt;li>B : 비로소 Table Lock 을 얻었다. (C는 여전히 대기 중이다.)&lt;/li>
&lt;/ol>
&lt;p>여기서 핵심은 &lt;code>fetch_and_inc&lt;/code> 인데, 마찬가지로 얻어오는 루틴과 값을 증가시키는 루틴이 따로 떨어져 있으면 중복된 티켓을 들고 기다리는 쓰레드들이 발생할 수 있다. 따라서 이것도 atomic operation 이 되어야 한다.&lt;/p></description></item><item><title>Timsort</title><link>https://1nterp.github.io/timsort/</link><pubDate>Mon, 23 Apr 2018 01:36:57 +0000</pubDate><guid>https://1nterp.github.io/timsort/</guid><description>&lt;p>알고리즘 강의를 들었다면, &lt;strong>가장 빠른 정렬 알고리즘이 뭐냐&lt;/strong>는 질문에 곧장 &lt;a class="link" href="https://www.toptal.com/developers/sorting-algorithms/quick-sort" target="_blank" rel="noopener"
>Quicksort&lt;/a> 라고 답할 수 있을 것이다. 실제로 현업에서도 적용하기 가장 편하기 때문에 많이 차용되는 편이다. 그런데 모든 문제를 쉽게 풀 수 있는 은탄은 세상에 존재하지 않듯, Quicksort 역시 특정 케이스에서는 성능이 낮게 나오는 경우가 있다. 더 심각한(?) 것은, 이 특정 케이스가 현실에서는 꽤나 자주 발생한다는 것이다.&lt;/p>
&lt;p>그 케이스란 바로 &amp;lsquo;거의 정렬된 데이터&amp;rsquo; 이다. 거의 정렬된 데이터라면 pivoting – partitioning 을 반복할 필요도 없이 Bubble Sort 나, 심지어는 Insertion Sort 를 해도 된다. &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC" target="_blank" rel="noopener"
>Bubble Sort&lt;/a> 의 경우엔 알고리즘 복잡도가 n&lt;sup>2 &lt;/sup>이지만 compare 과정에서 조기에 끝날 가능성이 매우 높아 비용이 거의 발생하지 않을 것이고, Insertion Sort 도 비슷한 이유로 빠르게 끝날 것이다. 하지만 모든 정렬 케이스가 거의 정렬된 데이터만 있지 않기 때문에 쓰지 않는 것일 뿐이다.&lt;/p>
&lt;p>만약에 데이터 순열이 &amp;lsquo;**거의 정렬된 데이터의 N 벌&amp;rsquo;**이라고 하자. &lt;span style="color: #3366ff;">1, 2, 3, …, 10&lt;/span>, &lt;span style="color: #800000;">2, 3, 4, …, 20&lt;/span> 이런 식으로 말이다. (여기서는 2벌) 그림을 그리자면 산이 N 개 생긴 것 처럼 보일 것이다. 이런 경우에는 Bubble Sort 가 큰 힘을 쓰지 못한다. 특정 원소가 산의 제 위치에 찾아가야 하는데, 조기에 끝났던 아까의 경우와는 달리 재수가 없다면 거의 모든 원소 개수와 비교해 봐야 하기 때문이다. 이럴 경우 역시 특효약이 있는데, 산마다 Mergesort 를 하면 쉽다.&lt;/p>
&lt;p>오늘 이야기할 &lt;a class="link" href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener"
>Timsort&lt;/a> 는 Mergesort 의 변형이라고 보면 된다. 아까 &amp;lsquo;산마다 Mergesort&amp;rsquo; 를 한다고 했는데, 어느 지점부터 산으로 봐야할지를 판단하는 알고리즘이 선행된다. 그리고 Mergesort 도 단순히 1개씩 건너뛰는 방법에서 좀 더 나은 방법을 제시한다.&lt;/p>
&lt;p>결론부터 말하자면 Timsort 는 무작위 데이터에서 Quicksort 보다 뒤쳐진다. 프로젝트할 때 적용해 본 결과로는 30~50% 정도 느렸다. 하지만 말했다시피, 현실 데이터는 어느 정도 정렬된 데이터의 덩어리를 가지고 있는 경우가 매우 많기 때문에, 그 부분에서는 확실한 성능 차이를 보였다.&lt;/p>
&lt;p>자, 이제 한 번 알아보자.&lt;/p>
&lt;h2 id="1단계--run">1단계 : Run&lt;/h2>
&lt;p>데이터 순열에서 &lt;strong>&lt;span style="color: #0000ff;">이미 정렬이 끝난 부분 데이터들을 Run&lt;/span>&lt;/strong> 이라고 한다. 1, 2, 1, 2, 3, 1, … 같이 주어졌을 때, 1, 2 와 1, 2, 3 을 Run 으로 인식하는 것이다. Timsort 에서는, 데이터 순열을 이런 Run 들로 찾거나 만들어서 확보하는 과정을 거친다. 이게 1단계이다.&lt;/p>
&lt;p>Timsort 는 &lt;span style="text-decoration: underline;">Run 이 너무 짧으면 나중에 의미가 없으므로, 최소 길이를 정해서 Run 을 만들도록 한다&lt;/span>. 보통은 길이가 16인 Run 부터 의미있게 쓰길래, 나도 똑같이 16으로 조건을 설정했다.&lt;/p>
&lt;p>Run 은 데이터 처음부터 정렬되어 있는 위치까지를 찾는다. 이 길이가 16 미만이라면, 해당 범위는 기억해 두고 다음 Run 을 찾는다. 이렇게 길이가 16 이상의 Run 을 만들 수 있는데, 이 때 쓰는 알고리즘은 사실 아무거나 가져다 써도 된다. 길이가 짧을 때의 정렬 알고리즘은 어느 것을 쓰나 대동소이하기 때문에, 나는 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC" target="_blank" rel="noopener"
>Insertion Sort&lt;/a>를 썼다.&lt;/p>
&lt;h2 id="2단계--merge">2단계 : Merge&lt;/h2>
&lt;p>1단계 이후로는, 이제 데이터 순열에 Run 여러개가 연속되어 있다. 만약 Run 이 1개뿐이라면? 축하한다. 아주 작은 원소 개수를 정렬하려 했거나, 이미 정렬된 데이터를 넣었단 것이니 이번 단계를 하지 않아도 된다.&lt;/p>
&lt;p>앞의 두 Run 을 불러서 Mergesort 하면 되는데, 여기서 Timsort 만의 트릭이 두 개 존재한다.&lt;/p>
&lt;p>하나는, Merge 에 참여할 두 Run 의 최소값/최대값을 서로 비교해서, &lt;span style="text-decoration: underline;">아예 이긴 구간이나 아예 진 구간을 미리 산정해 두는 것&lt;/span>이다. 이 부분은 사실상 Mergesort 과정에서 비교 대상이 될 필요가 없다. 괜한 compare 연산만 낭비하지 말고 처음에 (혹은 나중에) 순순히 들어와주기만 하면 된다. 이 전처리 과정이 끝나면, 남아있는 Run 끼리 Merge 과정을 거친다.&lt;/p>
&lt;p>두 번째는, Merge 과정에서 만약 한 쪽이 계속 이기는 상황 (오름차순 정렬이라고 가정했을 때, 한 쪽의 Run 이 계속 작은 원소를 가지고 있을 때) 라면 더 이상의 비교는 무의미하다. &lt;span style="text-decoration: underline;">이런 연속 위닝 회수를 정해서, 이후에는 &amp;lsquo;어디까지 이기는지 binary search 로 찾아서 한 번에 그냥 옮기자&amp;rsquo; 라는 건너뛰기 모드 (galloping mode) 로 전환된다.&lt;/span> 코드를 참조했을 땐, 이 위닝 회수는 3이었다. &lt;span style="color: #999999;">&lt;del>스윕승?&lt;/del>&lt;/span>&lt;/p>
&lt;p>건너뛰기 모드 (galloping mode) 에서는, 지고 있던 Run 의 첫 번째 원소가 이기고 있던 Run 의 어느 원소에서 비로소 이기는지를 찾는 것이다. 처음엔 한 칸, 다음엔 두 칸, 그 다음엔 네 칸씩 뛰며 이길 때 까지 찾는다. 그러다가 찾았다면, 직전 구간 사이를 Binary Search 를 통해 최초로 이긴 위치를 찾아내면 된다.&lt;/p>
&lt;p>그 다음은? 이기고 있던 Run 의 처음부터 발견된 위치 직전까지를 통째로 &lt;code>memcpy&lt;/code> 하면 된다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>이걸 구현할 때는 급한 나머지 그냥 구현했었는데, (물론 어딘가에선 하고 있겠지만) Mergesort 자체가 병렬 구현이 가능하므로 Timsort 역시 병렬 구현이 가능하리라 본다. Run 을 만드는 작업은 병렬로 할 수 있을까 고민이 되지만, Merge 과정은 작업 큐만으로도 쉽게 그려낼 수 있다.&lt;/p>
&lt;p>역시 이것도 만병통치약이 될 수 없다. 상황에 맞춰 적절히 섞어써야 한다. 이런 정렬 알고리즘도 있구나 하며 배웠던 소중한 기회로 여기고 있다.&lt;/p></description></item><item><title>정리는 비움으로, 그리고 마음부터</title><link>https://1nterp.github.io/%EC%A0%95%EB%A6%AC%EB%8A%94-%EB%B9%84%EC%9B%80%EC%9C%BC%EB%A1%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%A7%88%EC%9D%8C%EB%B6%80%ED%84%B0/</link><pubDate>Thu, 19 Apr 2018 02:57:40 +0000</pubDate><guid>https://1nterp.github.io/%EC%A0%95%EB%A6%AC%EB%8A%94-%EB%B9%84%EC%9B%80%EC%9C%BC%EB%A1%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%A7%88%EC%9D%8C%EB%B6%80%ED%84%B0/</guid><description>&lt;p>마음이 붕.&lt;/p>
&lt;p>몸은 여기 있는데, 어디로 가고 있는지조차 모를 정도로 격랑(激浪)에 떠밀려 가는 것처럼.&lt;/p>
&lt;p>조각난 지식들은 어딘가에 있겠지만, 약에 쓰려고 하면 개똥도 찾을 수 없는 것 처럼 내 단편의 끄적임을 찾기 힘들 때마다 드는 생각이 있다. 이걸 전부 모아뒀다면. 다짐은 용오름처럼 솟구치지만 이내 잠잠한 바다 속으로 꺼져버린다. 정리할 시간이 없진 않았을 텐데, 하면서.&lt;/p>
&lt;p>정리와 분류는 결국 데이터를 다루는 사람, 데이터 소프트웨어를 만드는 개발자 둘 모두에게 있어 경쟁력이자 기본이라고 생각한다. 어떻게 효율적으로 정리를 할 것인지 매번 고민한다. 사무실에서도, 집에서도, 혼자 스탠드등에 앉아 있으면서도. 정리해 두면, 잘 꺼내 쓸 수 있을거란 기대가 있으니까. 이 때 또 물어본다. 정말 꺼내 쓸만한 것들인지는 확인해 보았느냐고. 설마 폐지를 정리하려 드는 것은 아닐까 하고. 그래서 정리에는 비움이 필요하다.&lt;/p>
&lt;p>지금 이 생각에도 비움이 필요하다. 마음 속에 부는 바람줄을 하나씩 잠재워야 한다. 초가 타지 않도록, 그나마 따뜻한 이 믿음이 꺼지지 않도록. 이걸 먼저 정리해야겠다. 그래야 지금 앉아있는 곳으로 마음이 돌아올테니까.&lt;/p>
&lt;p> &lt;/p></description></item><item><title>조직 철학과 고객의 요구사항</title><link>https://1nterp.github.io/%EC%A1%B0%EC%A7%81-%EC%B2%A0%ED%95%99%EA%B3%BC-%EA%B3%A0%EA%B0%9D%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/</link><pubDate>Sat, 10 Mar 2018 12:30:51 +0000</pubDate><guid>https://1nterp.github.io/%EC%A1%B0%EC%A7%81-%EC%B2%A0%ED%95%99%EA%B3%BC-%EA%B3%A0%EA%B0%9D%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/</guid><description>&lt;p>회사가 고객에게 제공해야 할 것을 개념적으로 정의할 때 제품의 철학이라는 말을 사용한다. 제품의 시그니처이자 조직 내부를 움직이는 시금석이 되는데, 이걸 등한시하면 발생하는 문제에 대해 이야기하려고 한다.&lt;/p>
&lt;p>철학이라면 어떤 것을 말하는 걸까. &amp;lsquo;탐색 속도가 빨라야 한다, 로그인 없이도 정보 제공이 되어야 한다, 고객의 소리에 즉각적으로 귀를 기울인다&amp;rsquo; 같은 개념이 철학이지, &amp;lsquo;탐색 속도의 TPS 목표치, 로그인 폼의 형태, 고객이 원하는 것을 나열하는 것&amp;rsquo; 자체로 철학이라고 하지 않는다. 이건 요구사항이지, 철학이 아니다.&lt;/p>
&lt;p>그런데 후술한 구체적인 것들이 실제로 중요하기 때문에 (특히 고객이 원하는 것) 철학을 도외시하게 된다. 이래서는 안 된다. 조직이 하나로 뭉칠 수 있는 것은 그 철학에 있는데, 결정권자가 그걸 무시한 채 업무를 단장하는 순간 조직이 와해되는 것은 정말 시간문제다. 회사가 소규모이고, 창립멤버이며, 모두 새로운 이정표로 나아가는 데 동의를 하면 모르겠지만 조직이 커질수록 그런 함정에 빠지기 쉽다.&lt;/p>
&lt;p>당장의 이익이나 트렌드를 급히 따라가는 것은, 이유를 막론하고 숙고해야 할 문제이다. 단순히 예측되지 않은 미래에 대한 불안만으로 이야기하는 것이 아니다. 배의 크기가 클수록 키를 급하게 돌리면 배 자체에 문제가 발생하기 쉽다. 그걸 막기 위한 것이 조직이 동의한 (혹은 입사 때부터 배웠거나 인정했던) 가치인 것이다. 방향을 틀었다면, 조직 내부에서 큰 합의가 필요한데, 여기에 드는 비용을 무시할 수 없다. 그런데, 아무런 합의 없이 진행한다면 더 큰 비용을 감수하는 것이다. 다만, 문제가 터지기 전까진 보이지 않을 뿐.&lt;/p>
&lt;p>이걸 지켜내는 것이 정말 어려운 것임을 나는 안다. 초반에는 이걸 지킬 수 있었고, 유연하게 움직이기도 쉬웠을 것이다. 하지만 무작정 강요로 이끌어나간다면, 언젠가는 더 큰 이자를 내야 한다는 사실을 기억해야 할 것이다.&lt;/p></description></item><item><title>메타인지 – 적을 알기 전에 나를 알자</title><link>https://1nterp.github.io/%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80-%EC%A0%81%EC%9D%84-%EC%95%8C%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%82%98%EB%A5%BC-%EC%95%8C%EC%9E%90/</link><pubDate>Tue, 06 Mar 2018 06:43:00 +0000</pubDate><guid>https://1nterp.github.io/%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80-%EC%A0%81%EC%9D%84-%EC%95%8C%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%82%98%EB%A5%BC-%EC%95%8C%EC%9E%90/</guid><description>&lt;p>「완벽한 공부법」&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> 과 「일취월장」&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 두 책에서 언급되는 &amp;lsquo;메타인지&amp;rsquo; 라는 개념이 있다. &amp;lsquo;자신의 생각에 대해 판단하는 능력&amp;rsquo; 이라는 것인데, 나무위키 에서는 다음과 같이 쪼개놓았다.&lt;/p>
&lt;ul>
&lt;li>선언 지식 – 자신이 학습하는 부분에 대해서 얼마만큼의 지식과 능력을 가지고 있는지 아는 것.&lt;/li>
&lt;li>절차 지식 – 어떤 일을 하는 데 얼마만큼의 노력과 시간이 들어갈 지 아는 것.&lt;/li>
&lt;li>전략 지식 – 지식을 습득 할 때 어떤 방법을 선택해야 할지 아는 것.&lt;/li>
&lt;/ul>
&lt;p>사실 우등생은 다른 학생들보다 기억력이나 연산력이 월등히 좋거나 하진 않지만, 이 &amp;lsquo;메타인지&amp;rsquo; 능력에서 월등한 차이를 보인다고 한다. (정확히 기억나진 않지만) 어떤 실험을 하나 했는데, 학생들에게 제한 시간 안에 전부 외울 수 없는 영어단어들을 외우게 했다.&lt;/p>
&lt;p>그리고는 시험을 쳤다. 시험 결과는 우등생이나 다른 학생들이나 별다른 차이가 없었다. 그런데, 시험 후 채점을 하지 않고 몇 개나 맞췄을까라고 물어 본 결과는 달랐다. &lt;strong>우등생으로 분류된 학생들이 정확히 채점 결과와 일치하는 답을 내놨지만, 다른 학생들은 잘 모르겠다고 했단다.&lt;/strong>&lt;/p>
&lt;p>적을 아는 것도 중요하지만 또 나도 알아야 백전불태(百战不殆)&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>다. 혹시 적만 알아가는데 지치진 않았는지? 시험 문제를 그저 풀기 위해 학원에 가서 유형 분석을 하고 인강을 듣는건 아닌지 생각해 볼 필요가 있다. 내가 어디가 부족한지를 알고, 부족한 부분을 채우려는 전략적인 행동이 중요하다.&lt;/p>
&lt;p>「완공」 을 읽다가 이 대목에서 눈에 띄었던 이야기는, 메타인지를 키우려면 결국 혼자만의 공부를 해야 한다는 거다. 우등생들은 보통 혼자 공부하는 시간을 적어도 세시간 이상 둔다고 한다.&lt;/p>
&lt;p>일도 그렇지 않을까. 회사에서 주어진 일을 처리하는 것도 밥벌이로서 중요한 일이지만, 업무와 무관하게 내가 부족한 점은 무엇인지, 내가 쌓아야 하는 것은 어떤 지식인지를 스스로 탐구할 시간이 필요하다고 생각한다. 그것이 업무를 도와주는 지식이건 향후의 커리어에 도움이 되는 것이건 간에 말이다.&lt;/p>
&lt;div style="max-width: 854px;">
&lt;div style="position: relative; height: 0; padding-bottom: 56.25%;">
&lt;iframe style="position: absolute; left: 0; top: 0; width: 100%; height: 100%;" src="https://embed.ted.com/talks/lang/ko/dan_pink_on_motivation" frameborder="0" scrolling="no" allowfullscreen="allowfullscreen">&lt;/iframe>
&lt;/div>
&lt;/div>
&lt;br/>
&lt;p>책 「드라이브」&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> 의 저자 다니엘 핑크의 TED 강연&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>에서는, 협업 도구를 만드는 호주의 회사 Atlassian 을 소개한다. (내가 너무나 잘 쓰고 있는 Confluence 를 만든 회사이다.) 여기서는 업무 시간의 일정 부분을 떼서, 맡은 업무와 아무 상관없는 일을 해서 발표하는 시간을 가져 왔다고 한다. 거기서 놀라운 기능들이 나오기 시작했고, 회사는 이 비율을 20% 가까이 올렸다고 한다. 우리가 잘 알고 있는 구글 역시 이런 방식으로 새로운 기능을 자율적으로 얻을 수 있었고, Gmail 과 같은 놀라운 앱이 나온 것이다.&lt;/p>
&lt;p>이런 법칙을 개인에게도 적용해서, 외부의 과제를 잠시 내려놓고 내가 부족한 것은 없는지, 내가 비효율적으로 했거나 잘못 가고 있는 것은 아닌지 살펴보고 행동하는 시간을 가지는 것이 중요하지 않을까.&lt;/p>
&lt;p>(여담으로, 위의 강연은 양초 문제, 위키피디아의 성공 등과 같은 흥미로운 이야기를 하니 한번 보길 권한다.)&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://www.yes24.com/24/goods/34569935?scode=032&amp;amp;OzSrank=1" target="_blank" rel="noopener"
>http://www.yes24.com/24/goods/34569935?scode=032&amp;OzSrank=1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://www.yes24.com/24/Goods/57501187?Acode=101" target="_blank" rel="noopener"
>http://www.yes24.com/24/Goods/57501187?Acode=101&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://cndic.naver.com/zh/entry?entryID=c_38f7bfe4d2" target="_blank" rel="noopener"
>http://cndic.naver.com/zh/entry?entryID=c_38f7bfe4d2&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://www.yes24.com/24/goods/5819980?scode=032&amp;amp;OzSrank=5" target="_blank" rel="noopener"
>http://www.yes24.com/24/goods/5819980?scode=032&amp;OzSrank=5&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://www.ted.com/talks/dan_pink_on_motivation?language=ko" target="_blank" rel="noopener"
>https://www.ted.com/talks/dan_pink_on_motivation?language=ko&lt;/a>&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>먼저 다가가 도와주기</title><link>https://1nterp.github.io/%EB%A8%BC%EC%A0%80-%EB%8B%A4%EA%B0%80%EA%B0%80-%EB%8F%84%EC%99%80%EC%A3%BC%EA%B8%B0/</link><pubDate>Fri, 02 Mar 2018 06:56:41 +0000</pubDate><guid>https://1nterp.github.io/%EB%A8%BC%EC%A0%80-%EB%8B%A4%EA%B0%80%EA%B0%80-%EB%8F%84%EC%99%80%EC%A3%BC%EA%B8%B0/</guid><description>&lt;p>맡은 일을 하려면 쭉쭉 할 수 있을 것 같은데, 그럴 의지가 텅 비어버린 것 같다. 이 의지라는 것은 커피나 술 같은 것으로 긴급 보충이 가능하겠지만 그러기도 싫다. 그냥, 삼일절과 토요일 사이의 한가로운 근무일을 몇 가지 단상으로 때우다 보면 고것이 조금 고여있지 않을까? 그걸로 다시 일을 재개하겠노라 다짐하면서 블로그에 글을 하나 더 얹어 본다.&lt;/p>
&lt;p>어떻게 살 것인가? 라는 주제에 대해 이야기한 적이 있는데, 주변 사람들에게 긍정적인 영향을 줄 수 있는 사람이 되고 싶구나 라고 문득 생각난 적이 있다. 누군가에게 도움을 주고 웃어도 주고 들어도 주는. 그래서 처음에는 웃는 연습을 하고 지식을 채웠었다. (그것이 전문적인 것이던 가십거리가 되었던 간에) 그런데 이상했다. 여전히 날 찾는 사람이 별로 없는 것 같았다. 뭐가 문제지? 아, 마케팅을 잘 못했구나. 1인 기업이니 셀프 마케팅이니 그런 개념을 잊고 있었구나, 라고 생각했었다. 며칠 전까지는.&lt;/p>
&lt;p>마케팅 같은 거창하고 전문적인 개념으로 이 문제를 대하면 피로감이 몰려왔다. 와이프의 선배는 인맥을 관리하기 위해 분기에 한 번씩 아무런 일이 없는데도 주변 사람에게 전화를 한다고 했다. 아무런 일이 없는데도 말이다. 시시껄렁한 말이 오가면 그대로 통화는 끝난다. 이 이야길 처음 들었을 때도 비슷한 피곤이 느껴졌다. 왜 그래야 하지? 저 선배는 마케팅을 참으로 잘 하는구나.&lt;/p>
&lt;p>그런데 완전히 잘못 생각하고 있었단 생각이 들었다. 도움을 필요로 하는 사람은 &amp;lsquo;도와달라&amp;rsquo; 고 말하는 경우가 거의 없다. 처한 환경이 극단적인 경우이거나 술에 취했거나 한다면 조금 이야기가 다르겠지만, 대개는 도움을 줄 사람이 아주 명확한데다 질문하기가 거리낌이 없는 상태라야 저 말이 나온다. 그런데, 도움을 줄 사람이 명확한 경우도 거의 없고, 그 사람이 호의적으로 나올지도 모른다면? 반대로, 호의는 가지고 있는데 뭘 도와줘야 할지 모르겠다면?&lt;/p>
&lt;p>어떤 사람에게 도움이 되고자 한다면, 그 &amp;lsquo;사람&amp;rsquo; 이라는 것이 특정 타겟이 아닌 주변 사람 전부를 의미하는 거라면 접근법이 완전히 달라져야 한다. 내 문에 노크를 하며 도와달라고 말할 때 까지 기다려서도 안 되고, 주변인들이 필요해 보이는 것을 미리 준비하려고 해도 안 된다. 나도 그 사람에게 도움이 될지 안 될지 모르고, 그 사람도 나를 필요로 하는지 그렇지 않은지 모른다.&lt;/p>
&lt;p>그러니 먼저 가서, 위의 그 선배가 한 것처럼 시답잖은 이야기를 늘어놓으며 나의 존재를 알린다. 그 과정이 불편하다면 어쩔 수 없다. 하지만 적어도 그대가 뭘 필요로 하고 내가 뭘 해 줄 수 있는지 알아볼 기회가 생긴다. 그리고 내가 할 수 있는 일을 찾아서 도와줘라. 고민을 들어주고 웃어줘라. 뭔가 더 준비하지 말고, 갖춰진 상태에서 최대한 도와줘라.&lt;/p>
&lt;p>설령 도움이 안 되더라도, 적어도 나의 호의는 그대가 느낄 수 있게.&lt;/p>
&lt;p>다시 일을 시작해야겠다.&lt;/p></description></item><item><title>gdb commands 이용하기</title><link>https://1nterp.github.io/gdb-commands-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/</link><pubDate>Tue, 06 Feb 2018 08:46:05 +0000</pubDate><guid>https://1nterp.github.io/gdb-commands-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/</guid><description>&lt;p>gdb/ddd 에서 commands 를 사용하면 간편하게 breakpoint 의 상태를 출력할 수 있다. 물론 다양하게 응용이 가능하겠지만, 매뉴얼에서 제시한 케이스가 굉장히 편해서 따로 정리한다.&lt;/p>
&lt;p>참고 : &lt;a class="link" href="http://sourceware.org/gdb/onlinedocs/gdb/Break-Commands.html" target="_blank" rel="noopener"
>http://sourceware.org/gdb/onlinedocs/gdb/Break-Commands.html&lt;/a>&lt;/p>
&lt;h2 id="breakpoint-상황을-출력하기">Breakpoint 상황을 출력하기&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="mi">10&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sAddr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">aSize&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="mi">11&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">sAddr&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">12&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 코드에서 if 문에 breakpoint 를 걸고, 할당받은 시작 주소와 그 크기를 보고자 한다. 한두번 발생하는 거라면 breakpoint 를 걸어 둔 다음 print 나 graph display (ddd 전용) 으로 띄워서 관찰하면 된다. 그런데 이게 100번 200번이면 하염없이 엔터를 치게 된다.&lt;/p>
&lt;p>이럴 때 다음과 같이 입력한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> b &lt;span class="m">10&lt;/span> &lt;span class="c1"># 10번째 라인에 breakpoint&lt;/span>
&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> commands &lt;span class="c1"># 아무 것도 입력하지 않으면 최근 breakpoint 에 대한 command 입력&lt;/span>
&amp;gt; silent &lt;span class="c1"># breakpoint 에 멈췄단 메시지를 출력하지 말아달라&lt;/span>
&amp;gt; &lt;span class="nb">printf&lt;/span> &lt;span class="s2">&amp;#34;alloc address is %p\n and its size is %ld&amp;#34;&lt;/span>, *sAddr, aSize
&amp;gt; cont &lt;span class="c1"># 흔히 입력하는 cont 와 동일하다.&lt;/span>
&amp;gt; end &lt;span class="c1"># command 입력 종료&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러고 cont 를 날리면.. breakpoint 에서 멈추는 대신 해당 command 가 수행된다! 즉, 계속해서 주소와 할당 크기가 출력된다. 아주 편하다…&lt;/p>
&lt;h2 id="call-stack-보기">Call Stack 보기&lt;/h2>
&lt;p>일종의 응용인데, commands 내부에는 우리가 흔히 쓰는 명령어를 입력하면 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> commands
&amp;gt; silent
&amp;gt; bt &lt;span class="m">5&lt;/span> &lt;span class="c1"># backtrace (callstack) 을 출력하되, 안쪽에서 5개 까지만 출력&lt;/span>
&amp;gt; cont
&amp;gt; end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="commands-의-초기화">Commands 의 초기화&lt;/h2>
&lt;p>commands 명령어를 입력한 다음, 바로 end 로 끝내면 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> commands
&amp;gt; end
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Intel VTune Memory Bandwidth 분석하기</title><link>https://1nterp.github.io/vtune-memory-bandwidth/</link><pubDate>Mon, 22 Jan 2018 05:19:48 +0000</pubDate><guid>https://1nterp.github.io/vtune-memory-bandwidth/</guid><description>&lt;p>Intel VTune 으로 Memory Bandwidth 를 분석하려면, 분석할 수 있는 커널 드라이버를 로딩시켜야 한다. (참고로 메모리 분석은 리눅스에서만 가능하다.) 해당 작업을 하지 않고 &amp;lsquo;General Exploration &amp;gt; Analyze memory bandwidth&amp;rsquo; 를 체크하면 엄한 경고창이 반길 것이다.&lt;/p>
&lt;p>&lt;img src="https://1nterp.github.io/uploads/2018/01/before.jpg"
loading="lazy"
>&lt;/p>
&lt;p>&lt;a class="link" href="https://software.intel.com/en-us/vtune-amplifier-help-building-and-installing-the-sampling-drivers-for-linux-targets" target="_blank" rel="noopener"
>이 문서&lt;/a>를 참고해도 좋지만, VTune 이 설치된 경로에서 &lt;code>sepdk/src/README.txt&lt;/code> 를 보는 게 더 쉽다. 이 내용을 요약하면,&lt;/p>
&lt;ol>
&lt;li>커널 환경변수를 체크한다. 프로파일링이 가능하고 모듈 로딩이 가능해야 한다.
&lt;ul>
&lt;li>&lt;code>CONFIG_MODULES=y&lt;/code>&lt;/li>
&lt;li>&lt;code>CONFIG_MODULE_UNLOAD=y&lt;/code>&lt;/li>
&lt;li>&lt;code>CONFIG_PROFILING=y&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>커널 드라이버를 컴파일시킬 헤더파일이 필요하다. Linux 배포판에 따라, 커널 개발용 패키지를 내려받아 설치한다.&lt;br>
(언급한 Linux 배포판이 없으면 소스를 직접 받아둔다.)
&lt;ul>
&lt;li>Redhat 5/Fedora/CentOS : &lt;code>yum install kernel-devel&lt;/code>&lt;/li>
&lt;li>Ubuntu/Debian : &lt;code>apt-get install build-essential linux-headers-`uname-r`&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>VTune이 필요로 하는 커널 드라이버를 컴파일하고 로드시킨다.
&lt;ul>
&lt;li>&lt;code>cd ${VTune Directory}/spedk/src&lt;/code>&lt;/li>
&lt;li>&lt;code>./build_driver&lt;/code> (이 때 2번에서 설치한 커널 헤더파일의 위치를 정확히 입력해야 한다.)&lt;/li>
&lt;li>&lt;code>./insmod-sep3&lt;/code>
&lt;ul>
&lt;li>로딩 확인을 위해서는 &lt;code>./insmod-sep3 -q&lt;/code> 라고 입력해 보자.&lt;/li>
&lt;li>언로딩 시키려면 &lt;code>./rmmod-sep3&lt;/code> 이라고 입력하자.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Gitlab 아바타/첨부파일 상대 경로 설정</title><link>https://1nterp.github.io/gitlab-%EC%95%84%EB%B0%94%ED%83%80-%EC%83%81%EB%8C%80-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95/</link><pubDate>Mon, 08 Jan 2018 02:35:20 +0000</pubDate><guid>https://1nterp.github.io/gitlab-%EC%95%84%EB%B0%94%ED%83%80-%EC%83%81%EB%8C%80-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95/</guid><description>&lt;p>사내 사정으로 인해 Gitlab의 &lt;code>External_Url&lt;/code> 을 실제 서버 주소와 다르게 설정해서 쓰고 있다.&lt;/p>
&lt;p>물론 실제 nginx 에도 해당 도메인으로 접근할 수 있도록 설정해야 하는 게 맞다. 그렇지 않으면, 첨부파일과 아바타 이미지가 모두 깨져나온다. 하지만 그러기 전에 Gitlab 차원에서 상대 경로로 아바타를 출력할 수 있도록 수정하는 방법 &amp;lsquo;도&amp;rsquo; 있으니 편법으로 수정했다. 아래는 그 편법 내용을 다룬다.&lt;/p>
&lt;h2 id="아바타-상대-경로-설정">아바타 상대 경로 설정&lt;/h2>
&lt;p>&lt;code>/opt/gitlab/embedded/service/gitlab-rails/app/models/concerns/avatarable.rb&lt;/code> 파일에서 절대 경로로 수정하는 코드가 있는데, url_base 에 덧붙이는 코드들을 전부 주석처리하면 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">module&lt;/span> &lt;span class="nn">Avatarable&lt;/span>
&lt;span class="kp">extend&lt;/span> &lt;span class="no">ActiveSupport&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Concern&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">avatar_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">only_path&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">unless&lt;/span> &lt;span class="nb">self&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="ss">:avatar&lt;/span>&lt;span class="o">].&lt;/span>&lt;span class="n">present?&lt;/span>
&lt;span class="n">asset_host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">ActionController&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Base&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">asset_host&lt;/span>
&lt;span class="n">use_asset_host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">asset_host&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">present?&lt;/span>
&lt;span class="c1"># Avatars for private and internal groups and projects require authentication to be viewed,&lt;/span>
&lt;span class="c1"># which means they can only be served by Rails, on the regular GitLab host.&lt;/span>
&lt;span class="c1"># If an asset host is configured, we need to return the fully qualified URL&lt;/span>
&lt;span class="c1"># instead of only the avatar path, so that Rails doesn&amp;#39;t prefix it with the asset host.&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">use_asset_host&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">respond_to?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:public?&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="kp">public&lt;/span>&lt;span class="p">?&lt;/span>
&lt;span class="n">use_asset_host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;span class="n">only_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="n">url_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
&lt;span class="c1"># if use_asset_host&lt;/span>
&lt;span class="c1"># url_base &amp;lt;&amp;lt; asset_host unless only_path&lt;/span>
&lt;span class="c1"># else&lt;/span>
&lt;span class="c1"># url_base &amp;lt;&amp;lt; gitlab_config.base_url unless only_path&lt;/span>
&lt;span class="c1"># url_base &amp;lt;&amp;lt; gitlab_config.relative_url_root&lt;/span>
&lt;span class="c1"># end&lt;/span>
&lt;span class="n">url_base&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">avatar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>당연히 &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 를 해 줘야 한다.&lt;/p>
&lt;p>참고 : &lt;a class="link" href="https://gitlab.com/gitlab-org/gitlab-ce/merge" target="_blank" rel="noopener"
>https://gitlab.com/gitlab-org/gitlab-ce/merge&lt;/a>_requests/11001/diffs#note_28659864&lt;/p>
&lt;h2 id="첨부파일-상대-경로-설정">첨부파일 상대 경로 설정&lt;/h2>
&lt;p>단서가 없어서 맨땅에 헤딩하듯이 뒤지고 다녔다. Markdown 언어에서 링크를 담당하는 라이브러리가 있는데, 이름이 &amp;lsquo;&lt;strong>banzai&lt;/strong>&amp;rsquo; 이다 (…) &lt;span style="color: #808080;">&lt;del>무슨 생각으로 이름을 지은건지 도저히 모르겠지만&lt;/del>&lt;/span> 여기를 수정해야 한다.&lt;/p>
&lt;p>&lt;code>filter/upload_link_filter.rb&lt;/code> 를 보면, &lt;code>build_url()&lt;/code> 이란 함수가 있다. 여기서 Geo node 여부에 따라 base_path 를 설정하는 코드가 있는데, 여기서 원하는 내부 주소로 변경하면 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">def&lt;/span> &lt;span class="nf">build_url&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uri&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">base_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="no">Gitlab&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Geo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">secondary?&lt;/span>
&lt;span class="no">Gitlab&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Geo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">primary_node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="c1"># Gitlab.config.gitlab.url&lt;/span>
&lt;span class="s2">&amp;#34;http://your.address.com/&amp;#34;&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">group&lt;/span>
&lt;span class="n">urls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">Gitlab&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Routing&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url_helpers&lt;/span>
&lt;span class="c1"># we need to get last 2 parts of the uri which are secret and filename&lt;/span>
&lt;span class="n">uri_parts&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">uri&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">File&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">SEPARATOR&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">file_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">urls&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">show_group_uploads_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">group&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uri_parts&lt;/span>&lt;span class="o">[-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uri_parts&lt;/span>&lt;span class="o">[-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="no">File&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">base_path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">file_path&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="no">File&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">base_path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">project&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">full_path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uri&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Gitlab 11 버전 으로 업그레이드 되면서부터 해당 파일은 삭제되고, &lt;code>absolute_link_filter.rb&lt;/code> 와 &lt;code>external_link_filter.rb&lt;/code> , &lt;code>relative_link_filter.rb&lt;/code> 가 남아있다. 여기 있는 &lt;code>Gitlab.config.gitlab.url&lt;/code> 을 원하는 주소로 바꿔주면 가능하다. (relative.rb 의 경우 &lt;code>Gitlab.config.gitlab.base_url&lt;/code>)&lt;/p></description></item><item><title>대화는 필요해</title><link>https://1nterp.github.io/%EB%8C%80%ED%99%94%EB%8A%94-%ED%95%84%EC%9A%94%ED%95%B4/</link><pubDate>Fri, 05 Jan 2018 04:48:10 +0000</pubDate><guid>https://1nterp.github.io/%EB%8C%80%ED%99%94%EB%8A%94-%ED%95%84%EC%9A%94%ED%95%B4/</guid><description>&lt;img src="https://1nterp.github.io/uploads/2018/01/exhibition_see_visitors_gallery_museum_art-1035105.jpgd_.jpg" alt="Featured image of post 대화는 필요해" />&lt;p>매니저 자리에 처음 앉았을 때와 다르게, 언젠가부터 남과 대화하는 것을 기피하는 내 모습을 자주 발견하게 되었다. 의욕이 넘쳐서 이거저거 캐묻고 알아가던 때가 있었는데, 그러면서 반발도 부딪히고 구성원들이 나만큼 의욕적이지 않은 것 같고, 의심하고 실망하고를 반복하다 보니 이렇게 된 것 일까. &amp;lsquo;지쳤다&amp;rsquo; 나 &amp;lsquo;질렸다&amp;rsquo; 라고 해도 괜찮을 수준이었다.&lt;/p>
&lt;p>그런데 대화를 그만두면 더 좋지 않은 것 같다. 그냥 시간을 버리는 것 같다. 대화가 멈추면, 서로가 원하는 것을 모르고 각자 하고 싶은 대로 흘러간다.&lt;/p>
&lt;p>대화를 해서 손해를 보는 경우도 있다. 감정이 상할 수도 있다. 하지만 그 차이를 나도 양보하고 너도 양보해서 맞춰야 한다. 대화를 자주 해서 업무 방해가 일어난다거나, 쓸데없는 일이라고 여겨질 수도 있겠는데… 서로 대화하지 않고 흘러가게 두는 것이, 더 큰 손해를 끼칠 가능성이 높다고 생각한다.&lt;/p>
&lt;p>그래서 오늘도, 대화하기 싫어하는 나를 달래가며 다른 사람들에게 말해야 할 가장 적절한 질문과 주제를 찾고 있다.&lt;/p></description></item><item><title>Gitlab Markdown Parser 바꾸기</title><link>https://1nterp.github.io/gitlab-markdown-parser-%EB%B0%94%EA%BE%B8%EA%B8%B0/</link><pubDate>Wed, 03 Jan 2018 02:29:21 +0000</pubDate><guid>https://1nterp.github.io/gitlab-markdown-parser-%EB%B0%94%EA%BE%B8%EA%B8%B0/</guid><description>&lt;p>Github 과 비슷한 서비스인 &lt;a class="link" href="https://about.gitlab.com/" target="_blank" rel="noopener"
>Gitlab&lt;/a> 은 오픈소스이기 때문에 Community Edition 을 쓰건, Enterprise Edition 을 쓰건 on-premise 환경에서 설치한 뒤 맘대로 수정해서 사용이 가능하다. (물론 EE 는 라이센스가 필요하다) 수정하는 범위를 한정하지 않는다면, 일개 루비 (&lt;code>*.rb&lt;/code>) 파일까지 건드릴 수 있다.&lt;/p>
&lt;p>여기서는 Gitlab에서 문서 작성에 필요한 Markdown 의 Parser 부분을 미세하게 수정해서, 입맛에 맞게 바꾸기 위한 트윅을 정리해 둔다. Ruby 개발자가 아니라서 전체 순서가 정공법처럼 보이진 않겠지만.&lt;/p>
&lt;p>수정 내용은 다음과 같다. 원래 Markdown 문법에선 Enter 키를 두 번 치면 문단 바꿈, 줄 끝에 스페이스를 두 번 넣으면 줄바꿈이 된다. &lt;strong>그런데 Enter 키를 한 번만 쳐도 줄바꿈이 되면 좋겠다는 개발자가 많았다.&lt;/strong> &lt;del>님 Markdown 안 써보셨어요? 라고 따질 순 없었다.&lt;/del>&lt;/p>
&lt;h2 id="gitlab-10x--redcarpet">Gitlab 10.x : Redcarpet&lt;/h2>
&lt;p>Gitlab 10.x 에서는 Markdown Parser 를 &lt;a class="link" href="https://github.com/vmg/redcarpet" target="_blank" rel="noopener"
>Redcarpet&lt;/a> 으로 사용한다. 아마 &lt;a class="link" href="https://jekyllrb-ko.github.io/" target="_blank" rel="noopener"
>Jekyll&lt;/a> 도 기본적으로 Redcarpet 을 사용하는 것으로 알고 있다. 만약 Ruby의 Redcarpet 을 Markdown Parser 로 쓰는 경우라면 똑같이 적용이 가능하다.&lt;/p>
&lt;h3 id="parser-c-파일-수정하기">Parser C 파일 수정하기&lt;/h3>
&lt;p>&lt;code>/opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/redcarpet-3.4.0/&lt;/code> 으로 들어가면 Redcarpet의 소스코드가 존재한다. 여기서 &lt;code>ext/redcarpet&lt;/code> 디렉토리가 Parser C 파일들이 위치한 곳이다.&lt;/p>
&lt;p>내가 수정하고 싶은 것은 &amp;lsquo;&lt;strong>엔터 키를 두번 쳐야 (혹은 줄 끝에 스페이스를 2개 이상 줘야) 줄바꿈이 되는 불편함&lt;/strong>&amp;rsquo; 을 해소하고 싶었다. &lt;code>markdown.c&lt;/code> 파일을 보니 &lt;code>char_linebreak()&lt;/code>  라는 함수가 존재한다. 여기서 해당 부분을 주석처리했다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="cm">/* char_linebreak • &amp;#39;\n&amp;#39; preceded by two spaces (assuming linebreak != 0) */&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="n">size_t&lt;/span>
&lt;span class="nf">char_linebreak&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">buf&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">sd_markdown&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rndr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">uint8_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size_t&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size_t&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//if (offset &amp;lt; 2 || data[-1] != &amp;#39; &amp;#39; || data[-2] != &amp;#39; &amp;#39;)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// return 0; /* removing the last space from ob and rendering */
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">rndr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">cb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">linebreak&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rndr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">opaque&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="라이브러리-생성복사">라이브러리 생성/복사&lt;/h3>
&lt;p>수정이 끝나면 반드시 &lt;code>ext/redcarpet&lt;/code> 디렉토리에서 &lt;code>make&lt;/code> 를 수행해 주도록 하자. 그러면 Shared Library 파일인 &lt;code>redcarpet.so&lt;/code> 이 생성된다.&lt;/p>
&lt;p>이 파일을, 다음 경로에 모두 복사해주도록 하자.&lt;/p>
&lt;ul>
&lt;li>&lt;code>/opt/gitlab/embedded/lib/ruby/gems/2.3.0/extensions/x86_64-linux/2.3.0/redcarpet-3.4.0/&lt;/code>&lt;/li>
&lt;li>&lt;code>/opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/redcarpet-3.4.0/lib/&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="gitlab-재부팅">Gitlab 재부팅&lt;/h3>
&lt;p>대망의 재부팅이 남았다.&lt;/p>
&lt;p>&lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 를 실행시키면 반영이 된다!&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="gitlab-11x-이후--commonmark">Gitlab 11.x 이후 : Commonmark&lt;/h2>
&lt;p>11.x 부터는 Redcarpet 이 아니라 Commonmark 를 기본 파서로 사용한다. 구조가 달라져서 찾는게 귀찮아서 그렇지, 기본 원리는 비슷하다. 2칸 이상의 space 를 준 채로 줄바꿈하게 되면 &lt;code>CMARK_NODE_LINEBREAK&lt;/code>, 그렇지 않고 줄바꿈하면 &lt;code>CMARK_NODE_SOFTBREAK&lt;/code> 상태로 전이된다.&lt;/p>
&lt;p>옵션을 쓸 수 있다면 좋겠지만, 본인은 마음이 급한지라 참고할 만한 소스코드만 붙이고 도망가도록 한다. &lt;code>html.c:283&lt;/code> 부터다. 여기서 직접 line break 를 하도록 강제했다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">case&lt;/span> &lt;span class="nl">CMARK_NODE_SOFTBREAK&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">options&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">amp&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">CMARK_OPT_HARDBREAKS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">cmark_strbuf_puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;br/&amp;gt;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">options&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">amp&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">CMARK_OPT_NOBREAKS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// cmark_strbuf_putc(html, &amp;#39; &amp;#39;); // 수정 전
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cmark_strbuf_puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;br/&amp;gt;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 수정 후
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">cmark_strbuf_putc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이렇게 하고 make 를 치면.. 어? 빌드가 안 된다.&lt;/p>
&lt;p>당황하지 말고, &lt;del>이름 때문에 보기 싫지만&lt;/del> banzai filter 가 위치한 곳의 ruby 파일을 수정하면 된다. 여기에서 사실 옵션 조절이 가능하다. 파일 위치는 &lt;code>/opt/gitlab/embedded/service/gitlab-rails/lib/banzai/filter/markdown_engines/common_mark.rb&lt;/code> 이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="no">RENDER_OPTIONS&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>
&lt;span class="ss">:DEFAULT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1"># default rendering system. Nothing special.&lt;/span>
&lt;span class="ss">:HARDBREAKS&lt;/span> &lt;span class="c1"># Treat `\n` as hardbreaks (by adding `&amp;lt;br/&amp;gt;`). # 이걸 추가한다.&lt;/span>
&lt;span class="o">].&lt;/span>&lt;span class="n">freeze&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>반드시, Gitlab 재부팅을 잊지말자!&lt;/p>
&lt;p>한 가지 아쉬운 점은(?) 일부러 soft break 를 시도하는 경우에, 내부에서 line break 까지 겹쳐서 인식하기 때문에 결론적으로 &lt;code>&amp;lt;br/&amp;gt;&lt;/code> 이 두번 붙는 사태가 일어난다. 어쩔 수 없이 commonmark 를 한번 빌드하는 수밖에 없나.. 하는 생각이 들고 있다.&lt;/p></description></item><item><title>oh-my-zsh 색깔 고르기</title><link>https://1nterp.github.io/oh-zsh-%EC%83%89%EA%B9%94-%EA%B3%A0%EB%A5%B4%EA%B8%B0/</link><pubDate>Wed, 13 Dec 2017 05:43:01 +0000</pubDate><guid>https://1nterp.github.io/oh-zsh-%EC%83%89%EA%B9%94-%EA%B3%A0%EB%A5%B4%EA%B8%B0/</guid><description>&lt;p>oh-my-zsh 테마 작업을 agnoster 를 기반으로 고쳐서 사용 중이다. 그런데 주석을 보면 다음 색깔만 지원하는 것 처럼 나온다.&lt;/p>
&lt;blockquote>
&lt;p>white, black, red, blue, green, yellow, cyan, magenta&lt;/p>
&lt;/blockquote>
&lt;p>위의 색깔 외에 다른 색상을 설정하려면, 다음 작업이 필요하다.&lt;/p>
&lt;ul>
&lt;li>터미널 종류가 xterm-256color 여야 한다. (xterm 으로 설정되어 있으면 제대로 출력이 안된다.)&lt;/li>
&lt;li>oh-my-zsh 에서, &lt;code>%{%K{---}%}&lt;/code> 또는 &lt;code>%{%F{---}%}&lt;/code> 를 가지고 색깔을 찾는다. 이 때 &lt;code>---&lt;/code> 대신 0~255 사이의 숫자를 입력한다.&lt;/li>
&lt;li>0~255 숫자와 대응되는 색상을 찾아야 하는데, &lt;a class="link" href="https://jonasjacek.github.io/colors/" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/li>
&lt;/ul></description></item><item><title>‘왜’에서 찾는 특별한 나</title><link>https://1nterp.github.io/%EC%99%9C%EC%97%90%EC%84%9C-%EC%B0%BE%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%EB%82%98/</link><pubDate>Mon, 11 Dec 2017 03:20:57 +0000</pubDate><guid>https://1nterp.github.io/%EC%99%9C%EC%97%90%EC%84%9C-%EC%B0%BE%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%EB%82%98/</guid><description>&lt;p>이제 자기계발서들은, 목표에 대한 진척을 강요하거나 쥐어짜려는 설득을 더 이상 하지 않게 되었다. 아니면, 그런 글귀와 말을 사람들이 더 이상 찾지 않는 것일지도 모른다. 사람들이 열광하는 주제가, 맹목적인 믿음이나 노력을 채찍질하는 것에서 벗어나 자신에 대한 탐구로 옮겨가고 있는 것처럼 보인다. &amp;lsquo;어떻게&amp;rsquo; 라기 보다는 &amp;lsquo;왜&amp;rsquo; 에 좀 더 가까운 것 같다.&lt;/p>
&lt;h3 id="어떻게-가-아닌-왜">&amp;lsquo;어떻게&amp;rsquo; 가 아닌, &amp;lsquo;왜&amp;rsquo;&lt;/h3>
&lt;p>조금만 시간을 거슬러 올라가도 공부에 대한 방법론, 단기간에 끝내기, 맹목적으로 바라보기, 노력은 배신하지 않는 등의 주제가 가득했다. 공부 잘 하면 좋고, 노력은 배신하지 않는 것도 동의한다. 그런데 그걸 왜 하냐고, 설마 남 좋으라고 하는건가? 그 흐름에 나를 넣어야 하는데, 그렇지 않다면 과연 자기계발이 맞는 걸까?&lt;/p>
&lt;p>최근 자기계발서의 내용들은 그렇지가 않다. 남 눈치보지 말자, 내 인생은 내가 책임진다, 모두가 날 좋아할 수는 없다, 뭐 이런 거다. 일종의 위로이자 응원이다. &lt;a class="link" href="https://www.youtube.com/watch?v=VnSMIgsPj5M" target="_blank" rel="noopener"
>베네딕트 컴베비치가 레터스라이브에서 매우 격앙된 어조로 낭독한 영상&lt;/a>을 줄이면 &lt;em>&amp;lsquo;남에게 눈치보지 말고 그냥 해라고!'&lt;/em> 라는 것이었다. 화난 듯 말하지만, 사실은 위로이자 응원이다. 남에게 눈치보고 있다는 것은, 말 그대로 내가 아닌 남이 원하는 삶을 살고 있는 것이다. 그냥 해보라는 말도, 뭘 하고 싶고 뭘 할 수 있는지 찾아서 하라는 것이다.&lt;/p>
&lt;h3 id="내가-한-일은-남들도-다-할-수-있다">내가 한 일은 남들도 다 할 수 있다&lt;/h3>
&lt;p>목 마른 사람이 우물을 파겠지만, 지금껏 우리는 우물을 어떻게 파느냐, 어디에 우물이 잘 나오느냐만 들었을 뿐이다. 정말 목이 마른지, 배가 고픈지, 잠이 오는지는 생각해보지 못한 게 아닐까. 다른 사람과 다른 &amp;lsquo;나&amp;rsquo; 이기 때문에.&lt;/p>
&lt;p style="text-align: left;">
내가 할 수 있는 일은, 남들도 다 할 수 있다.&lt;br /> &lt;strong>그렇지만, 남들이 하지 않기 때문에 내가 특별하다.&lt;/strong>
&lt;/p>
&lt;p>이런 장황한 이야기를 한 이유는 두 가지이다. 다른 모든 사람이 각자 누리고 있는 우물을 나도 파내서 마시기엔 시간이 부족하다는 점을 인정하기 위해, 그리고 나만의 특별함을 강조하기 위해서다. 살면서 느꼈던, 소중한 경험을 잘 간직하고 계속 행복할 수 있는 방법을 찾아나가는 것을, &amp;lsquo;어떻게&amp;rsquo; 라는 주위에 널린 해답에서는 찾지 말길 바란다.&lt;/p></description></item><item><title>X11 on Windows Linux Subsystem</title><link>https://1nterp.github.io/x11-windows-linux-subsystem/</link><pubDate>Wed, 29 Nov 2017 08:32:52 +0000</pubDate><guid>https://1nterp.github.io/x11-windows-linux-subsystem/</guid><description>&lt;p>먼저, Windows 10 에서 지원하는 Linux Subsystem 기능에 대해 이야기한다. 잘 모르겠다면 &lt;a class="link" href="https://msdn.microsoft.com/en-us/commandline/wsl/install-win10" target="_blank" rel="noopener"
>이 글&lt;/a>을 읽고 설치에 도전해 보자. &lt;span style="color: #999999;">&lt;del>그런데 글 내용을 보면 이거랑 관련 없다. Babun, Mintty, Git on Bash, Putty 전부 포함이다&lt;/del>&lt;/span>&lt;/p>
&lt;ul>
&lt;li>SSH에 접속한 서버에서 X11 Forwarding 을 받고 싶은 경우를 이야기한다. 단적으로, 접속한 서버에서 파이어폭스 브라우저를 실행하면 내 윈도우 화면에 브라우저 창이 실행되는 거다. 이걸 따로 이야기하고 싶지 않으니 &lt;a class="link" href="https://www.google.co.kr/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=0ahUKEwj1yoOCrePXAhWCG5QKHeIRCkEQFggkMAA&amp;amp;url=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fxming%2F&amp;amp;usg=AOvVaw2r18vOyEGzisW0WiHH4ksg" target="_blank" rel="noopener"
>Xming&lt;/a> 이나 &lt;a class="link" href="https://www.google.co.kr/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=0ahUKEwj-y9aGrePXAhUJoZQKHXKpB2IQFggkMAA&amp;amp;url=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fvcxsrv%2F&amp;amp;usg=AOvVaw2UIxI0S4LFsqeqk9A47MSR" target="_blank" rel="noopener"
>VcXsrv&lt;/a> 을 참고해 설치해보자.&lt;/li>
&lt;/ul>
&lt;p>참고로, 이 방법은 Client측 PC의 X Server로 접근하는 무식한 방법이므로, 일반 데스크탑 PC에서 서버로 접속했을 때엔 사용할 수 없을 것 같다. 좀 더 알아보고 보충해야겠다.&lt;/p>
&lt;p>그리고, ssh_config 에서 &lt;code>X11ForwardTrusted&lt;/code> 를 확인하지 않았었다. 이걸 설정하니까 Server에서 DISPLAY를 따로 설정하지 않아도 잘 된다? &lt;code>xauth generate&lt;/code> 를 한번 더 해보긴 했는데.. 한번 더 실험이 필요하다.&lt;/p>
&lt;h2 id="windows에서-한-일">Windows에서 한 일&lt;/h2>
&lt;p>클라이언트 PC에서 작업한 일이다. 참고로 나는 Ubuntu 를 Linux Subsystem 으로 설치했는데, 어느 리눅스 버전이어도 상관 없을 것이다.&lt;/p>
&lt;ol>
&lt;li>Xming 또는 VcXsrv 를 설치해서 실행시켰다. 트레이 아이콘에 &amp;lsquo;X&amp;rsquo; 라고 떠 있으면 완료. (이걸 X Server 라고 부른다)&lt;/li>
&lt;li>Ubuntu Console을 하나 열어서,&lt;code>/etc/ssh/ssh_config&lt;/code> (sshd_config 가 아니다) 파일을 확인했다. 여기에서 ForwardX11 yes, ForwardX11Trusted yes 를 확인했다. (주석 처리되어 있다면 주석을 제거, sudo 권한 필요)&lt;/li>
&lt;li>SSH 접속을 하면, 다음 에러 메시지가 떠서 보기 싫었다.
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">No xauth data; using fake authentication data for X11 forwarding.
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>그래서 다음과 같이 처리했다.
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ xauth list &lt;span class="c1"># ~/.Xauthority 파일이 없었다!&lt;/span>
$ xauth generate :0 . trusted &lt;span class="c1"># ~/.Xauthority 파일을 만들어준다고 한다..&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>(Optional) Xming 또는 VcXsrv 의 설치 디렉토리에 가면 &lt;code>X0.hosts&lt;/code>라는 파일이 있다. 여기서 Server의 Hostname 또는 IP를 적어줘야 한다.&lt;/li>
&lt;/ol>
&lt;h2 id="server에서-한-일">Server에서 한 일&lt;/h2>
&lt;p>직접 SSH로 접속하고 나서 설정해야 할 것을 적었다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>/etc/ssh/sshd_config&lt;/code> 에서 &lt;code>X11UseLocalHost&lt;/code> 가 yes 로 되어 있거나, 활성화되어 있지 않아야 한다. 만약 no로 되어 있으면 yes 로 변경해야 한다.&lt;/li>
&lt;li>&lt;code>$DISPLAY&lt;/code> 환경 변수를 아예 Windows (클라이언트 PC) 의 Hostname 또는 IP 주소로 설정해버린다.
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">export&lt;/span> &lt;span class="nv">DISPLAY&lt;/span>&lt;span class="o">=&lt;/span>192.168.0.xxx:0
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>참고로, 뒤에 :0 또는 :10 같이 여러 예제가 인터넷에 나도는데, Windows 에서 X 아이콘에 마우스를 가져다 대면 &lt;code>Hostname:X.X&lt;/code> 라고 나올 것이다. X.X 를 저기에 쓰는 것이다. (나는 0.0 이라고 떠서 그냥 0만 적었다.)&lt;/li>
&lt;li>firefox 를 실행해 보자. 끝.&lt;/li>
&lt;/ol></description></item><item><title>C# xUnit 실습</title><link>https://1nterp.github.io/csharp-xunit-practice/</link><pubDate>Wed, 29 Nov 2017 03:28:03 +0000</pubDate><guid>https://1nterp.github.io/csharp-xunit-practice/</guid><description>&lt;p>대학생 때 팀 프로젝트로 윈도우 어플리케이션을 끄적이던 때가 있었다. 그 때 C# 기반으로 진행했었는데, 나는 뷰에 집중했던지라 디자인하고 프로퍼티 만지기 바빴고 뼈대는 다른 친구가 만들어 줬었던 기억이 난다. 그 때부터 C/C++ 와는 다르지만 비슷한 이름의 이 언어에 왠지 모를 끌림이 있었다. 하지만 배울 기회는 없었지..&lt;/p>
&lt;p>바로 그 언어, C#을 현업에서 당장 써먹어야 하는 상황이 발생했다. (이런 상황이 왜 발생했는지 한탄은 나중에 일단 하기로 하고) 어쩔 수 없이 배움의 기회로 삼는 수 밖에 없다.&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.microsoft.com/ko-kr/dotnet/core/testing/unit-testing-with-dotnet-test" target="_blank" rel="noopener"
>dotnet test 및 xUnit을 사용하여 .NET Core에서 C# 유닛 테스트&lt;/a>라는 MS 문서를 기반으로 실습을 했는데, 여기서 중요한 것은, 내가 만들어야 하는 라이브러리의 Target Framework가 .NET Core 가 아니라 .NET Framework 4.0 이다. xUnit은 최소 .NET Framework 4.5 이상에서만 돌아간다.&lt;/p>
&lt;p>그럼 나는 테스트를 못 하는 것인가? 실제론 그렇지는 않았다. xUnit 프로젝트만 .NET Framework 4.5 로 두고, 라이브러리 프로젝트는 .NET Framework 4.0 으로 설정해서 테스트를 진행해 봤다. 대부분의 내용은 위의 문서를 요약한 것에 지나지 않지만, 중간에 Target Framework를 설정하는 부분에 대해서도 설명하겠다.&lt;/p>
&lt;h2 id="사전-준비">사전 준비&lt;/h2>
&lt;p>혹시나 해서 적어둔다. 다 필요없고 .NET Core SDK 를 설치해주자.&lt;/p>
&lt;ul>
&lt;li>.NET Framework 4.0, .NET Framework 4.5 SDK 가 설치되어 있어야 한다. (Visual Studio 설치하면서 같이 설치하는게 속편하다)&lt;/li>
&lt;li>.NET Framework 4.5 이후의 TargetFramework를 가져가는 경우엔 .NET Core SDK 를 설치하는 것으로 끝날지도 모른다는 어렴풋한 추측을 해 본다. (Target Framework를 수정한 다음 dotnet restore 를 하면?)&lt;/li>
&lt;/ul>
&lt;p>그리고 아래 실습은 Visual Studio 가 아니라 Powershell 에서 진행한다. 사내 빌드할 때 Visual Studio를 안 쓰기 때문이다. 단지 그 뿐이다..&lt;/p>
&lt;h2 id="솔루션프로젝트-준비">솔루션/프로젝트 준비&lt;/h2>
&lt;ol>
&lt;li>디렉토리를 하나 만든다. 여기서는 &lt;code>testSolution&lt;/code> 라고 하자.&lt;/li>
&lt;li>&lt;code>dotnet new sln&lt;/code> 을 실행한다. 솔루션 파일이 생성된다.&lt;/li>
&lt;li>내부에 디렉토리를 하나 만든다. 여기서는 &lt;code>projLibrary&lt;/code> 라고 하자.&lt;/li>
&lt;li>&lt;code>projLibrary&lt;/code> 에 들어가서 &lt;code>dotnet new classlib&lt;/code> 명령으로 프로젝트를 만든다. &lt;br>
&lt;code>classlib&lt;/code> 라고 입력하면 해당 프로젝트는 라이브러리를 생성하는 것이 된다.&lt;/li>
&lt;li>다시 &lt;code>testSolution&lt;/code> 디렉토리로 돌아와서, &lt;code>dotnet sln add projLibrary/projLibrary.csproj&lt;/code> 를 입력한다.&lt;br>
이제 솔루션에 해당 프로젝트가 등록된다.&lt;/li>
&lt;li>&lt;code>testSolution&lt;/code>내부에 테스트용 디렉토리를 하나 만든다. 여기서는 &lt;code>projTest&lt;/code> 라고 하자.&lt;/li>
&lt;li>&lt;code>projTest&lt;/code> 에 들어가서 &lt;code>dotnet new xuint&lt;/code> 를 입력해 테스트용 프로젝트를 만든다.&lt;br>
&lt;code>xuint&lt;/code> 라고 입력하면, 해당 프로젝트는 테스트를 위한 것이 된다.&lt;/li>
&lt;li>다시 &lt;code>testSolution&lt;/code> 디렉토리로 돌아와서, &lt;code>dotnet sln add projTest/projTest.csproj&lt;/code> 를 입력한다. 이제 솔루션에 해당 프로젝트가 등록된다.&lt;/li>
&lt;li>마지막으로 테스트 프로젝트에 라이브러리 프로젝트를 참조할 수 있도록 연결해야 한다.&lt;br>
&lt;code>projTest&lt;/code> 에 들어가서 &lt;code>dotnet add reference ../projLibrary/projLibrary.csproj&lt;/code> 를 입력한다.&lt;/li>
&lt;/ol>
&lt;p>그러면 아래와 같이 디렉토리와 파일이 구성되어야 한다. (자동으로 생성되는 &lt;code>Class1.cs&lt;/code> 는 제외했다.)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">/testSolution
testSolution.sln
/projLibrary
projLibrary.csproj
/projTest
&lt;span class="c1"># other referenced files (xunit)&lt;/span>
projTest.csproj
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="test-framework-수정">Test Framework 수정&lt;/h2>
&lt;p>&lt;code>projLibrary&lt;/code> 에 있는 &lt;code>projLibrary.csproj&lt;/code>를 열어서 아래를 수정한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;TargetFramework&amp;gt;&lt;/span>net40&lt;span class="nt">&amp;lt;/TargetFramework&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>만들고자 하는 프레임워크 버전을 명시하면 되고, 버전은 [여기][2]를 참고한다. 여러 개의 버전을 명시할 경우에는 세미콜론(;) 으로 구분하면 된다.&lt;/p>
&lt;p>역으로, &lt;code>projTest&lt;/code> 에 있는 &lt;code>projTest.csproj&lt;/code> 는 이렇게 수정해야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;TargetFramework&amp;gt;&lt;/span>net45&lt;span class="nt">&amp;lt;/TargetFramework&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>기본적으로 netcore2.0 으로 설정되어 있을텐데, 이러면 net40 과 호환이 안되어서 참조조차 안되는 불상사가 발생한다. net45 또는 그 이상의 .NET Framework를 지정하되, netcore1.x 에 대응되는 버전으로만 지정하면 될 것으로 보인다.&lt;/p>
&lt;h3 id="테스트-작성">테스트 작성&lt;/h3>
&lt;p>&lt;code>projLibrary&lt;/code>에서 Class1.cs 에 다음을 추가하자.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="k">using&lt;/span> &lt;span class="nn">System&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">namespace&lt;/span> &lt;span class="nn">ProjLibrary&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Class1&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">IsPrime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">candidate&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">NotImplem&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">span&lt;/span> &lt;span class="n">style&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="s">&amp;#34;display: inline-block; width: 0px; overflow: hidden; line-height: 0;&amp;#34;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="n">mce&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="s">&amp;#34;bookmark&amp;#34;&lt;/span> &lt;span class="n">class&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="s">&amp;#34;mce_SELRES_start&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="n">span&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="n">entedException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Please create a test first&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>아직 구현을 안 한 거다. 이제 &lt;code>projTest&lt;/code>에서 Class1.cs에 다음을 추가한다&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="k">using&lt;/span> &lt;span class="nn">Xunit&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">using&lt;/span> &lt;span class="nn">ProjLibrary&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">namespace&lt;/span> &lt;span class="nn">Prime.UnitTests.Services&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">TestClass1&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">Class1&lt;/span> &lt;span class="m">_&lt;/span>&lt;span class="n">service&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="n">Class1_IsPrimeShould&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="m">_&lt;/span>&lt;span class="n">service&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Class1&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="na">
&lt;/span>&lt;span class="na"> [Fact]&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">ReturnFalseGivenValueOf1&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">var&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">_&lt;/span>&lt;span class="n">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">IsPrime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">Assert&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">False&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;1 should not be prime&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="테스트">테스트&lt;/h3>
&lt;p>다 끝났다. 이제 솔루션 디렉토리에서 &lt;code>dotnet test&lt;/code> 를 힘차게 불러보자.&lt;/p>
&lt;p>에러가 날 것이다. 당연히 테스트 코드에서 result 값이 FALSE가 나오기를 기대하는데, 지금은 그냥 Exception 으로 떨어지기 때문이다.&lt;/p>
&lt;p>&lt;code>projLibrary&lt;/code>에서 &lt;code>IsPrime()&lt;/code> 함수의 리턴을 FALSE로 바꿔주면 테스트가 성공하는 것을 확인할 수 있다.&lt;/p>
&lt;p>[1]:
[2]: &lt;a class="link" href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard" target="_blank" rel="noopener"
>https://docs.microsoft.com/en-us/dotnet/standard/net-standard&lt;/a>&lt;/p></description></item><item><title>Gitlab 10.x 삽질기</title><link>https://1nterp.github.io/gitlab-%EC%82%BD%EC%A7%88%EA%B8%B0/</link><pubDate>Wed, 15 Nov 2017 09:17:58 +0000</pubDate><guid>https://1nterp.github.io/gitlab-%EC%82%BD%EC%A7%88%EA%B8%B0/</guid><description>&lt;h2 id="upgrade">Upgrade&lt;/h2>
&lt;p>8.x 로 쓰다가 10.x 로 업그레이드를 진행했다. 아니.. 그런데 Postgresql Database 버전이 다르다고? 알고보니 이렇게 대격변을 일으키면 안 되던 거였다. 그래서 겸사겸사 9.5.10 으로 다시 설치하니까 된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>gitlab-ctl reconfigure&lt;/code> 를 설치 직후에 반드시 해 줘야 한다.&lt;/li>
&lt;li>가끔 &lt;code>gitlab-ctl pg-upgrade&lt;/code> 를 꼭 하라는 말이 있던데, 내가 해보니까 &lt;code>gitlab-ctl reconfigure&lt;/code> 할 때 알아서 한다 (…) 했던 거 또 하는 느낌.&lt;/li>
&lt;li>&lt;code>gitlab-ctl restart&lt;/code> 를 할 때 postgresql 이나 다른 곳에서 &amp;lsquo;down, up, want up&amp;rsquo; 이런 게 뜨면 서비스가 온전히 수행될 수 없는 상황이다. &lt;code>gitlab-ctl tail&lt;/code> 을 실행시켜 로그를 뒤져봐야 한다. 에러가 났거나, 무한히 반복되는 메시지가 없는지 확인하자.&lt;/li>
&lt;/ul>
&lt;h2 id="runner">Runner&lt;/h2>
&lt;p>우리 회사 Gitlab 구조는 웹 서비스 주소와 내부 공유 주소가 다르다. (도메인을 거의 리다이렉트 비슷하게 해놨기 때문이기도 하지만) 비공개 저장소다 보니, 웹 접속은 외부에서 되었면서 Clone 은 똑같은 주소로 절대 받을 수 없게 해 놨다. 이게 Gitlab Runner 를 바보로 만들었다 (…)&lt;/p>
&lt;p>Gitlab Runner는 &lt;code>.gitlab-ci.yml&lt;/code> 의 구성에 상관없이, 선작업으로 해당 저장소를 Cloning 하거나 Fetching 하게 된다. (양자택일은 웹 페이지의 Runner 관리 페이지에서 설정이 가능하다.) 이건 Runner의 Executer를 Docker를 하던 Shell 을 하던 똑같다. 문제는 내가 언급했던 대로, 이 저장소 주소를 웹 주소에 기반해서 가져가기 때문에, 항상 실패했다는 것이다.&lt;/p>
&lt;p>짜증이 치밀 즈음, 아예 이 작업을 끌 수는 없을까 하고 봤더니… 역시나 답은 있었다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">variables:
GIT_STRATEGY: none
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이렇게 두면, Runner의 옵션을 Cloning 으로 줬건 Fetching 으로 줬건 간에 &lt;strong>하지 않는다&lt;/strong>.&lt;/p>
&lt;p>즉, 모든 작업을 온전히 CI 명령에 맡기는 것이다. 위험하기도 하고, 캐싱도 안 되고 약점이 많지만, 나는 상관이 없었다. 직접 내부 주소의 저장소로 접근해서 받아오면 그만!&lt;/p>
&lt;h3 id="repository-에-ssh-key-등록">Repository 에 SSH Key 등록&lt;/h3>
&lt;p>그런데, 문제가 생겼다. 아래와 같이 &amp;lsquo;gitlab-runner&amp;rsquo; 사용자로 Runner Service를 등록하고, 실행시켰다고 가정하자.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">gitlab-runner install --user gitlab-runner
gitlab-runner start
ps aux &lt;span class="p">|&lt;/span> grep gitlab-runner &lt;span class="c1"># gitlab-runner run 이 잘 되고 있어야 한다.&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>나는 Executer를 Shell 로 쓰고 있는데, 이 친구가 내부 저장소로 (그것도 SSH 주소로) 접근하려면… SSH Public Key를 넣어줘야 된다. 넣지 않으면 인증에서 실패한다. 그런데 Gitlab Runner 의 Shell 사용자는 위에서 보이는 것 처럼 &amp;lsquo;gitlab-runner&amp;rsquo; 인데.. 얘는 Gitlab 계정도 없는 가상 사용자다. 어떻게 Public Key를 등록할까?&lt;/p>
&lt;p>Gitlab은, 각 사용자 계정의 SSH Public Key를 관리해 주기도 하지만 Project 별로 SSH Key를 등록할 수도 있다. &lt;em>Project 페이지의 Settings &amp;gt; Repository&lt;/em> 에서 Deploy Keys 부분을 펼쳐보자. 그러면 익숙한 SSH Key 등록 폼이 나온다. 여기에, 아까 언급한 &amp;lsquo;gitlab-runner&amp;rsquo; 의 SSH Key를 등록하면 된다. (당연히 gitlab-runner 계정에서 SSH Key 생성을 해야한다.)&lt;/p>
&lt;p>그러면&lt;code>.gitlab-ci.yml&lt;/code> 에 마구잡이로 &lt;code>'git clone git@~~~~:&amp;lt;user or group&amp;gt;/&amp;lt;project&amp;gt;.git'&lt;/code> 이런 식으로 스크립트를 적어도 아주 잘 clone 되는 걸 확인할 수 있다!&lt;/p>
&lt;h2 id="create-new-branch-의-기본-branch-바꾸기">&lt;em>Create New Branch&lt;/em> 의 기본 Branch 바꾸기&lt;/h2>
&lt;p>Issue 페이지에서 Create New Branch (9.x 에서는 New Branch) 를 하면, Branch의 이름이 &amp;lsquo;421 – invalid table error&amp;rsquo; 이런 식으로 뜬다. 이슈 번호와 이슈 제목.&lt;/p>
&lt;p>그런데 내부적으로는 이슈 제목에 한글을 많이 써서 Branch 이름을 출력하고 싶지 않았다. 그리고 규격화된 이름 (ISSUE#XXXX) 으로 Branch를 생성하고픈 욕구가 치밀었다. (참고로 Push Rule 에서 Branch Naming Rule에 저렇게 규칙을 쓰고, Create New Branch 를 누르면 절대로 Branch가 생기지 않는다.)&lt;/p>
&lt;p>Gitlab에 이미 &lt;a class="link" href="https://gitlab.com/gitlab-org/gitlab-ce/issues/21143" target="_blank" rel="noopener"
>#21143&lt;/a> 으로 이슈가 등록되었고, 10.3 에서 업데이트가 된다지만… 이렇게 되면 사용자가 매번 Push Rule을 피하려고 Branch 이름을 일일이 쳐넣는 어처구니없는 상황이 계속된다. 그래서 코드를 찾아내서 고치는 편이 낫다고 생각했다.&lt;/p>
&lt;p>Ruby는 쥐뿔도 모르지만 코드는 코드일 뿐.&lt;/p>
&lt;p>이슈에 대한 브랜치를 생성하는 작업은 &lt;a class="link" href="https://gitlab.com/gitlab-org/gitlab-ce/merge_requests/2808/diffs" target="_blank" rel="noopener"
>이 Merge Request&lt;/a> 에서 반영된 것이다. 여기 Diff를 쭉 봤더니 &lt;code>to_branch_name&lt;/code> 이 눈에 띈다. 오호라. 하지만 어디서 수정해야 할까?&lt;/p>
&lt;p>Gitlab을 Omnibus 로 정직하게 설치했다면 소스코드 경로는 &lt;code>/opt/gitlab/embedded/service/gitlab-rails/&lt;/code> 에 있다. 여기서 grep으로 &lt;code>to_branch_name&lt;/code> 을 검색해 보면?&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">cd&lt;/span> /opt/gitlab/embedded/service/gitlab-rails/
grep to_branch_name . -rn
&lt;span class="c1"># ./embedded/service/gitlab-rails/app/models/issue.rb:XXX def to_branch_name&lt;/span>
&lt;span class="c1"># 이하 생략&lt;/span>
vi app/models/issue.rb
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>여기서 &lt;code>&amp;quot;#{iid}-#{title.parameterize}&amp;quot;&lt;/code> 라고 정의된 부분을 적절히 바꿔주자. 나는 &lt;code>&amp;quot;ISSUE##{iid}&amp;quot;&lt;/code> 로 심플하게 바꿨다.&lt;/p>
&lt;p>이것만 바꾸면 &amp;lsquo;Create New Branch&amp;rsquo; 를 누를 때 잘 될 것 같다. 하지만 Issue 페이지에서 &amp;lsquo;연관된 Issue Branch&amp;rsquo; 목록에 연결되지 않는다. 수정한 파일 &lt;code>/opt/gitlab/embedded/service/gitlab-rails/app/models/issue.rb&lt;/code> 에서, 더 수정할 것이 남아있다. 다음 함수를 수정해야 한다.&lt;/p>
&lt;ul>
&lt;li>has_related_branch&lt;/li>
&lt;li>related_branches&lt;/li>
&lt;/ul>
&lt;p>수정 방법은 간단한데, Branch와 비교하는 Regular Expression 의 문법을 찾아보자. &lt;code>/\A${iid}-(?!\d+-stable)/i&lt;/code> 라고 되어 있을 것이다. 이걸 실제로 &lt;code>irb&lt;/code> 에서 테스트해 보면, &lt;code>420-title&lt;/code> 같은 건 되는데 &lt;code>420-0-stable&lt;/code> 은 인식이 안 되는 것을 알 수 있다. (뭔가.. 이상하다) 아무튼 이걸 적절한 Regular Expression 으로 바꿔 주도록 하자. Ruby의 Regexp 에 익숙치 않다면 &lt;a class="link" href="http://rubular.com/" target="_blank" rel="noopener"
>Rubular 사이트&lt;/a>의 도움을 받아보도록 하자. (내 경우는 간단하게 &lt;code>/\AISSUE#{iid}/i&lt;/code> 라고 했다.)&lt;/p>
&lt;p>수정을 했다. 하지만 끝이 아니다. 마무리를 해 줘야 한다. 실제 Gitlab이 서비스되고 있는 경로는 &lt;code>/var/opt/gitlab&lt;/code> 이므로, 해당 경로로 적용을 시켜줘야 한다. 어떻게?&lt;/p>
&lt;p>간단하다. &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 를 입력하자.&lt;/p></description></item><item><title>Linux 에서 CPU/Memory/Disk 확인</title><link>https://1nterp.github.io/linux-%EC%97%90%EC%84%9C-cpumemorydisk-%ED%99%95%EC%9D%B8/</link><pubDate>Mon, 30 Oct 2017 08:31:03 +0000</pubDate><guid>https://1nterp.github.io/linux-%EC%97%90%EC%84%9C-cpumemorydisk-%ED%99%95%EC%9D%B8/</guid><description>&lt;p>자주 쓰긴 하지만, 곧바로 생각나지 않을 것을 대비해서&amp;hellip; 서버실 서버 사양을 전부 체크하려다 보니 어쩔 수 없이 정리했다.&lt;/p>
&lt;h2 id="cpu--memory-확인">CPU / Memory 확인&lt;/h2>
&lt;p>CPU / Memory 는 사실 쉽다. &lt;code>/proc/cpuinfo&lt;/code> 와 &lt;code>/proc/meminfo&lt;/code> 안에 들어있기 때문이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat /proc/cpuinfo &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;model name&amp;#34;&lt;/span>  &lt;span class="p">|&lt;/span> sort -u
model name : Intel&lt;span class="o">(&lt;/span>R&lt;span class="o">)&lt;/span> Core&lt;span class="o">(&lt;/span>TM&lt;span class="o">)&lt;/span> i3-4160 CPU @ 3.60GHz
$ cat /proc/meminfo &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;MemTotal&amp;#34;&lt;/span>
MemTotal: &lt;span class="m">8040588&lt;/span> kB
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="disk-확인">Disk 확인&lt;/h2>
&lt;p>&lt;code>df&lt;/code> 는 mount 된 것만 확인이 가능해서 별로고, &lt;code>lsblk&lt;/code> 를 하면 마운트되지 않은 것까지 나온다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda 8:0 &lt;span class="m">0&lt;/span> 477G &lt;span class="m">0&lt;/span> disk
├─sda1 8:1 &lt;span class="m">0&lt;/span> 468.8G &lt;span class="m">0&lt;/span> part /
└─sda2 8:2 &lt;span class="m">0&lt;/span> 8.2G &lt;span class="m">0&lt;/span> part &lt;span class="o">[&lt;/span>SWAP&lt;span class="o">]&lt;/span>
sdb 8:16 &lt;span class="m">0&lt;/span> 2.7T &lt;span class="m">0&lt;/span> disk
&lt;span class="c1">## df 는 sdb가 보이지 않는다.&lt;/span>
$ df -h
Filesystem Size Used Avail Use% Mounted on
/dev/sda1 462G 8.4G 430G 2% /
tmpfs 79G 224K 79G 1% /dev/shm
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>현상을 통찰하는 방법</title><link>https://1nterp.github.io/%ED%98%84%EC%83%81%EC%9D%84-%ED%86%B5%EC%B0%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</link><pubDate>Thu, 12 Oct 2017 01:09:33 +0000</pubDate><guid>https://1nterp.github.io/%ED%98%84%EC%83%81%EC%9D%84-%ED%86%B5%EC%B0%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</guid><description>&lt;p>게임 &amp;lsquo;배틀그라운드&amp;rsquo; 에서, 어떻게 해야 상위 랭크에 도달할 수 있는지를 &lt;a class="link" href="http://blog.naver.com/kyuminsim/221115164331" target="_blank" rel="noopener"
>수학적인 접근으로 잘 풀어낸 네이버 블로그 글&lt;/a>을 봤다. 누군가에겐 그저 즐기는 게임이 될 수 있지만, 누군가에게는 연구대상이 된다. 사물이나 현상을 어떻게 바라보느냐, 얼마나 관심있느냐에 따라서 통찰이 생겨난다. 이것은 모두에게 열려있다. 반대로 생각하면, 논문을 쓰는 사람들은 결단코 고상한 사람들이 아니다.&lt;/p>
&lt;p>&amp;lsquo;수학적인 접근&amp;rsquo;이라는 말 때문에 설득력이 떨어질 수는 있다. 하지만 어느 분야나 자신의 경험을 녹여 전혀 다른 곳에서 적응하는 사람들을 우리는 일상에서 많이 봤다. 그것이 상식이 될 수도 있고, 연륜이 될 수도 있다. (개인적으로는, &amp;lsquo;나이를 먹어감에 따라 현명해지는 것은 잘못된 생각이다&amp;rsquo; 라는 누군가의 말에 동의하지만…)&lt;/p>
&lt;p>그런 사람이 되어야 하지 않을까, 생각한다.&lt;/p></description></item><item><title>mmap : 메모리를 파일처럼</title><link>https://1nterp.github.io/mmap-memory-block-like-file/</link><pubDate>Wed, 20 Sep 2017 13:29:57 +0000</pubDate><guid>https://1nterp.github.io/mmap-memory-block-like-file/</guid><description>&lt;p>&lt;code>mmap&lt;/code> 은 memory map 의 줄임말이다. 메모리의 특정 영역을 파일 디스크립터로 인식하게 만드는 것이다.&lt;/p>
&lt;blockquote>
&lt;p>map or unmap files or devices into memory&lt;br>
(메모리 영역을 파일이나 디바이스로 인식하게 합니다)&lt;/p>
&lt;p>– manpage of mmap&lt;/p>
&lt;/blockquote>
&lt;h2 id="사용">사용&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">mmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">size_t&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">prot&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">off_t&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>여기서 의미가 있는 건 Length, Prot (Protection), Flag 뿐이다.&lt;/p>
&lt;ul>
&lt;li>Start 는, Kernel이 아무 곳이나 지정해도 좋다면 NULL을 입력한다.&lt;/li>
&lt;li>Offset 은, 보통 0으로 둔다. (MAP_ANONYMOUS 또는 MAP_ANON Flag가 있는 경우엔 무시된다)&lt;/li>
&lt;li>Fd 는, 연결할 파일 디스크립터를 지정한다. (MAP_ANONYMOUS 또는 MAP_ANON Flag를 통해서 &amp;lsquo;파일로 사용하지 않는다&amp;rsquo; 라고 한다면 -1을 넣어줘야 한다. (사실 안 넣어주고 무시해도 되지만 몇몇 구현에서는 넣어야 한다 카더라)&lt;/li>
&lt;/ul>
&lt;h2 id="protection">Protection&lt;/h2>
&lt;p>매핑된 메모리 영역의 사용 권한 같은 것을 정하는 것이라고 이해하자. 리눅스 파일 시스템의 권한과 비슷한 분류로 이해하면 더욱 쉽다. (물론 똑같지는 않지만)&lt;/p>
&lt;ul>
&lt;li>PROT_NONE : 메모리 영역은 아무것도 할 수 없다.&lt;/li>
&lt;li>PROT_READ : 메모리 영역을 읽을 수 있다.&lt;/li>
&lt;li>PROT_WRITE : 메모리 영역을 쓸 수 있다.&lt;/li>
&lt;li>PROT_EXEC : 메모리 영역이 실행될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이 때, 연결된 파일 디스크립터의 모드와 절대 충돌해서는 안 된다. 예를 들어 파일 디스크립터를 획득할 때는 &lt;code>w+&lt;/code> 라고 해놓고 여기서 PROT_READ 라고 하면, 예상치 못한 무언가가 일어나지 않을까?&lt;/p>
&lt;p>메모리 영역의 보호에 관련된 자세한 내용은 &lt;a class="link" href="http://man7.org/linux/man-pages/man2/mprotect.2.html" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/p>
&lt;h2 id="flag">Flag&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Flag&lt;/th>
&lt;th>사용 가능 커널&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MAP_SHARED&lt;/td>
&lt;td>–&lt;/td>
&lt;td>이 매핑을 다른 프로세스들이 공유할 수 있다. (실제 파일과 연결되어 반영된다. 하지만 자동으로 반영하지는 않고 &lt;code>msync&lt;/code> 나 &lt;code>munmap&lt;/code> 을 호출해야 반영된다.)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_PRIVATE&lt;/td>
&lt;td>–&lt;/td>
&lt;td>이 매핑을 다른 프로세스들과 공유하지 않는다. 실제 파일과도 연결되지 않으므로, &lt;code>mmap&lt;/code> 이후에 파일에 반영되는 변경 내역이 매핑된 영역에 반영되는지는 확신할 수 없다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_32BIT&lt;/td>
&lt;td>~2.4.20, 2.6&lt;/td>
&lt;td>첫 2GB 안에서 영역을 잡는다. x86-64 프로그램에서만 사용이 가능하다.&lt;br /> (초기 64-bit 프로세서에서는 context-switch 비용 절감을 위해 사용할 수 있는 옵션이겠지만, 지금은 그렇지 않으므로 굳이..)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_ANONYMOUS&lt;br /> MAP_ANON&lt;/td>
&lt;td>–&lt;/td>
&lt;td>파일 디스크립터로 인식하지 않는다. fd와 offset은 무시되지만, 몇몇 구현에서는 fd를 반드시 -1로 입력해야 한다. &lt;br/> ※ SHARED와 같이 사용하려면 Kernel Version 이 2.4 이하여야 한다.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>헉헉.. 아래에 더 있는데 여기까지만 해야겠다. 내가 사용하고자 하는건 사실 ANONYMOUS Flag 만 있으면 되는데 말이지.&lt;/p></description></item><item><title>pthread_yield vs. sleep</title><link>https://1nterp.github.io/pthread_yield-vs-sleep/</link><pubDate>Thu, 24 Aug 2017 05:35:24 +0000</pubDate><guid>https://1nterp.github.io/pthread_yield-vs-sleep/</guid><description>&lt;p>&lt;code>pthread_yield()&lt;/code> 와 &lt;code>sleep()&lt;/code> 의 차이를 묻는 &lt;a class="link" href="https://stackoverflow.com/questions/936993/pthread-what-is-the-difference-between-time-hsleep-and-pthread-hpthread" target="_blank" rel="noopener"
>Stack Overflow 글&lt;/a> 의 답을 발췌한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>pthread_yield()&lt;/code> 는, 호출한 쓰레드가 프로세서 사용을 그만두고, 스케쥴링이 될 때 까지 작업 큐(run queue)에서 기다립니다. 만약 호출되었을 때 작업 큐가 비어 있다면, 즉시 스케쥴링이 되겠죠.&lt;/p>
&lt;p>&lt;code>sleep()&lt;/code> 은 X초만큼 지나거나, 무시할 수 없는 시그널이 도착할 때 까지 (다른 쓰레드를 포함한) 호출 프로세스를 재웁니다.&lt;/p>
&lt;p>현재 쓰레드를 실제로 지연시키고 싶지 않지만 (호출 쓰레드 대신) 다른 쓰레드에게 실행권을 넘겨주고 싶은 경우라면, &lt;code>sleep()&lt;/code> 보단 &lt;code>pthread_yield()&lt;/code> 가 적합할 것 같습니다.&lt;/p>
&lt;/blockquote>
&lt;p>sleep 자체가 프로세스를 아예 멈추게 하니까 pthread_yield 를 통해서 나는 잠시 빠져주는 상태로 만드는 거였다. 코드를 보면서 감으로만 &amp;lsquo;아 저건 sleep() 같진 않지만 뭔가 이럴 때 쓰는거야&amp;rsquo; 라고만 어렴풋이 알고 있었는데, 무엇이든 확실히 알아야 한다.&lt;/p></description></item><item><title>다시, 한 걸음</title><link>https://1nterp.github.io/%EB%8B%A4%EC%8B%9C-%ED%95%9C-%EA%B1%B8%EC%9D%8C/</link><pubDate>Sun, 13 Aug 2017 22:29:22 +0000</pubDate><guid>https://1nterp.github.io/%EB%8B%A4%EC%8B%9C-%ED%95%9C-%EA%B1%B8%EC%9D%8C/</guid><description>&lt;p>위기가 찾아왔을 때는, 위기를 만든 사람들에게 원망하고 싶다. 그렇게 원망 해 봐야 위기가 물러가진 않지만 말이다. 그래서 위기를 어떻게 해결할 것인지를 고민해야 한다**.** 그게 오히려 스트레스를 덜 받는다.&lt;/p>
&lt;p>사람에 대해 스트레스를 계속 받고 심지어는 사람을 잃어버리면서, 나 자신에 대한 원망이 점점 심해지고 있다는 걸 느꼈다. 왜 그때 그랬을까, 그러지 않았다면 좋았을텐데. 그렇게 해 봐야 떠났던 사람을 다시 붙잡을 수는 없지만 말이다. 미련이나 후회가 아닌, 해결해야 할 과제로 여기기로 했다. 그러면서 조금 마음이 편해졌다.&lt;/p>
&lt;p>원망하고 후회하는 것이 오히려 더 쉽다. 해결은 답을 찾고 시도해야 하는 비싸고 귀찮은 작업이라고 생각하기 때문이다. 하지만 멀리 보면, 해결을 하기 위한 노력이 필요하다. 또 원망하고 후회하지 않으려면.&lt;/p>
&lt;p>여전히 화내고 우울해 하며 제자리에 서 있는 나를 방치하지 않으려면 말이다.&lt;/p></description></item><item><title>Search</title><link>https://1nterp.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://1nterp.github.io/search/</guid><description/></item></channel></rss>
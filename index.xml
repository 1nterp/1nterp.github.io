<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>InterP Blog</title><link>https://interp.blog/</link><description>Recent content on InterP Blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Thu, 09 Feb 2023 02:00:00 +0900</lastBuildDate><atom:link href="https://interp.blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker Container 출력이 Disk 를 채운다</title><link>https://interp.blog/docker-container-print-uses-disk/</link><pubDate>Thu, 09 Feb 2023 02:00:00 +0900</pubDate><guid>https://interp.blog/docker-container-print-uses-disk/</guid><description>&lt;img src="https://interp.blog/docker-container-print-uses-disk/feature.png" alt="Featured image of post Docker Container 출력이 Disk 를 채운다" />&lt;p>어느 날, GCP 에서 알람이 날아왔다. 테스트로 docker container를 하나 올려 둔 VM (Compute Engine) 에서 &lt;em>Disk 가 꽉 차서 아무것도 할 수 없다&lt;/em>는 것이었다.&lt;/p>
&lt;p>디스크를 쓴다고? 이 container 는 mount 된 volume 도 없었고, container 가 하는 일은 소스에서 데이터를 받아 계산한 뒤 GCP Cloud Storage 에 저장하는 것 밖에 하지 않는데?&lt;/p>
&lt;h1 id="문제">문제&lt;/h1>
&lt;p>Docker container 만 떠 있고 아무런 작업을 하지 않는 Host 의 &lt;strong>디스크 사용량이 계속해서 줄어든다.&lt;/strong> 결국, 디스크를 100% 가까이 쓰게 되어 시스템을 마비시킨다.&lt;/p>
&lt;h1 id="진단">진단&lt;/h1>
&lt;p>우선 해당 Host (VM 또는 on-premise) 에 접속해서 &lt;code>df -h&lt;/code> 를 실행하자. &lt;code>/&lt;/code> 경로에서 디스크 사용량이 압도적으로 많다면, 해당 문제에 접근한 것이다.&lt;/p>
&lt;p>이제 이 부분을 실행해 보자. (root 가 아니라면, sudoer 권한이 필요하다)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">sudo du -h -d &lt;span class="m">1&lt;/span> /var/lib/docker/containers
&lt;/code>&lt;/pre>&lt;/div>&lt;p>해당 경로에서 특정 container 의 디스크 사용량이 &lt;code>df -h&lt;/code> 를 입력했을 때의 사용량과 비슷하다면, 이 친구가 문제다.&lt;/p>
&lt;h1 id="분석">분석&lt;/h1>
&lt;p>그렇다면 왜 디스크를 쓰는 container 가 아닌데, 이렇게 디스크를 먹었던 것일까?&lt;/p>
&lt;p>&lt;code>docker logs&lt;/code> 를 입력하면 container 의 stdout/stderr 출력 내용을 볼 수 있다. &lt;strong>문제는, Docker daemon 은 별다른 지시가 없다면 container 가 출력하는 내용을 전부 디스크에 쓴다는 것이다.&lt;/strong>&lt;/p>
&lt;p>바로 &lt;code>/var/lib/docker/containers&lt;/code> 경로에 말이다!&lt;/p>
&lt;br/>
&lt;p>&lt;a class="link" href="https://docs.docker.com/config/containers/logging/configure/" target="_blank" rel="noopener"
>Docker docs 페이지&lt;/a>에도 같은 내용을 경고하고 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>By default, no log-rotation is performed.&lt;/strong> As a result, log-files stored by the default json-file logging driver logging driver can cause a significant amount of disk space to be used for containers that generate much output, which can lead to disk space exhaustion.&lt;/p>
&lt;/blockquote>
&lt;h1 id="해결">해결&lt;/h1>
&lt;p>container directory 를 지우는 것은, 문제를 완화하고 서비스를 잠시 정상으로 되돌려 놓을 순 있지만 진짜 해결책은 아니다.&lt;/p>
&lt;p>분석에서 말한 대로, container 가 출력하는 내용을 rotation 으로 기록하도록 만들어야 한다. 즉, &lt;em>최근 출력만 기억하게 하고 오래된 것은 삭제하도록&lt;/em> 말이다.&lt;/p>
&lt;p>먼저, &lt;code>/etc/docker/daemon.json&lt;/code> 에 아래 내용을 넣는다. (없으면 만든다)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;log-driver&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;json-file&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;log-opts&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;max-size&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;10m&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;max-file&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;3&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>container 가 출력하는 최신 내용을 JSON 포맷으로 10MB 씩 3개의 파일로 저장하고, 오래된 내용은 없애도록 하는 것이다. 원하는 값으로 수정하거나, &lt;a class="link" href="https://docs.docker.com/config/containers/logging/configure/" target="_blank" rel="noopener"
>Docker docs 페이지&lt;/a> 를 참고해 다양한 설정으로 바꿔줘도 무방하다.&lt;/p>
&lt;p>설정이 끝났다면, Docker daemon 을 재시작한다. 나의 경우엔 &lt;code>sudo service docker restart&lt;/code> 로 재시작했다.&lt;/p>
&lt;p>이후 container 를 다시 실행시킨 뒤, 출력이 쌓일 때 까지 기다렸다가 &lt;code>/var/lib/docker/containers/&lt;/code> 에서 &lt;code>{container_id}&lt;/code> directory 에 있는 &lt;code>.log&lt;/code> 파일이 3개&lt;strong>만&lt;/strong> 생성되어 있는지 확인하면 된다.&lt;/p></description></item><item><title>Secure Communication 에 대한 모든 것</title><link>https://interp.blog/ssl-tls-pki-x509-certificate/</link><pubDate>Thu, 02 Feb 2023 17:00:00 +0900</pubDate><guid>https://interp.blog/ssl-tls-pki-x509-certificate/</guid><description>&lt;img src="https://interp.blog/ssl-tls-pki-x509-certificate/feature.jpeg" alt="Featured image of post Secure Communication 에 대한 모든 것" />&lt;h1 id="시작하면서">시작하면서&lt;/h1>
&lt;p>SSL/TLS/HTTPS 부터 알아보자.&lt;/p>
&lt;ul>
&lt;li>SSL (Secure Socket Layer): 클라이언트와 서버 간 보안 통신을 위한 프로토콜이다.&lt;/li>
&lt;li>TLS (Transport Layer Security): SSL 에서 발전된 프로토콜. SSL/TLS 로 묶어서 부르고 있음.&lt;/li>
&lt;li>HTTPS (HTTP Secure): SSL/TLS 위에서 통신하는 HTTP&lt;/li>
&lt;/ul>
&lt;p>결국은 셋 모두 &amp;lsquo;클라이언트와 서버가 주고받는 정보가 안전하게 만드는 프로토콜&amp;rsquo; 이라는 것인데, 그럼 TLS 에서는 어떻게 정보를 안전하게 만드는 걸까? 이해한 대로 최대한 쉽게 풀어내 보려고 한다.&lt;/p>
&lt;p>대부분의 내용은 &lt;a class="link" href="https://www.udemy.com/course/certified-kubernetes-administrator-with-practice-tests/" target="_blank" rel="noopener"
>Udemy CKA 강의&lt;/a>를 바탕으로 정리했다.&lt;/p>
&lt;h1 id="시나리오-1-암호화-비대칭-키">시나리오 (1) 암호화, 비대칭 키&lt;/h1>
&lt;p>태초에 (?) 클라이언트와 서버는 다음과 같이 통신을 시작한다.&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>클라이언트가 서버에 접속한다.&lt;/li>
&lt;li>서버는 클라이언트에게 사용자 정보 (ID, Password) 를 요청한다.&lt;/li>
&lt;li>클라이언트는 사용자 정보를 서버에게 보낸다.&lt;/li>
&lt;li>이제 서버는 클라이언트의 사용자를 확인할 수 있다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>이 과정에 아무런 보안이 적용되지 않는다면, &lt;strong>해커가 패킷을 수집해서 ID 와 패스워드를 들여다 볼 수 있다.&lt;/strong> 평문 (plain text) 으로 전달되기 때문이다. 그렇다면 이 평문을 알아볼 수 없게 해야 한다. 암호화/복호화 (encryption/decryption) 를 해야 한다.&lt;/p>
&lt;p>서버는 암호화와 복호화가 가능한 키 (key) 를 만들어 뒀다고 가정하자.&lt;/p>
&lt;blockquote>
&lt;ol start="2">
&lt;li>서버는 클라이언트에게 &lt;strong>키&lt;/strong>를 준다. &amp;lsquo;이걸로 암호화해서 줘&amp;rsquo;&lt;/li>
&lt;li>클라이언트는 &lt;strong>서버가 준 키를 가지고 사용자 정보를 암호화&lt;/strong>해서 보낸다.&lt;/li>
&lt;li>서버는 암호화한 정보를 &lt;strong>복호화&lt;/strong>해서 안전하게 (?) 사용자를 확인한다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>이 시나리오의 문제는? (2) 에서 &lt;strong>키를 보내는 패킷은 암호화되지 않는다는 점&lt;/strong>이다. 이 키를 읽게 되면, (3) 에서 보낸 정보를 해커 역시 복호화 할 수 있게 된다. 그래서 나온 것이 비대칭 키 (asymmetric key) 이다. 오래전부터 사용된 &lt;a class="link" href="https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29" target="_blank" rel="noopener"
>RSA&lt;/a> 같은 것들 말이다.&lt;/p>
&lt;p>이번엔 서버가 공개 키와 비공개 키를 한 쌍 (public/private key pair) 만들어 뒀다고 가정하자.&lt;/p>
&lt;blockquote>
&lt;ol start="2">
&lt;li>서버는 클라이언트에게 &lt;strong>공개 키&lt;/strong>를 준다. &amp;lsquo;이걸로 암호화해서 줘&amp;rsquo;&lt;/li>
&lt;li>클라이언트는 서버가 준 &lt;strong>공개 키&lt;/strong>를 가지고 사용자 정보를 암호화해서 보낸다.&lt;/li>
&lt;li>서버는 암호화한 정보를 &lt;strong>비공개 키로&lt;/strong> 복호화해서 안전하게 (?) 사용자를 확인한다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>여기서 주목할 점은, &lt;strong>공개 키는 &lt;u>암호화&lt;/u>할 때 쓰고 비공개 키는 &lt;u>복호화&lt;/u> 할 때만 쓴다는 점&lt;/strong>이다. 그러면 복호화에 필요한 비공개 키는 해커가 알 수 없으니 안전해 보인다.&lt;/p>
&lt;h1 id="시나리오-2-피싱-그리고-인증서">시나리오 (2) 피싱, 그리고 인증서&lt;/h1>
&lt;p>이번엔 해커가 패킷을 수집하는 것을 포기하고, &lt;strong>클라이언트나 사용자를 속여서 피싱을 했다&lt;/strong>고 가정하자.&lt;/p>
&lt;p>피싱 방법은 여러 가지인데, 사회공학적 기법으로 구별하기 어려운 URL 을 사용자에게 제공하거나, 클라이언트나 DNS를 해킹하는 방법이 필요하겠다. 아무튼 해커가 준비한 가짜 사이트로 들어가게 되면, 해커가 마련한 비대칭 키를 가지고 사용자 정보가 고스란히 넘어가게 된다.&lt;/p>
&lt;p>이런 시나리오를 방지하기 위해서, 서버가 보내는 공개 키를 누군가가 보증해야 하며, &amp;lsquo;이 공개 키는 안전합니다! &lt;del>안심하고 정보를 넘겨 주십시오&lt;/del>&amp;rsquo; 라는 뜻의 &lt;strong>인증서&lt;/strong>가 필요하다.&lt;/p>
&lt;blockquote>
&lt;ol start="2">
&lt;li>서버는 클라이언트에게 &lt;strong>공개 키가 담긴 인증서&lt;/strong>를 준다. &lt;br/>&amp;lsquo;이거 &lt;u>인증 받은&lt;/u> 공개키야, 이걸로 암호화해서 줘&amp;rsquo;&lt;/li>
&lt;li>클라이언트는 서버가 준 인증서가 진짜인지 확인한다. (사인해 준 곳에 가서 물어보거나..)&lt;/li>
&lt;li>클라이언트는 서버가 준 공개 키를 가지고 사용자 정보를 암호화해서 보낸다.&lt;/li>
&lt;li>서버는 암호화한 정보를 비공개 키로 복호화해서 안전하게 (?) 사용자를 확인한다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>이렇게 공개 키를 인증받고 교환하는 모든 과정을 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C_%ED%82%A4_%EA%B8%B0%EB%B0%98_%EA%B5%AC%EC%A1%B0" target="_blank" rel="noopener"
>공개 키 기반 구조 (Public Key Infrastructure, PKI)&lt;/a> 이라고 부른다. 그리고 PKI 의 ITU 표준이 &lt;a class="link" href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener"
>X.509&lt;/a> 인 것이다.&lt;/p>
&lt;p>간략히 말하자면, 이 인증서에는 (1) 공개 키 (2) 서버의 신원 (호스트네임, 기관이나 개인 이름 등) (3) 인증서에 사인을 해 준 기관 (Certificate Authority, &lt;em>CA&lt;/em>) 이 포함되어 있다. (CA 로부터 사인받지 않았다면 self-signed 로 표시된다)&lt;/p>
&lt;div style="background-color: var(--body-background); width: 98%; margin:1px; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
💡
&lt;/div>
&lt;div>
&amp;lsquo;CA 의 비대칭 키 한 쌍&amp;rsquo; 은 &lt;strong>Root/Intermediate Certificate&lt;/strong> 라고 한다. &lt;br/>&lt;br/>
Root 와 Intermediate 의 차이는 CA 의 공개 키를 어디서 인증 받았는지 여부에 달렸다. Root Certificate 의 공개 키는 Self-signed 이고, &lt;strong>Intermediate Certificate 의 공개 키는 는 다른 CA 가 사인해 준 것&lt;/strong>이다. CA 에서 발급받은 일반 인증서는 Leaf Certificate 라고 부른다. (&lt;a href="https://cert-manager.io/docs/reference/tls-terminology/#whats-the-difference-between-root-intermediate-and-leaf-certificates">링크&lt;/a>) &lt;br/>&lt;br/>
일반적인 인터넷 환경이라면 이 차이를 굳이 알 필요가 없지만, Kubernetes Cluster 를 구축하거나 운영할 때는 master node 에 위치한 Root Certificate 부터 다룰 수 있어야 한다. (K8s Cluster 의 다른 서비스와 보안 통신을 하기 위해서!)
&lt;/div>
&lt;/div>
&lt;p>자, 이제 여기서 해커가 생각할 수 있는 건 무엇일까?&lt;/p>
&lt;h2 id="self-signed-인증서를-보낸다면">Self-signed 인증서를 보낸다면?&lt;/h2>
&lt;p>위의 피싱 시나리오에서, 해커가 혼자 사인한 (self-signed) 인증서로 감싸서 던지면 되지 않을까?&lt;/p>
&lt;p>&lt;strong>이제부터는 클라이언트 (좀 더 친숙한 표현으론, 웹 브라우저) 에서 경고를 뿜는다.&lt;/strong> &amp;ldquo;이 인증서를 받았는데, 발급 기관이 없는데요? (아니면 이상한데요?)&amp;rdquo; 라고 말이다. 쉽게 말하면, 주소창에 &lt;code>https://&lt;/code> 로 시작하는 주소를 입력했는데, 자물쇠 모양이 &lt;span style="color:red">빨갛게&lt;/span> 보이는 경우다.&lt;/p>
&lt;h2 id="해커가-ca-를-만들어-사인을-받는다면">해커가 CA 를 만들어 사인을 받는다면?&lt;/h2>
&lt;p>아예 악의적인 CA 를 만들어서, 거기서 인증서를 사인해 주면 어떨까?&lt;/p>
&lt;p>대부분의 웹 브라우저는 공인된 CA 의 공개 키를 이미 내장하고 있다. 이외의 CA 와 통신하고자 한다면 브라우저가 경고를 보낸다. &amp;ldquo;이 인증서가 진짜인지 확인하기 위해, 인증서가 가리키는 CA 와 통신하려고 하는데요.. 제가 모르는 곳인데 괜찮나요?&amp;rdquo; 라고 말이다.&lt;/p>
&lt;h1 id="정리-결국-암호화">정리: 결국 암호화&lt;/h1>
&lt;p>정리를 해 보니 결국 통신 암호화를 확실히 하기 위한 일련의 역사를 되짚은 느낌이다. 용어에 통일성이 없으니 들을 때마다 어색해지기 마련이었는데, 이렇게나마 나열해 보니 두려움이 조금 사라지긴 했다.&lt;/p>
&lt;p>CKA 시험에는 CSR (Certificate Signing Request) 보내는 방법까지 배우긴 하는데 거기까진 여기서 다루지 않아도 될 듯하다.&lt;/p></description></item><item><title>키보드 키가 자꾸 빠질 때</title><link>https://interp.blog/keyboard-key-pop-up-problem/</link><pubDate>Thu, 19 Jan 2023 17:00:00 +0900</pubDate><guid>https://interp.blog/keyboard-key-pop-up-problem/</guid><description>&lt;img src="https://interp.blog/keyboard-key-pop-up-problem/IMG_4745.JPG" alt="Featured image of post 키보드 키가 자꾸 빠질 때" />&lt;p>오랫동안 사무용/게이밍용으로 사용중인 기계식 키보드 레오폴드 FC750RT.&lt;/p>
&lt;p>그런데 자주 써서 그런건지, 치다 보면 몇몇 키들이 마치 팝콘 튀긴 것 처럼 &amp;lsquo;퐁&amp;rsquo; 하고 튀어나왔다. 보통 반복적으로 튕기듯 누르는 키들이 잘 튀어나왔었는데, 내구성 테스트 겸 용의선상에 있는 친구들 중 하나인 &amp;lsquo;오른쪽 방향키&amp;rsquo; 를 계속 팅팅 눌러봤다.&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="IMG_4748.JPG#center" width="70%"/>
&lt;/figure>
&lt;p>아아&amp;hellip; 갈축 스위치가 적나라하게 드러났다. 십(十)자 모양 스위치와 키 뒤쪽에 있는 십자 홈이 정확히 끼어있지 않은 것일 테다. 이리저리 검색을 해 봤는데, 홈을 조금 더 좁게 메꿀 수 있는 일종의 민간요법 (?) 을 찾았다. 바로 &lt;strong>마스킹 테이프&lt;/strong>로 메꾸기!&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="IMG_4749.JPG#center" width="70%"/>
&lt;/figure>
&lt;h1 id="준비물">준비물&lt;/h1>
&lt;ul>
&lt;li>(빠진) 키보드&lt;/li>
&lt;li>(빠진) 키보드 키&lt;/li>
&lt;li>마스킹 테이프&lt;/li>
&lt;/ul>
&lt;p>방법은 간단하다. 마스킹 테이프를 키 뒤쪽 십자 홈 크기로 작게 잘라낸 뒤, 아래와 같이 살짝 붙여둔다. &lt;strong>접착면이 키 안쪽으로, 보이는 면이 키 바깥 (밑면)이 되도록&lt;/strong> 한다.&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="IMG_4750.JPG#center" width="70%"/>
&lt;/figure>
&lt;p>그 다음, 그 상태 그대로 스위치에 맞추고 &lt;strong>지그시&lt;/strong> 눌러준다. 잘 안들어갈 것 같지만, 생각보다 쏙 들어간다. 마스킹 테이프가 말려들어가면서, 키의 십자 홈을 더욱 메꿔주는 효과를 보여주는 것이다.&lt;/p>
&lt;p>마스킹 테이프가 가장 좋아보이지만, 굳이 없다면 비슷한 재료로 비슷하게 해도 좋을 것 같다.&lt;/p>
&lt;ul>
&lt;li>얇은 종이도 가능할 것 같지만, A4 두께는 생각보다 두껍다. 차라리 휴지로 하는게 낫지 않을까?&lt;/li>
&lt;li>일반 테이프는 바깥면이 미끄러워서, 홈을 메꿔주더라도 계속 빠질 것 같은 느낌이 든다.&lt;/li>
&lt;li>&lt;strong>절대로 접착제를 안에 넣지 말자.&lt;/strong> 나중에 스위치 문제가 생기거나, 청소를 해야 할 때 애로사항이 생긴다.&lt;/li>
&lt;/ul></description></item><item><title>명상으로의 입문</title><link>https://interp.blog/entering-meditation/</link><pubDate>Sat, 24 Dec 2022 09:00:01 +0900</pubDate><guid>https://interp.blog/entering-meditation/</guid><description>&lt;img src="https://interp.blog/entering-meditation/pexels-thirdman-6956573.jpg" alt="Featured image of post 명상으로의 입문" />&lt;p>회사 직원들을 위해 &lt;a class="link" href="https://insighttimer.com/" target="_blank" rel="noopener"
>Insight Timer&lt;/a> 라는 앱을 무료로 사용할 수 있다는 공지를 최근에 받았다. 설치해 보니 명상 앱이라고 한다. 반신반의하며 첫 날 15분 정도의 인트로 코스를 시작했는데, 기본적인 자세와 호흡법을 알려주고 마음가짐에 대해 조곤조곤 이야기해 줬다.&lt;/p>
&lt;h1 id="불안한-마음에-도움이-되는-듯">불안한 마음에 도움이 되는 듯?&lt;/h1>
&lt;p>해 본지 얼마 되지 않았지만 지금까지 내가 느낀 건, &lt;strong>번잡한 마음이 어느정도 정리된다는 것&lt;/strong>이었다.&lt;/p>
&lt;p>요즘 들어 업무나 일상에서 눈에 띄게 의욕이 줄어들었는데 &lt;em>&amp;lsquo;이런 걸 해서 무엇하나&amp;rsquo;&lt;/em> 같은 마음이 계속 자리잡고 있었기 때문이다. 확실한 방향으로 갈피를 잡지 못한 것이 클 것이다. 하지만 명상을 통해 마음이 떠올린 소리를 같이 경청하면, 내가 가졌던 불안이나 불확실한 마음이 잠시 뒤로 물러나는 신기한 경험을 했다.&lt;/p>
&lt;p>딱 집어서 마음이 치유되었다거나 다음 할 일과 마음가짐이 생겨났다고 말하긴 힘들지만, 적어도 불안한 마음을 달래줄 수는 있었다.&lt;/p>
&lt;h1 id="가라앉히려면-가만히-있어야-한다">가라앉히려면 가만히 있어야 한다&lt;/h1>
&lt;p>명상은 마치 &lt;strong>내 몸 속을 하수처리장에 맡기는 느낌&lt;/strong>이다. 걱정이나 불안이 뒤섞인 마음에 이리저리 움직여보거나 바람을 불어봐야, 그것은 더욱 탁해지고 말 것이다. 명상은 이것들을 멈추고 고요한 상태에서 나쁜 생각을 침전시키는 작업일 것이다.&lt;/p>
&lt;p>나의 불안은 무엇이었고, 그 속에서 걸러진 깨끗한 나의 성취는 또 무엇이었는지, 굳이 내가 구분짓지 않아도 내 마음이 구별해 낼 수 있는 상태를 만드는 것이다. 당장 이 마음을 내버리지 못 하더라도, &lt;strong>어떤 마음이 있었는지 아는 것만으로도 큰 위안이 될 수 있다.&lt;/strong> 아니면, 그 속에서 걸러진 나의 플러스, 나의 성취에 주목할 수도 있다.&lt;/p>
&lt;h1 id="시간-아깝다고-불안한-채로-살-것인가">시간 아깝다고 불안한 채로 살 것인가&lt;/h1>
&lt;p>명상은 마치 어질러진 거실을 치우는 것과도 같다.&lt;/p>
&lt;p>사실 거실이 정돈되었건 어질러졌건 간에, 나라는 존재와는 무관한 상태이긴 하다. 하지만 우리는 (적어도 나는) 깨끗한 거실을 볼 때 더욱 안정되며, 발을 옮기는데 고민을 해야 할 정도로 물건들이 널부러져 있다면 계속 마음이 심란할 것이다. 시간을 들여서 제자리에 가져다 두고 나면, 치우는 수고가 아깝다는 생각이 사라질 것이다. 그대로 뒀다면, 나머지 시간동안 안 좋은 기분으로 생활해야 하니까.&lt;/p>
&lt;p>이렇듯 명상을 하기 전에는 시간을 버리는 일이 아닐까 주저하게 되지만, &lt;strong>불안한 마음을 걸러주지 않는다면 계속 불안한 채로 하루를 보내야 하지 않을까?&lt;/strong>&lt;/p>
&lt;hr>
&lt;p>&lt;a class="link" href="https://insighttimer.com/" target="_blank" rel="noopener"
>사용하고 있는 앱&lt;/a>을 구글링 해 보니, 무료 명상 앱에서는 남바완 (&amp;hellip;) 이라고 홍보는 하더라. 프리미엄 구독으로 들을 수 있는 강사의 &lt;del>영어&lt;/del> 코칭 세션을 하지 않더라도, 백그라운드 음악과 세션을 입맛에 맞춰 만들어 두면 아무런 제약없이 재생 할 수 있기 때문에 무료 앱은 맞는 것 같다.&lt;/p>
&lt;p>그 외에도 인터넷에 명상법은 엄청나게 많고, 지금까지 내가 느끼기론 단순히 &lt;em>&amp;lsquo;편안한 자세로 호흡 잘 하고 마음 속 떠오르는 걸 잡아보는 것&amp;rsquo;&lt;/em> 에서 출발해도 좋을 것 같다.&lt;/p>
&lt;p>아! 넷플릭스에서 하던 &lt;strong>&lt;a class="link" href="https://www.netflix.com/title/81280926" target="_blank" rel="noopener"
>명상 시리즈&lt;/a>&lt;/strong> 도 많은 도움이 되었다.&lt;/p></description></item><item><title>SSH 비대칭 키로 접속할 때 문제 해결</title><link>https://interp.blog/ssh-authorized-keys-problem/</link><pubDate>Fri, 23 Dec 2022 13:57:59 +0900</pubDate><guid>https://interp.blog/ssh-authorized-keys-problem/</guid><description>&lt;img src="https://interp.blog/ssh-authorized-keys-problem/feature.jpg" alt="Featured image of post SSH 비대칭 키로 접속할 때 문제 해결" />&lt;p>클라이언트에서 서버로 SSH 접속을 패스워드 없이 하기 위해&lt;/p>
&lt;ul>
&lt;li>클라이언트 컴퓨터에서, RSA 알고리즘으로 비대칭 키를 생성했다.&lt;/li>
&lt;li>비대칭 키의 Public Key 를 서버의 &lt;code>~/.ssh/authorized_keys&lt;/code> 파일에 붙여넣었다.&lt;/li>
&lt;/ul>
&lt;p>그런데도 아직 패스워드를 입력하라고 하면?? 혹시나 해서 &lt;code>ssh -vvv ..&lt;/code> 로 디버그 메시지를 출력해 보니&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">debug1: Offering public key: debug3: send packet: type 50
debug2: we sent a publickey packet, wait for reply
debug3: receive packet: type 51
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이런 메시지를 혹시 만났다면, 다음을 체크해 보자.&lt;/p>
&lt;h1 id="ssh-의-소유자권한-점검">&lt;code>.ssh/&lt;/code> 의 소유자/권한 점검&lt;/h1>
&lt;p>아래 사항이 모두 맞는지 점검한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>~/.ssh&lt;/code> 권한이 700 이어야 한다.
&lt;ul>
&lt;li>&lt;code>ls -al ~ | grep .ssh&lt;/code> 결과가 &lt;code>d r w x - - - - - -&lt;/code> 로 시작되어야 한다.&lt;/li>
&lt;li>수정하는 방법은 &lt;code>chmod 700 ~/.ssh&lt;/code> 이다. (&lt;code>-R&lt;/code> 옵션을 붙이지 말자!)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>~/.ssh&lt;/code> 소유자가 달라서는 안 된다.&lt;/li>
&lt;li>&lt;code>~/.ssh/authorized_keys&lt;/code> 권한이 600 이어야 한다.
&lt;ul>
&lt;li>&lt;code>ls -al ~/.ssh/authorized_keys&lt;/code> 결과가 &lt;code>- r w - - - - - - -&lt;/code> 로 시작되어야 한다.&lt;/li>
&lt;li>수정하는 방법은 &lt;code>chmod 600 ~/.ssh/authorized_keys&lt;/code> 이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>~/.ssh/authorized_keys&lt;/code> 소유자가 달라서는 안 된다.&lt;/li>
&lt;/ul>
&lt;p>한 가지 더 중요한 것은, &lt;strong>만약 &lt;code>$HOME&lt;/code> 경로가 &amp;lsquo;심볼릭 링크&amp;rsquo; 를 포함하는 경우&lt;/strong>라면, 반드시 실제 경로에서 적용해야 한다는 점이다.&lt;/p>
&lt;h1 id="rsa-는-이제-그만">RSA 는 이제 그만..&lt;/h1>
&lt;p>서버가 OpenSSH 를 쓰는 경우라면, RSA 를 곧 지원하지 않는다는 release note 가 있다. 따라서 RSA 대신 다른 알고리즘으로 된 비대칭 키를 생성해서 쓰는 것도 방법이 될 수 있다. 나는 &lt;strong>ECDSA&lt;/strong> 를 사용해 봤다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">ssh-keygen -t ECDSA
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="참고자료">참고자료&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="https://chemicloud.com/kb/article/ssh-authentication-refused-bad-ownership-or-modes-for-directory/" target="_blank" rel="noopener"
>https://chemicloud.com/kb/article/ssh-authentication-refused-bad-ownership-or-modes-for-directory/&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-authentication-issues/" target="_blank" rel="noopener"
>https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-authentication-issues/&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.openssh.com/txt/release-8.7" target="_blank" rel="noopener"
>https://www.openssh.com/txt/release-8.7&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>K8s Headless Service, 왜 필요한가</title><link>https://interp.blog/k8s-headless-service-why/</link><pubDate>Thu, 22 Dec 2022 11:13:12 +0900</pubDate><guid>https://interp.blog/k8s-headless-service-why/</guid><description>&lt;p>K8s Resource 를 보거나 Helm Chart 를 보거나 헷갈리는 개념 중 하나가 바로 &lt;strong>&amp;lsquo;Headless Service&amp;rsquo;&lt;/strong> 이다.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="20221220_63a1afceb4826.jpg"
alt="흐라챠!" width="40%"/> &lt;figcaption>
&lt;p>흐라챠!&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>머리가 없는 서비스를 &lt;del>위 짤방처럼&lt;/del> 왜 만드는 건지부터 이해하려면, 먼저 서비스가 왜 필요한지 알아야 한다.&lt;/p>
&lt;h1 id="설명-먼저">설명 먼저&lt;/h1>
&lt;p>공식 문서 설명을 먼저 보자. &lt;a class="link" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="noopener"
>영어 원문&lt;/a>과 &lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4" target="_blank" rel="noopener"
>한국어 번역본&lt;/a>을 적절히 믹스했다.&lt;/p>
&lt;blockquote>
&lt;p>로드 밸런싱 (Load-balancing) 이나 단일 서비스 IP 가 필요하지 않은 경우엔, &amp;lsquo;헤드리스&amp;rsquo; 서비스라는 것을 만들 수 있다. &lt;code>.spec.clusterIP: None&lt;/code> 을 명시적으로 지정하면 된다.&lt;/p>
&lt;p>이 헤드리스 서비스를 통해, 쿠버네티스의 구현에 의존하지 않고도 다른 서비스 디스커버리 메커니즘과 인터페이스할 수 있다.&lt;/p>
&lt;p>헤드리스 서비스의 경우, 클러스터 IP가 할당되지 않고, kube-proxy가 이러한 서비스를 처리하지 않으며, 플랫폼에 의해 로드 밸런싱 또는 프록시를 하지 않는다. DNS가 자동으로 구성되는 방법은 서비스에 &lt;code>selector&lt;/code> 가 정의되어 있는지에 달려있다.&lt;/p>
&lt;/blockquote>
&lt;p>나름 의역을 섞어가며 최대한 쉽게 풀려고 노력했지만&amp;hellip; &lt;em>죄송합니다.&lt;/em> 지금 읽어봐도 무슨 소리를 하는지 잘 모르겠다.&lt;/p>
&lt;p>아마도, 영어 설명에서 함의된 내용이 너무나 많기 때문인 것 같다.&lt;/p>
&lt;hr>
&lt;p>내가 가장 마음에 들어하는 다른 설명을 가져와 봤다. 이번엔 &lt;a class="link" href="https://stackoverflow.com/questions/52707840/what-is-a-headless-service-what-does-it-do-accomplish-and-what-are-some-legiti" target="_blank" rel="noopener"
>스택 오버플로우 답변&lt;/a>이다.&lt;/p>
&lt;blockquote>
&lt;p>Service 로 향하는 네트워크 연결은 결국 서비스 아래에 존재하는 여러 Pod 중 하나로 가게 될 겁니다. 그런데, &lt;strong>클라이언트가 Pod 1개가 아니라 모든 Pod 들과 통신해야 한다면요&lt;/strong>? 만약 &lt;strong>같은 서비스 아래에 있는 Pod A 와 Pod B 가 서로 통신해야 한다면요&lt;/strong>?&lt;/p>
&lt;p>Service 를 통하는 건 확실한 방법은 아닙니다. 그럼 뭘까요?&lt;/p>
&lt;p>모든 Pod 들과 통신해야 하는 클라이언트를 위해, 개별 Pod 의 IP 주소를 알아내는 게 필요하겠죠. 그러면 클라이언트가 K8s API Server 에 접속해서 해당 Pod 들의 IP 리스트를 얻어내는 방법이 있습니다. 이상적인 방법은 아닙니다. &lt;strong>여러분이 개발 중인 어플리케이션을 K8s Cluster 가 있는지조차 모르게 (K8s-agnostic) 만들고 싶어 하잖아요.&lt;/strong>&lt;/p>
&lt;p>다행히도, Kubernetes 는 클라이언트에게 Pod IP 리스트를 알려주는 방법을 DNS Lookup 을 통해 제공합니다. 대개는, 어떤 Service 를 위한 DNS Lookup 를 수행하면 DNS 서버는 IP 주소 1개를 반환합니다. 바로 Service 의 Cluster IP 죠. 그런데 여러분이 Service 를 만들 때 Cluster IP 가 필요 없다고 알려주면, DNS 서버는 (해당 Service 를 위한 DNS Lookup 요청에) 소속된 Pod IP 주소 목록을 전부 반환합니다. 즉, DNS A 레코드 1개가 아니라, 각각의 Pod 과 통신할 수 있는 A 레코드 여러 개가 반환되는 것이죠. 그러면 클라이언트는 간단하게 이 A 레코드를 순회하면서 다시 DNS Lookup 을 할 수 있고 실제 Pod 들의 IP 를 얻을 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>보통 Service 의 역할은, Service 로 들어온 요청을 &lt;em>여러 개의 Pod 중 하나&lt;/em> 에만 전달하는 것이다. 하지만 이 요청이 &lt;strong>모든 Pod 에&lt;/strong> 전달되어야 하는 경우에는 적합하지 않다.&lt;/p>
&lt;p>이를 위해서 k8s-api-server 에 요청해서, Service 에 속한 Pod 의 IP 리스트를 얻어오도록 애플리케이션을 구성할 수는 있겠지만, 그 때부터 애플리케이션은 해당 API 서버 위치에 의존해야 하기 때문에 적절한 방법이 아닌 것이다.&lt;/p>
&lt;p>위의 설명대로라면, Cluster IP 를 없앤 Service 의 경우 DNS Server 가 모든 Pod 들의 A 레코드를 직접 알려주는 (resolving) 것이다. &lt;strong>요청을 수신받을 Cluster IP 가 없으니, 머리가 없는 Service 라고 부를 수 있겠다.&lt;/strong>&lt;/p>
&lt;h1 id="데모">데모&lt;/h1>
&lt;p>사실 데모는 다른 블로그에서 많이 찾아볼 수 있어서, 최소한으로 재현 할 수 있는 방법을 알아보도록 하자.&lt;/p>
&lt;h2 id="deployment-생성">Deployment 생성&lt;/h2>
&lt;p>우리는 &lt;code>nginx&lt;/code> 로 포트 오픈도 해 두고 &lt;code>curl&lt;/code> 이나 &lt;code>nslookup&lt;/code> 으로 Pod 간 통신을 체크해야 하니, &lt;code>praqma/network-multitool&lt;/code> 이미지로 replica 3개의 deployment 를 하나 만들도록 하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl create deployment test-deploy --image&lt;span class="o">=&lt;/span>praqma/network-multitool --replicas&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span> --port&lt;span class="o">=&lt;/span>&lt;span class="m">80&lt;/span>
kubectl get pods -lapp&lt;span class="o">=&lt;/span>test-deploy -o wide
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">NAME READY STATUS ...
test-deploy-7bff8c5f84-hxcfw 1/1 Running ...
test-deploy-7bff8c5f84-rjdm9 1/1 Running ...
test-deploy-7bff8c5f84-w5l8j 1/1 Running ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>첫 번째 Pod 의 IP 가 &lt;code>200.96.1.50&lt;/code> 이다. 두 번째 Pod 에서 첫 번째 Pod 으로 접속을 시도해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># connect to test-deploy-7bff8c5f84-hxcfw &lt;/span>
kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- curl 200.96.1.50:80
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Praqma Network MultiTool (with NGINX) - test-deploy-7bff8c5f84-hxcfw - ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>접속이 잘 된다. 하지만 여기 보이는 Pod IP 는 &lt;strong>언제든지 바뀔 수 있기 때문에&lt;/strong> 이런 식으로 쓰면 안 된다.&lt;/p>
&lt;h2 id="headless-service-생성">Headless Service 생성&lt;/h2>
&lt;p>이제 Headless Service 를 만들어보자. 이번에는 바로 만들지 말고 manifest 를 YAML 파일로 저장해 둔 다음에 수정이 좀 필요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl create service clusterip test-cs-svc --clusterip&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;None&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --tcp&lt;span class="o">=&lt;/span>80:80 --dry-run&lt;span class="o">=&lt;/span>client -oyaml &amp;gt; test-cs-svc.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Headless 로 만드는 핵심 옵션이 바로 &lt;code>--clusterip=&amp;quot;None&amp;quot;&lt;/code> 라는 걸 알 수 있다. 여기서 출력되는 파일을 열어서, &lt;code>spec.selector&lt;/code> 를 deployment 의 것으로 바꿔줘야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-cs-svc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-cs-svc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">clusterIP&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">None&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80-80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-deploy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># test-deploy deployment 가 가지고 있던 app label&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterIP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">loadBalancer&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>저장해 주고, 해당 YAML 파일을 적용하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl apply -f test-cs-svc.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="dns-lookup-하기">DNS Lookup 하기&lt;/h2>
&lt;p>이제 남은 일은 Service 의 domain name 을 가지고 DNS Lookup 을 한 결과를 받아오는 일이다.&lt;/p>
&lt;p>그런데, domain name 을 어떻게 아냐고? 마지막 참고 자료에 있는 &lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener"
>K8s DNS&lt;/a> 를 읽어봐도 좋지만, 직접 알아보기 위해서는 아까 생성한 Pod 에서 &lt;code>/etc/resolv.conf&lt;/code> 가 어떻게 설정되어 있는지 확인하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- cat /etc/resolv.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">search default.svc.cluster.local svc.cluster.local ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기 잘 보면, 해당 Pod 위치에서 요청하는 domain name 에 &lt;code>default.svc.cluster.local&lt;/code> 을 자동으로 붙여서 resolving 하려는 걸 볼 수 있다. (default namespace 에 있는 모든 Pod 들이 똑같을 것이다)&lt;/p>
&lt;p>즉, 우리는 전체 domain name 을 알 필요가 없이 Service Name 만 가지고도 DNS Lookup 을 할 수 있다.&lt;/p>
&lt;p>바로 Lookup 을 하러 가보자. 똑같이 &lt;code>kubectl exec&lt;/code> 를 할 텐데, 이번에는 &lt;code>nslookup&lt;/code> 을 해보도록 한다. domain name 은 그냥 Service Name 을 입력한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- nslookup test-cs-svc
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Server: 200.64.0.10
Address: 200.64.0.10#53
Name: test-cs-svc.default.svc.cluster.local
Address: 200.96.1.50
Name: test-cs-svc.default.svc.cluster.local
Address: 200.96.0.59
Name: test-cs-svc.default.svc.cluster.local
Address: 200.96.2.24
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여러 개의 A 레코드로 이뤄진 Pod IP 목록을 얻을 수 있다. 그리고 &lt;code>test-cs-svc&lt;/code> 처럼 Service Name 만 입력했을 뿐인데 &lt;code>test-cs-svc.default.svc.cluster.local&lt;/code> 로 바뀐 것도 볼 수 있다.&lt;/p>
&lt;h2 id="head-를-달아주면요">Head 를 달아주면요?&lt;/h2>
&lt;p>이번에는 &lt;code>test-cs-svc-head&lt;/code> 라는 이름의 Service 를 하나 더 만들자. 단순히, &lt;code>spec.clusterIP: None&lt;/code> 부분만 없는 &lt;code>test-cs-svc&lt;/code> 나 다름없다. 아까 만들어 둔 파일에서 &lt;code>metadata.name&lt;/code> 부분과 &lt;code>spec.clusterIP&lt;/code> 부분만 바꿔서 &lt;code>kubectl apply -f&lt;/code> 로 적용해 보자.&lt;/p>
&lt;p>여기에 대고 똑같이 &lt;code>nslookup&lt;/code> 을 해보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- nslookup test-cs-svc-head
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Server: 200.64.0.10
Address: 200.64.0.10#53
Name: test-cs-svc-head.default.svc.cluster.local
Address: 200.68.238.114
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 IP 는 어디서 왔을까? 바로 Service 의 Cluster IP 되시겠다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl get svc test-cs-svc-head
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
test-cs-svc-head ClusterIP 200.68.238.114 &amp;lt;none&amp;gt; 80/TCP 2m32s
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="주의할-점">주의할 점&lt;/h2>
&lt;p>&lt;code>test-cs-svc&lt;/code> 나 &lt;code>test-cs-svc-head&lt;/code> 는 DNS Lookup 에서는 차이를 보이지만, &lt;code>curl&lt;/code> 결과는 차이가 없다. 더 자세히 말하면, &lt;strong>두 요청 모두 3개의 Pod 중 1개에만 랜덤하게 전달된다는 것이다.&lt;/strong>&lt;/p>
&lt;p>다음 명령들을 반복적으로 실행해 보자. 목적지 Pod 주소가 매번 다를 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- curl test-cs-svc:80 &lt;span class="p">|&lt;/span> head -2
kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- curl test-cs-svc-head:80 &lt;span class="p">|&lt;/span> head -2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>왜 이렇게 되는 것일까? Headless Service 의 경우, DNS Lookup 하는 A 레코드 순서가 랜덤으로 전달되고 &lt;code>curl&lt;/code> 은 그저 맨 위의 것을 쓰기 때문이다. &lt;code>nslookup&lt;/code> 을 반복적으로 해 보면 보다 더 확실해 질 것이다.&lt;/p>
&lt;h1 id="이해를-돕기-위한-기초자료">이해를 돕기 위한 기초자료&lt;/h1>
&lt;p>혹시 아직도 이해가 잘 안된다면, 기초자료로 다음을 참고해보자. &lt;del>혹은 &lt;a class="link" href="https://interp.blog/cka-exam-review/" >CKA 시험 준비&lt;/a>를 하는 것도 좋은 방법이다!&lt;/del>&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/service/" target="_blank" rel="noopener"
>K8s Service&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener"
>K8s DNS&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>VSCode 문자열 자동완성 설정</title><link>https://interp.blog/vscode-string-suggestion-config/</link><pubDate>Wed, 21 Dec 2022 14:33:07 +0900</pubDate><guid>https://interp.blog/vscode-string-suggestion-config/</guid><description>&lt;p>프로그래밍 언어 키워드나 객체 이름만 추천받을 때 유용하게 쓸 수 있는 IntelliSense. VSCode 에도 물론 내장되어 있어 유용하게 쓸 순 있지만 다음 경우에는 잘 되지 않았다.&lt;/p>
&lt;ul>
&lt;li>반복되는 문자열을 복사/붙여넣기 하지 않고 물 흐르듯 쓰고 싶을 때&lt;br>
(복사할 대상이 여러개이고, 번갈아 반복되는 경우라면 더더욱.. A/B/A/B 이런 식으로)&lt;/li>
&lt;li>다른 형식의 확장자로 된 파일 내용에서 반복되는 문자열을 추천받고 싶을 때&lt;/li>
&lt;/ul>
&lt;p>나의 경우는, 한 쪽에는 &lt;code>.env&lt;/code> 파일을 열어두고 다른 쪽에는 &lt;code>docker-compose.yaml&lt;/code> 을 열어둔 경우가 여기에 해당한다. 설정 가능한 변수는 &lt;code>.env&lt;/code> 에 변수로 등록하고, &lt;code>docker-compose.yaml&lt;/code> 파일 작업할 때 참조해서 쓰고 싶은데 자동완성이 안 돼서 힘들었다. 결국 검색해서 찾아내긴 했는데, 이게 기본 설정인지 아닌지는 잘 모르겠다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">{
&amp;#34;editor.quickSuggestions&amp;#34;: {
&amp;#34;strings&amp;#34;: &amp;#34;on&amp;#34;
},
&amp;#34;editor.wordBasedSuggestions&amp;#34;: true,
&amp;#34;editor.wordBasedSuggestionsMode&amp;#34;: &amp;#34;allDocuments&amp;#34;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 두면, 필요한 파일을 열어두기만 하면 모든 문자열을 추천받을 수 있다.&lt;/p>
&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/2-98NrJ9rG4"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>조금 이상한 부분은, 참조해야 할 파일을 한 번 수정하거나 저장해야 적용이 되는 것 처럼 보이기는 했는데&amp;hellip; 조금 더 써보고 업데이트 해야겠다.&lt;/p></description></item><item><title>Mac 에서 Eclipse Home/End 키 바인딩 하기</title><link>https://interp.blog/mac-eclipse-key-binding-home-end/</link><pubDate>Tue, 20 Dec 2022 10:57:42 +0900</pubDate><guid>https://interp.blog/mac-eclipse-key-binding-home-end/</guid><description>&lt;p>아이폰, 아이패드, 애플워치까지 갖고 있지만 macbook 을 본격적으로 써 본지 만 1년도 안 된다. 그래서 윈도우에서 즐겨 쓰던 Home/End 가 Mac 에서는 Cmd 키와 화살표로만 이뤄지는 걸 극복하는데 너무 힘들었다. 물론 적응하면 되겠지만, 습관이란 게 무서운 거라고.&lt;/p>
&lt;p>결국 어떻게 하면 고칠까 알아보면서 하나씩 적용하고 있다. 일단 KeyBindings 에서 Home/End 키로 줄 시작과 줄 끝으로 이동하도록 해 두는 걸 적용했다. (&lt;a class="link" href="https://apple.stackexchange.com/questions/16135/remap-home-and-end-to-beginning-and-end-of-line" target="_blank" rel="noopener"
>링크&lt;/a>)&lt;/p>
&lt;p>그런데 어째선지, Eclipse 기반의 에디터에서는 이것과 무관하게 Home/End 가 &amp;lsquo;페이지 시작/끝&amp;rsquo; 으로 작동하는게 아닌가! Page Up/Down 키가 옆에 버젓이 있는데도 말이다! 최근에 PostgreSQL (정확히는 &lt;a class="link" href="https://docs.timescale.com/" target="_blank" rel="noopener"
>TimescaleDB&lt;/a>) 를 조사할 기회가 생겨서 &lt;a class="link" href="https://dbeaver.io/" target="_blank" rel="noopener"
>DBeaver&lt;/a> 를 설치했는데, 이 친구도 Eclipse 기반의 에디터라서 KeyBindings 설정 내용과 딴판으로 놀았었다.&lt;/p>
&lt;p>그렇다, 이 글을 쓰는 이유 되시겠다.&lt;/p>
&lt;h2 id="키-설정을-바꿔야-한다">키 설정을 바꿔야 한다&lt;/h2>
&lt;ol>
&lt;li>Eclipse 의 Preference (설정) 을 열어보자. 어딘지 모르겠다면 &lt;code>Cmd + ,&lt;/code> 를 누르면 된다.&lt;/li>
&lt;li>여기서 &lt;code>Key&lt;/code> 라고 검색해 보면 &lt;strong>User Interface -&amp;gt; Key (키)&lt;/strong> 부분에 하이라이트가 되어 있다.&lt;/li>
&lt;li>카테고리를 눌러 Text Editor (텍스트 편집기) 로 이동한다.&lt;/li>
&lt;/ol>
&lt;p>여기서 다음 항목을 입맛대로 바꾸면 된다.&lt;/p>
&lt;ul>
&lt;li>Line Start (행 시작) : Home &lt;code>↖&lt;/code>&lt;/li>
&lt;li>Select Line Start (행 시작 선택) : Shift+Home &lt;code>⇧↖&lt;/code>&lt;/li>
&lt;li>Line End (행 끝) : End &lt;code>↘&lt;/code>&lt;/li>
&lt;li>Select Line End (행 끝 선택) : Shift+End &lt;code>⇧↘&lt;/code>&lt;/li>
&lt;li>Page Up (텍스트 시작) : Page Up &lt;code>⇞&lt;/code>&lt;/li>
&lt;li>Page Down (텍스트 끝) : Page Down &lt;code>⇟&lt;/code>&lt;/li>
&lt;/ul>
&lt;figure>
&lt;img loading="lazy" src="setting.png"/>
&lt;/figure>
&lt;h2 id="그래도-안-되면">그래도 안 되면?&lt;/h2>
&lt;p>내 경우엔 이렇게 두고 &lt;code>Apply and Close&lt;/code> 를 눌러도 적용이 안 되더라. 심플하게 Eclipse (여기선 DBeaver) 를 껐다 다시 실행시키면 되었다.&lt;/p></description></item><item><title>The Colonists</title><link>https://interp.blog/the-colonists/</link><pubDate>Mon, 05 Dec 2022 09:00:01 +0900</pubDate><guid>https://interp.blog/the-colonists/</guid><description>&lt;img src="https://interp.blog/the-colonists/feature.jpeg" alt="Featured image of post The Colonists" />&lt;h1 id="세틀러와-아노">세틀러와 아노&lt;/h1>
&lt;p>부록 때문에 게임 잡지를 사 모으던 어린 시절, PC G@M 이라는 곳에서 세틀러3 라는 게임을 줬었다. 1편도 모르고 2편도 모르지만, 아기자기한 마을 주민들이 모여 집도 짓고 밥도 짓고 타워도 지었다. 자원을 캐내서 무기도 만들고 병사도 모았다. 운동장 돌멩이가 아니라 진짜로 컴퓨터와 땅따먹기를 했다. 남의 건물을 철거하면 빈 땅이 됐고, 거기에 내가 알박기를 하면 내 땅이 됐다. 영토 행사는 이렇게 하는 거라고 확실히 (?) 배울 수 있었고, 금새 나는 이런 &amp;lsquo;땅따먹기류&amp;rsquo; 건설경영 시뮬레이션에 빠져들게 되었다.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="settler3.jpeg"
alt="당시로서는 너무나 아기자기했던 세틀러3"/> &lt;figcaption>
&lt;p>당시로서는 너무나 아기자기했던 세틀러3&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>세월이 흘러, 아노 (Anno) 시리즈가 그 향수를 조금 불러일으켰다. 그러나 이 게임은 기초 재료를 모아 생산 파이프라인을 만든다는 부분만 좋았다. 파이프라인만 할 거라면 팩토리오를 해도 될 것 같았고, 세틀러의 주민들, 배가 나와 뒤뚱거리지만 할 건 다 하는 사람들이 보고 싶었다. 그래서 아노는 사놓고 진득히 하질 못했다. &lt;del>어려워서 그랬을지도 모르지&lt;/del>&lt;/p>
&lt;h1 id="식민지를-개척하는-로봇-이야기">식민지를 개척하는 로봇 이야기&lt;/h1>
&lt;figure>
&lt;img loading="lazy" src="20221205070056_1.jpg"/>
&lt;/figure>
&lt;p>더 콜로니스트 (The Colonists) 를 보면서, 다시 세틀러를 만난 느낌이 들었다. 아니나 다를까. 게임 튜토리얼을 시작하면, &lt;em>앞선 두 게임에서 영감을 받은 게임&lt;/em>이라는 설명을 대놓고 한다. 배 나온 주민은 아니고 귀여운 복제 로봇들이지만, 뒤뚱거리지 않고 시킨 일을 잘 해 낸다. 다른 우주선에서 내린 복제 로봇 (컴퓨터) 과 싸우고, 땅따먹기도 할 수 있다. 그런데 하다 보니, 생산 파이프라인을 정교하게 가져가서 효율을 극대화하는 전략이 필요했다. 이건 또 아노가 아닌가?&lt;/p>
&lt;p>주어진 맵에서, 특정 조건을 달성하거나 지도 상에 존재하는 모든 적을 물리치는 등의 목표를 완수하면 되는 게임이다. 그 목표를 이루기 위해, 초반 자원을 캐고 건물을 더 짓고, 더욱 발전된 테크를 타기 위해 건물 배치와 도로 배치를 고민하는 게임이다.&lt;/p>
&lt;h1 id="결국-생산-생산">결국 생산, 생산&lt;/h1>
&lt;p>게임은 연구라는 개념을 통해서 아래와 같은 테크 트리를 강제하게 된다.&lt;/p>
&lt;ol>
&lt;li>맵의 목표를 달성하기 위해, 더 높은 수준의 &lt;strong>연구&lt;/strong>가 필요하다.&lt;/li>
&lt;li>연구소를 업그레이드 하기 위해, &lt;strong>고급 자원 + 일정한 에너지 등급&lt;/strong>이 필요하다.&lt;/li>
&lt;li>고급 자원을 생산하기 위해, &lt;strong>추가 생산 건물 + 일정한 에너지 등급&lt;/strong>이 필요하다.&lt;/li>
&lt;li>일정한 등급의 에너지를 생산하기 위해, &lt;strong>식량자원&lt;/strong>이 필요하다.&lt;/li>
&lt;li>식량자원을 생산하기 위해, &lt;strong>추가 생산 건물 + 땅&lt;/strong>이 필요하다. (부동산은 늘 중요하다)&lt;/li>
&lt;li>생산 건물을 지을 수 있게, 연구가 필요하다&amp;hellip; 로 반복한다.&lt;/li>
&lt;/ol>
&lt;figure>
&lt;img loading="lazy" src="research.png"
alt="차근차근 연구를 통해 발전해야 한다"/> &lt;figcaption>
&lt;p>차근차근 연구를 통해 발전해야 한다&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>처음에 게임을 시작하면, 우주선이 지도에 착륙한다. 우주선은 나무와 1단계 에너지를 소량 생산한다. 1단계 에너지는 1단계 에너지는 물과 음식 (양고기 또는 야채) 만 있으면 만들 수 있다. 이 에너지로 일단 벌목꾼 오두막에 사는 벌목꾼 로봇을 돌릴 수 있다. 거기서부터 게임은 시작된다.&lt;/p>
&lt;p>건물 사이에 있는 도로를 만드는데는 비용이 들지 않는다. 도로 포스트에는 드나드는 자원을 통제할 수 있는 기능이 있다. 건물 사이에도 마찬가지로, 특정 건물에서 나온 자원만 받도록 할 것인지, 어느 건물에만 생산된 자원을 보낼 수 있는지도 조정이 가능하다.&lt;/p>
&lt;!--&lt;figure>
&lt;img loading="lazy" src="Untitled.jpg"
alt="포스트 도로에는 운송봇이 상주하며 화물을 날라다 준다" width="65%"/> &lt;figcaption>
&lt;p>포스트 도로에는 운송봇이 상주하며 화물을 날라다 준다&lt;/p>
&lt;/figcaption>
&lt;/figure>
-->
&lt;p>복잡한 수출입 규칙이니 포스트 규칙이니, 이런 거 안 해도 &amp;lsquo;보이지 않는 손&amp;rsquo; 으로 인해 게임이 잘 굴러 갈 것 같다는 생각은 하지 않았으면 좋겠다. 생산 효율이 50% 쯤 나올 때 쯤, 도로에서 배달되는 자원을 아무거나 눌러보면 경악할 테니까. &lt;del>채소 바구니 하나가 동남아 순회공연을 한다고!&lt;/del>&lt;/p>
&lt;h1 id="다양한-게임-모드">다양한 게임 모드&lt;/h1>
&lt;p>우선 튜토리얼 성격의 스토리 모드가 잘 되어 있다. 후반 미션은 많이 어렵겠지만, 그래도 게임 시스템에 익숙해졌다면 시간을 잘 투자하고 계획을 잘 세운다면 결국 모든 미션을 클리어 할 수 있을 것이다.&lt;/p>
&lt;p>랜덤 맵 역시 &amp;lsquo;샌드박스&amp;rsquo; 라는 메뉴로 지원한다. 그리고 다른 플레이어들의 &lt;del>정신나간&lt;/del> 맵들도 창작마당을 통해 플레이 할 수 있다. 또한, 매 월마다 특정 맵에서 특정 목표를 향해 플레이 해 볼 수 있는 프론티어 미션이 존재한다. 미션 성공 시간이 가장 짧은 순서대로 랭킹을 볼 수 있다. &lt;del>1등 기록을 보면 핵을 쓴 거 같다&lt;/del>&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="Untitled-3.png"
alt="매 월마다 갱신되는 프론티어 미션" width="50%"/> &lt;figcaption>
&lt;p>매 월마다 갱신되는 프론티어 미션&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h1 id="다소-아쉬운-적군-ai">다소 아쉬운 적군 AI&lt;/h1>
&lt;p>세틀러 시리즈는 솔직히 AI 가 어땠는지 기억나지 않는다. 그저 재밌었다는 기억 뿐이었다. 하지만 머리가 굵어져서 그런건지, 콜로니스트의 적대 AI 는 많이 무성의했다.&lt;/p>
&lt;p>우선 AI 들이 나름 공격적으로 확장을 시도하긴 하지만, 플레이어가 작정하고 벌목한 다음 감시탑을 통해 무한 확장하게 되면 거기서 1단계 영토는 고정된다. 상대 감시탑을 공격하려면 2단계 연구를 시작하면서 화살 감시탑으로 업그레이드해야 하기 때문이다. 문제는 1단계에서 영토를 쪼그라들게 만들면, 한정된 지역에서 발전하기가 쉽지 않기 떄문이다.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="attack.gif"/>
&lt;/figure>
&lt;p>좀 더 주요 자원 위주로 공격적인 감시탑 러시를 강제해야, 플레이어가 압박을 크게 느낄 수 있을 것 같다. 이를테면, 맵에 돌 광산이 1개 뿐이면 여기를 먹어야 이길 수 있기 때문에, 무조건 내달려야 한다. 그런데 적군은 그런거 없고 그냥 빈 땅만 확장한다.&lt;/p>
&lt;p>물론 이 게임은 제한된 환경에서 효율적인 생산을 추구하는 것이 목표인 1인용 빌드에 초점이 맞춰져 있다. 컴퓨터와의 대전이 주된 요소는 아니라는 것이다. 그래도 엄연히 게임 요소인 만큼, 좀 더 신경 써 주면 좋겠다는 생각은 든다.&lt;/p>
&lt;hr>
&lt;p>여담인데, 재밌게 하다 보니 한국어 번역이 거슬렸다. 존댓말과 반말이 섞여있고, 명명법에 통일성이 없었다. 게임 안에 있는 디스코드 버튼을 눌러, 개발자에게 DM 을 보냈다. 번역한 사람 어딨냐고.&lt;/p>
&lt;p>개발자가 답하기를, 우리는 자발적으로 참여한 사람에 한해 언어 번역을 진행하고 있고, 한국어 담당자는 한 번 하고는 가버렸다고 한다. 내가 전부 다 갈아엎고 다시 해도 되냐고 했더니, 게임 카피를 하나 주면서 땡큐라고 했다. 그 인연(?) 으로 지금까지 한국어 번역을 담당하고 있다. 번역이 이상하다면, 디스코드에 오셔서 같이 도와주세요!&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="Untitled-4.png"
alt="예, 접니다.."/> &lt;figcaption>
&lt;p>예, 접니다..&lt;/p>
&lt;/figcaption>
&lt;/figure></description></item><item><title>스태프 엔지니어</title><link>https://interp.blog/staff-engineer/</link><pubDate>Sun, 27 Nov 2022 12:00:01 +0900</pubDate><guid>https://interp.blog/staff-engineer/</guid><description>&lt;img src="https://interp.blog/staff-engineer/feature.jpeg" alt="Featured image of post 스태프 엔지니어" />&lt;figure>
&lt;img loading="lazy" src="feature.jpeg" width="55%"/>
&lt;/figure>
&lt;p>여기 두 명의 개발자가 있다.&lt;/p>
&lt;ul>
&lt;li>나는 매니저가 되는 게 싫다. 회사에서도 하라는 걸 극구 거부했다. 기술을 놓지 않고 싶다.&lt;/li>
&lt;li>내가 신입 때, 개발자는 40이 되면 은퇴해야 한다고 들었다. 내가 40이 되었을 때엔, 사람들은 50이 되면 은퇴해야 한다고 말했다. 이제 나는 50에 가까워지고 있는데 은퇴해야 하나? 난 여전히 엔지니어다. 그리고 이 일을 계속 할 자신이 있다.&lt;/li>
&lt;/ul>
&lt;p>이 책을 처음 접했을 때, 적어도 두 분께는 알려드려야 될 것 같았다. 길벗 출판사에서 새로 펴낸 소프트웨어 엔지니어 교양서 &amp;lsquo;&lt;a class="link" href="http://www.yes24.com/Product/Goods/112904809" target="_blank" rel="noopener"
>스태프 엔지니어&lt;/a>&amp;rsquo; 말이다.&lt;/p>
&lt;h1 id="스태프-엔지니어">스태프 엔지니어?&lt;/h1>
&lt;p>앞선 두 분의 개발자에게 있어, 다음 커리어는 무엇일까? 물론 개발 역량만 충분하다면 계속 시니어 엔지니어를 하셔도 될거라고 생각한다. 그러나 특정 팀이나 프로젝트에만 소속되어 있어서, 권한이 제한되거나 조직 비전에 불만이 있어도 묵살당하기 일쑤였다. 그런 걸 봐 온 나로서는, 그 길이 정답이라고 콕 집을 순 없었다.&lt;/p>
&lt;p>관리자와 비교했을 때, &lt;strong>스태프 엔지니어는 기술 직군으로 커리어를 이어나갈 수 있는 또 다른 트랙&lt;/strong>이라고 소개한다. 한국에서는 아직 생소할 수도 있는 단어지만, 사실 스태프 엔지니어의 대표 역할인 &lt;em>&amp;lsquo;테크 리드&lt;/em>&amp;rsquo; 나 &lt;em>&amp;lsquo;아키텍트&amp;rsquo;&lt;/em> 같은 직함을 들어보면 그렇게 낯설지는 않다.&lt;/p>
&lt;p>관리자가 아닌 기술 커리어 트랙이 대체 왜 필요한 걸까? (역시 스태프 엔지니어이신) 이 책의 역자 장현희 님의 서문 중 일부가 답이 될 것 같았다.&lt;/p>
&lt;blockquote>
&lt;p>조직의 입장에서도 이런 식의 승진 절차는 한편으로는 손해이기도 합니다. 시니어 언제니어로 좋은 성과를 내던 사람이 팀장 승진 대상이 됩니다. &lt;strong>이 사람이 팀장이 되면 조직은 유능한 시니어 엔지니어 한 명을 잃고 초보 팀장 한 명을 얻게 되는 셈이기 때문이지요.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>그렇다고 스태프 엔지니어가 시니어 엔지니어의 연장선이라는 것은 아니다. 이제는 팀 간, 부서 간을 넘나들며 플레이해야 하는 역할이기 때문이다. &amp;lsquo;테크 리드&amp;rsquo; 나 &amp;lsquo;아키텍트&amp;rsquo;, &amp;lsquo;해결사&amp;rsquo;, &amp;lsquo;오른팔&amp;rsquo; 처럼 책에서 구분해 둔 스태프 엔지니어 역할을 읽다 보면 정말 다양한 사람을 만나고, 또 다양한 일을 다뤄야 한다는 사실을 알 수 있다.&lt;/p>
&lt;h1 id="따라한다고-되는-게-아니다">따라한다고 되는 게 아니다&lt;/h1>
&lt;p>길벗 출판사의 다른 커리어 조언서인 &amp;lsquo;소프트 스킬/커리어 스킬&amp;rsquo; 이나 &amp;lsquo;이펙티브 엔지니어&amp;rsquo;, &amp;lsquo;&lt;a class="link" href="https://interp.blog/simple-software/" >심플 소프트웨어&lt;/a>&amp;rsquo; 와 책 디자인은 비슷한데, 이 책은 앞선 책들과 다른 점이 있다. 책의 지침을 다 따라한다고 해도 스태프 엔지니어가 될 수 없다는 점이다.&lt;/p>
&lt;p>앞선 책들은 (물론 주제가 다르긴 해도) 사실 비슷한 구석이 있었다. 전반적인 커리어 관리, 업무 태도, 효율적인 업무를 위한 조언들 말이다. &amp;ldquo;야, 너두 할 수 있어&amp;rdquo; 같은 느낌이랄까. 하지만 이 책을 읽는 동안엔 왠지 모를 압박을 받았다. &lt;strong>&amp;ldquo;이래도 할 거야?&amp;quot;&lt;/strong> 같은. 지침서가 아니라, 다큐멘터리를 보는 느낌이었다.&lt;/p>
&lt;p>하고 싶다고 해서 되는 것도 아니다. 스태프 엔지니어가 되려면 노력과 운이 동시에 필요하다는 것이다. 개인적인 노력도 중요하지만, 네트워킹을 통해 스폰서 내지는 지지 기반을 만들어야 한다. 그러기 위해선, 자신이 어떤 일을 원하는지 어떤 역할로써 스태프 엔지니어가 될 것인지 스폰서 (대개는 팀장이나 본부장) 에게 공유해야 하는 것이 첫 번째라고 조언한다.&lt;/p>
&lt;p>하지만 스태프 엔지니어가 된다고 해서, 더욱 커진 권한을 통해 자신의 비전을 마구잡이로 주입해도 된다는 말은 아니다. 책에서 표현하는 &lt;em>&amp;ldquo;관리자를 놀라게 하는 일들&amp;rdquo;&lt;/em> 이 그런 것일텐데, 결국 회사 입장에서는 회사 비전에 가장 잘 맞추는 사람을 승진시키려고 할 것이기 때문이다. 따라서, 자신이 하고자 하는 일과 회사 비전을 최대한 맞추되, 그 속에서도 회사가 우선시되어야 한다고 강조한다.&lt;/p>
&lt;p>회사와의 비전을 정 못 맞추겠다면 이직해서 스태프 엔지니어 자리에 앉는 것도 고려할 수 있다는 사실 역시 물론 짚어준다. 지지기반이 낮을 순 있지만, 다니는 회사의 규모가 크거나 스태프 엔지니어 자리가 쉽게 나지 않을 때는 고려해 볼 수 있다는 것이다.&lt;/p>
&lt;h1 id="경험담만-들어도-이득">경험담만 들어도 이득&lt;/h1>
&lt;p>이 책을 집어들고 &amp;lsquo;난 이제 스태프 엔지니어가 되고 말겠어!&amp;rsquo; 라고 외치진 말자. 이 책이 당장의 업무에 직접적인 영향을 줄 수 있다고 보긴 힘들다. 반대로 말하면, 지금 내 위치를 점검해 보고 스태프 엔지니어들의 경험담을 들어볼 수 있다.&lt;/p>
&lt;p>이미 그 길을 걸어온 사람들의 경험담을 듣고, 그들이 조언하는 것을 듣는 것은 매우 소중한 기회이다. 스태프 엔지니어 같은 직함에 매달리지 말고, 그냥 잘 하는 선배 개발자들의 직업관, 마음가짐, 업무에 대한 경험담을 듣는 것만으로도 이 책은 절반의 역할을 다 했다고 생각한다. 실제로 책 후반부는 모조리 14명의 스태프 엔지니어들의 인터뷰로 준비되어 있다. 책에서 주석으로 알려주는 다양한 블로그나, 인터뷰 말미에 나오는 추천도서 역시 쏠쏠하다.&lt;/p>
&lt;p>그런 면에서, 꼭 시니어 엔지니어가 아닌 신입 개발자라도 이 책은 큰 도움이 될 것이다. 물론 그런 경우라면 &amp;lsquo;커리어 스킬&amp;rsquo; 을 읽는 게 더욱 도움이 될 거라 보는데, 그 이유는 이 책의 전반부가 너무 지엽적인 조언들로 가득하기 때문이다. 인터뷰만 보는 걸 추천하는 이유이기도 하다.&lt;/p>
&lt;hr>
&lt;p>이 책에서 엮은 다양한 경험담과 조언들을 통해, 최소한 나의 다음 커리어에 대해 고민해 볼 수 있었다. 그리고 언제나처럼, 승진은 개인이 잘 해서 되는게 아니라는 사실, 네트워킹은 필수불가결한 요소라는 것도 같이 알아 갈 수 있었다. (본인처럼) 다음 커리어에 대해 불안감을 가진 개발자/엔지니어에게도, 이 책이 도움이 되지 않을까 생각해 본다.&lt;/p>
&lt;p>&lt;em>※ 출판사의 서평 이벤트를 통해 증정받은 책으로 작성하였습니다.&lt;/em>&lt;/p></description></item><item><title>김봉현의 글쓰기 랩</title><link>https://interp.blog/writing-lab/</link><pubDate>Tue, 22 Nov 2022 09:30:01 +0900</pubDate><guid>https://interp.blog/writing-lab/</guid><description>&lt;img src="https://interp.blog/writing-lab/feature.jpeg" alt="Featured image of post 김봉현의 글쓰기 랩" />&lt;figure>
&lt;img loading="lazy" src="feature.jpeg" width="45%"/>
&lt;/figure>
&lt;p>정지우 작가의 글쓰기 에세이인 &lt;a class="link" href="http://www.yes24.com/Product/Goods/105521868" target="_blank" rel="noopener"
>&amp;lsquo;우리는 글쓰기를 너무 심각하게 생각하지&amp;rsquo;&lt;/a> 를 읽었다. 아니 정확히는 읽다가 포기했다. 노파심에 이야기하지만, 매일 글을 펴내는 작가의 페이스북을 팔로우해서 매일 글을 읽을 정도로 그의 글이 싫은 게 아니다.&lt;/p>
&lt;p>초반부에 추천하는 이 책 때문이었다. &lt;a class="link" href="http://www.yes24.com/Product/Goods/78586548" target="_blank" rel="noopener"
>&lt;strong>김봉현의 글쓰기 랩&lt;/strong>&lt;/a>.&lt;/p>
&lt;p>마지막 글자에 눈길이 갔다. &amp;lsquo;누구보다 빠르게 남들과는 다르게&amp;rsquo; 코칭해줄 것 만 같은 기대가 들었다. 그가 힙합 관련 책까지 몇 권이나 써 낸 힙합저널리스트이자 음악 평론가라는 사실을 뒤늦게 알고 나니, 책 제목이 더욱 그럴싸 해 보였다. 하지만 오해를 방지하기 위해, Rap 이 아닌 Lab 이라는 것을, 합평회라는 이름의 글쓰기 연구소 이야기임을 알려 둔다.&lt;/p>
&lt;h1 id="verse-1">Verse 1&lt;/h1>
&lt;p>이 책의 앞 부분은 합평회를 하면서, 또는 작가 개인이 가지고 있는 글쓰기에 대한 생각이 담겨있다. 그러면서 자신의 글도 스리슬쩍 끼웠고, 다른 작가의 좋은 글도 선례로 끼웠다. 와이프와 함께 김소연 시인의 산문집 &lt;a class="link" href="http://www.yes24.com/Product/Goods/76109558" target="_blank" rel="noopener"
>&amp;lsquo;사랑에는 사랑이 없다&amp;rsquo;&lt;/a> 의 글귀를 두 번씩이나 돌려 봤다. 또 다른 책으로 새끼를 쳐 주신 것이다. 작가 두 분, 아니 세 분에게 감사 인사를 전합니다.&lt;/p>
&lt;p>앞 부분에서 크게 와닿았던 것은 두 가지인데, 하나는 &lt;strong>글이 공감 뿐만 아니라 영감을 줘야 한다&lt;/strong>는 것이었다. 물론 여기에는 &amp;lsquo;좋은 글&amp;rsquo; 이라는 기준이 작용하는 것이고 &amp;lsquo;상업적인 글&amp;rsquo; 이라는 기준에는 조금 갸우뚱할 수 있겠단 생각이 들었다. 빠르게 소비하는 시대에 얕은 공감만 불러일으켜도 많은 조회수를 얻는 그런 글 말이다. 하지만 이 책을 읽는 사람들은 분명 좋은 글을 쓰고자 하는 열망으로 가득 차 있을 것이었다. 분명 기우일 것이다.&lt;/p>
&lt;p>나머지 하나는 &lt;strong>자기만의 스타일을 발견하고 또 유지해야 한다&lt;/strong>는 것이다. 스타일에는 정답이 없으니까. 스타일을 잘 읽히게 만드는 노력과는 별개로 말이다. 다른 이야기일 순 있는데, &lt;em>-인 것 같다&lt;/em> 라거나 &lt;em>-라고 생각한다&lt;/em> 고 붙이는 게 깔끔치 못할 순 있어도 글의 흐름이 자연스럽고 개성있는 스타일이 유지된다면 못 쓸게 있냐는 것이다.&lt;/p>
&lt;p>그가 글을 쓸 때 전개하는 과정, 글감을 모으고 확장하고 자료를 찾고 재배치하고 뼈대를 만들어 살을 더 붙이는 과정을 읽는 것은 몹시 흥미로웠다. 퇴고할 때는 문장의 리듬감, 문단의 첫/마지막 문장만 남겨 글의 흐름이 깨지진 않는지 체크한다는 부분이 나에겐 주요 체크였다. 힙합을 잘 모르지만, &lt;strong>펀치라인의 타이밍과 플로우가 기본이듯이?&lt;/strong>&lt;/p>
&lt;h1 id="verse-2">Verse 2&lt;/h1>
&lt;p>책의 뒷 부분은 합평회의 호스트로서 많은 사람들의 글을 보고 피드백한 내용으로 구성되어 있다. 실제 피드백 대상이 되었던 글과 피드백 자체를 고스란히 실었는데, 마치 현장에 있는 느낌이 들었다. **내 글도 아닌데, 내가 혼나는 느낌. **&lt;/p>
&lt;p>특히, 어떤 글은 만연체로 특징 없이 주절주절 적어 뒀는데 정말 내 글과 닮아 있었다. 그러니 신랄한 피드백이 뒤따라올 수 밖에. 쓸 때는 몰랐거나 모른 체 했을 부분들이 독자가 되면 여실히 드러나는 거였다.&lt;/p>
&lt;p>작가의 피드백을 모아 보면 전부는 아니지만 많은 곳에서 &amp;lsquo;노력하지 않은 글&amp;rsquo; 에 대한 지적이 눈에 띈다. 글쓴이는 실력은 좋은데 노력을 안 해서 글이 엉성하다, 시작은 좋은데 끝이 흐지부지 됐다, 강렬한 주제로 시작했는데 거기까지인 것 같다 등등. &lt;strong>좀 더 신경썼다면 어땠을까 하는 아쉬움이 묻어나는 코멘트였다.&lt;/strong> 결국 글쓰기는 엉덩이 싸움인 것이다. (물론 재능도 있어야겠지만)&lt;/p>
&lt;p>와이프가 읽기 전에, 내가 일부러 소제목을 포스트잇으로 다 가려서 줬었다. 나는 제목을 보고 읽기 시작해서 선입견이 생기지 않았을까 하는 마음에 시도해 본 것이었다. 신기하게도, 와이프가 피드백을 읽으면서 _&amp;lsquo;와 이 사람 나랑 같은 생각했어!&amp;rsquo; 를 몇 번이고 연발했다. 나만, 아니 작가만 이렇게 생각한 건 아니었구나 싶었다. 혼자만 그렇게 생각했다면 디스였겠지.&lt;/p>
&lt;hr>
&lt;p>강원국 작가가 언젠가 한번 합평회에 대한 이야기를 한 것이 떠올랐다.&lt;/p>
&lt;blockquote>
&lt;p>합평은 정말 좋은 실전에 내 글을 던지는 용기의 시간입니다.&lt;br>
잘 하게 되면, 가장 잘 쓰는 사람의 수준으로 모두 상향 평준화가 될 수 있어요.&lt;/p>
&lt;/blockquote>
&lt;p>작가는 용기의 시간을 함께 해 주고, 또 그들의 글이 책에 실릴 수 있게 허락해 준 많은 사람들에게 감사 인사를 잊지 않았다. 어떤 글을 보니 &amp;lsquo;평소 리스펙트 하던 선생님께 메시지를 드렸고, 결국 합평회에 합류하게 되었다&amp;rsquo; 는 문장이 있었는데, 나도 욕심이 살짝 났다. 혹시 또 안하시나요?&lt;/p>
&lt;p>그 전에, 내가 읽어도 마음에 드는 글을 쓸 수 있도록 무던히 노력하는 것이 먼저인 것 같다. 그런 글이 나오면 와이프에게도 읽혀보고, 그 단계도 통과를 해야 내 글을 용기있게 꺼낼 수 있을 것 같다.&lt;/p>
&lt;p>아, 당연히 다음 에세이 책 리뷰는 이미 정해져 있고 &lt;em>&amp;lsquo;글쓰기를 너무 심각하게 생각하지&amp;rsquo;&lt;/em> 않을 때 할 예정이다!&lt;/p></description></item><item><title>카드 샤크</title><link>https://interp.blog/card-shark/</link><pubDate>Mon, 21 Nov 2022 13:00:01 +0900</pubDate><guid>https://interp.blog/card-shark/</guid><description>&lt;img src="https://interp.blog/card-shark/feature.jpg" alt="Featured image of post 카드 샤크" />&lt;p>18세기 프랑스의 어느 여관. 주인의 양아들로 지내는 주인공은 벙어리였다. 어느 날 한 백작이 그를 불러 손기술이 좋으니 같이 일해서 큰 돈을 벌어보지 않겠냐고 제안했다. 공교롭게도 그날 그들의 손기술은 탄로나고 테이블 건너편에 있던 장군이 홧김에 쏜 총알은 여관 주인을 향했다. 주인공은 도망자 신세가 되어 자의 반 타의 반으로 백작과 함께 전국투어를 했다. 프랑스판 고니와 평경장 스토리인가 싶지만, &lt;em>&amp;lsquo;서양 타짜&amp;rsquo;&lt;/em> 라는 별명을 가진 인디 게임 &lt;strong>카드 샤크&lt;/strong>의 초반부 내용이다.&lt;/p>
&lt;h2 id="타짜가-되어-보자">타짜가 되어 보자&lt;/h2>
&lt;figure>
&lt;img loading="lazy" src="1st.png"
alt="주인공의 초반 트릭, 훔쳐보기 (&amp;amp;hellip;)"/> &lt;figcaption>
&lt;p>주인공의 초반 트릭, 훔쳐보기 (&amp;hellip;)&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>영화 &amp;lsquo;타짜&amp;rsquo; 와 다른 점은, 내가 직접 손기술을 구사해 볼 수 있다는 것이다. 셔플, 딜링, 스택 더블링, 표시목 새기기, 훔쳐보기, 카드 소매넣기 등 참신한 기법을 체험해 볼 수 있다는 데 이 게임은 큰 의의가 있다.&lt;/p>
&lt;p>그래서 이 게임은 &lt;em>&amp;lsquo;나쁜 내 머리를 용서해라&amp;rsquo;&lt;/em> 같은 댓글이 수두룩 달린다. 백작이 알려주는 기본 규칙을 잘 듣고 셔플에 인조깅/아웃조깅이나 카드 끼워넣기를 언제 할지 플레이어가 판단해야 하기 때문이다. 딜링할 때도, 밑장을 뺄지 다음장을 뺄지 그냥 줄지 판단해야 한다. 그나마 다행인 점은, 모든 손패를 외우라는 일은 시키지 않는다는 것이다. 대신 높은 패 (AKQJ) 를 빼돌리거나, 문양이 가장 많은 카드 개수와 그 문양을 외우는 정도면 충분하다.&lt;/p>
&lt;p>특정 기법은 QTE 범벅이라 호불호가 있을 수는 있지만, 대부분은 커맨드 입력에 집중하기만 하면 된다. 그렇다고 &amp;lsquo;아수라발발타&amp;rsquo; 를 외쳐가며 느긋하게 했다간 &lt;strong>의심 게이지&lt;/strong>가 계속 차오르는 걸 봐야 한다. 계산이 끝났다면 신속하게 움직여야 한다.&lt;/p>
&lt;h2 id="스토리">스토리&lt;/h2>
&lt;figure>
&lt;img loading="lazy" src="2nd.png"
alt="늘상 쫒기고 붙잡히고 죽을 뻔 하고, 이것이 타짜의 인생"/> &lt;figcaption>
&lt;p>늘상 쫒기고 붙잡히고 죽을 뻔 하고, 이것이 타짜의 인생&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>게임은 실제 18세기 프랑스 시대상과 실존 인물을 섞어 진짜 이야기인 것 처럼 풀어낸다. 실존 인물만 넷이나 나오는데, 그 중 &amp;lsquo;평경장&amp;rsquo; 역할에는 프랑스 최후의 연금술사이자 불로불사라고 소문난 &amp;lsquo;생 제르맹 백작&amp;rsquo; 이 나온다. 루이 15세도 사건의 중심 인물로 등장하며, 초반에는 프랑스 철학자 볼테르와 수학자 달랑베르가 조연으로 등장한다.&lt;/p>
&lt;p>대강의 스토리 전개는 이렇다. 루이 15세에겐 &amp;lsquo;열두 병의 우유&amp;rsquo; 라고 불리는 치부에 가까운 사건이 있었는데, 생 제르맹 백작이 왕정을 실각시키기 위해 사기도박을 다니면서 그 정보를 수집하러 다니는 것이다. 그 비밀이 한꺼풀 벗겨질 때 마다 둘에게는 몇 번의 위기가 찾아온다.&lt;/p>
&lt;p>즉, 트럼프 카드로 도박하는 것은 게임의 내러티브를 풀기 위한 일종의 수단인 셈이다. 그럼에도 수단과 스토리 사이에는 묘한 공통점이 있다. &lt;strong>모두 &amp;lsquo;비밀&amp;rsquo; 에 엮여 있다는 것이다.&lt;/strong> 비밀을 만든 사람과 의심하는 사람의 대립이 발생한다. 작은 테이블 위에서 시작해, 프랑스 왕가 전체로.&lt;/p>
&lt;h2 id="짧은-플레이타임-기대만큼은-하는-재미">짧은 플레이타임, 기대만큼은 하는 재미&lt;/h2>
&lt;p>인디 게임인 만큼, 게임 볼륨에 큰 기대를 하지 않았는데 딱 그만큼의 볼륨을 자랑한다. 28종의 카드 트릭을 다 배우면 실질적으로 1회차를 마무리할 수 있다. 멀티 엔딩이 있긴 하지만 마지막 분기만 엔딩에 영향을 미치기 때문에 리플레이성이 그만큼 떨어진다. 2회차부터는 설명을 건너뛸 순 있지만 어쨌건 털어먹는 과정을 다 밟아야 하기 때문에 굳이 2회차를 돌릴 이유가 없는 셈.&lt;/p>
&lt;p>스토리와 관련없이, 트릭만 계속 사용할 수도 있는 일종의 &lt;em>무한 맵&lt;/em> 역시 존재한다. 그래서 트릭에 재미를 많이 느끼는 플레이어라면 여기만 들락날락 해도 될 성 싶다. 물론 트릭을 내 맘대로 선택할 수 없고 무작위로 주어지는 3개 중 1개를 골라 플레이하는 식이라서, 조금 아쉬울 수도 있지만 시스템 상 어쩔 수 없는 선택이었다고 본다.&lt;/p>
&lt;hr>
&lt;p>마무리하면, 앞서 말한 대로 &lt;strong>카드 트릭을 직접 수행해 보는 맛은 일품이다.&lt;/strong> 반면, 트릭 개수가 28개라고는 하지만 몇가지 기본 트릭의 조합 개수에 지나지 않는다. 이 점은 허위광고처럼 들릴 수 있다. 그러나 그런 조합을 상황에 맞춰 쓰는 센스도 함께 느껴볼 수 있다고 본다.&lt;/p>
&lt;p>곁다리로, 한글화가 안 되다가 최근에 된 건지 쾌적한 플레이가 가능하긴 했다. 하지만 트릭을 설명하는 생 제르맹 백작의 지문을 아무리 읽어봐도 이해가 안 되는 부분이 몇 군데 보였다. 그럴 땐 그냥 반복 연습과 독자 연구 (&amp;hellip;) 를 통해 내가 규칙을 찾는 수 밖에 없었다. 이 부분은 아주 살짝 아쉬웠다.&lt;/p></description></item><item><title>세브란스: 단절</title><link>https://interp.blog/severance/</link><pubDate>Sun, 20 Nov 2022 21:23:01 +0900</pubDate><guid>https://interp.blog/severance/</guid><description>&lt;img src="https://interp.blog/severance/feature.jpg" alt="Featured image of post 세브란스: 단절" />&lt;figure>
&lt;img loading="lazy" src="feature.jpg" width="50%"/>
&lt;/figure>
&lt;p>애플TV 구독을 자처하진 않았다. PS5 를 구매했더니 몇 개월, 카카오페이로 결재하는 조건으로 몇 개월 씩 무료로 받은 것 뿐이다. 하지만 그다지 볼 게 없었다. 그렇게 유명하다는 &lt;em>파친코&lt;/em> 조차 중도 하차할 정도로, 드라마를 고르는 내 기준이 점점 좁아지고 있었다. 그 와중에 커뮤니티에서 어떤 드라마의 1회분의 요약을 봤다. 어디서 볼 수 있냐는 댓글에 넌지시 애플TV 독점이라는 친절한 답글이 달려있었다. 아직 무료 구독일이 남아 있어서 다행이라고 생각하며, &lt;strong>&amp;lsquo;세브란스&amp;rsquo;&lt;/strong> 를 보기 시작했다.&lt;/p>
&lt;p>요약은 대강 이랬다. 워라밸을 꿈꾸는 제약회사 직원 몇몇이 자원해서 뇌 수술을 받는다. 출근을 하면 지하로 내려가는 엘리베이터를 타고, 그 사이에 새로운 자아로 교체된다. 퇴근을 하면 올라오는 엘리베이터 안에서 다시 원래 자아로 교체된다. 즉, 원래 나 자신은 출근해서 엘리베이터를 타자마자 바로 내리고 곧바로 퇴근이다. &lt;em>야, 이 얼마나 이상적인 워라밸인가!&lt;/em>&lt;/p>
&lt;h2 id="일하는-자아는-어떻게-되는가">일하는 자아는 어떻게 되는가&lt;/h2>
&lt;p>하지만 드라마는 지옥으로 떨어진 새로운 자아에 대한 이야기를 놓치지 않는다. 어떤 여자가 아무런 기억 없이 회의실에서 눈을 뜬다. 오늘이 첫 출근인 것이다. 다른 사람들은 여자를 위로하면서 곧 익숙해 질거라고 한다. 팀장이라는 사람이 제일 사근거리지만, 여자가 보기엔 어쩐지 다들 미친 것 같다. 일하는 자아는 영원히 퇴근할 수 없다. 엘리베이터를 타자마자 다시 내려야 한다. 업무만 할 수 있는, 그야말로 지옥이 따로 없다. 그녀는 바깥 자아에게 퇴사를 종용하거나 경고 메시지를 보내기 위해 자해도 해 보고, 자살도 시도했다. 모두 수포로 돌아갔고, 결국 그녀는 체념한다.&lt;/p>
&lt;p>드라마는 일터에 갇힌 자아들의 불합리함을 이질적으로 보여준다. 마치 자아를 &amp;lsquo;다 큰 아이들&amp;rsquo; 로 분류해 두고 사회성 실험을 하는 것처럼. 하는 업무들이 정상적인 것도 아니고, 목표를 달성하면 보상으로 준다는 것들이 고작 케익 조각이나 댄스 파티, 크리스탈 장식품 따위이기 때문이다. 행여나 잘못을 하면, 휴게실로 들어가 &amp;lsquo;잘못했다&amp;rsquo; 는 말을 거짓말 탐지기에 걸리지 않을 때 까지 반복해야 한다. 제약회사의 창립자를 마치 신처럼 받들어 기리는 장소, 그의 말을 정리한 책이 마치 성경처럼 한 켠에 자리하고 있는 것은 일종의 세뇌작업처럼 보인다.&lt;/p>
&lt;h2 id="일터와-현실의-대비">일터와 현실의 대비&lt;/h2>
&lt;p>요약글을 읽었을 때는, 업무의 굴레에 처음 떨어진 그 여자가 주인공이라고 생각했다. 하지만 실제로 드라마는 그녀를 보듬어주던 팀장이 진짜 주인공이다. 회사 안은 물론이고, 퇴근 후의 자아까지 가장 많이 묘사되기 때문이다. 왜 이 프로그램에 지원하게 되었는지도 알 수 있다. 진짜배기는, 본래 자아는 사회에 절어 있는 푸석한 모습이라면 새로운 일하는 자아는 매우 밝고 당차다는 것이다. 그 대비가 극명해서 몇몇 배우들의 1인 2역은 필수 요소일 수 밖에 없었다.결론적으로는 정말로 잘 했다고 본다.&lt;/p>
&lt;p>분리된 두 무대의 배경 또한 극명한 대비를 이룬다. 일터는 하얀색 바탕에 형광등, 텅 빈 공간에 80년대에나 볼법한 컴퓨터 콘솔이 파티션 사이에 놓여있다. 복도는 도대체 방향을 가늠할 수 없을 정도로 이정표 없이 하얗기만 하다. 반대로 바깥은 만년설이라도 내린 듯 소복히 눈 쌓인 도시, 우중충한 거리, 해가 빨리 떨어져버린 어두운 밤을 강조한다. 이 대비가 참 마음에 들었다. 주인공이 우울한 이유는 바로 이 극야같은 삶이 아니었을까 생각해 본다. 낮에는 내가 없으니까.&lt;/p>
&lt;hr>
&lt;p>공고할 것만 같은 워라밸 시스템은, 비밀을 간직한 전 팀원이 팀장 (정확히는 팀장의 본래 자아) 의 눈 앞에 나타나면서 작은 균열이 생기기 시작한다. 일터의 자아들은 의심의 싹을 키우기 시작하고, 그걸 무마해야만 하는 관리팀 직원들과 대치하게 된다. 여긴 어떤 공간일까, 우리 말고 다른 팀이 있는지, 우리가 모르는 방이 있을지, 자아를 어떻게 바꾸는 것인지, 나는 바깥에서 어떤 사람인지 같은 질문을 하나씩 가지게 된다. 그리고 하나씩 풀어내게 된다.&lt;/p>
&lt;p>사실 중간에 들어온 그 여자가 그 균열을 확장한 것이다. 체념한 듯 해 보였지만, 팀원들에게 보다 근원적인 질문을 던지기 시작한다. 그리고 그녀의 정체는-&lt;/p>
&lt;p>&lt;strong>나머지는 시즌2가 나와야 한다.&lt;/strong> 떡밥 회수가 절반도 안 되었다. 추후 전개나 결말이 어떻게 되건, 너무나 신선한 소재이기에 차기 시즌 소식에 눈을 뗄 수 없을 것 같다.&lt;/p>
&lt;p>이제 내 자아는 일하러 가야 겠다.&lt;/p></description></item><item><title>바닷가 작업실에서는 전혀 다른 시간이 흐른다</title><link>https://interp.blog/spielraum/</link><pubDate>Thu, 27 Oct 2022 22:00:36 +0900</pubDate><guid>https://interp.blog/spielraum/</guid><description>&lt;img src="https://interp.blog/spielraum/feature.jpeg" alt="Featured image of post 바닷가 작업실에서는 전혀 다른 시간이 흐른다" />&lt;p>김정운 교수가 쓴 에세이로, 부제는 &amp;ldquo;슈필라움의 심리학&amp;rdquo; 이다. 슈필라움 (Spielraum) 은 독일어로 &amp;lsquo;내 마음대로 할 수 있는 물리적/심리적 공간&amp;rsquo; 을 뜻한다. 전라남도 여수에서 작업실을 차려, 그 슈필라움 속에서 겪었던 경험이나 떠올랐던 생각들을 엮은 것이다.&lt;/p>
&lt;h1 id="그의-슈필라움은-여수에-있다">그의 슈필라움은 여수에 있다&lt;/h1>
&lt;p>작가는 교수 일을 그만두고 미술을 공부하러 일본 유학을 다녀왔다고 한다. 그리고 한 화가의 작업실에 반해, 자신도 여수에서 전망 좋은 곳에 화실을 임대했다. 그러다 문득, 여자도(汝自島) 라는 섬에 위치한 사용하지 않는 미역창고를 사서 리모델링 해 서재가 있는 작업실을 만들겠다고 다짐했다고 한다. 바닷가에 있어 책 보관이 힘들 것이다, 물이 들어차면 어떡하냐, 섬에서 대공사를 하는 비용이 만만치 않을 것이다, 갖가지 반대가 쏟아졌지만 그는 이렇게 생각했다. &lt;em>&amp;ldquo;한 일에 대한 후회는 오래가지 않는다&amp;rdquo;&lt;/em> 라고.&lt;/p>
&lt;p>그렇게 그 만의 슈필라움을 구축하는 데 우여곡절이 많았지만, 그는 2층에 화실을 두고 있는 화가이자 조그만 배를 몰 수 있는 선장이면서, 해안가에 책이 가득한 작업실을 가진 작가로 원하는 것을 할 수 있게 되었다. 솔직히, 마냥 부럽기만 하다.&lt;/p>
&lt;h1 id="작가의-독서론">작가의 독서론&lt;/h1>
&lt;p>작가는 이 곳에서 좋은 책을 하나씩 채워가며 살고 싶다고 했다. 다 본 책을 꽂는게 아니라, 볼 책을 꽂는 것이라고 그는 강조한다.&lt;/p>
&lt;p>독서라는 것은, 여러 책을 묶어서 읽어야지 한 권을 끝까지 읽는 것은 문학작품을 읽을 때만 하면 된다고 한다. 발췌독을 해서 좋은 책은 곁에 두고 다른 책과 엮어가며 같이 읽는 것이다. 좋은 책은, 읽을수록 다른 책들이 떠오르고 읽고 싶게 만드는 책이라고 한다. 그의 표현으로는 &amp;lsquo;새끼를 치는 책&amp;rsquo; 이라고. 고구마 줄기처럼 딸려올라오는 것이 많은 책이라고. 그게 다른 책이건, 생각이건 간에 말이다.&lt;/p>
&lt;p>책을 구입하는 것이 결코 낭비가 아님을 강조한다. 비싼 그림 한 점 살 돈으로, 책을 여러권 사서 책장을 장식하는게 더 지적으로 풍부해 보이고 저렴하다는 것이다. 작가는 여행의 목적이 좋은 책을 찾고 사는 것이라고 할 정도로, 책에 진심인 사람이다. 그가 고백하기로, 독일과 일본 유학으로 언어에 제약이 적다 보니 독서를 통한 지식 습득에 훨씬 유리하다고 했다.&lt;/p>
&lt;p>그렇다, 이런 이유로라도 나는 영어 하나만큼은 정말 편안하게 쓸 수 있도록 공부해야 겠단 생각이 들었다.&lt;/p>
&lt;h1 id="심리학-이야기">심리학 이야기&lt;/h1>
&lt;p>심리학 교수인 만큼 거의 모든 에피소드에 심리학 관련 내용이 붙어 있는데, 기억나는 몇 가지만 적는다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>평생 즐겨 듣게 되는 노래들은, 20대 전후로 형성된다는 연구가 있다.&lt;/strong> 김조한 노래를 듣다가 나도 모르게 무릎을 탁 쳤다.&lt;/li>
&lt;li>&lt;strong>걱정의 96%는 쓸데없는 것, 일어나지 않은 것에 대한 것이라고 한다.&lt;/strong> 걱정을 문장으로 풀어내서 가나다순으로 정렬하면, 걱정이 걱정이 아니게 된단다. 걱정의 개념화!&lt;/li>
&lt;li>&lt;strong>말을 중간에 끊는 것은 매우 무례한 일이다.&lt;/strong> 의사소통에서는 순서 주고받기가 중요한데, 내 순서를 뺏기면 인간은 은연중에라도 분노할 수 밖에 없다.&lt;/li>
&lt;li>나쁜 이야기에 끌리는 이유는, 원시적으로 생존에 유리한 정보를 더 잘 들으려 하기 때문이다. 하지만 현대 사회에서는 직접적인 위협이 아니니, 되도록 나쁜 이야기를 피해 다니자.&lt;/li>
&lt;li>나쁜 이야기를 전달하는 사람은, 타인의 반응으로 자신의 존재를 확인하려는 불안한 인간이다. 정 불안하면, 불안과 공포로부터 해방되고자 했던 것에서 출발한 &amp;lsquo;예술&amp;rsquo; 을 즐겨라. 미술관에 가거나 음악회를 가 보라.&lt;/li>
&lt;li>페이스북 창립 멤버가 고백하기를, &amp;lsquo;좋아요&amp;rsquo; 로 이어지는 시스템은 마치 술이나 도박같이 &amp;lsquo;도파민에 의한 단기 피드백&amp;rsquo; 의 올가미가 되었다고 한다. &lt;strong>인정 투쟁의 아주 쉽고 정량적인 결과물이다.&lt;/strong> 좋아요 개수로 인정받는 세상.&lt;/li>
&lt;li>자연인이 인기가 좋은 이유는, 자유 때문이다. 불 피우는 자유, 시선의 자유 때문이다. &lt;strong>남 눈치 안 봐도 되는 자유, 높은 데서 먼 곳을 조망할 수 있는 자유.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>책을 다 읽고 여전히 부러운 마음이 떠나진 않았지만, 나 역시도 슈필라움이 아주 없진 않구나 싶었다.&lt;/p>
&lt;p>아이들이 크면 어떻게 될지 모르겠지만, 지금은 재택근무를 핑계로 온전히 내가 쓸 수 있는 방이 있다. 피아노도 있고 책장도 있고 게임기도 있다. 아침에는 커피를 내리는 조그만 공간도 있고, 베란다에는 철봉과 작은 운동기구 그리고 이따금씩 물을 주는 화분들도 있다. 마음만 먹으면 무엇이든 할 수 있는 공간이 있으니 얼마나 다행인가. 원래부터 내가 이사오면서 조건을 내 걸긴 했지만, 이 책을 읽고는 지금 내 방이 꼭 필요했다는 걸 지지받은 기분이 들었다.&lt;/p>
&lt;p>발췌독이 효과를 발휘하려면 작가처럼 많은 책을 내 곁에 두고 돌려가며 읽어야 한다. 나는 아직 좋은 책을 찾는 선문안(選文眼) 이 부족하다 느껴져서 책을 많이 사진 않았는데, 내년부터는 즐거운 마음으로 취미생활 비용을 책 구입에 써 보는 것도 재밌겠단 생각을 했다. 주변인 중에 책 사는 것 자체를 취미로 하는 사람도 있고, 스팀 라이브러리를 채우기 위해 게임을 구매한다는 것보다는 훨씬 고상해 보이니까 (&amp;hellip;)&lt;/p>
&lt;p>오늘은 지금의 걱정거리를 일기에 죽 늘어놓고, 하나씩 &amp;lsquo;별거 아니네&amp;rsquo; 라는 코멘트를 달아봐야겠다.&lt;/p></description></item><item><title>Tistory 에서 다시 Hugo 로</title><link>https://interp.blog/return-to-hugo-from-tistory/</link><pubDate>Mon, 17 Oct 2022 18:47:14 +0900</pubDate><guid>https://interp.blog/return-to-hugo-from-tistory/</guid><description>&lt;img src="https://interp.blog/return-to-hugo-from-tistory/feature.jpeg" alt="Featured image of post Tistory 에서 다시 Hugo 로" />&lt;h2 id="티스토리로-갔던-이유">티스토리로 갔던 이유&lt;/h2>
&lt;p>휴고에서 티스토리로 옮긴 지 두 달 밖에 되지 않았었다.&lt;/p>
&lt;p>이유는 여러 가지가 있었다. Forestry 나 VSCode 를 열어두고 글인지 코드인지 모를 포스트를 쓰는 것이 귀찮아졌고, 하나부터 열까지 내가 조정해 줘야 하는 것 보다는 쉽게 글을 쓰고 싶어서였다. 주로 한글로 된 포스팅을 올릴 거라, 휴고에서 구축해 둔 다국어 기능을 전부 활용할 수 없겠단 생각도 들었다. 그리고 티스토리에 올려두면 적어도 다음이나 카카오에서는 검색이 좀 더 활발하지 않을까 하는, 더 많은 유입을 고려한 결정도 있었다.&lt;/p>
&lt;h2 id="다시-휴고로-돌아온-이유">다시 휴고로 돌아온 이유&lt;/h2>
&lt;p>그러나, 이번에는 확실히 휴고로 돌아왔다.&lt;/p>
&lt;p>이유는 너무나 단순하고 어이없게도, &lt;a class="link" href="https://cs.kakao.com/helps?service=102&amp;amp;category=286&amp;amp;locale=ko&amp;amp;device=3136&amp;amp;articleId=1073204770" target="_blank" rel="noopener"
>10월 15일 카카오가 사용하는 데이터센터에 화재가 발생&lt;/a>하면서 티스토리도 같이 서비스가 중단되었기 때문이다. 현재는 로그인도 되고 글도 살릴 수는 있지만, 모바일 보기만 지원되고 다른 스킨으로 적용도 되지 않는다.&lt;/p>
&lt;p>구글 애널리틱스는 너의 사이트가 이상하다며, 조치를 취하라는 이메일을 일요일에 발송했었다. 지금은 구글 검색에 다 빠져 있을 것이다. 대부분의 티스토리 포스트가 구글 검색에서 썰물처럼 빠지고 있기 때문이다.&lt;/p>
&lt;p>물론 복구가 된다면, 다시 포스트가 검색되고 아무렇지 않게 지나갈 수 있을 것이다. 그런데 그 이틀 동안, 나 뿐만 아니라 다른 포스팅까지 정전이 일어났다는 사실이 나에겐 너무 크게 느껴졌다. 어떻게 보면 별 것 아닐 수 있다. 서비스라는 것이 장애도 있고 종료도 있을 거니까. 그렇다면 이 질문을 하지 않을 수 없다.&lt;/p>
&lt;blockquote>
&lt;p>장애나 종료 이후에, 내가 쓴 글을 쉽게 백업받을 수 있을까? &lt;br/>
백업 받은 걸 다른 곳에 쉽게 올릴 수 있을까?&lt;/p>
&lt;/blockquote>
&lt;p>네이버 블로그에서는 포스트를 PDF 로 떨궈준다. Confluence 백업을 받아둬도 그걸 파싱해 가는 데 한 세월이다. 결국 마크다운 만큼 기본 내용만큼은 쉽게 다른 곳에 옮길 수 있는 포맷이 없다.&lt;/p>
&lt;p>물론 티스토리도 마크다운을 지원한다. 지금도 잘 옮겨뒀다. 하지만 장애가 이렇게 나 버리면, 옮길 수가 없다. Github Pages 에 올려 둔 Hugo 는 다르다. 일단 내 컴퓨터에 로컬 저장소가 있다. 적어도 거기서 출발하면 된다. 장애가 나면 서버를 열고, 거기에 소스를 부어서 시작해도 된다. 티스토리는 그게 안 된다.&lt;/p>
&lt;p>서비스형 블로그의 한계를 너무 꼬집는다 생각할 수 있다. 이번에 그 한계가 진짜구나, 어쩔 수 없겠다 싶으니 다시 가지 않을 것이다.&lt;/p>
&lt;h2 id="다시-처음-이유를-돌아보자">다시 처음 이유를 돌아보자&lt;/h2>
&lt;p>글인지 코드인지 모를 포스트를 쓰는 것은 극복해야 할 문제 같다. 다양한 자동화 기능과 snippet 을 동원해야 한다. 포스트 마다 설정 가능한 옵션 파라메터를 확보해야 한다. 다국어 기능은 쓸 수 있을 때 쓰면 된다. 너무 욕심낼 필요는 없다. 유입을 더 많이 바라보기 보다는, 포트폴리오 성격으로 꾸준히 쓰는 게 중요한 것 같다. 괜찮은 글은 한 번 봐주십사 요청도 하고 다니면 어떨까 싶다.&lt;/p>
&lt;p>플랫폼이 중요한 게 아니었다. 사실 디자인도 우선순위가 높은 작업이 아니다.&lt;/p>
&lt;p>결국 무슨 내용이 살고 있는지가 중요한 것 같다.&lt;/p></description></item><item><title>항상 앞부분만 쓰다가 그만두는 당신을 위한 어떻게든 글쓰기</title><link>https://interp.blog/writing-no-matter-what/</link><pubDate>Fri, 14 Oct 2022 10:01:07 +0900</pubDate><guid>https://interp.blog/writing-no-matter-what/</guid><description>&lt;img src="https://interp.blog/writing-no-matter-what/feature.jpeg" alt="Featured image of post 항상 앞부분만 쓰다가 그만두는 당신을 위한 어떻게든 글쓰기" />&lt;figure>
&lt;img loading="lazy" src="feature.jpeg" width="40%"/>
&lt;/figure>
&lt;p>빨간 책 표지보다도 묘하게 긴 제목, 그리고 고양이와 함께 글을 허둥지둥 쓰는 작가의 오너캐가 더욱 눈길을 끈다. 곽재식 작가의 글쓰기 에세이를 재밌게 읽어봤다. 나도 사실 이 분의 작품을 읽어본 건 아니었지만, 한동안 글쓰기 관련 책을 찾던 때에 &amp;lsquo;유퀴즈에 나왔던?&amp;rsquo; 하는 생각이 스쳐서 골라오게 되었다.&lt;/p>
&lt;p>&amp;lsquo;훌륭한 글&amp;rsquo; 을 쓰는 스킬이라기 보다, &amp;lsquo;글 자체&amp;rsquo; 를 꾸준히 쓸 수 있는 스킬을 알려준다는 점에서 책 제목과 통하는 면이 있다. 글을 쓰고는 싶은데, 시작도 못했거나 시작만 하고 끝을 못 냈다면.&lt;/p>
&lt;p>어떻게든 글을 쓰고 싶다면, 이 책이 도움이 될지도 모른다.&lt;/p>
&lt;h2 id="글쓰기-스킬-창고-대방출">글쓰기 스킬 창고 대방출!&lt;/h2>
&lt;p>책은 크게 네 부분으로 나뉘어, 글감을 찾는 방법, 글을 시작하는 방법, 글을 꾸미는 방법, 글을 꾸준히 쓸 수 있는 마음가짐을 공유한다.&lt;/p>
&lt;p>다시 말하지만, 이 책은 훌륭한 글이나 책을 쓰기 위한 나만의 필살기 같은 걸 알려주진 않는다. (그런게 과연 있을지, 있더라도 전수가 가능한지는 모르겠지만.) 그보다는, 다른 작가들도 늘 할 것만 같은, 어떤 초식들을 알려주는 데 집중한다. &lt;del>스킬이란게 별 게 없거든요&lt;/del>&lt;/p>
&lt;p>앞서 소개한 네 챕터 중, 글을 꾸미는 방법의 분량이 가장 적은데, 훌륭한 글을 쓰는데엔 결국 작가의 부던한 노력 (그리고 좋은 편집자를 만나 편집자의 말을 잘 따르는 것) 이 중요하다고 말하기 때문이다. 반대로, 작가 개인의 경험에 비춰 글감을 어떻게 찾는지, 그리고 글을 꾸준히 쓸 수 있는 마음가짐을 어떻게 유지할 수 있는지를 읽을 수 있다는 점이 차별점일 것이다.&lt;/p>
&lt;h2 id="글감을-찾는-방법--상상하기">글감을 찾는 방법 : 상상하기&lt;/h2>
&lt;p>작가는 소설을 위주로 펴내기 때문에, 소설을 쓸 때 필요한 방법을 많이 알려준다. 하지만 (책에서도 강조한 것 처럼) 물론 다른 유형의 글에도 효과적으로 적용할 수 있다고 믿는다.&lt;/p>
&lt;p>작가는 책 뿐만 아니라 영화를 참 많이 봐왔다고 한다. (영화 리뷰도 인터넷에 꾸준히 올렸다고 한다.) 이 영화의 좋은 점은 무엇이었을까, 나쁜 점은 무엇이었을까를 돌이켜 생각해 보면, 거기서 글쓰기에 대한 힌트를 얻을 수 있었다고 이야기한다. 좋은 점은 살리고, 나쁜 점은 피하고. 좋고 나쁨은 평론가나 대중의 생각이 아닌, 자신만의 느낌으로 선택해야 한다. 그리고 왜 선택했는지 정도는 기준이 있어야 한다. (이것만 나열해도 좋은 리뷰 글이 된다)&lt;/p>
&lt;p>좋은 부분을 차용해서 써도 되지만, 얼개를 그대로 가져다 쓰면 표절이나 다름 없으니 시대 배경이나 공간 배경을 바꿔보란 조언을 한다. 작가 말로는 &amp;lsquo;&lt;em>판을 바꿔친다&lt;/em>&amp;rsquo; 라고 한다. 정말 어디서부터 써야할지 모르겠다면, 가장 재밌게 봤던 내용을 그대로 써 보되 판을 바꿔치는 것을 추천했다. 나쁜 점은 무조건 피하라는 것도 아니다. 그중에서도, 나라면 저렇게 스토리를 안 짰을텐데 싶은 건 거기서 출발해서 새로운 글감으로 써도 된다.&lt;/p>
&lt;p>이런 건 비단 영화 뿐만 아니라 일상 사건에도 적용이 가능하다. 심지어는, 아무 일도 일어나지 않았지만 어떤 상상으로 스토리를 이끌어 낼 수도 있다. 가령, 지하철에서 할아버지께 자리를 양보했더니 별안간 &amp;lsquo;땡큐&amp;rsquo; 라고 하시곤, 앉아 계시는 내내 아무 말씀이 없으셨다고 하자 (진짜 어제 내 이야기다)&lt;/p>
&lt;blockquote>
&lt;p>이 할아버지는 우리나라 사람일까 아닐까? 그저 노인분들께서 으레 하시는, &amp;lsquo;고맙다&amp;rsquo; 라는 말로 전달하기엔 쑥쓰러움이 고마움이 뒤섞여 나온 흔한 수사일 뿐일까? 그렇다고 하기엔 발음이 꽤 정확한데다 숫기가 없었다.&lt;/p>
&lt;/blockquote>
&lt;p>정말 별 것 아닌데도 꼬리에 꼬리를 무는 질문과 묘사로 글이 써지기 시작하는게 느껴지지 않는가? &lt;del>나만 그런가&lt;/del>&lt;/p>
&lt;h2 id="메모와-백업의-힘">메모와 백업의 힘&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>소재가 생각나면 바로 메모하자&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>책에서 대놓고 강조하는 부분이다. &lt;strong>메모하지 않으면 소재는 다시 기억나지 않는다.&lt;/strong> 작가는 신발 끈을 묶다가 기가 막힌 아이디어가 떠올랐는데, 끈을 다 묶고 나니 그것이 전혀 기억나지 않았다고 했다. 나 또한 많이 겪었고, 아마 다른 분들도 비슷한 경험을 가지고 있으리라 믿는다.&lt;/p>
&lt;p>마지막 챕터에는 글 쓴 것을 잘 백업하자고 조언한다. 나는 이 백업을 글 뿐만 아니라 소재에도 적용해야 한다고 생각한다. 메모라는 것은 온라인으로 작성했건 노트에 끼적였건 간에, 수명이 굉장히 짧기 때문이다. 메모를 정리하고 발전하는 과정이 반드시 필요하며, 그걸 위해서는 (제텔카스텐 같은 본격적인 관리 기법 이전에) 언제 썼고 어떤 상황에 썼고 어떤 아이디어였는지 정도는 관리되어야 한다고 생각한다.&lt;/p>
&lt;p>그래야 메모가 지속되고, 글감을 찾아 헤맬 때 큰 도움이 될 수 있을 것이다&lt;/p>
&lt;h2 id="글을-끝까지-쓰는-방법--일단-써라">글을 끝까지 쓰는 방법 : 일단 써라&lt;/h2>
&lt;p>글을 그냥 써야 하는 이유는 마지막 챕터에 몰아서 설명한다.&lt;/p>
&lt;ul>
&lt;li>글을 쓰지 않으려는 핑계는 많을 수 밖에 없다.&lt;/li>
&lt;li>글의 질이 당장 떨어져도, 나중에 고치면 된다. 두려워 말고 써라.&lt;/li>
&lt;li>글의 질보다는, 빨리 마무리해 펴 내는 것이 중요한 세상에 살고 있다. (마감!)&lt;/li>
&lt;li>소설이나 에세이 책이 아니더라도, 블로그, SNS 에 짧은 글을 올릴 수 있다.&lt;br>
(그걸 엮어서 책으로 출판하는 세상이다)&lt;/li>
&lt;/ul>
&lt;p>하루에 한 시간, 일주일에 다섯 시간을 할애할 수 있다면 (작가 기준으로) 충분한 시간이라고 한다. 그것도 칼을 썰어내듯 한 시간 딱 채워 쓰지 말고, 아이디어가 샘솟을 때 멈추지 말고 쓰는 것을 추천했다. 작가는 한 번, 저녁에 시작한 글쓰기를 새벽 동이 다 틀 때 까지 한 적이 있다고 한다.&lt;/p>
&lt;p>나도 역시, 창의적인 일을 연달아 하거나, 일거리가 레고 블록처럼 딱딱 맞아 떨어질 때에는 쉬지 않는다. 이 때는 머리도 잘 돌아가고 환경도 받쳐주는, 소위 물 들어오는 때이기 때문에 노를 멈추는 것이 손해라고 생각하기 때문이다.&lt;/p>
&lt;hr>
&lt;p>아직 읽어야 할 글쓰기 책이 더 많이 남았지만, 내가 읽었던 책 중에서 어떤 책이 가장 쉬웠냐고 묻는다면 이 책을 주저없이 꼽을 수 있겠다. 글쓰기 책들이 공통적으로 조언하는 &amp;lsquo;써봐야 안다&amp;rsquo; 는 것을 여기서도 찾아 볼 수 있었지만, 곽재식 작가는 좀 더 친근하게, 자신의 경험담을 살려서 알려주기에 책이 좀 더 쉽게 읽혔던 것 같다.&lt;/p>
&lt;p>끝으로 작가가 추천하는 정말 정말 쓸 소재가 없거나 이야기가 막혔을 때 하는 방법을 소개한다. &lt;em>그냥 고양이 이야기를 써라&lt;/em>. 독자들에게 한 동안 고양이는 인기가 있을 법 하다며. 고양이는 귀여우니까? 🤣&lt;/p></description></item><item><title>25살에 알았더라면 좋았을 14가지</title><link>https://interp.blog/25%EC%82%B4%EC%97%90-%EC%95%8C%EC%95%98%EB%8D%94%EB%9D%BC%EB%A9%B4-%EC%A2%8B%EC%95%98%EC%9D%84-14%EA%B0%80%EC%A7%80/</link><pubDate>Thu, 13 Oct 2022 09:05:22 +0900</pubDate><guid>https://interp.blog/25%EC%82%B4%EC%97%90-%EC%95%8C%EC%95%98%EB%8D%94%EB%9D%BC%EB%A9%B4-%EC%A2%8B%EC%95%98%EC%9D%84-14%EA%B0%80%EC%A7%80/</guid><description>&lt;img src="https://interp.blog/25%EC%82%B4%EC%97%90-%EC%95%8C%EC%95%98%EB%8D%94%EB%9D%BC%EB%A9%B4-%EC%A2%8B%EC%95%98%EC%9D%84-14%EA%B0%80%EC%A7%80/feature.jpg" alt="Featured image of post 25살에 알았더라면 좋았을 14가지" />&lt;p>&lt;a class="link" href="https://medium.com/@iamalexmathers/14-things-i-wish-i-knew-at-25-now-that-im-38-b9796e9ba574" target="_blank" rel="noopener"
>Alex Mathers 의 medium 글&lt;/a> 을 간추린 것이다. 저자는 38살 생일에 이 글을 썼다고 한다.&lt;/p>
&lt;h1 id="여러분의-가치를-키우는-데-집중해라">여러분의 가치를 키우는 데 집중해라&lt;/h1>
&lt;p>행복을 찾는 일, 열정을 불러 일으키는 일들을 모두 따라가는 것은 중요하지만, 전부 다 할 수 없다. 오히려 독이 된다. 물론 다양한 것을 시도하는 것은 좋다. 그 중에서 여러분의 가치를 창출하는 데 집중해야 한다.&lt;/p>
&lt;h1 id="돈을-저축해라">돈을 저축해라&lt;/h1>
&lt;p>젊을 때는 저축에 무관심해 질 수 있지만, &lt;strong>돈은 시간을 먹고 자라기 때문에&lt;/strong> 젊을 때 부터 펀드에 적립하거나 투자에 관심을 보여야 한다.&lt;/p>
&lt;h1 id="너의-모든-것을-고칠-필요는-없다">너의 모든 것을 고칠 필요는 없다&lt;/h1>
&lt;p>여러분의 &amp;lsquo;문제&amp;rsquo; 에 대해 개선하라고 말하는 사람은 잠시 무시해도 좋다. 사실 여러분은 전혀 틀리지 않았다. 앙금이나 트라우마를 안고 사는 것은, 여러분의 한계를 제한하는 것이다. &lt;strong>경험을 쌓고, 다른 사람을 행복하게 만들고 멋진 걸 만드는 데에도 시간은 부족하다.&lt;/strong>&lt;/p>
&lt;h1 id="사회는-너를-약하고-우울하게-만드려-한다">사회는 너를 약하고, 우울하게 만드려 한다&lt;/h1>
&lt;p>네가 옳다는 것을 따라가고, 군중의 트렌드를 좆을 필요 없다. 무시해라.&lt;/p>
&lt;h1 id="대중매체-mainstream-의-어느-것도-믿지-마라">대중매체 (mainstream) 의 어느 것도 믿지 마라&lt;/h1>
&lt;p>대중매체는 엔터테인먼트 그 이상도 이하도 아니다. 그건 여러분을 겁주기 위해 만들어져 있어서, 대중매체가 제시하는 해답에 의존하게 만든다. 대중 매체가 아니라, &lt;strong>행복하게 사는 사람들로부터 충고나 동기부여를 얻어라.&lt;/strong>&lt;/p>
&lt;h1 id="자극이-되는-일에-너무-의존하지-마라">자극이 되는 일에 너무 의존하지 마라&lt;/h1>
&lt;p>자극이 되는 일은 인생에서 주연이 되려고 노력하기 때문에, 여러분을 제한할 것이다. 이를테면 포르노, 설탕, 커피, 니코틴, 비디오 게임 같은 것들 말이다. 더 적게 의존할 수록, 여러분은 더욱 자유로워질 것이다.&lt;/p>
&lt;p>필요한 때때로 즐기는 건 아무 상관이 없다. 하지만 여기에 의존해선 안 된다.&lt;/p>
&lt;h1 id="다른-사람을-행복하게-만드는데-집중해라">다른 사람을 행복하게 만드는데 집중해라&lt;/h1>
&lt;p>우리는 나르시시즘 문화에서 살고 있다. 이런 문화에 맞서서, 자신을 사랑하는 것보다는 다른 사람의 인생을 가꾸는데 집중하기 시작하라. 행복해 질 것이다.&lt;/p>
&lt;h1 id="감정-조절은-가장-중요한-스킬이다">감정 조절은 가장 중요한 스킬이다.&lt;/h1>
&lt;p>어떤 순간에 갑자기 욱하게 된다면, 여러분은 반드시 해야 할 일이 있는 것이다. 이런 기질은 여러분 인생을 완전히 무너뜨릴 것이다. &lt;strong>고요한 상태로 돌아가는 습관을 개발하는 것&lt;/strong>, 이것이 여러분이 키워야 할 가장 중요한 스킬이다.&lt;/p>
&lt;h1 id="한-가지-일에-특출나도록-해라">한 가지 일에 특출나도록 해라&lt;/h1>
&lt;p>수백가지를 시도하면서 어느 일에도 능숙하지 못한 것보다는, 한 가지 일에 특출나야 한다. 경험, 스킬을 다양화하는 것은 당연히 좋지만, 이렇게 해서는 한 가지 분야에 대한 마스터가 될 수 없다. &lt;strong>세상은 전문가를 원한다&lt;/strong>.&lt;/p>
&lt;h1 id="아무도-믿지-마라-하지만-품위있게-행동해라">아무도 믿지 마라, 하지만 품위있게 행동해라&lt;/h1>
&lt;p>이 말은 소시오패스가 되라는 말이 아니다. 여러분의 시간, 에너지, 자원을 보호하란 말이다. 그러니까, 사납게 굴 필요 없다. 상냥하고 공손하게 하되, 그런다고 해서 어느 누구에게도 신뢰를 받을 수 없다는 사실을 기억하면 된다.&lt;/p>
&lt;h1 id="멈추는-걸-멈취라">멈추는 걸 멈취라&lt;/h1>
&lt;p>신기한 것들에 몹시 흥분하지만, 이내 그 기분은 식고 (wear off) 다음 빛나는 걸 찾으러 떠난다. 이렇게 자주 멈춰서는 안 된다. 한 곳에 지루하게 머물 수 있는 힘을 키워야 한다.&lt;/p>
&lt;h1 id="몇년동안-너를-꼼짝-못하게-할-선택을-하지-마라">몇년동안 너를 꼼짝 못하게 할 선택을 하지 마라&lt;/h1>
&lt;p>매우 비싼 결정을 해야 할 상황이 있다면, 그 결정을 피해라. 가장 나쁜 결과를 예측할 수 있고 다룰 자신이 있다면, 무슨 수단을 써서라도 시도해라. 그렇지 않다면 (조금만 불분명한 부분이 있다면) 물러나라.&lt;/p>
&lt;h1 id="운동해라">운동해라&lt;/h1>
&lt;p>건강해지는 것은, 30대에 시작할 습관이어서는 안 된다. &lt;strong>지금 해야 한다.&lt;/strong> 지금 운동하고 식이습관을 개선하면, 30대가 될 늙은 몸이 정말 고마워 할 것이다. 게다가, 20대를 매우 x4 활기차게 보낼 수 있다.&lt;/p>
&lt;h1 id="집을-떠나-독립하라">집을 떠나 독립하라&lt;/h1>
&lt;p>고향에서 다른 지방으로 떠나는 것은 여러분을 불안하게 만들 수 있지만, 그것보다 더 큰 의미가 있다. 지구촌 세상에서, 지리적으로 자유로워지는 것에 견디기 힘들다면 당신은 결코 자유롭지 못할 것이다.&lt;/p></description></item><item><title>screen, tmux, 그리고 byobu</title><link>https://interp.blog/terminal-multiplexer-screen-tmux-byobu/</link><pubDate>Wed, 12 Oct 2022 08:57:42 +0900</pubDate><guid>https://interp.blog/terminal-multiplexer-screen-tmux-byobu/</guid><description>&lt;img src="https://interp.blog/terminal-multiplexer-screen-tmux-byobu/feature.jpg" alt="Featured image of post screen, tmux, 그리고 byobu" />&lt;p>개발자들은 전통적으로 워크스테이션이나 서버에 단말기를 접속해서 개발을 진행해 왔다. 이 때 사용되는 기기를 단말, 터미널 (terminal) 이라고 했다. 과거에는 컴퓨팅 파워를 구성하는 단가가 비쌌기 때문에, 저사양의 단말 컴퓨터를 가지고 상대적으로 고사양의 서버에 접속해 일을 하는 것이다.&lt;/p>
&lt;p>물론 지금은 PC 나 노트북 역시 충분히 고사양이긴 하다. 그래도 여전히 훨씬 더 효율적이고 강력한 서버 컴퓨터가 조직마다 존재하고, 클라우드 컴퓨팅으로 인해 자원을 필요할 때 마다 (on-demand) 빌려 쓸 수 있는 시대이다. 그렇기에 터미널은 여전히 유효하고, SSH 프로토콜로 통신하는 터미널 프로그램으로 남아있게 된다.&lt;/p>
&lt;p>어디서든, 어떤 단말로도 서버에 (또는 클라우드 VM 에) 접속할 수 있다는 것은 장점이지만, 네트워크 연결이 끊기거나 다른 단말로 다시 접속하게 되면 새로운 SSH 세션이 시작되고, 텅 빈 화면에서 다시 시작하게 되는 문제가 동시에 존재한다.&lt;/p>
&lt;p>또 한 가지 문제는, 한 화면에 하나의 세션만 열 수 있다는 것이다. 아니, 지금은 다양한 터미널 프로그램에서 &amp;lsquo;다중 윈도우, 다중 탭&amp;rsquo; 을 지원하는데, 그래서 여러 세션으로 넘나드는 게 가능한데 이게 무슨 문제일까? 그런 GUI 도 없는 유닉스/리눅스 시절엔 문제였다&amp;hellip;&lt;/p>
&lt;p>이 두 문제를 해결해 줄 Terminal Multiplexer 에 대해 알아보자.&lt;/p>
&lt;h2 id="terminal-multiplexer--tmux-screen">Terminal Multiplexer : tmux, screen&lt;/h2>
&lt;p>우선 흔히들 쓰는 tmux 의 매뉴얼 첫 설명을 보자.&lt;/p>
&lt;blockquote>
&lt;p>tmux is a terminal multiplexer: it enables a number of terminals to be created, accessed, and controlled from a single screen. &lt;strong>tmux may be detached from a screen and continue running in the background, then later reattached&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>터미널을 다중화해서, 한 화면에 여러 개의 터미널을 다룰 수 있다고 한다. 그리고 이 터미널 조합은 프로세스로 떠 있어서, (프로세스가 죽지 않는 한) 서버에 재접속 해서 해당 터미널 조합을 그대로 쓸 수 있다는 것이다.&lt;/p>
&lt;p>screen 의 설명은 조금 더 길고 복잡하다. (그래서 tmux 설명을 먼저 소개했다) 그 중에서 소개글을 발췌해 보면 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>Screen is a full-screen window manager that multiplexes a physical terminal between several processes (typically interactive shells). When &lt;code>screen&lt;/code> is called, it creates a single window with a shell in it (or the specified command) and then gets out of your way so that you can use the program as you normally would.&lt;/p>
&lt;p>Then, at any time, you can create new (full-screen) windows with other programs in them (including more shells), kill existing windows, view a list of windows, turn output logging on and off, copy-and-paste text between windows, view the scrollback history, switch between windows in whatever manner you wish, etc.&lt;/p>
&lt;p>&lt;strong>All windows run their programs completely independent of each other&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>screen 에서는 여러 터미널이 윈도우라는 개념으로 나뉘어지며, 여기서 실행하는 프로그램은 완전히 독립된다는 것을 강조한다.&lt;/p>
&lt;p>각자 다른 특징을 지닌 것 같지만, 결국 둘 모두 terminal multiplexer 라는 것은 변함이 없고, 앞서 언급한 특성들을 모두 공유한다. 즉, 서론에서 이야기한 문제를 전부 해결해 줄 수 있는 특징이 있다.&lt;/p>
&lt;ol>
&lt;li>여러 터미널을 한 화면에 띄우고, 관리할 수 있다.&lt;/li>
&lt;li>이 터미널 조합은, 서버에 재 접속해서 그대로 쓸 수 있다.&lt;/li>
&lt;li>각 터미널 안에서 수행하는 작업들은 철저히 독립적이다.&lt;/li>
&lt;/ol>
&lt;p>개인적으로 두 개 중 어느 것을 써도 문제는 없을 것 같다. 몇몇은 screen 에서 최신 기능이나 자잘한 것들이 지원되지 않는다는 사람도 있었고, 몇몇은 screen 을 계속 써와서 굳이 바꿔야 할 이유를 찾지 못했다는 이야기도 들었으니까.&lt;/p>
&lt;h2 id="byobu">byobu&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.byobu.org" target="_blank" rel="noopener"
>https://www.byobu.org&lt;/a>&lt;/p>
&lt;p>byobu 는 병풍(屏風)이라는 뜻의 일본어 독음이다. Canonical 에서 우분투 서버와 클라우드 팀에 있는 Dustin Kirkland 의 개인 프로젝트 라고 한다. (와우&amp;hellip;)&lt;/p>
&lt;p>이 프로그램은 &lt;strong>tmux 와 screen 의 wrapper&lt;/strong> 라고 보면 된다. 즉, 두 multiplexer 중 하나를 좀 더 쉽고 간단하게 쓸 수 있도록 만든 것이다. 처음에 실행하면, 둘 중 어느 것을 쓸 것인지 선택할 수 있다.&lt;/p>
&lt;h3 id="설치-방법">설치 방법&lt;/h3>
&lt;p>나는 brew 를 설치한 다음에 byobu 를 설치했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">/bin/bash -c &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="c1"># install brew into ~/.linuxbre&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;eval &amp;#34;$($HOME/.linuxbrew/bin/brew shellenv)&amp;#34;&amp;#39;&lt;/span> &amp;gt;&amp;gt; ~/.zshrc
brew install byobu
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="사용-방법">사용 방법&lt;/h3>
&lt;p>유튜브 튜토리얼 영상을 보면, 모짜르트 교향곡과 함께 윈도우를 화려하게 넘나드는 것을 볼 수 있다.&lt;/p>
&lt;p>&lt;code>man byobu&lt;/code> 를 입력해서 매뉴얼을 열어보자. 여기서 단축키 리스트를 알려주긴 하, 당장 내가 자주 쓰는 단축키는 이 정도다.&lt;/p>
&lt;ul>
&lt;li>F2 : 새로운 윈도우를 만든다. 이 때 새로운 세션을 시작한다.&lt;/li>
&lt;li>F3/F4 : 이전/다음 윈도우로 포커스를 이동한다.&lt;/li>
&lt;li>Shift+F2 : 스크린을 상/하로 분할해, 아래쪽에 새로운 세션을 시작한다.&lt;/li>
&lt;li>Ctrl+F2 : 스크린을 좌/우로 분할해, 오른쪽에 새로운 세션을 시작한다.&lt;/li>
&lt;li>Shift+F3/F4 : 이전/다음 스크린으로 포커스를 이동한다.&lt;/li>
&lt;li>F7 : 스크롤백 모드로 전환한다. 방향키 또는 PageUp/Dn 를 이동해 화면을 스크롤할 수 있고, Enter 를 치면 종료된다.
&lt;ul>
&lt;li>복사 : Spacebar 를 누르면 커서부터 블록을 잡을 수 있다. 블록을 다 잡고 나서 Enter 를 누르면 복사가 된다&lt;/li>
&lt;li>붙여넣기 : Alt+Insert (나는 안 됐음 ㅜㅜ) &lt;strong>Ctrl+a 누른 후 ]&lt;/strong> (이게 잘 됨!)&lt;br>
(iterm2 의 경우, applications in terminal may access clipboard 옵션을 켜줘야 함)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="접속하면-자동으로-byobu-실행하기">접속하면, 자동으로 byobu 실행하기&lt;/h3>
&lt;p>접속하자 마자 byobu 를 실행하려면 아래를 입력하면 되는데,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">byobu-enable
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>man byobu-launcher-install&lt;/code> 을 보면 알겠지만, 이게 &lt;code>~/.profile&lt;/code> 에 내용이 추가되는 거라서, shell 설정에 따라서는 적용 자체가 안 될 수도 있다. &lt;code>~/.profile&lt;/code> 의 마지막 줄 내용을 &lt;code>~/.bashrc&lt;/code> 또는 &lt;code>~/.zshrc&lt;/code> 에 옮겨줘야 한다.&lt;/p>
&lt;h3 id="macos-에서-ctrl-키가-먹지-않을-때">macOS 에서 Ctrl 키가 먹지 않을 때&lt;/h3>
&lt;p>매뉴얼에서 나오는 Ctrl+F2 단축키가 맥북에서는 먹질 않는다. Ctrl 이 인식되지 않는다기 보단 Function Key 인식에 문제가 있는 것 같다. (그렇다고 Ctrl+Fn+F2 를 누르면 F2 효과가 난다..)&lt;/p>
&lt;p>그래서 아예 byobu 단축키를 수정했다. tmux 를 쓴다고 가정했을 때, 아래 파일을 열어보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># assume that you&amp;#39;re using with tmux&lt;/span>
vi &lt;span class="nv">$BYOBU_PREFIX&lt;/span>/share/byobu/keybindings/f-keys.tmux
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 &lt;code>C-F2&lt;/code> 따위의 키워드를 검색할 수 있는데, 이걸 Function Key 가 들어가지 않는 조합으로 바꿔주자.&lt;/p>
&lt;p>참고 : &lt;a class="link" href="https://askubuntu.com/questions/969846/ubuntu-server-using-byobu-ctrlf2-does-not-split-screen-in-vertical" target="_blank" rel="noopener"
>https://askubuntu.com/questions/969846/ubuntu-server-using-byobu-ctrlf2-does-not-split-screen-in-vertical&lt;/a>&lt;/p></description></item><item><title>Golang: errors.new() vs. fmt.Errorf()</title><link>https://interp.blog/golang-errorsnew-fmterrorf/</link><pubDate>Tue, 04 Oct 2022 09:01:55 +0900</pubDate><guid>https://interp.blog/golang-errorsnew-fmterrorf/</guid><description>&lt;p>두 함수 호출 모두 error 를 리턴하지만, 어디서는 &lt;code>errors.new()&lt;/code> 를 쓰고 다른 데서는 &lt;code>fmt.Errorf()&lt;/code> 를 써서 헷갈렸다. &lt;a class="link" href="https://www.digitalocean.com/community/tutorials/how-to-add-extra-information-to-errors-in-go" target="_blank" rel="noopener"
>링크&lt;/a>에서 확인한 결과, 아래와 같은 설명이 되어 있었다.&lt;/p>
&lt;blockquote>
&lt;p>Generally, when creating a sentinel error value, the &lt;a class="link" href="https://pkg.go.dev/errors#New" target="_blank" rel="noopener"
>errors.New&lt;/a> function from the &lt;a class="link" href="https://pkg.go.dev/errors" target="_blank" rel="noopener"
>errors&lt;/a> package is used instead of the &lt;code>fmt.Errorf&lt;/code> function you’ve been using thus far.&lt;/p>
&lt;p>&lt;strong>Using &lt;code>errors.New&lt;/code> instead of &lt;code>fmt.Errorf&lt;/code> does not make any foundational changes to how the error works&lt;/strong>, though, and both functions could be used interchangeably most of the time.&lt;/p>
&lt;p>The biggest difference between the two is the &lt;code>errors.New&lt;/code> function will only create an error with a static message, and &lt;strong>the &lt;code>fmt.Errorf&lt;/code> function allows formatting the string with values&lt;/strong>, similar to &lt;code>fmt.Printf&lt;/code> or &lt;code>fmt.Sprintf&lt;/code>. Since sentinel errors are fundamental errors with values that don’t change, it’s common to use errors.New to create them.&lt;/p>
&lt;/blockquote>
&lt;p>두 함수 호출로 리턴되는 error 에 특별한 차이는 없지만, &lt;strong>포맷이 필요하면 fmt.Errorf, 포맷이 필요없는 static error message 라면 errors.New&lt;/strong> 를 쓰는 것이다.&lt;/p></description></item><item><title>사진 찍는 힐링 게임, TOEM</title><link>https://interp.blog/ps5-toem/</link><pubDate>Tue, 04 Oct 2022 08:46:59 +0900</pubDate><guid>https://interp.blog/ps5-toem/</guid><description>&lt;img src="https://interp.blog/ps5-toem/feature.jpg" alt="Featured image of post 사진 찍는 힐링 게임, TOEM" />&lt;figure>
&lt;img loading="lazy" src="feature.jpg" width="50%"/>
&lt;/figure>
&lt;p>TOEM 은 플레이스테이션5 로 출시되었고, 흑백의 귀여운 캐릭터들과 다양한 이야깃거리가 가득한, &lt;strong>사진 여행 어드벤처 게임&lt;/strong>이다.&lt;/p>
&lt;p>주인공은, 할머니가 보았던 아름다운 TOEM 의 광경을 사진에 담아오기 위해 여행을 떠난다. 공짜 버스를 타기 위해선 들르는 마을마다 사람들을 도와줘야 한다.&lt;/p>
&lt;h3 id="첫-인상--hidden-folks">첫 인상 : Hidden folks?&lt;/h3>
&lt;figure>
&lt;img loading="lazy" src="hiddenfolks.jpg"/>
&lt;/figure>
&lt;p>흑백이기 때문에, 개인적으로 iOS 앱으로 출시된 Hidden Folks 와 비슷한 이미지라고 느꼈다. 물론 장르 자체도 다르고 내러티브를 전달하는 방식이 다르지만, 그래픽이 워낙 비슷하고 결국 무언가를 찾아야 한다는 공통적인 목표 때문에 비슷하다고 느낄 수도 있겠다.&lt;/p>
&lt;h3 id="게임의-핵심--카메라">게임의 핵심 : 카메라&lt;/h3>
&lt;p>카메라를 활용한 플레이가 이 게임의 핵심이기 때문에, 사진 촬영으로 게임을 진행하는 것이 일반적이다. 여기에 더해, 뷰파인더로 물건 찾기나 사진기에 경적을 달아 울리기, 삼각대를 활용한 사진, 셀피, 갖가지 프레임과 필터를 활용하는 경우도 있어서 1인칭 슈터 장르를 섞은 듯하면서도 다양한 양상으로 게임을 풀어나갈 수도 있다. 한 가지 아쉬운 건, 프레임이나 필터 종류가 다양하지만 퀘스트만 하다 보면 다 활용하지 않게 되는 경우가 많다는 것이다.&lt;/p>
&lt;h3 id="힐링이-되었어요">힐링이 되었어요&lt;/h3>
&lt;p>이 게임은 기본적으로 힐링 게임을 목표로 한다. 카세트 테이프에는 잔잔하면서도 귀를 간지럽히는 다양한 배경 음악과 함께, 마을 사람~과 유령~들의 기상천외하고 귀여운 퀘스트를 하나씩 해나가다 보면, 산 정상에서 TOEM 을 어렵지 않게 볼 수 있다. 플래티넘 달성율이 말해주듯, 주변에 관심만 조금 더 기울인다면 트로피 난이도도 어렵지 않다. &lt;/p>
&lt;p>짧은 플레이 시간, 잔잔한 사운드, 귀여우면서도 소소하게 재밌는 내러티브를 느끼고 싶다면 주저없이 고를 수 있다. 반대로 도전적인 게임을 좋아한다거나, 지난한 찾기 퀘스트 따위에 시간 할애를 하기 싫어한다거나, 플레이스테이션 5가 없다면 (PS4도 안 된다) 이 게임은 추천할 수가 없겠다.&lt;/p></description></item><item><title>클로저 (Closure)</title><link>https://interp.blog/program-language-closure/</link><pubDate>Sun, 18 Sep 2022 08:33:23 +0900</pubDate><guid>https://interp.blog/program-language-closure/</guid><description>&lt;p>개발자 친구랑 이런저런 이야기를 하던 중, 내 리뷰가 리젝당한 경험담을 이어서 꺼내기 시작했다. &amp;ldquo;내가 클로저를 썼는데 리뷰어가 그게 뭐냐고, 함수로 빼달라고 하는거 있지?&amp;rdquo; 한참을 듣던 그 친구가 대뜸 이렇게 반문했다.&lt;/p>
&lt;blockquote>
&lt;p>그런데, 클로저가 뭐야?&lt;/p>
&lt;/blockquote>
&lt;p>&amp;ldquo;어&amp;hellip;그거 있잖아! 함수 안에 함수 만드는거! 그런데 그 함수 바깥도 참조할 수 있는거!&amp;rdquo; 라고 얼버무렸다. 그러고 나자 (친구는 가만히 있는데) 나 혼자 이런 생각이 들었다. &amp;lsquo;&lt;em>함수면 함수지 왜 안에다 만들어? 변수 참조는 왜 해? 리펙터링 하기 싫어서 필요한 건가?&lt;/em>&amp;rsquo; ㅠㅠ..&lt;/p>
&lt;p>일단 나부터 잘 모르고 쓰고 있다는 생각이 들어, 이참에 정리를 해 두려고 한다.&lt;/p>
&lt;h2 id="정의">정의&lt;/h2>
&lt;p>프로그래밍 언어에서 Closure 는, 함수 바깥에 있는 변수를 참조하는 함수 &amp;lsquo;값&amp;rsquo; 을 말한다. 한국어판 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%ED%81%B4%EB%A1%9C%EC%A0%80_%28%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%29" target="_blank" rel="noopener"
>위키백과 설명&lt;/a>을 보도록 하자.&lt;/p>
&lt;blockquote>
&lt;p>컴퓨터 언어에서 클로저(Closure)는 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4" target="_blank" rel="noopener"
>일급 객체 함수&lt;/a>(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다.&lt;br>
기능상으로, 클로저는 함수를 저장한 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EB%A0%88%EC%BD%94%EB%93%9C" target="_blank" rel="noopener"
>레코드&lt;/a>(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener"
>MDN&lt;/a> 에서 말하는 클로저의 정의는?&lt;/p>
&lt;blockquote>
&lt;p>A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the &lt;strong>lexical environment&lt;/strong>). In other words, a closure gives you access to an &lt;strong>outer function&amp;rsquo;s scope&lt;/strong> from an inner function.&lt;/p>
&lt;/blockquote>
&lt;figure>
&lt;img loading="lazy" src="giphy.webp"
alt="시방 저것이 뭔 소리여"/> &lt;figcaption>
&lt;p>&lt;del>시방 저것이 뭔 소리여&lt;/del>&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h2 id="golang-에서의-closure">Golang 에서의 Closure&lt;/h2>
&lt;p>백문이 불여일견, 일단 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">outer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">x&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">x&lt;/span>&lt;span class="o">++&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">x&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">inner_f&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">outer&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nf">inner_f&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nf">inner_f&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>inner_f() 가 &lt;strong>함수&lt;/strong>라면, 상태가 저장되는 곳이 있을 리 만무하며, 입력 값에 변화가 없기 때문에 (아예 입력 값 자체가 없다!) 두 번의 호출이 동일한 결과를 낼 것 같다. 하지만 현실은 그렇지 않다. 사실은, inner_f 는 함수가 아니라 &lt;strong>클로저&lt;/strong>이기 때문이다. &lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">1
2
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="일급-객체-일급-함수">일급 객체, 일급 함수&lt;/h2>
&lt;p>잠시 일급 객체라는 개념을 먼저 짚고 넘어가자. 일급 객체가 되려면, 세 가지 조건이 있다.&lt;/p>
&lt;ul>
&lt;li>변수에 담을 수 있는 것&lt;/li>
&lt;li>인자로 전달이 가능한 것&lt;/li>
&lt;li>반환값으로도 전달이 가능한 것&lt;/li>
&lt;/ul>
&lt;p>일급 함수는 함수형으로 된 일급 변수를 뜻하니까, 짧게 설명하면 &lt;strong>변수처럼 다룰 수 있는 함수&lt;/strong> 일급 함수라 할 수 있다. (&lt;a class="link" href="https://velog.io/@mgm-dev/%EC%9D%BC%EA%B8%89%ED%95%A8%EC%88%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" target="_blank" rel="noopener"
>참조&lt;/a>)&lt;/p>
&lt;p>대부분의 스크립트 프로그래밍 언어가 일급 함수를 취급하지만, 오래된 언어들 (기본 C, Algol&amp;hellip;) 은 위의 세 가지 조건 중 일부만 지원하기 때문에 일급 함수 취급이 불가능하다.&lt;/p>
&lt;h2 id="스코프">스코프&lt;/h2>
&lt;p>어떤 변수의 스코프는, 다른 말로 하면 변수가 어디까지 접근 가능한지를 나타낸 개념이다. 특정 변수의 수명 (lifetime) 으로도 나타내더라만, 나는 두 개념이 모두 포함된 것이라고 본다.&lt;/p>
&lt;p>앞서 본 것 처럼, 클로저는 함수가 선언된 스코프 (scope) 안에 선언된 어느 변수라도 접근이 가능하다. 즉, 함수 스코프의 상위 스코프 까지다. &lt;/p>
&lt;p>예제에서는 변수 x 가 이에 해당 한다. outer() 안에 선언된 클로저 안에는 x 가 없지만, 클로저가 선언된 스코프 (그러니까 outer() 전체) 에는 x 가 사용 가능하다. 물론 이건 클로저 역시 마찬가지다.&lt;/p>
&lt;p>수명 이야기를 했는데, outer() 가 호출되기 시작할 때 변수 x 는 스택에 쌓이고, 호출이 종료되면 x 는 스택에서 빠질 것이다. 하지만 클로저가 선언되어 있다면 이 변수 x 의 수명은 늘어나게 된다. 그럼 이렇게 수명이 늘어난 변수 x 는 어디에 저장될까?&lt;/p>
&lt;h2 id="자유-변수">자유 변수&lt;/h2>
&lt;p>클로저에서 숨어있는 개념이 바로 &amp;lsquo;&lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%9E%90%EC%9C%A0_%EB%B3%80%EC%88%98%EC%99%80_%EC%A2%85%EC%86%8D_%EB%B3%80%EC%88%98" target="_blank" rel="noopener"
>자유 변수 (free variable)&lt;/a>&amp;rsquo; 이다. 수식 속에서 상수로 치환이 가능한 변수를 말한다. 그 외의 변수는 전부 종속 변수 (bound variable) 이라고 말한다.&lt;/p>
&lt;p>클로저에서 말하는 자유 변수는, 클로저를 선언한 스코프 안에 위치한다. 쉽게 말하면, &lt;strong>자유 변수 = 클로저 바깥 변수&lt;/strong>다. 클로저가 그냥 함수였다면, 자유 변수가 어떤 값을 가지고 있건 상관 없이 작동해야 한다. (자유 변수라는 말 자체가 수학에서 나온 말이다) 이런 자유 변수로 인해 함수가 닫힐 수 있게 만든 것을, 우리는 클로저 (closure) 라고 부르는 것이다.&lt;/p>
&lt;p>클로저에겐 자유 변수가 필요충분 조건이다. 계속 살아있어야 한다.&lt;/p>
&lt;h2 id="다시-정의를-읽어보자">다시 정의를 읽어보자&lt;/h2>
&lt;blockquote>
&lt;p>컴퓨터 언어에서 클로저(Closure)는 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4" target="_blank" rel="noopener"
>일급 객체 함수&lt;/a>(first-class functions)의 개념을 이용하여, 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>참고로 일급 객체 함수와 클로저는 같은 말이 아니라, 일급 객체 함수 ∋ 클로저이다.&lt;/li>
&lt;li>스코프에 묶인 변수를 바인딩한다는 뜻은, 클로저가 사용할 수 있게 계속 유지한다는 말과 같을 것이다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>기능상으로, 클로저는 함수를 저장한 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EB%A0%88%EC%BD%94%EB%93%9C" target="_blank" rel="noopener"
>레코드&lt;/a>(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>클로저 = 함수를 저장한 레코드!&lt;/li>
&lt;li>스코프의 인수는, 달리 말하면 클로저가 선언된 스코프에 선언된 모든 변수/객체를 말한다. 이 것들이 클로저가 만들어질 때 (=선언될 때) 정의된다는 것이다. 어디에? 바로 레코드 안에.&lt;/li>
&lt;li>스코프 내의 영역이 실제로 소멸되는 시점은, 스코프가 호출이 끝난 시점 (=함수 호출이 끝난 시점) 일 것이다. 하지만 그 접근은 클로저 안에서는 영원히 계속될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>여기까지 해석해 보면, 간접적으로 메모리를 좀 더 쓸 것이라는 추측이 가능하다. 단순히 생각해도 지역 변수들의 수명이 클로저 때문에 계속 되도록 만들어야 하기 때문이다.&lt;/p>
&lt;p>MDN 정의도 다시 읽어보자. 이번엔 해석을 해 봤다.&lt;/p>
&lt;blockquote>
&lt;p>A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function&amp;rsquo;s scope from an inner function.&lt;br>
클로저란, 클로저를 둘러싼 상태 (사전적 환경) 와의 참조를 함께 넣어 묶은, 함수의 조합입니다. 다른 표현으로, 클로저를 통해 함수 내부에서 함수 외부로 접근을 가능하게 만들 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>클로저를 둘러싼 상태, lexical environment 라는 말들 전부 &lt;strong>클로저 바깥&lt;/strong>을 말한다. 사실 뒷 문장이 다 설명을 해 주고 있다.&lt;/p></description></item><item><title>VSCode Python 디버그 반응이 없을 때</title><link>https://interp.blog/vscode-python-debugging-no-response/</link><pubDate>Tue, 23 Aug 2022 22:26:07 +0900</pubDate><guid>https://interp.blog/vscode-python-debugging-no-response/</guid><description>&lt;img src="https://interp.blog/vscode-python-debugging-no-response/feature.png" alt="Featured image of post VSCode Python 디버그 반응이 없을 때" />&lt;h1 id="증상">증상&lt;/h1>
&lt;p>Visual Studio Code 에서 Python 파일을 디버깅 (debugging) 하려 하면, &lt;strong>아무런 반응이 없고 곧바로 종료된다.&lt;/strong> 그냥 실행 자체를 하지 않은 것 처럼 말이다..!&lt;/p>
&lt;h1 id="분석">분석&lt;/h1>
&lt;p>관련해서 메시지가 나타나지 않기 때문에, 단서를 찾기가 쉽진 않았다. 그나마 &amp;lsquo;&lt;em>Output&lt;/em>&amp;rsquo; 패널에 있는 &amp;lsquo;&lt;em>Python&lt;/em>&amp;rsquo; 에서 아래와 같은 로그가 한 줄 떠 있었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">DAP Server launched with command: /home/interp/work/project/venv/bin/python \
/home/interp/.vscode-server/extensions/ms-python.python-2022.12.1/pythonFiles/lib/python/debugpy/adapter
&lt;/code>&lt;/pre>&lt;/div>&lt;p>저기서 &lt;code>.. with command:&lt;/code> 이후의 명령어를 그대로 &lt;strong>터미널에서&lt;/strong> 입력해 보았다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">Traceback &lt;span class="o">(&lt;/span>most recent call last&lt;span class="o">)&lt;/span>:
File &lt;span class="s2">&amp;#34;/home/interp/.pyenv/versions/3.6.12/lib/python3.6/runpy.py&amp;#34;&lt;/span>, line 193, in _run_module_as_main
&lt;span class="s2">&amp;#34;__main__&amp;#34;&lt;/span>, mod_spec&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;/home/interp/.pyenv/versions/3.6.12/lib/python3.6/runpy.py&amp;#34;&lt;/span>, line 85, in _run_code
exec&lt;span class="o">(&lt;/span>code, run_globals&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;/home/interp/.vscode-server/extensions/ms-python.python-2022.12.1/pythonFiles/lib/python/debugpy/adapter/__main__.py&amp;#34;&lt;/span>, line 212, in &amp;lt;module&amp;gt;
__import__&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;debugpy&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;/home/interp/.vscode-server/extensions/ms-python.python-2022.12.1/pythonFiles/lib/python/debugpy/adapter/../../debugpy/__init__.py&amp;#34;&lt;/span>, line 28, in &amp;lt;module&amp;gt;
&lt;span class="s2">&amp;#34;Python 3.6 and below is not supported by this version of debugpy; &amp;#34;&lt;/span>
AssertionError: Python 3.6 and below is not supported by this version of debugpy&lt;span class="p">;&lt;/span> use debugpy 1.5.1 or earlier.
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="원인과-해결">원인과 해결&lt;/h1>
&lt;p>저기서 마지막 문장이 중요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">AssertionError: Python 3.6 and below is not supported by this version of debugpy; \
use debugpy 1.5.1 or earlier.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>찾아보니 Python Extension 에서 debugpy 버전을 업그레이드 했고, 더 이상 Python 3.6 에서 호환되지 않는 것이 문제였다. &lt;a class="link" href="https://marketplace.visualstudio.com/items/ms-python.python/changelog" target="_blank" rel="noopener"
>Changelog&lt;/a>를 보니, 2022.10.0 버전부터 debugpy 를 1.6.2 로 올린 것을 확인할 수 있었다.&lt;/p>
&lt;p>그러면 해결책은 간단하다. 원하는 대로 해주거나, 되돌아가거나.&lt;/p>
&lt;h2 id="1-python36-에서-버전-업그레이드">(1) Python3.6 에서 버전 업그레이드&lt;/h2>
&lt;p>가장 간단한 방법은 더 높은 버전의 Python을 설치하고, 해당 버전을 기본 환경으로 설정하면 된다.&lt;/p>
&lt;p>&lt;code>virtualenv&lt;/code> 없이 Python 버전만 바꾼다면, VSCode 에서 Command Palette (&lt;code>Ctrl/Cmd+Shift+P&lt;/code>) 를 열어서 &lt;strong>Python: Select Interpreter&lt;/strong> 를 선택하는 것으로 버전 선택이 가능하다.&lt;/p>
&lt;p>나는 &lt;code>virtualenv&lt;/code> 를 통해 개발 환경을 구성하기 때문에 아래와 같은 순서대로 업그레이드를 진행했다. 혹시 참고가 되길 바라며 정리해 둔다.&lt;/p>
&lt;ol>
&lt;li>(requirements.txt 따위로 관리하고 있지 않는다면) &lt;code>pip freeze &amp;gt; requirements.txt&lt;/code> 로 설치된 라이브러리 백업&lt;/li>
&lt;li>기존 virtualenv directory 삭제 (예: &lt;code>venv&lt;/code> 라고 가정하자)&lt;/li>
&lt;li>(python3.9 를 설치했다면) &lt;code>python3.9 -m virtualenv venv&lt;/code> 으로 virtualenv directory 생성&lt;/li>
&lt;li>&lt;code>source venv/bin/activate &amp;amp;&amp;amp; pip install -r requirements.txt&lt;/code> 로 라이브러리 재설치&lt;/li>
&lt;/ol>
&lt;h2 id="2-extension-다운그레이드-하기">(2) Extension 다운그레이드 하기&lt;/h2>
&lt;p>다른 해결책으로는, VSCode Python 의 Extension 버전을 다운그레이드 하는 방법이다.&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="downgrade.png#center"/>
&lt;/figure>
&lt;p>Extension 탭에서 Python 을 찾은 다음, &lt;strong>Install Another Version&lt;/strong> 을 선택한다. 잠시 기다리면, 버전 목록이 나타나며, 초록색 부분 (그 아래도 상관없음) 을 클릭하면 된다.&lt;/p>
&lt;p>하지만 별로 추천하고 싶진 않다. Python 3.10 까지 나온 마당에 특별한 이유가 없다면 (1) 번처럼 Python 버전을 올리는게 좋을 것 같다.&lt;/p>
&lt;h2 id="3-symbolic-link-경로-문제">(3) Symbolic link 경로 문제&lt;/h2>
&lt;p>혹시 (1) 이나 (2) 번을 전부 적용해도 (아니면 이미 Python 3.6 이상의 버전을 쓰고 있는데도) 디버깅이 안 된다면 이 해결책이 도움이 될 것이다.&lt;/p>
&lt;p>한 번은, symbolic link 경로로 workspace directory 를 열었을 때 디버깅 문제가 생겼었다. 반대로 말하면, symbolic link 경로가 아닌 &lt;strong>실제 directory 경로로 workspace 를 열어야&lt;/strong> 한다.&lt;/p>
&lt;p>예를 들어, &lt;code>/home/interp/&lt;/code> 는 사실 symbolic link 이고, 실제 경로는 &lt;code>/SSD/homes/interp&lt;/code> 이라고 가정하자. 그렇다면, &lt;em>File - Open Folder..&lt;/em> 메뉴로 directory 를 열 때, 다음 중 하나만 디버깅이 가능하다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>/home/interp/workspace_python&lt;/code> ❌&lt;/li>
&lt;li>&lt;code>/SSD/homes/interp/workspace_python&lt;/code> ✅&lt;/li>
&lt;/ul></description></item><item><title>BDD in Python: Behave</title><link>https://interp.blog/bdd-in-python-behave/</link><pubDate>Fri, 19 Aug 2022 09:00:36 +0900</pubDate><guid>https://interp.blog/bdd-in-python-behave/</guid><description>&lt;p>&lt;a class="link" href="https://interp.blog/bdd-behavior-driven-development/" >지난 포스팅&lt;/a>으로 BDD 는 어떤 개발방법론이고, 어떤 면에서 이 방법이 필요한지를 정리해 봤다. &lt;/p>
&lt;p>이번 포스팅을 시작으로, 직접 다양한 언어에서 BDD 를 적용하는 방법을 정리해 볼 예정이다. 첫 시간으로는 &lt;strong>파이썬&lt;/strong> (Python) 언어를 가지고 할 것이다. Python 라이브러리 중 하나인 &lt;a class="link" href="https://behave.readthedocs.io/en/stable/" target="_blank" rel="noopener"
>behave&lt;/a> 를 통해, BDD 테스트 프레임워크를 구성하고, 예제 시나리오를 만들어서 테스트 자동화가 어떻게 이뤄질 수 있을지 알아보자.&lt;/p>
&lt;h1 id="예제-프로젝트-생성">예제 프로젝트 생성&lt;/h1>
&lt;div style="background-color: var(--body-background); width: 98%; margin:1px; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
💡
&lt;/div>
&lt;div>
모든 명령어는 리눅스 OS 또는 WSL 환경에서 실행한다고 가정한다.
&lt;/div>
&lt;/div>
&lt;p>파이썬이 설치된 환경에서 다음과 같이 디렉터리만 만들면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir behave-test &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">cd&lt;/span> behave-test
&lt;/code>&lt;/pre>&lt;/div>&lt;p>나는 virtualenv 를 이용해 환경을 분리해 두도록 하겠다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">virtualenv venv
&lt;span class="nb">source&lt;/span> venv/bin/activate
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="behave-설치">behave 설치&lt;/h1>
&lt;p>&lt;code>pip install behave&lt;/code> 만 하면 된다.&lt;/p>
&lt;h1 id="featuressteps-디렉터리-생성">&lt;code>features/steps&lt;/code> 디렉터리 생성&lt;/h1>
&lt;p>behave 는 &lt;code>features/steps&lt;/code> 를 필요로 한다. 만들어 주자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir -p features/steps
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>디렉터리만 만들고 곧장 &lt;code>behave&lt;/code> 를 실행하면, &lt;code>ConfigError: No feature files in $(pwd)/features&lt;/code> 라는 메시지가 뜰 것이다.&lt;/p>
&lt;h1 id="feature-파일-만들기">&lt;code>.feature&lt;/code> 파일 만들기&lt;/h1>
&lt;p>&lt;code>features/hotdog.feature&lt;/code> 라는 파일을 하나 만들어보자. 핫도그 12개에서 5개를 먹으면 반드시 7개가 남아야 한다는 내용이다. 단순 영어로 되어 있지만, 문법에 대해 더 자세히 알고 싶다면 &lt;a class="link" href="https://interp.tistory.com/entry/BDD-%EC%9D%98%EB%AF%B8%EC%99%80-%ED%95%84%EC%9A%94%EC%84%B1" target="_blank" rel="noopener"
>이전 포스팅&lt;/a>을 꼭 참고하고 오자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gherkin" data-lang="gherkin">&lt;span class="k">Feature:&lt;/span>&lt;span class="nf"> eat hotdogs
&lt;/span>&lt;span class="nf">
&lt;/span>&lt;span class="nf"> &lt;/span>&lt;span class="k">Scenario:&lt;/span>&lt;span class="nf"> Eat 5 out of 12
&lt;/span>&lt;span class="nf">&lt;/span>&lt;span class="k"> Given &lt;/span>&lt;span class="nf">there are &lt;/span>&lt;span class="s">12&lt;/span>&lt;span class="nf"> hotdogs
&lt;/span>&lt;span class="nf"> &lt;/span>&lt;span class="k">When &lt;/span>&lt;span class="nf">I eat &lt;/span>&lt;span class="s">5&lt;/span>&lt;span class="nf">
&lt;/span>&lt;span class="nf"> &lt;/span>&lt;span class="k">Then &lt;/span>&lt;span class="nf">there should be &lt;/span>&lt;span class="s">7&lt;/span>&lt;span class="nf"> remaining
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>이제 다시 &lt;code>behave&lt;/code> 를 실행하면, 아래 구조로 되어 있는 테스트 파일이 존재하지 않다고 하면서, 스니펫 (snippet) 을 출력해 주고 내부를 구현해 달라고 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># None&lt;/span>
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># None&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># None&lt;/span>
Failing scenarios:
features/hotdog.feature:3 Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span>
&lt;span class="m">0&lt;/span> features passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> scenarios passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> steps passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped, &lt;span class="m">3&lt;/span> undefined
Took 0m0.000s
You can implement step definitions &lt;span class="k">for&lt;/span> undefined steps with these snippets:
@given&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
def step_impl&lt;span class="o">(&lt;/span>context&lt;span class="o">)&lt;/span>:
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: Given there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
@when&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;I eat 5&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
def step_impl&lt;span class="o">(&lt;/span>context&lt;span class="o">)&lt;/span>:
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: When I eat 5&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
@then&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
def step_impl&lt;span class="o">(&lt;/span>context&lt;span class="o">)&lt;/span>:
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: Then there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="테스트-python-파일-만들기">테스트 Python 파일 만들기&lt;/h1>
&lt;p>방금 출력된 내용을 단순히 복사해서 &lt;code>features/steps/hotdog.py&lt;/code> 라는 파일을 만들었다. 참고로 파일 이름은 상관없지만 반드시 &lt;code>features/steps&lt;/code> 디렉터리에 위치해야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">behave&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="o">*&lt;/span>
&lt;span class="nd">@given&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">NotImplementedError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;STEP: Given there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@when&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;I eat 5&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">NotImplementedError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;STEP: When I eat 5&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">NotImplementedError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;STEP: Then there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>시나리오의 각 구절 (&lt;em>GIVEN, WHEN, THEN&lt;/em>) 에 연결되는 기준은, 각 method 에 위치한 decorator 인 &lt;code>@given&lt;/code>, &lt;code>@when&lt;/code>, &lt;code>@then&lt;/code> 에 따라 달려있기 때문에, 파일 이름은 상관없고 해당 decorator 만 수정하지 않으면 된다. &lt;/p>
&lt;p>그리고 주의할 것은, 반드시 맨 위에 &lt;code>from behave import *&lt;/code> 와 같이 &lt;code>behave&lt;/code> 라이브러리를 import 해야 한다는 것이다.&lt;/p>
&lt;hr>
&lt;p>이렇게 하고 다시 &lt;code>behave&lt;/code> 를 실행하면, 예상대로 &lt;code>NotImplementedError&lt;/code> exception 이 발생하면서 traceback 이 출력되고, 테스트는 실패한 것으로 간주한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
Traceback &lt;span class="o">(&lt;/span>most recent call last&lt;span class="o">)&lt;/span>:
File &lt;span class="s2">&amp;#34;/home/behave-test/venv/lib/python3.6/site-packages/behave/model.py&amp;#34;&lt;/span>, line 1329, in run
match.run&lt;span class="o">(&lt;/span>runner.context&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;/home/behave-test/venv/lib/python3.6/site-packages/behave/matchers.py&amp;#34;&lt;/span>, line 98, in run
self.func&lt;span class="o">(&lt;/span>context, *args, **kwargs&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;features/steps/hotdog.py&amp;#34;&lt;/span>, line 5, in step_impl
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: Given there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
NotImplementedError: STEP: Given there are &lt;span class="m">12&lt;/span> hotdogs
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># None&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># None&lt;/span>
Failing scenarios:
features/hotdog.feature:3 Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span>
&lt;span class="m">0&lt;/span> features passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> scenarios passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> steps passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">2&lt;/span> skipped, &lt;span class="m">0&lt;/span> undefined
Took 0m0.000s
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="테스트-파일-구현하기">테스트 파일 구현하기&lt;/h1>
&lt;p>이제 테스트 파일 안의 method 를 구현해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">behave&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="o">*&lt;/span>
&lt;span class="nd">@given&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there are &lt;/span>&lt;span class="si">{num_hotdog}&lt;/span>&lt;span class="s1"> hotdogs&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_hotdog&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hotdogs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_hotdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@when&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;I eat &lt;/span>&lt;span class="si">{eaten_hotdog}&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">eaten_hotdog&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hotdogs&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">eaten_hotdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there should be &lt;/span>&lt;span class="si">{remaining_hotdog}&lt;/span>&lt;span class="s1"> remaining&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">remaining_hotdog&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">assert&lt;/span> &lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hotdogs&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">remaining_hotdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>decorator 에서 숫자를 나타내는 부분을 &lt;code>num_hotdog&lt;/code> 같은 식으로 파라메터로 치환한 것을 주목해 달라. 이렇게 해 두면, 나중에 숫자만 바꾼 시나리오를 추가해도, 위의 세 개 method 를 재사용할 수 있는 장점이 있다.&lt;/p>
&lt;p>그리고 behave 는 &lt;a class="link" href="https://behave.readthedocs.io/en/stable/tutorial.html?highlight=eq_#context" target="_blank" rel="noopener"
>&lt;code>context&lt;/code> 라는 파라메터를 입력으로 받을 수 있도록&lt;/a> 지원한다. 해당 시나리오가 진행되는 동안 유효한 객체이며, 따라서 여기에 원하는 attribute 를 만들어 값을 저장하고 열람할 수 있다. 예제 시나리오에서는, 남은 핫도그 개수를 &lt;code>context.hotdogs&lt;/code> 로 보관한다.&lt;/p>
&lt;blockquote>
&lt;p>엄밀히 말하면, when 에 해당하는 method 에서 핫도그 개수를 차감하는 부분은 &lt;strong>여기서 구현하면 안 된다&lt;/strong>. 실제 업무에 사용하려면, 여기서 &lt;strong>&amp;lsquo;실제로 구현한 로직&amp;rsquo; 을&lt;/strong> &lt;strong>호출해야&lt;/strong> 한다. 그래야 검증을 할 수 있으니 말이다!&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>다시 &lt;code>behave&lt;/code> 를 실행하면, 이제야 모든 테스트가 통과되었음을 알 수 있다!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># features/steps/hotdog.py:8 0.000s&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># features/steps/hotdog.py:12 0.000s&lt;/span>
&lt;span class="m">1&lt;/span> feature passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">1&lt;/span> scenario passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">3&lt;/span> steps passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped, &lt;span class="m">0&lt;/span> undefined
Took 0m0.000s
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="숫자만-바꾼-시나리오를-추가하면">숫자만 바꾼 시나리오를 추가하면?&lt;/h1>
&lt;p>시나리오&lt;strong>만&lt;/strong> 추가하더라도 이미 재사용이 가능한 형태로 테스트 method 를 구현했기 때문에, 아래처럼 성공적으로 작동한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># features/steps/hotdog.py:8 0.000s&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># features/steps/hotdog.py:12 0.000s&lt;/span>
Scenario: Eat &lt;span class="m">10&lt;/span> out of &lt;span class="m">20&lt;/span> &lt;span class="c1"># features/hotdog.feature:8&lt;/span>
Given there are &lt;span class="m">20&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
When I eat &lt;span class="m">10&lt;/span> &lt;span class="c1"># features/steps/hotdog.py:8 0.000s&lt;/span>
Then there should be &lt;span class="m">10&lt;/span> remaining &lt;span class="c1"># features/steps/hotdog.py:12 0.000s&lt;/span>
&lt;span class="m">1&lt;/span> feature passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">2&lt;/span> scenarios passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">6&lt;/span> steps passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped, &lt;span class="m">0&lt;/span> undefined
Took 0m0.001s
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>이제 이 테스트 케이스를 구현할 때 mock 라이브러리를 통해 mocking 을 하면, 기능 검증을 충분히 할 수 있을 것이다. 시나리오를 추가하는 것은 개발자 뿐만이 아닌 비 개발자나 QA 도 할 수 있어야 하고, 개발자는 그렇게 푸시된 새로운 시나리오를 보고 커버리지를 달성하기 위해 테스트에 좀 더 집중할 수 있을 것이다.&lt;/p>
&lt;p>한 가지 맹점은, 기존 시나리오가 바뀌면 테스트 케이스 개발 과정에서 엄청난 고통이 뒤따를 수 있단 것이다. 따라서 (전에도 말했지만) 항상 시나리오는 합의 하에 신중히 추가되어야 한다.&lt;/p>
&lt;p>다음 시간에는 golang 으로 똑같은 시나리오를 테스트 해 볼 예정이다.&lt;/p></description></item><item><title>뽀모도로 (Pomodoro)</title><link>https://interp.blog/%EB%BD%80%EB%AA%A8%EB%8F%84%EB%A1%9C-Pomodoro/</link><pubDate>Wed, 17 Aug 2022 17:31:36 +0000</pubDate><guid>https://interp.blog/%EB%BD%80%EB%AA%A8%EB%8F%84%EB%A1%9C-Pomodoro/</guid><description>&lt;img src="https://interp.blog/%EB%BD%80%EB%AA%A8%EB%8F%84%EB%A1%9C-Pomodoro/feature.jpg" alt="Featured image of post 뽀모도로 (Pomodoro)" />&lt;p>2020년 3월, 코로나 바이러스 전파 차단을 이유로 회사는 무기한 재택 근무에 돌입하게 되었다. &amp;lsquo;이제 누구의 감시도 받지 않고 혼자 할 일만 처리하면 마음껏 놀 수 있는 것인가!&amp;rsquo; 싶었지만. 얼마 지나지 않아서 백로그를 뒤져가며, 새벽이며 밤이며 게걸스럽게 일을 찾아 하면서 &lt;del>회사님 충성충성&lt;/del> 더욱 고단해졌었다.&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="1.jpg#center"
alt="(본 사진은 제 책상 사진이 아닙니다)" width="70%"/> &lt;figcaption>
&lt;p>(본 사진은 제 책상 사진이 아닙니다)&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>왜냐하면, 정작 업무 시간에는 애들 육아며 집안일이며 인터럽트도 많았고 개인 시간을 쓸 수 있다는 자유 때문에 회사에서는 못 해 볼 것들 (e.g. 점심먹고 침대에서 낮잠! 뛰쳐나가서 동네 카페나 서점 들르기!) 을 하다보면 업무 시간을 다 못 채웠다는 이상한 강박에 시달리게 되었다. 그 못다한 일을 나름 채우려고, 저녁 먹고나서 혹시 급히 처리해야 할 버그가 생기진 않았는지 시스템은 잘 도는지 둘러보기 일쑤였다. 회고해보면, 내 뇌는 이런 작은 것까지 다 업무의 연장으로 판단하고, 지속적으로 긴장을 했던 것 같다. 물론 안 좋았다는 말이다.&lt;/p>
&lt;p>그래서, 타임 트래킹 방법을 좀 찾아봤다. 우선 &amp;ldquo;내가 얼마나 일했는지 적어도 내가 알아볼 수 있는 방법&amp;rdquo; 이어야만 했다. 처음에는 그냥 메모장에 &amp;lsquo;&lt;em>O시 O분 ~ X시 X분 : 무슨무슨 일 했음&lt;/em>&amp;rsquo; 이라고 적으려 했다. 그런데, 그것보다는 더 효율적인 방법을 누가 찾지 않았을까? 누군가는 같은 고민을 했을 것이라고 믿었기 때문이다.&lt;/p>
&lt;p>그렇게 찾아낸 방법이 바로 &amp;lsquo;&lt;strong>뽀모도로&lt;/strong>&amp;rsquo; 이다.&lt;/p>
&lt;h2 id="뽀모도로-기법httpsenwikipediaorgwikipomodoro_technique이란">&lt;a class="link" href="https://en.wikipedia.org/wiki/Pomodoro_Technique" target="_blank" rel="noopener"
>뽀모도로 기법&lt;/a>이란?&lt;/h2>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="feature.jpg#center" width="70%"/>
&lt;/figure>
&lt;p>이 방법은 존 손메즈 (John Sonmez) 의 &amp;lsquo;&lt;a class="link" href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=298621616" target="_blank" rel="noopener"
>소프트 스킬&lt;/a>&amp;rsquo; 책에서 처음 접했다. 이 책을 읽은 건 사실 코로나 사태 이전이었는데, 방법을 고민해보다가 불현듯 책에서 나온 뽀모도로 기법을 적용하면 되지 않을까? 해서 책장에서 꺼내 다시 읽어보게 되었다.&lt;/p>
&lt;p>단순하게 설명하자면, 뽀모도로 기법은 &lt;strong>25분 집중하고 5분 쉬기를 반복하는 것&lt;/strong>이다. 4번째 휴식마다 5분이 아닌 15분을 쉬면 된다. 이 기법의 발명가인 프란체스코 시릴로 (Francesco Cirillo) 는 &amp;lsquo;뽀모도로 타이머&amp;rsquo; 라는 25분짜리 주방용 타이머에서 아이디어를 얻었다고 한다. (뽀모도로_pomodoro_ 는 이탈리아어로 &amp;lsquo;토마토&amp;rsquo; 라는 뜻이다) 즉, 25분의 집중 시간을 1개의 뽀모도로 라는 단위로 세면, 하루에 몇 개의 뽀모도로를 채웠는지 알 수 있다.&lt;/p>
&lt;h2 id="시간-관리--집중-향상">시간 관리 &amp;lt; 집중 향상&lt;/h2>
&lt;p>뽀모도로 기법은 &amp;lsquo;타임 트래킹&amp;rsquo; 이 주 목적인 방법은 아니다. 그보다는, &amp;lsquo;집중 (focus)&amp;rsquo; 에 맞춰져 있다. 25분 동안은 스마트폰도 방해 금지 모드로 설정하고, 방문도 닫는다. (방문에 작업중이란 걸개를 걸어뒀다) 아웃룩도 끄고 메신저도 알람을 꺼버린다. 그래서 집중 향상에 좀 더 초점을 맞추도록 강요하는 기법이다. 이게 결과적으론 시간 관리를 효율적으로 할 수 있도록 해 주지만 말이다.&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="3.jpg#center"
alt="집중, 집중" width="70%"/> &lt;figcaption>
&lt;p>집중, 집중&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>이 시간들을 기록하면 좋은 점이, &lt;strong>어느 시간대에 집중을 잘 하고 어느 시간대에 상대적으로 집중이 덜 되는지&lt;/strong> (=방해를 받거나 마음의 준비가 안 되어 있는지) 를 알 수 있다. 나는 운 좋게도 재택에다가 자율 근무 기반이라서, 내가 집중이 잘 되는 시간인 새벽 시간과 오후 시간을 업무에 할애하고, 보통 아침을 먹은 직후에는 &lt;del>집안일도 하고&lt;/del> 개인적인 공부를 한다. 물론 바쁠 때는 여유 부릴 새가 없지만, 내가 선택할 수 있을 때는 가장 좋은 효율을 낼 수 있도록 도와주는 귀중한 백데이터가 되는 셈이다.&lt;/p>
&lt;h2 id="이런게-어렵더라">이런게 어렵더라&lt;/h2>
&lt;p>이것만 하면 별거 없다고 생각하겠지만, 생각보다 지키기 어렵다. &lt;/p>
&lt;ul>
&lt;li>&lt;strong>25분이 생각보다 길다&lt;/strong>. 타이머를 중간에 쳐다볼 수도 있고, 좀이 쑤실 수 있다.
&lt;ul>
&lt;li>처음에 적응이 어렵다면 20분으로 줄이는 걸 추천한다.&lt;/li>
&lt;li>그리고 가급적 타이머가 울리기 전 까지는 안 보는 걸 추천한다. 그것 자체가 주의 분산 (distraction) 이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>5분 휴식이 생각보다 짧다&lt;/strong>. 4개의 뽀모도로를 채우면 15분이 주어지니까 괜찮을 것 같지만, 다르게 생각하면 2시간이나 지나야 휴식 다운 휴식을 할 수 있는 것이다.
&lt;ul>
&lt;li>그래서 5분 휴식에는 생리적인 일 (e.g. 화장실, 물 마시기, 일어나서 몸 풀기) 외에는 아~무것도 하지 않는 것을 추천한다. 제발. 특히 스마트폰으로 웹 서핑은 되도록이면 하지 말자. 이전 업무의 대부분을 뇌내에서 소거시킨다. 몸이나 푸는게 최고.&lt;/li>
&lt;li>나는 심지어 이메일이나 메신저 보는 시간도 새로 시작하는 25분 초반에 한 번에 몰아본다. 거기서 업무로 발전시켜야 할 것이나 오래 생각해야 할 거라면, 다음 뽀모도로에서 처리한다. 그 외에는 답장하고 다시 알람을 꺼버린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>4 뽀모도로를 하고 나면, 긴 휴식시간 동안 나름 뿌듯하면서도 이제 그만 하고 싶다&lt;/strong>. 와, 내가 2시간 가량 초집중으로 했어! 기특해! 보통 이후의 반응은 둘 중 하나일 텐데, &amp;ldquo;&lt;em>더 해서 오늘 하루 알차게 보내야지&lt;/em>&amp;rdquo; 와 &amp;ldquo;&lt;em>이쯤 했으니 나 오늘 괜찮지 않어?&lt;/em>&amp;rdquo; 같은 편협한 생각을 일삼게 된다. 그렇다, 난 후자였다&amp;hellip; &lt;del>도대체 전엔 어떻게 일 한거지&lt;/del>
&lt;ul>
&lt;li>이건 어쩔 수 없다. 한계를 돌파해보겠다는 어떤 신념으로 단 한번이라도 8, 12 를 해 봐야 한다. 그렇게 해 봐야 &amp;lsquo;&lt;em>나 이렇게까지 집중할 수 있는 인간이었어?&lt;/em>&amp;rsquo; 라고 보람찬 기분을 느껴보면, 다음 날에는 그만하고 싶다는 저항이 덜하게 될테니까.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="뽀모도로-개수에-집착하지-말자">뽀모도로 개수에 집착하지 말자&lt;/h2>
&lt;p>이런 질문을 할 수도 있겠다. &amp;lsquo;&lt;em>8, 12 뽀모도로는 할 수 있다는데&lt;/em>, &lt;em>16, 20도 할 수 있는 거 아닌가요?'&lt;/em>&lt;/p>
&lt;p>음&amp;hellip; 16이면 산술적으로 (휴식시간 포함) 8시간이 좀 안 되는데, 우리나라 정규 업무시간을 일 8시간이라고 한다면 이론상으론 할 수 있다. 하지만 &lt;strong>난 2년동안 16개의 뽀모도로를 채운적이 단 한 번도 없다&lt;/strong>. 난 고3때도 (8시간 기준으로) 그렇게 8시간을 5분, 15분씩 쉬면서 한 적이 없다. 단지 투입 시간이 많았을 뿐&amp;hellip;&lt;/p>
&lt;p> &amp;lsquo;소프트 스킬&amp;rsquo; 책에서는, 저자가 일주일에 50-55 의 뽀모도로를 목표로 한다고 나와 있다. 평일 환산하면 10-11 개 수준에 지나지 않는다. 나 또한 정말 많으면 13개, 보통은 9-10개에 그친다. &lt;del>팀장님 이 글 보지 마세요!&lt;/del> 물론 여러분이 결코 못 할 거라고 단언하는 것은 아니다. 업무 시간이 8시간이니까 그 시간을 전부 뽀모도로 기법으로 채워서 업무를 처리하겠다는 말 자체가 굉장히 어렵단 말을 해 주고 싶다.&lt;/p>
&lt;p>여담이지만, 김영하 작가는 &amp;lsquo;&lt;a class="link" href="https://www.youtube.com/watch?v=MbZ9qyY--CE&amp;amp;ab_channel=tvN" target="_blank" rel="noopener"
>자신은 일을 할 때 에너지를 100% 쏟으면 큰일난다고 생각한다.&lt;/a> 60-70% 만 써야 한다. 무슨 일이 일어날 지 모르는데 일에 모든 에너지를 쏟으면 안 된다&amp;rsquo; 라는 말을 알쓸신잡을 통해 했던 기억이 난다. 그리고 수학자 앙리 푸엥카레는 &lt;a class="link" href="https://en.wikipedia.org/wiki/Henri_Poincar%c3%a9#Toulouse%27s_characterisation" target="_blank" rel="noopener"
>규칙적으로 오전 10시-12시까지, 오후 5-7시까지 단 4시간만 일했다&lt;/a>고 한다. 그보다 오래 일해봐야 얻는게 거의 없다고 판단했기 때문이라나? 그러니 너무 뽀모도로 개수에 강박을 갖지 말자.&lt;/p>
&lt;h2 id="타이머-프로그램앱">타이머 프로그램/앱?&lt;/h2>
&lt;p>앱을 몇개 둘러보진 않았는데, 나에게는 애플 앱 스토어의 &amp;lsquo;&lt;a class="link" href="https://apps.apple.com/kr/app/flat-tomato-time-management/id719462746" target="_blank" rel="noopener"
>Flat tomato&lt;/a>&amp;rsquo; 가 제일 나았다. 그렇다고 이게 다른 앱 대비 특출난 건 없고 그냥 깔끔해서. 게다가 이건 결국 유료 구매를 해야 되는 거라 섣불리 추천하기가 애매하다. 다른 앱 중에선 &lt;a class="link" href="https://apps.apple.com/kr/app/focus-timer-%EC%A7%91%EC%A4%91%EB%A0%A5-%ED%96%A5%EC%83%81-%EC%96%B4%ED%94%8C/id974920073" target="_blank" rel="noopener"
>포커스 타이머&lt;/a>를 좀 쓰다가, 복잡해서 포기했던 기억이 난다.&lt;/p>
&lt;p>정 싫으면 PC 용으로 나온 프로그램을 쓰자. 검색해보니 윈도우에는 &lt;a class="link" href="https://apps.microsoft.com/store/detail/powerpom-pomodoro-timer/9P5ZSCL5QC8W?hl=ko-kr&amp;amp;gl=KR" target="_blank" rel="noopener"
>PowerPom&lt;/a>, 맥에서는 &lt;a class="link" href="https://flowapp.info/" target="_blank" rel="noopener"
>flow&lt;/a> 가 있다. 둘 다 안 써 봤지만, 옵션이나 통계 기능이 없는, 말 그대로 타이머일 가능성이 높다. &lt;strong>그래도&lt;/strong> &lt;strong>뭐라도 써 보자.&lt;/strong> 통계 기능이 없으면, 하루동안 몇 개 뽀모도로 하는지 세서 일기장에 적으면 그만이다. &lt;/p>
&lt;h2 id="중요한-것은-시간의-퀄리티">중요한 것은 시간의 퀄리티&lt;/h2>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="4.jpg#center"
alt="뽀모도로의 크기가 작건 크건, 색깔이 다르건 간에 중요한 것은 시간을 효율적으로 보냈다는 증거 그 자체다." width="70%"/> &lt;figcaption>
&lt;p>뽀모도로의 크기가 작건 크건, 색깔이 다르건 간에 중요한 것은 시간을 효율적으로 보냈다는 증거 그 자체다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>물론 25분-5분 루틴이 마음에 안 들면 조정할 수도 있다. 학교 때 처럼 50분-10분으로 조정해도 된다.&lt;/p>
&lt;p>&amp;lsquo;&lt;a class="link" href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=195380024&amp;amp;start=slayer" target="_blank" rel="noopener"
>일단, 오늘 1시간만 공부해 봅시다&lt;/a>&amp;rsquo; 라는 책에서는 결국 50분-10분의 1시간 루틴을 최종적으로 추천하기도 하니, 도전해 보는 것도 나쁘지 않다. &lt;del>나는 공부만 하는 것이 아니어서, 그렇겐 안 할란다&lt;/del>&lt;/p>
&lt;p>중요한 것은, 업무를 할 때나 다른 일을 할 때 그 시간을 확실히 집중해서 보냈느냐를 기록할 수 있고 되돌아 볼 수 있는 것이 뽀모도로 기법의 특징이다. 하지만, 그냥 방해는 받지 않고 모니터에서 멍하니 있었어도 1 뽀모도로로 계산되는 점이 맹점이라고 볼 수는 있다. 이런 아쉬움은, 뽀모도로 기능을 제공하는 앱들 대부분이, 각 뽀모도로 마다 &amp;lsquo;별점&amp;rsquo; 을 매길 수 있게 되어 있다. 방해는 안 받았는데 집중이 잘 안됐다면 높은 점수를 주지 않으면 된다. 이 기능을 활용하면 퀄리티를 좀 더 세심하게 기록할 수 있을 것이라 본다.&lt;/p>
&lt;p>나는 뽀모도로를 업무에만 쓰지 않는다. 책을 읽을 때도 쓰고 (보통 하루에 2-3 뽀모도로를 쓴다) 프로그래밍 연습을 할 때도 쓰고 (매일은 아니고, 주당 5 뽀모도로를 채우려고 노력한다. 잘 안 된다) 심지어 영화를 보거나 게임을 할 때도 쓴다. (물론 내가 원할 때 세이브를 할 수 있는 것이어야 한다) 이런 다양한 작업까지 다 합치면 하루에 16 개의 뽀모도로를 모으는 날도 있다. 물론 보낸 시간은 8시간보다 훨씬 많지만 말이다. &lt;/p>
&lt;p>시간은 누구에게나 소중한 것이니, 소개한 뽀모도로 기법을 통해 훨씬 가치있게 시간을 사용할 수 있기를 바란다.&lt;/p></description></item><item><title>Oh my zsh! 에서 kubectl 자동 완성 하기</title><link>https://interp.blog/oh-my-zsh-kubectl-autocomplete/</link><pubDate>Tue, 16 Aug 2022 12:31:36 +0900</pubDate><guid>https://interp.blog/oh-my-zsh-kubectl-autocomplete/</guid><description>&lt;p>&amp;lsquo;&lt;a class="link" href="https://kubernetes.io/ko/docs/tasks/tools/included/optional-kubectl-configs-zsh/" target="_blank" rel="noopener"
>zsh 자동 완성&lt;/a>&amp;rsquo; 이라는 Kubernetes 공식 문서에 따르면, 다음 명령으로 자동 완성이 가능하다고 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">source&lt;/span> &amp;lt;&lt;span class="o">(&lt;/span>kubectl completion zsh&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>그런데 Oh my zsh! 에서는 몇가지 더 설정을 해야 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>$HOME/.zshrc&lt;/code> 를 열어서, plugins 에 다음을 추가한다.
&lt;ul>
&lt;li>kubectl&lt;/li>
&lt;li>kube-ps1&lt;/li>
&lt;li>zsh-syntax-highlighting&lt;/li>
&lt;li>zsh-autosuggestions&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nv">plugins&lt;/span>&lt;span class="o">=(&lt;/span>git kubectl kube-ps1 zsh-syntax-highlighting zsh-autosuggestions&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>kubectl, kube-ps1 은 이미 설치되어 있을텐데, 아래 2개는 별도 설치가 필요할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># zsh-syntax-highlighting&lt;/span>
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">ZSH_CUSTOM&lt;/span>&lt;span class="k">:-&lt;/span>&lt;span class="p">~/.oh-my-zsh/custom&lt;/span>&lt;span class="si">}&lt;/span>/plugins/zsh-syntax-highlighting
&lt;span class="c1"># zsh-autosuggestions&lt;/span>
git clone https://github.com/zsh-users/zsh-autosuggestions &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">ZSH_CUSTOM&lt;/span>&lt;span class="k">:-&lt;/span>&lt;span class="p">~/.oh-my-zsh/custom&lt;/span>&lt;span class="si">}&lt;/span>/plugins/zsh-autosuggestions
&lt;/code>&lt;/pre>&lt;/div>&lt;p>참고로 Auto-suggestion 되는 내용이 하얀색으로 나와서 타이핑하거나 알아보기가 힘들다면, 해당 내용만 다른 색으로 바꿔줄 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>export ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=(number)'&lt;/code> 라고 쓰면 된다.&lt;/li>
&lt;li>나는 &lt;code>(number)&lt;/code> 자리에 &lt;code>243&lt;/code> 을 사용했다. 연한 회색이다.&lt;/li>
&lt;li>자세한 color 값은 &lt;a class="link" href="https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자. 물론 사용하려면 &lt;code>$TERM&lt;/code> 값이 &lt;strong>xterm-256color&lt;/strong> 여야 한다.&lt;/li>
&lt;/ul>
&lt;p>그리고 다시 로그인하면, 탭키(&lt;code>&amp;lt;tab&amp;gt;&lt;/code>) 를 통해 자동 완성이 잘 되는 것을 확인할 수 있다.&lt;/p></description></item><item><title>부자들의 초격차 독서법</title><link>https://interp.blog/%EB%B6%80%EC%9E%90%EB%93%A4%EC%9D%98-%EC%B4%88%EA%B2%A9%EC%B0%A8-%EB%8F%85%EC%84%9C%EB%B2%95/</link><pubDate>Fri, 12 Aug 2022 11:00:36 +0000</pubDate><guid>https://interp.blog/%EB%B6%80%EC%9E%90%EB%93%A4%EC%9D%98-%EC%B4%88%EA%B2%A9%EC%B0%A8-%EB%8F%85%EC%84%9C%EB%B2%95/</guid><description>&lt;img src="https://interp.blog/%EB%B6%80%EC%9E%90%EB%93%A4%EC%9D%98-%EC%B4%88%EA%B2%A9%EC%B0%A8-%EB%8F%85%EC%84%9C%EB%B2%95/feature.jpg" alt="Featured image of post 부자들의 초격차 독서법" />&lt;figure class="align-center ">
&lt;img loading="lazy" src="feature.jpg#center" width="50%"/>
&lt;/figure>
&lt;p>이 책을 두 문장으로 요약하면, 책을 완독하는 것도 좋지만 중요한 건 책이 내 인생에 어떤 도움이 되는지 얻어야 한다. 그 부분’만' 빠르게 하면, 짧은 시간에 엄청난 양의 책을 읽을 수 있고 인생에 큰 도움이 된다는 것이다.&lt;/p>
&lt;h2 id="한-권-읽는-데-30분">한 권 읽는 데 30분&lt;/h2>
&lt;p>한 권을 읽을 때는 30분을 잡는다고 한다. (물론 어려우면 더 많은 시간을 써도 된다. 요점은 한 권을 통독하는게 아니고, 찾고자 하는 요점을 반복적으로 시도하는 과정에 있다.&lt;/p>
&lt;p>30분을 다음과 같이 세 파트로 나눈다.&lt;/p>
&lt;h3 id="처음--책-고르기">처음 : 책 고르기&lt;/h3>
&lt;p>우선 책을 골라야 한다. 고르는데 필요한 팁은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>자신의 현재 인생 목표에 맞는 책이어야 한다. 목표와 동떨어진 책은 이 방법을 사용해도 효과가 적거나 없다.&lt;/li>
&lt;li>목표에 맞는 책을 얼마나 읽어야 할까? 보통 7권 정도 읽으면 배울만큼 배울 수 있다고 저자는 주장한다. 기초서 2, 다양한 시각을 가진 3권, 전문서 2권.&lt;/li>
&lt;li>책의 뒷면, 띠지, 속지에 적힌 글을 통해, 책의 분위기와 수준을 알 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="15분--빠르게-주요-페이지-찾기">15분 : 빠르게 주요 페이지 찾기&lt;/h3>
&lt;p>책을 최대한 빠르게 읽으면서, 내가 생각하기에 중요한 페이지를 접는다. (나는 플래그 인덱스를 사용한다) 이 방법이 속독은 아닌데,&lt;/p>
&lt;ul>
&lt;li>에필로그와 감사의 말은 넘어간다. 모든 독자를 위한 글은 아니기 때문이다.&lt;/li>
&lt;li>해당 챕터 또는 문단에서, 저자가 말하고자 하는 바를 먼저 찾는다. 예제라던지, 에피소드 같은 건 이해를 도와주는 곁들임 정보일 뿐이다.&lt;/li>
&lt;li>말하고자 하는 바를 찾기 위한 몇 가지 팁이 있는데, (적고보니 언어영역 특강인 줄…)
&lt;ul>
&lt;li>한자어가 들어있는 문장에, 더 많은 정보가 있다.&lt;/li>
&lt;li>“그러나, 하지만” 같은 접속사 뒤에 있는 친구가 요점이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>중복된 내용이다 싶으면 넘어간다. 도표나 그림도 마찬가지다.&lt;/li>
&lt;/ul>
&lt;h3 id="10분--주요-내용의-에피소드-기억">10분 : 주요 내용의 에피소드 기억&lt;/h3>
&lt;p>두 번째 독서는 10분을 할애하며, 표시했던 중요한 페이지들 위주로 심도있게 읽는다.&lt;/p>
&lt;ul>
&lt;li>두 번째 독서는 첫 번째와 다른 장소에서 읽으면 도움이 된다.&lt;/li>
&lt;li>중요한 부분을 요약하거나, 어떻게 자기 삶에 적용할 수 있는지 책에 적는다.
&lt;ul>
&lt;li>나는 대여한 책이 많아서, 옆에 노트를 두고 적었다.&lt;/li>
&lt;li>단순 필사는 의미가 없다. 이 내용을 어디에 써먹어야지, 이 내용은 그때 그 것과 비슷한 것 같다 라는 식으로 요약해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>내용은 파란 펜으로 쓴다. (파란 펜이 뇌과학적으로 어쩌고… 사실 상관없을 것 같다)&lt;/li>
&lt;/ul>
&lt;h3 id="5분--아웃풋-노트">5분 : 아웃풋 노트&lt;/h3>
&lt;p>그냥저냥한 책이라면 2단계까지 해도 좋지만, 정말 울림이 커서 곁에 두고 인생에 늘 적용해야겠다고 판단되면 ‘아웃풋 노트’ 를 작성하라고 한다. 이 노트에는,&lt;/p>
&lt;ol>
&lt;li>목표&lt;/li>
&lt;li>책 제목&lt;/li>
&lt;li>에센스들
&lt;ul>
&lt;li>13~20자 내외의 문장 10개 정도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>행동 계획&lt;/li>
&lt;/ol>
&lt;p>아웃풋 노트는 항상 곁에 두고 점검해야 한다. 적고나면 까먹기 때문이다.&lt;/p>
&lt;h2 id="독서의-필요성-속독의-해악">독서의 필요성, 속독의 해악&lt;/h2>
&lt;p>저자는 이 방법을 알려주기 전에 (다른 사람들이 늘 하는 것 처럼) 이 방법의 믿음을 주기 위해 많은 서문을 남겼다. 자신은 이 방법을 써서 성공한 사람이 되었다, 이 방법을 쓰면 어떤게 좋고 어떤게 또 좋다. 책을 읽어보면 다 도움이 되지만, 나는 이 초격차 독서법을 이 책에도 그대로 적용했기 때문에 다 넘겼다. 하다 보면 자연스럽게 장점을 취할 수 있을 거라고 기대하면서.&lt;/p>
&lt;p>인터넷이 있는데 굳이 이렇게 독서를 할 필요가 있을까? 라는 질문에는 내 생각과 일치하는 답을 내놓은 점이 흥미롭다. 책은 저자가 기를 쓰고 움직이지 않는 매체 (글과 그림)로만 설득하고 설명해야 하기 때문에 한 권을 통해 종합적으로 받아들일 수 있지만, 인터넷 정보는 단편적이고 검증되지 않은 정보가 섞여있기 때문에 통합해서 받아들이기 어려운 면이 있다는 것이다.&lt;/p>
&lt;p>저자는 속독을 하는 것이 아무런 도움이 되지 않는다고 하면서, 대신 요점을 빠르게 파악해 내 인생에 도움 되는 것을 ‘편취’ 하는 방법이 훨씬 시간을 아낄 수 있다고 주장한다. 나도 속독엔 그다지 흥미가 없었다. 오히려 느린 속도로 통독하는 걸 좋아했었으니까. 그런데 저자가 주장하는 바는 일단 인생에 도움이 되는 정보를 빠르게 얻는다는 목적이 매력적이어서 한번 실천해보고자 한다.&lt;/p></description></item><item><title>BDD (Behavior-driven Development) 소개</title><link>https://interp.blog/bdd-behavior-driven-development/</link><pubDate>Thu, 11 Aug 2022 16:31:36 +0000</pubDate><guid>https://interp.blog/bdd-behavior-driven-development/</guid><description>&lt;img src="https://interp.blog/bdd-behavior-driven-development/feature.jpg" alt="Featured image of post BDD (Behavior-driven Development) 소개" />&lt;p>작년 즈음에, 팀에 테스트 주도 개발 (Test-driven Development,TDD) 에 대해 어떤 강력한 합의 (?) 가 필요하지 않을까라고 팀장님께 주장했던 기억이 났다. &lt;del>일단 나부터 좀 잘 해야 할텐데&lt;/del> 그런데 그걸 언제 또 기억하셔서는, 올 초에 ‘TDD 말고 BDD 에 대해 조사해서 차기 프로젝트에 녹여보면 어떻겠냐’ 는 제안을 하셨다. 두 눈을 동그랗게 뜬 채 음성 채팅으로 ‘그것이… 무엇이죠?!’ 라고 되물었던 슬픈 기억이 난다.&lt;/p>
&lt;p>지금은 프로젝트를 진행 중인데 거의 설계 단계를 지났고, 프로토타이핑이 끝나간다. 바쁜 시간이 지나고서야 팀장님의 부름이 닿아, 뒤늦게나마 우리가 쥐고 있는 요구사항이 무엇인지, 어떻게 적용할 수 있는지 찾아보고 있다. 그런데 이 결과물을 팀원들에게 공유하려면 내가 먼저 ‘BDD 를 왜 써야 하는지’ 를 이해하고 설명할 수 있어야 하기에, 블로그에 정리해 보려고 한다.&lt;/p>
&lt;h2 id="bdd-란">BDD 란?&lt;/h2>
&lt;p>BDD 는 &lt;strong>Behavior-driven Development&lt;/strong>, 즉, 제품이나 서비스의 행동에 초점을 맞춘 개발 방법론이다. 소프트웨어가 어떤 일을 해내야하는지가 가장 중요하며, 개발과 테스팅이 거기에 맞춰 진행되어야 한다는 것이다. &lt;del>뭐, 당연한 소리 아닌가? 다들 이렇게 다 하잖아요, 그쵸?&lt;/del>&lt;/p>
&lt;p>&lt;a class="link" href="https://cucumber.io/docs/bdd/" target="_blank" rel="noopener"
>Cucumber 에서의 BDD 정의&lt;/a>는 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>BDD is a way for software teams to work that closes the gap between business people and technical people by:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Encouraging collaboration&lt;/strong> across roles to build shared understanding of the problem to be solved&lt;/li>
&lt;li>Working in rapid, small iterations to increase feedback and the flow of value&lt;/li>
&lt;li>&lt;strong>Producing system documentation&lt;/strong> that is automatically checked against the system’s behavior&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://inviqa.com/blog/bdd-guide#what-is-it" target="_blank" rel="noopener"
>Inviqa 의 BDD 블로그 포스트&lt;/a>에서는 이렇게 정의했다.&lt;/p>
&lt;blockquote>
&lt;p>BDD is a process designed to aid the management and the delivery of software development projects by improving communication between engineers and business professionals. In so doing, BDD ensures all development projects remain focused on delivering what the business actually needs while meeting all requirements of the user.&lt;/p>
&lt;/blockquote>
&lt;p>잘 보면 collaboration, communication 이 겹쳐 보인다.&lt;/p>
&lt;h2 id="bdd-적용-방식">BDD 적용 방식&lt;/h2>
&lt;p>여기서 나는 BDD 의 Best Practice 나 심지어 Gherkin 문법에 대해서 자세히 조사해 정리하지 않을 것이다. 왜냐하면 나도 배우는 입장이고, 이 포스팅의 목적은 ‘BDD 가 정말 필요할까요?’ 를 밝히는 것이기 때문이다.&lt;/p>
&lt;p>정말 필요하다고 생각하면, 그때서야 더 깊이 찾아보면 될 일이다.&lt;/p>
&lt;h3 id="discovery">Discovery&lt;/h3>
&lt;p>User Story 에서 실제 예제를 만든다. 이 예제는 합의되어야 한다.&lt;/p>
&lt;p>이 과정은 협업 단계이다. 워크샵을 통해 아이디어를 모으고, 구체적인 예시를 들어야 한다. 이 과정을 통해 어떤 기능이 정말 필요한지 우선순위를 정할 수도 있다. User Story 의 범위를 조정하는 작업이기도 하다.&lt;/p>
&lt;p>이런 과정을 통해, 우리가 뭘 해야 할지 결정하기 위해 빠진 정보를 알아낼 수도 있다. 처음부터 모든 정보를 들고 요구사항을 구체화할 수 없기 때문이다. 다시 채워서, 다시 이야기해야 한다.&lt;/p>
&lt;p>다시 말하지만, 여기서 산출된 예제들은 합의된 것이어야만 한다. 그렇지 않으면 다음 사이클에 영향을 끼친다.&lt;/p>
&lt;h3 id="formulation">Formulation&lt;/h3>
&lt;p>예제를 자동화 가능한 형태로 문서화한다. 이 문서는 합의되어야 한다.&lt;/p>
&lt;p>문서는 Gherkin 문법 (GIVEN - WHEN - THEN) 으로 정형화한다. 이 문서 내용을 다시 모든 조직원들에게 공유해, 이렇게 테스트할 것이라고 검증받아야 한다. (다시 말하지만, 이 문서도 합의되어야 한다.)&lt;/p>
&lt;h3 id="automation">Automation&lt;/h3>
&lt;p>문서에 맞춰 구현하고 테스트한다.&lt;/p>
&lt;p>언어 별로 다양한 라이브러리/패키지가 지원되며, BDD 또는 Cucumber, Gherkin 으로 검색하면 관련 자료가 늘 나왔었다. 내가 확인한 건 일단 Java (&lt;a class="link" href="https://site.mockito.org/" target="_blank" rel="noopener"
>Mockito&lt;/a>), Python (&lt;a class="link" href="https://behave.readthedocs.io/en/stable/" target="_blank" rel="noopener"
>behave&lt;/a>), Go (&lt;a class="link" href="https://github.com/cucumber/godog" target="_blank" rel="noopener"
>godog&lt;/a>) 정도가 있다.&lt;/p>
&lt;p>Gherkin 문법으로 정형화된 문서를 입력으로, 코드 템플릿을 출력하거나 코드 템플릿과 일치하는 테스트 케이스가 존재하면 바로 테스트 결과를 출력한다. (behave, godog 만 테스트해 봤다) 각 언어 별 실제 사용 예제는 블로그에 따로 정리할 예정이다.&lt;/p>
&lt;h3 id="gherkin-format">Gherkin Format&lt;/h3>
&lt;p>그럼 도대체 Gherkin &lt;del>오이피클&lt;/del> 은 어떻게 쓰는가? 가장 간단한 방법은 세 문장으로 나타내는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Given there are 12 cucumbers
When I eat 5 cucumbers
Then I should have 7 cucumbers
&lt;/code>&lt;/pre>&lt;/div>&lt;p>GIVEN 은 전제 조건이고, WHEN 은 액션, THEN 은 그 결과이다. 이 부분을 테스트 케이스로 만드려면,&lt;/p>
&lt;ul>
&lt;li>GIVEN : 전제조건이 되도록 환경을 구성하거나 mocking 한다.&lt;/li>
&lt;li>WHEN : 액션을 가한다. (함수를 호출하거나)&lt;/li>
&lt;li>THEN : 실제 결과가 명세에서 예상한 대로 나왔는지 검증하는 코드가 필요하다.&lt;/li>
&lt;/ul>
&lt;p>물론 세 가지 키워드 말고도 다양한 방법으로 ‘예제’ 를 표현할 수 있다. 자세한 문법 내용은 &lt;a class="link" href="https://cucumber.io/docs/gherkin/reference/" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/p>
&lt;h2 id="내가-생각하는-bdd">내가 생각하는 BDD&lt;/h2>
&lt;p>BDD 가 어떤 것인지 맛을 봤으니, 이제는 왜 이 방법론이 필요한지 내 생각과 경험을 얹어 설명해 보겠다.&lt;/p>
&lt;blockquote>
&lt;p>보통 프로젝트를 시작하거나 하면 TDD 를 기본으로 깔고 시작한다.&lt;/p>
&lt;p>우선 개발자는 요구사항에 맞는 테스트 케이스를 만든다. 그 요구사항은 프로젝트 안에서 개인에게 할당된 작업 내용에 관한 것일 수도 있고, 정말 고객이나 비즈니스에서 원하는 기능에 대한 요구사항 명세일 수도 있다.&lt;/p>
&lt;p>테스트 케이스를 먼저 만들고, 테스트 케이스는 물론 실패한다. 실패하지 않게 구현하고, 박수를 짝짝 치고 PR 을 연다. 리뷰를 받고 파이프라인을 통과해 프로덕션 브랜치로 기능 (또는 수정 내역) 이 반영된다.&lt;/p>
&lt;/blockquote>
&lt;p>문장 자체로만 보면 아주 당연하고 아름다운 순서이겠지만, 여기서 뭔가 꺼림칙한 부분이 생기게 된다. 나는 크게 두 가지가 걸리는데,&lt;/p>
&lt;ol>
&lt;li>&lt;strong>테스트 케이스가 요구사항을 온전히 반영했는지 검증이 가능한가?&lt;/strong> 사람은 오류와 상상의 동물이라서, 요구사항을 아무렇게나 해석해서 테스트 케이스를 만들어 둘 수 있다. 물론 코드 리뷰하면 다 나오는거, 맞다. 그런데 우리가 리뷰해야 할 것은 리펙터링과 모킹 (mocking) 이 복잡하게 뒤섞인 ‘코드’ 란 말이다. 정말 그 오류를 잘 찾아낼 수 있나?&lt;/li>
&lt;li>&lt;strong>요구사항은 대체 어떻게 만드는가?&lt;/strong> 이건 좀 더 근원적인 질문인데, 요구사항이라는 것은 언제나 ‘고객/비즈니스-개발 조직’ 또는 ‘프로젝트 리더-프로젝트 개발자’ 사이에 정량적으로 합의된 내용이어야 한다. 티켓에 적힌 내용, 회의록이 합의된 결과 아니냐고? 글쎄… 그걸 다 모아다가 볼 수 있나? UML 은 어떨까? UML 다이어그램에 대한 지식이 없는 사람은 그럼 요구사항 리뷰를 못 하는 걸까?
&lt;ul>
&lt;li>우리는 늘 이런 걸 겪지 않았던가? “&lt;em>그건 제가 하고 싶은 말이 아니었어요!&lt;/em>” “&lt;em>그건 제가 원하던 것이 아니었어요!&lt;/em>” 라는 말… 어정쩡하고 단방향의 요구사항은 늘 화를 불러오게 되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이런 방식대로라면 (1) 사용자가 정말 원하는 &lt;strong>요구사항을 ‘요구사항 명세’ 가 100% 커버하는지&lt;/strong> (결과물이 너무 다양하거나 복잡하기 때문에) 쉽게 알 수도 없고 (2) &lt;strong>요구사항 명세가 테스트 케이스로 변환되어 100% 기능하고 있는지&lt;/strong>도 쉽게 알 수 없다는 것이다. 내가 ‘쉽게’ 라는 말을 붙이긴 했지만, 현실에서는 거의 불가능하다고 본다.&lt;/p>
&lt;p>내가 봤을 때 BDD 는 두 가지 문제를 짚어 나가는데 효과적이다. 개발 외 조직으로부터 사용자 요구사항을 받는 것 말고도, 개발조직 내부에서 요구사항을 합의하고 기능을 검증할 때도 효과적이라는 점 역시 덧붙이고 싶다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>이렇게 설명해놓고 보니, 일선 개발자에겐 TDD 의 확장 개념이라고 여기게 될까 조심스럽다. 어차피 자연어로 된 문서를 소스로 한다는 점만 틀리지, 거기서 생성된 테스트 케이스의 코드를 구현하고 Regression 을 돌리는 작업이 기존에 하던 TDD 와 무엇이 다르냐고 할 수도 있겠다.&lt;/p>
&lt;p>하지만 TDD 를 시작하기 이전에 ‘어떻게 테스트 케이스를 만들죠’ 라는 부분에 대한 하나의 대안으로 생각해주면 좋겠다. 이 방법이 부상하기 전부터, 소프트웨어 공학에서 제시한 UML 명세나 수 많은 다이어그램에 기초해서 테스트 케이스를 만들지 않았던가. 조직에서 이런 방식으로 이미 명세-테스트 케이스 자동화가 되어 있다면 정말로 BDD 가 필요없을 순 있겠다. 하지만, UML 부터 무척 복잡하다고 느끼는 것은 비단 나 뿐일까?&lt;/p>
&lt;p>&lt;strong>BDD 는 확실히 사용자가 정말 원하는 예제를 찾고, 보완하는데 불편함이 적다.&lt;/strong> 누구나 읽을 수 있는 언어로 되어 있으니, 비즈니스를 다루는 직원은 뭔가를 더 배울 필요가 없다. 개발자는 나름 규격화된 문서를 가지고 테스트 케이스를 만들 수 있다. 즉, 이 방법론은 조직 전체에 걸쳐 광범위한 개발 방법론이라고 볼 수 있겠다.&lt;/p>
&lt;p>다음 포스팅은, 내가 실제로 구동해 본 behave 나 godog 예제가 될지, 아니면 현업에서 적용해보고 난 뒤 받은 피드백에 대해서 이야기할지 고민 중이다. 아직 이렇다 할 피드백이 없어서, 아마도 실제로 따라 써 볼 수 있는 글을 쓰는게 현실적이리라 본다.&lt;/p></description></item><item><title>상환 완료된 대출 계좌, 증명서 발급하기</title><link>https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/</link><pubDate>Thu, 11 Aug 2022 16:31:36 +0000</pubDate><guid>https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/</guid><description>&lt;img src="https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/1.jpg" alt="Featured image of post 상환 완료된 대출 계좌, 증명서 발급하기" />&lt;p>부동산 매매 거래를 할 때, 매도인이 담보대출 건을 당일 말소시키겠단 조건을 보통 넣게 되면 매수인의 대출 실행 은행 측 법무사가 와서 &lt;strong>&amp;lsquo;상환이 완료됐는지 증명해야 하니까 증명서를 달라&amp;rsquo;&lt;/strong> 고 한다. 증명서요? 상환 다 했는데요??&lt;/p>
&lt;p>당황해서 인터넷뱅킹 홈페이지를 여기저기 뒤지고, 영업점에 전화도 해 보고, 그러다보면 시간이 쫓길 수 있다! 우리의 시간은 소중하고 나도 이사 갈 곳에 잔금 치뤄야 하는데 이게 뭐야 ㅠㅠ&lt;/p>
&lt;p>그래서 이 참에 정리해 봤다. &lt;strong>우리은행&lt;/strong>을 예로 들겠지만, 다 비슷할 거라 생각한다.&lt;/p>
&lt;h3 id="대출완제-영수증-발급-받기">&lt;strong>대출완제 영수증&lt;/strong> 발급 받기&lt;/h3>
&lt;p>대출완제 영수증이란 즉, 대출 상환을 다 마쳤다는 영수증이다. &lt;br>
&amp;lsquo;개인 &amp;gt; 조회 &amp;gt; 계좌조회 &amp;gt;  &lt;strong>해지계좌 조회&lt;/strong>&amp;rsquo; 로 들어간다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/1.jpg"
width="1195"
height="389"
srcset="https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/1_hud172bdad67328e68179b793afc1d9b05_48172_800x0_resize_q75_h2_box.webp 480w, https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/1_hud172bdad67328e68179b793afc1d9b05_48172_1600x0_resize_q75_h2_box.webp 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="307"
data-flex-basis="737px"
>&lt;/p>
&lt;p>조회구분에 &amp;lsquo;대출&amp;rsquo; 이 있는데, 이걸 클릭한 다음, 상환이 완료된 날짜가 포함되도록 기간을 설정해 조회하면 끝.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/2.jpg"
width="1001"
height="76"
srcset="https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/2_hu467ff9db7ee772827b57a23a7af4e476_6153_800x0_resize_q75_h2_box.webp 480w, https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/2_hu467ff9db7ee772827b57a23a7af4e476_6153_1600x0_resize_q75_h2_box.webp 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1317"
data-flex-basis="3161px"
>&lt;/p>
&lt;p>그러면, 대출완제 영수증 출력 버튼과 함께, 해지된 계좌가 나타나게 되는데, 그걸 출력해 법무사에게 건네주면 끝!&lt;/p>
&lt;h3 id="주택자금대출-상환증명서-발급-받기">&lt;strong>주택자금대출 상환증명서&lt;/strong> 발급 받기&lt;/h3>
&lt;p>연말정산 용으로 주택담보대출의 이자액을 공제받을 목적이나 기타 목적으로 상환 증명서를 떼야 할 수 있다. 주의할 점은, 이 상환 증명서는 상환한 대출 이력만 나오므로 대출이 전액 상환되었는지 증명할 수 없는 서류라는 점. &lt;/p>
&lt;p>이걸 떼 주면 법무사가 &amp;lsquo;이거 아니야&amp;rsquo; 라고 고개를 절레절레&amp;hellip; 그러니 대출의 전액 상환을 증명하려면, 앞서 소개한 &amp;lsquo;대출완제 영수증&amp;rsquo; 을 발급받아야 하니 주의!&lt;/p>
&lt;p>이번에는 &amp;lsquo;개인 &amp;gt; 뱅킹관리 &amp;gt; 증명서발급 &amp;gt; &lt;strong>증명서신청&lt;/strong>&amp;rsquo; 으로 간다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/3.jpg"
width="1193"
height="272"
srcset="https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/3_huff77fb2c231d1bab12f0b9fecf3b4fc9_35510_800x0_resize_q75_h2_box.webp 480w, https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/3_huff77fb2c231d1bab12f0b9fecf3b4fc9_35510_1600x0_resize_q75_h2_box.webp 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="438"
data-flex-basis="1052px"
>&lt;/p>
&lt;p>그 안에서 주택자금대출상환증명서를 선택한 뒤, 발급 신청을 통해 받을 수 있다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/4.jpg"
width="1191"
height="400"
srcset="https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/4_hu9bcdb35a3b2ed26c6795bb2abd1c0496_56133_800x0_resize_q75_h2_box.webp 480w, https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/4_hu9bcdb35a3b2ed26c6795bb2abd1c0496_56133_1600x0_resize_q75_h2_box.webp 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="297"
data-flex-basis="714px"
>&lt;/p></description></item><item><title>키보드 키 바운싱 문제 해결</title><link>https://interp.blog/keyboard-key-bouncing-problem/</link><pubDate>Thu, 11 Aug 2022 02:25:04 +0000</pubDate><guid>https://interp.blog/keyboard-key-bouncing-problem/</guid><description>&lt;img src="https://interp.blog/images/featured/keyboard-key-bounce.jpg" alt="Featured image of post 키보드 키 바운싱 문제 해결" />&lt;p>회사에서 기계식 키보드를 아무거나 사라고 해서 &lt;a class="link" href="http://prod.danawa.com/info/?pcode=1458635" target="_blank" rel="noopener"
>i-rocks의 KR-6251&lt;/a> 을 사서 5년 째 쓰고 있다. 2년 전부터 &lt;strong>몇몇 키들은 한 번 누를 때마다 두 번 입력&lt;/strong>되는 느낌을 받았고, 쓰면서 이 현상이 더욱 가중되어 성가신 느낌을 지우기 힘들었다.&lt;/p>
&lt;p>그런데 이 문제를 어떻게 인터넷에서 검색하지? 감을 통 잡을 수 없으니 &amp;lsquo;그냥 새로운 키보드 하나 사야 하나?&amp;rsquo; 라고 고민하고 있었다. &lt;del>이럴 때만 지름신이 오셔서는, &amp;lsquo;비싼 걸 사서 쓰라&amp;rsquo; 고 말씀하시지&lt;/del> 그러다가 우연찮게 이런 유형의 문제를 &amp;lsquo;키 바운스&amp;rsquo; 라고 부르는 몇몇 문서를 발견할 수 있었다.&lt;/p>
&lt;h2 id="키-바운스">키 바운스?&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.youtube.com/watch?v=Du3rcfI9hDY" target="_blank" rel="noopener"
>&lt;del>그대가 돌아서면~♪&lt;/del>&lt;/a> 말 그대로, 키가 제멋대로 춤을 춰서 한번 더 스위치와 부비는(!) 현상을 말한다.&lt;/p>
&lt;p>무접점 키보드가 아닌 이상, 일반 키보드인 멤브레인을 포함, 스위치를 사용하는 기계식 키보드들은 발생할 수도 있는 증상이다. &lt;strong>분명히 나는 한 번 키를 눌렀다 뗐는데, 내부에서 진동으로 인해 스위치가 한번 더 (혹은 여러 번) 눌리는 현상&lt;/strong>이라고 이해하면 되겠다. 다른 말로 채터링(Chattering) 이라고도 부르더라.&lt;/p>
&lt;h2 id="해결시도-1-청소">해결시도 (1) 청소&lt;/h2>
&lt;p>원인은 여러 가지가 있을 수 있지만, 원칙적으로는 스위치 고장이라고 생각해야 하지 않을까. 이럴 땔, 스위치 교체를 해야 한다. 혹시 키캡-스위치 접촉 불량으로 미세하게 덜렁거릴 수도 있으니 청소를 한번 해봤는데… 청소를 다 하고도 똑같은 문제가 자주 발생하는 걸 보면 그렇게 효과가 크진 않은 것 같다.&lt;/p>
&lt;h2 id="해결시도-2-바이오스-업데이트">해결시도 (2) 바이오스 업데이트&lt;/h2>
&lt;p>바이오스 업데이트로 키 입력에 대한 패치를 하는 방법도 있다는데, 잘 모르겠으니 제조사에서 추가 정보가 업데이트 되었는지 확인해 보는 방법도 있겠다. (당연히 내 키보드는 이미 단종이라 그런 사후지원을 기대할 수 없었다.)&lt;/p>
&lt;h2 id="해결시도-3-os-설정으로-문제-억제시키기">해결시도 (3) OS 설정으로 문제 억제시키기&lt;/h2>
&lt;p>그럼 스위치를 교체하거나 키보드를 버려야 할까? 잠깐 그 잔인한 생각을 집어넣고 타협할 방법을 알려드리도록 하겠다.&lt;/p>
&lt;p>나 역시 소프트웨어적으로 이런 반복적인 키 입력을 막을 방법이 분명히 있을거라고 생각했는데, 다양한 해결책이 있었다. 모든 OS는 &amp;lsquo;사용자 접근성&amp;rsquo;이란 메뉴가 존재한다. 화면 글씨를 일부러 키우거나 소리를 읽어주거나 하는 그런 기능들이다. 여기서 제공하는 것들 중 &amp;lsquo;탄력 키&amp;rsquo; 기능을 사용한다.&lt;/p>
&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>윈도우 7 이후의 버전이라면, &amp;lsquo;제어판&amp;rsquo; 의 &amp;lsquo;접근성 센터&amp;rsquo; 에서 &amp;lsquo;키보드를 사용하기 쉽게 설정&amp;rsquo; 항목으로 들어간다. 여기에서 &amp;lsquo;필터 키 켜기&amp;rsquo; 를 적용하면 된다. 그러나 애석하게도 필터 키의 바운스 타임을 뜻하는 &amp;lsquo;탄력 키 입력 인식 시간&amp;rsquo; 간격을 0.5초 이하로 조정할 수 없다. 이 말은, 키를 반복해서 탁탁 칠 때 0.5초보다 빠른 간격으로 치면 모두 무시된다는 소리고, 생각보다 빠른 입력을 할 때 (특히 백스페이스를 반복해서 누를 때) 복장이 터질 가능성이 높다. 결국 이걸 낮추려면 레지스트리를 건드려야 하는데, [이 포스팅][2]을 참고해서 조정이 가능하다.&lt;/p>
&lt;h3 id="linux-ubuntu">Linux (Ubuntu)&lt;/h3>
&lt;p>나 같은 리눅스 사용자는 그럼 어떡해야 할까. Ubuntu 기준으로 설명하면, &amp;lsquo;설정&amp;rsquo; – &amp;lsquo;접근성&amp;rsquo; – &amp;lsquo;자판 입력&amp;rsquo; 에 있는 &amp;lsquo;탄력 키&amp;rsquo; 를 켜서 허용 지연 시간 바(Bar)를 거의 왼쪽으로 갖다 두면 윈도우의 최소 단위인 0.5초보다 간격이 낮아져서, 반복 입력을 해도 무시되는 경우가 거의 없는데다가 키 바운싱이 완화되는 것을 확인할 수 있다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>&lt;a class="link" href="http://m.blog.naver.com/dondek77/140178945548" target="_blank" rel="noopener"
>위 네이버 포스팅&lt;/a>에도 언급되지만, 100% 해결책은 아니다. &amp;lsquo;다&amp;rsquo; 를 치는데 &amp;lsquo;ㄷ&amp;rsquo; 키가 바운싱이 되는 사이에 &amp;lsquo;ㅏ&amp;rsquo;가 입력되면 OS 입장에서는 &amp;lsquo;ㄷㄷ&amp;rsquo; 같은 중복 키로 인식하지 않으므로 &amp;lsquo;닫&amp;rsquo; 같은 문자가 입력되기 때문이다. 이런 문제는 지금 포스팅을 쓰는데도 발생하고 있다 (이런!)&lt;/p>
&lt;p>결국 지름신을 모셔야 할 것 같지만… 어느 정도 완화할 수는 있겠다 싶어서 작성한다.&lt;/p></description></item><item><title>Superliminal</title><link>https://interp.blog/superliminal/</link><pubDate>Thu, 11 Aug 2022 09:00:36 +0900</pubDate><guid>https://interp.blog/superliminal/</guid><description>&lt;img src="https://interp.blog/superliminal/feature.jpg" alt="Featured image of post Superliminal" />&lt;p>서브리미널 (Subliminal) 은 식역하 (識閾下) 라고도 하는데, 인지하는 영역 밖에서 우리가 인지한 것들을 말한다. 김현정의 노래를 뒤로 감아 돌리면 ‘&lt;a class="link" href="https://www.youtube.com/watch?v=fLKsI1gI2E8&amp;amp;ab_channel=%EA%B9%80%ED%98%84%EC%A0%95%28KimHyunJung%29" target="_blank" rel="noopener"
>MP3 다운 말고 제발 앨범 사주세요&lt;/a>’ 처럼 들리는 식의 이른바 백마스킹 (backmasking) 도 그 일종이고, 연구에는 실패했노라 결론났지만 영상에 중간 중간 메시지를 짧은 시간 반복적으로 노출하면, 시청자들이 인지하기 전에 그 메시지를 따른다는 이론도 있었다.&lt;/p>
&lt;p>그렇다면 식역상 (識閾上) 은 어떤 모습일까? &lt;strong>우리가 인지하고 있다지만 사실은 그게 충분한 것이 아니라면?&lt;/strong> 우리가 인지하는 방법이 사실은 틀린 것이라면?&lt;/p>
&lt;p>1인칭 퍼즐 슈터 게임의 계보를 잇는 게임, 슈퍼리미널 (Superliminal) 엔딩을 봤다. 우리의 인지방식, 그러니까 관점에 대한 내러티브를 통해 교훈을 주는 퍼즐 게임이라고 보면 된다. 간단하게 말하면, 보이는 대로 플레이 한다는 참신함은 있었지만 그보다는 지금껏 나온 여러 게임의 믹스처럼 느껴졌다.&lt;/p>
&lt;h1 id="스탠리-패러블-안티챔버-포탈">스탠리 패러블? 안티챔버? 포탈?&lt;/h1>
&lt;p>처음엔 &lt;strong>스탠리 패러블&lt;/strong>같이 배배 꼬여있는 법칙들과, 알 수 없는 나레이션들이 주위를 감쌌다. 그렇다고 멀티 엔딩이 존재하는 것도 아니고 철학적인 메시지가 그 만큼 다채롭진 않다. 배배 꼬여있는 법칙을 풀기 위해선 말도 안되는 생각들을 끼워넣어야 하는데, 이건 마치 &lt;strong>안티챔버&lt;/strong>를 연상케 한다.&lt;/p>
&lt;p>하지만 오히려 이 게임이 메시지를 던지는 방식은, 내러티브와 제4의 벽을 이용한 스탠리 보다는 안티챔버와 비슷한 결을 내고 있다. 그리고 기본적인 퍼즐 플레이 자체는 어쩔 수 없이 포탈과 비슷하다. 물건을 버튼 위에 놓아둬야 문이 열리는 루트는 누가 봐도 &lt;strong>포탈&lt;/strong>이다.&lt;/p>
&lt;p>이런 특성을 고스란히 믹스해 두면서도, 고유의 정체성을 유지하는 것은 어렵다. 아니, 셋 다 내가 봤을 땐 대단한 게임들이라서, 오히려 세 가지 색을 섞고 비어있는 걸 창조한게 아닌가 하는 질 나쁜 의심마저 들 정도다. 사실은 ‘보이는 대로 만들자’ 라고 만들었더니 저런 것들이 다 들어가 있던 것일 수도 있잖아. 하지만 포탈이야 거의 모든 게임에 영향을 줬다고 봐도 무방하니까 기본 값으로 쳐도, 이 게임은 굳이 비교를 하자면 &lt;strong>스탠리의 스킨을 쓴 안티 챔버&lt;/strong>다.&lt;/p>
&lt;h1 id="단순하진-못한-게임-규칙">단순하진 못한 게임 규칙&lt;/h1>
&lt;p>게임의 볼륨이 생각보다 크지 않은데, 왜냐하면 아까 말 했듯 선형적인 구조기 때문에 리플레이를 전혀 할 필요가 없다. 퍼즐 자체의 난이도 1인칭 퍼즐 슈터 장르 안에서는 쉬운 순서로 랭크될 게임이다. 그런데 이런 딜레마는 제작사가 생각하지 않을 수 없었을 텐데, 바로 인지영역 밖의 퍼즐 디자인 자체가 굉장히 힘들다는 것을 반증한다.&lt;/p>
&lt;p>지금까지 언급되건 언급되지 않았건, &lt;strong>1인칭 퍼즐은 단순하고 체계적인 법칙으로 게임의 동력을 만든다.&lt;/strong> 포탈은 ‘물리 법칙’, 탈로스의 법칙은 ‘전기’, 그리고 더 위트니스 (The Witness) 는 ‘그리기’ 라는 도구로 설명할 수 있으니, 어떤 방식으로도 디자인 해도 푸는 사람이 존재할 수 있다. 안티 챔버는 비슷한 딜레마를 겪었을 진 몰라도, 게임 자체가 미쳤기 때문에 (…) 말도 안되는 법칙을 섞어낼 수도 있었던데다 매터 건의 법칙은 일면 단순했기 때문에 (호불호가 있겠지만) 정복 욕구가 생길 수 있었다. 스탠리는 애당초 퍼즐 정복이 아닌 엔딩 정복 게임 같은 거니까 차치하고.&lt;/p>
&lt;p>그런데 슈퍼리미널에선, 조금만 어렵게 만들어도 풀 수 있는 사람이 엄청나게 제한되며, 누가 이런걸 공략으로 올리면 ‘아니 이게 무슨 억지야’ 라는 댓글이 달리기 뻔하기 때문이다. 그 균형을 맞추려면 디자인 패턴에 제약이 생길 수 밖에 없다. 게임이 그 부분을 얼마나 잘 풀어냈는지는 직접 플레이 해보시길.&lt;/p>
&lt;h1 id="불가능을-가능으로">불가능을 가능으로&lt;/h1>
&lt;p>이 게임이 주는 메시지는 ‘&lt;strong>불가능 할 거 같지만 다르게 보면 가능할지도?&lt;/strong>‘ 라는 것이다. 사실상 이게 전부긴 한데, 후반부로 진입할 수록 이 메시지와 내가 풀고 있는 퍼즐 사이에 심각한 괴리가 생겼다. 그래서 어떡하란 건지, 더 이상 현실이 아닌 공간에 플레이러를 가두고는 “할 수 없었던 걸 하니까 좋지요?” 라는 메시지가 갑자기 들어오면 쉽사리 공감이 가질 않는다. 그 때부턴 그냥 게임을 ‘게임답게’ 받아들이고 퍼즐 푸는데만 집중하게 되었으니까.&lt;/p>
&lt;p>하지만 이 게임이 가지고 있는 기본적인 참신함, 1인칭 퍼즐에 목말라 있던 유저들에겐 더할 나위 없이 좋은 신작이라 말할 수 있다. 그 참신함이 어디선가 본 것 같으면서도 크게 와닿지 않는 점이 아쉬울 뿐이다.&lt;/p>
&lt;p>이제 또 다른 관점에서 하루를 시작해 볼 차례다. 게임에서처럼, 알람 소리가 당신을 깨울 것이다.&lt;/p></description></item><item><title>그럴 땐 바로 토끼시죠</title><link>https://interp.blog/rabbit-run-away-in-this-case/</link><pubDate>Mon, 08 Aug 2022 00:48:00 +0000</pubDate><guid>https://interp.blog/rabbit-run-away-in-this-case/</guid><description>&lt;img src="https://interp.blog/images/2022-10-16-toki-cover.png" alt="Featured image of post 그럴 땐 바로 토끼시죠" />&lt;figure class="align-center ">
&lt;img loading="lazy" src="https://interp.blog/images/2022-10-16-toki-cover.png#center" width="60%"/>
&lt;/figure>
&lt;p>인스타툰으로 (나를 포함한) 많은 팔로워를 둔 지수 작가의 첫 번째 에세이. 인스타그램에선 몇 장의 사진으로 하나의 포스트를 이루는데, 다양한 관계와 이따금씩 드는 기분에 대하여 친근하면서도 진솔한 해석을 남긴다. 독자에게 공감을 남기면서도, 따뜻한 위로를 건네주는 것 같다.&lt;/p>
&lt;p>책은 주로 작가의 일상에서 출발해 어떤 생각에 도달했는지를 풀어나가지만, 비단 작가 개인만이 느꼈던 것은 아니었을 보편적인 감정이기 때문에 공감하기 쉬운 주제들로 엮었다. &lt;em>너도 이런 비슷한 경험을 해보지 않았을까?&lt;/em> 그런 질문이 결코 강압적이지 않고, 너가 무슨 생각이 들던 나는 그랬다며 미소짓는 듯하다. 이 책은 마치 김토끼의 얼굴을 닮았다.&lt;/p>
&lt;h1 id="기억나는-문구">기억나는 문구&lt;/h1>
&lt;p>몇 가지 기억나는 부분을 표시했는데, 필사를 해 보니 다음이 남았다. (허락받고 발췌해야 하나?!)&lt;/p>
&lt;blockquote>
&lt;p>나를 찾아가는 여정에 지름길은 없다. 누구도 명쾌하게 답해 주지 않는다.&lt;br>
&lt;strong>인생에는 긴지 짧은지 대 볼 수 있는 명확한 줄자가 없기 때문이다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>다른 사람이 이뤄낸 것을 내가 꼭 이뤄야 할 필요는 없다. 모든 분야를 잘 하는 사람은 현실적으로 존재하지 않는데도, 우리는 예전보다 남들과 비교하기 좋은 세상에 살고 있다. 유튜브, 인스타그램, 페이스북, 블로그, 연예 기사를 보면서 우리보다 잘난 사람들의 이야기를 끊임없이 듣는다. 때로는 그 이야기 속에 &amp;lsquo;여러분도 저 처럼 될 수 있어요!&amp;rsquo; 라며 그들만의 줄자를 나에게 들이밀 때도 있다. 잠시 그 소음을 내려놓고, 내가 정말 원하는 것은 무엇인지 나만의 줄자를 만들어야 한다. 중요한 건, 그게 다른 사람의 것보다 하찮고 짧아도 아무런 상관이 없다는 것!&lt;/p>
&lt;blockquote>
&lt;p>볼링 내기할 때만 그러면 좋으련만 나는 평소에도 내 손을 떠난 일에 시간과 정신을 쏟곤 한다.&lt;br>
&lt;strong>할 수 있는게 아무것도 없어졌을 때 오히려 더 악착같이 집착할 때도 있다.&lt;/strong>&lt;br>
볼링공을 던져놓고 허공에다 대고 허우적거리는 것처럼 말이다.&lt;/p>
&lt;/blockquote>
&lt;p>나 또한 어쩔 수 없는 일에 걱정이 많은 타입인데, 비유가 너무나도 찰지다. 내 손에서 떠난 볼링공을 손짓 발짓을 해가며 기다리는 것. 기우제가 따로 없다.&lt;/p>
&lt;blockquote>
&lt;p>(구독자들에게) 고마운 것은 그뿐이 아니다.&lt;br>
&lt;strong>그들은 콘텐츠를 소비하는 사람이기에 앞서 나와 공감대를 형성하는 사람들이다.&lt;/strong>&lt;br>
그 존재 덕에 큰 위로를 받는다.&lt;/p>
&lt;/blockquote>
&lt;p>내 이야기를 들어주는 사람, 내 생각에 반응해주는 사람이 있다는 것은 얼마나 고마운가. 작가가 다른 사람들에게 영향을 줄 수 있는 것만큼이나, 구독자들도 작가에게 응원을 보내주는 것이라 여긴다면, 글을 쓰거나 그림을 그리면서 내가 가는 방향이 틀리진 않았다는 뜻이지 않을까.&lt;/p>
&lt;blockquote>
&lt;p>세계 여행 경비 마련을 위해 단기로 일거리를 구한 프리랜서, 사직서 한 장을 늘 품고 다니는 마케터, 꿈의 회사로 이직할 작정으로 경력을 쌓는 회사원, 자기가 만든 아이스크림을 먹지 않는 아이스크림 회사 사장, 책보다는 커피를 좋아하는 서점 주인, 틈틈이 쓴 소설로 매해 신춘문예에 응모하는 독서실 아르바이트생 등등…&lt;/p>
&lt;/blockquote>
&lt;p>기가막힌 플로우를 타고 흐르는 래핑 같아서, 가장 애정하는 문구이다. 특히 ‘&lt;em>아이스크림 안 먹는 사장&lt;/em>’ 에서 머리가 뎅- 울렸다. 우리는 회사 이름 뒤에, 직함 뒤에, 직업 뒤에 숨어서 우리 삶을 과하게 일반화시키고 있는 건 아닐까? 그 안에서 우리는 반짝반짝 다른 사람과 전혀 다른 빛깔을 때깔나게 발산할 수 있는데, 그 뒤에 숨어버려서 남들 하는 만큼만 하고 말아버리는 것일지도.&lt;/p>
&lt;h1 id="에세이의-힘">에세이의 힘&lt;/h1>
&lt;p>이 책을 읽으면서, 때때로 내 과거는 다른 사람의 과거와 ‘똑’ 같을 수가 없더라도, 그 안에서 내가 생각한 것들을 이렇게 남들에게 공유하는 것만으로도 쉽게 공감을 이끌어 낼 수 있을 것 같은 용기를 얻었다. 물론 이렇게 잘 할 순 없겠지만, 누구나 처음부터 잘 하는 것은 아니었을 테니까. 책에서 이야기하는 마지막 구절. &lt;strong>의무적으로 꿈을 꾸는, 노력하는 시간을 들여야 언젠간 꿈에 닿을 수 있다고 한다.&lt;/strong> 이렇게 공돌이 한 명은, 전공과 전혀 다른 기묘한 꿈을 꾸어 본다. 나는 이제부터 토끼지 않을 거니까.&lt;/p></description></item><item><title>그레이 맨 (The Gray Man, 2022)</title><link>https://interp.blog/the-gray-man-2022/</link><pubDate>Sat, 06 Aug 2022 23:38:00 +0000</pubDate><guid>https://interp.blog/the-gray-man-2022/</guid><description>&lt;img src="https://interp.blog/images/2022-10-16-grey-man-poster.jpeg" alt="Featured image of post 그레이 맨 (The Gray Man, 2022)" />&lt;p>살인 혐의로 수감된 범죄자가, CIA 가 주도하는 프로그램에 참여한다. 정보가 없기 때문에, 죽어도 기록이 남지 않는 비밀 요원이 된다. 코드네임은 &amp;lsquo;&lt;em>식스&lt;/em>&amp;rsquo;. 몇년 뒤, 누군가가 CIA 의 극비 정보를 넘긴다는 첩보를 입수하고, 그를 제거하기 위해 식스가 나선다. 잡고 보니 그 역시 같은 프로그램 소속이었고 식스를 알아본다. 극비 정보가 담긴 칩은 사실 CIA 의 치부라며 식스에게 넘겨주고, 식스는 이 칩을 숨기게 된다. 센터장은 그가 숨기고 있다고 확신하며, 소시오패스 프리랜서 킬러인 &amp;lsquo;&lt;em>로이드&lt;/em>&amp;rsquo; 에게 그를 제거하라고 지시한다.&lt;/p>
&lt;h1 id="주연들">주연들&lt;/h1>
&lt;ul>
&lt;li>마블 시네마틱 유니버스를 주도한 루소 형제의 넷플릭스 영화이다. 그래서 크리스 에반스라는 이름이 있는 것이 자연스러워 보인다. 그런데, 막상 영화를 보고 있으면 &amp;lsquo;그래서 캡틴 아메리카는 어디 있나요?&amp;rsquo; 같은 생각이 든다. 그보다는 &amp;lsquo;나이브스 아웃&amp;rsquo; 의 랜섬이 콧수염 붙이고 포마드를 더 씨게 발라 나왔다고 보는 편이 맞다. 이마저도 틀린 비유일 정도로, 유니크한 소시오패스 연기를 잘 했다고 생각한다.&lt;/li>
&lt;li>&amp;lsquo;나이브스 아웃&amp;rsquo; 영화 이야기가 나왔으니 또 언급해야 할 사람이 아나 데 아르마스이다. 같은 영화에서 이민자 가정부 역할로 나왔던 순진한 소녀는 어디로 가고, 여기서는 단발에 액션도 불사하는 요원으로 분했다. &amp;lsquo;블레이드 러너 2049&amp;rsquo; 에서도 출연한 걸 보니, 다른 주연들간의 연결고리가 제법 있는 편.&lt;/li>
&lt;li>라이언 고슬링이 저렇게 벌크업을 했던 영화가.. 있구나, 블레이드 러너. 그래도 여기서는 육탄 액션을 마음껏 선보인다. 특유의 능글맞음이 영화에도 녹아있지만, 그것이 라이언 레이놀즈의 깨방정보다는 훨씬 진지하다. ~그리고 이런 농담따먹기는 로이드가 더 많이 한다.~&lt;/li>
&lt;/ul>
&lt;h1 id="본-시리즈-를-생각하고-왔는데">&amp;lsquo;본 시리즈&amp;rsquo; 를 생각하고 왔는데?&lt;/h1>
&lt;p>일단 &lt;em>여러 도시를 누빈다는 설정 + 정보기관이 버린 먼치킨 주인공 + 싸이코 빌런&lt;/em> 설정은 제이슨 본 시리즈의 공식을 따라했다고 생각한다. 맨몸 액션도 다수 섞은 걸 보면 거의 계승한 듯 싶다. 하지만 차이점은 분명한데, 일단 ~카 체이싱 장면이 없잖아!~ 식스가 탈출하거나 진입하는데 개연성이 심히 떨어진다. 그냥 목표에 접근하거나 목적을 이루는 과정은 생략되었다. 이런 사이다를 좋아할 사람들도 있겠지만, 나는 잘 모르겠다.&lt;/p>
&lt;p>그리고 긴장을 가하거나 해소하는 과정에서 왜 저래? 싶은 장면이 한 두개가 아니다. 지나보니 로이드 편에 선 사람은 없었던 게 되고, 프로그램을 주도했던 &amp;lsquo;피츠&amp;rsquo; 의 퇴장은 너무 뻔했다. 일단 다 차치하고, 잔인한 소시오패스라고 하면서, 난 이대로 못 간다며 식스와 1:1 맞짱을 뜬다고? 아니, 이 장면은 &amp;lsquo;강력3반&amp;rsquo; 엔딩 생각나는데&amp;hellip; 맙소사. &lt;del>저기서도 윤태영이 사이코패스 악역이잖아&lt;/del>&lt;/p>
&lt;p>그렇다면 액션은 좋은지? 볼 당시에 피곤해서 그런건지는 모르겠는데, 잠이 솔솔 왔다는 점만 이야기하고 싶다. 딱 넷플릭스 용 킬링 타임 블록버스터 느낌이다. &amp;lsquo;레드 노티스&amp;rsquo; 보다는 스케일이 크고 더욱 짜임새가 좋기는 한데, 재미 면에선 별반 차이는 없는 듯 하다.&lt;/p>
&lt;p>★★★&lt;/p></description></item><item><title>내 인생 영화 BEST 5</title><link>https://interp.blog/my-life-best-5-movies/</link><pubDate>Thu, 04 Aug 2022 18:09:24 +0000</pubDate><guid>https://interp.blog/my-life-best-5-movies/</guid><description>&lt;img src="https://interp.blog/my-life-best-5-movies/feature.jpg" alt="Featured image of post 내 인생 영화 BEST 5" />&lt;blockquote>
&lt;p>&amp;ldquo;다섯 번째로 좋아하는 영화가 뭐예요?&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>이 질문은 장강명 작가의 &amp;lsquo;&lt;a class="link" href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=247906273&amp;amp;start=slayer" target="_blank" rel="noopener"
>책 한번 써봅시다&lt;/a>&amp;rsquo; 에서, 나의 개성을 알아내는 질문으로 제시된 것 중 하나이다. 여기에 답하려면 가장 좋아하는 영화를 골라내고, 어떤 기준으로 영화의 순위가 갈라지는지 알아야 한다. 이런 질문은 글감을 찾아내기에도 안성 맞춤이라고 한다.&lt;/p>
&lt;p>그래서 무턱대고, &lt;a class="link" href="https://pedia.watcha.com/" target="_blank" rel="noopener"
>왓챠&lt;/a>에 기록한 내 영화 리스트를 죽 꺼내들어서 별점이 가장 높은 영화 중 5편만 꼽아봤다. 참고로 내 왓챠 평균 별점은 3.9점이다. 후해도 너무 후하다 (&amp;hellip;) 물론 철학적으로 사유하기 좋은 영화도 많고, 고전 영화도 심심찮게 많이 봤다. 하지만 어디까지나 개인적인 기준의 BEST5 이니 편한 마음으로 봐주시길.&lt;/p>
&lt;div style="background-color: var(--body-background); width: 98%; margin:1px; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
❗
&lt;/div>
&lt;div>
스포일러가 있을 수 있습니다!
&lt;/div>
&lt;/div>
&lt;h1 id="5-반지의-제왕--두-개의-탑httpsmovienavercommoviebimibasicnavercode31795-2002">5. &lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.naver?code=31795" target="_blank" rel="noopener"
>반지의 제왕 : 두 개의 탑&lt;/a> (2002)&lt;/h1>
&lt;p>&lt;img src="https://interp.blog/my-life-best-5-movies/2022-08-05-16-28-13.png"
width="1068"
height="1524"
srcset="https://interp.blog/my-life-best-5-movies/2022-08-05-16-28-13_huce8b0876025f6f67ad21e1449daee675_3588439_800x0_resize_q75_h2_box_3.webp 480w, https://interp.blog/my-life-best-5-movies/2022-08-05-16-28-13_huce8b0876025f6f67ad21e1449daee675_3588439_1600x0_resize_q75_h2_box_3.webp 1024w"
loading="lazy"
alt="center"
class="gallery-image"
data-flex-grow="70"
data-flex-basis="168px"
>&lt;/p>
&lt;p>이 시리즈의 첫 번째 영화인 &amp;lsquo;&lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.naver?code=31794" target="_blank" rel="noopener"
>반지 원정대&lt;/a>&amp;rsquo; 는 내가 영화관에서 본 두 번째 영화다. (첫 번째는 스티븐 스필버그의 A.I.) 이 계기로 모든 시리즈를 영화관에서 보게 되었는데, 순전히 옛날 추억으로 다섯손가락에 꼽은 것만은 아니다.&lt;/p>
&lt;p>시리즈 두 번째 영화인 &amp;lsquo;두 개의 탑&amp;rsquo; 은 본격적인 오크의 침공이 그려지기 때문에 스케일 면에서 장엄함을 느낄 수 있다. 지금까지도 이런 전투 스케일을 그려내는 판타지 영화가 없다고 할 정도니까. 그리고 마지막 간달프의 증원은 길이 회자될 만 하다.&lt;/p>
&lt;p>하지만 역시 후술할 다른 영화들보다 오래된 영화라 그런지, 추억속에서 건져올릴 만한 것이 없는 영화이기도 하다.&lt;/p>
&lt;h1 id="4-본-얼티메이텀httpsmovienavercommoviebimibasicnavercode59075-2007">4. &lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.naver?code=59075" target="_blank" rel="noopener"
>본 얼티메이텀&lt;/a> (2007)&lt;/h1>
&lt;p>&lt;img src="https://interp.blog/my-life-best-5-movies/2022-08-05-16-31-08.png"
width="1055"
height="1512"
srcset="https://interp.blog/my-life-best-5-movies/2022-08-05-16-31-08_hudc7b08a8e47d734088e1cd734d633552_3192591_800x0_resize_q75_h2_box_3.webp 480w, https://interp.blog/my-life-best-5-movies/2022-08-05-16-31-08_hudc7b08a8e47d734088e1cd734d633552_3192591_1600x0_resize_q75_h2_box_3.webp 1024w"
loading="lazy"
alt="center"
class="gallery-image"
data-flex-grow="69"
data-flex-basis="167px"
>&lt;/p>
&lt;p>개인적으로 본 시리즈를 다 좋아하지만, 세 편 모두 넣을 순 없어서 가장 애정하는 한 편만 넣기로 했다. &lt;del>아, 그 다음에 나온 영화들이요? 그게 뭐였죠? ㅎㅎㅜㅜ&lt;/del>&lt;/p>
&lt;p>대사나 명장면은 1편인 &amp;lsquo;&lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.naver?code=35273" target="_blank" rel="noopener"
>본 아이덴티티&lt;/a>&amp;rsquo; 가 더 많이 떠오르는데, 아무래도 거의 모든 비밀을 알게된 본이 활약하는 세 번째 시리즈가 전체적으로 더 기억에 남는다. 그리고 마지막 엔딩까지 완벽하게!&lt;/p>
&lt;p>설정이 무엇보다 매력적이다. 기억을 잃었는데, 알고 보니 내가 킹왕짱 센 특급 비밀 요원?! 옛날 성룡의 영화들에서 볼 수 있는 임기응변 식의 액션이나 탈출 씬이 많아, 덜 작위적면서도 손에 땀을 쥐게 만들었다.&lt;/p>
&lt;p>반지의 제왕보다 순위가 높은 점은, 일단 지루하지 않다는 점이다. 반대로, 상위권 영화보다 순위가 낮은 점은, 리플레이성은 확실히 떨어진다는 점이다. (그래도 한 예닐곱번은 본 듯)&lt;/p>
&lt;h1 id="3-초속-5센티미터httpsmovienavercommoviebimibasicnavercode66820-2007">3. &lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.naver?code=66820" target="_blank" rel="noopener"
>초속 5센티미터&lt;/a> (2007)&lt;/h1>
&lt;p>&lt;img src="https://interp.blog/my-life-best-5-movies/2022-08-05-16-31-28.png"
width="1583"
height="2268"
srcset="https://interp.blog/my-life-best-5-movies/2022-08-05-16-31-28_hu69d55124ff679eaba6e2ecb95704a4be_3903146_800x0_resize_q75_h2_box_3.webp 480w, https://interp.blog/my-life-best-5-movies/2022-08-05-16-31-28_hu69d55124ff679eaba6e2ecb95704a4be_3903146_1600x0_resize_q75_h2_box_3.webp 1024w"
loading="lazy"
alt="center"
class="gallery-image"
data-flex-grow="69"
data-flex-basis="167px"
>&lt;/p>
&lt;p>이제부터는 얼마나 영화를 많이 봤느냐에 따라 순위가 매겨진다. 개인적으로 볼 때 마다 감상이 조금씩 달라지는 영화를 매우 좋아하는데, 그러자면 먼저 해석할 여지가 많거나 아니면 어느 한 부분이 특출난 영화여야 한다. &lt;del>재미있는 건, 해석할 여지가 많은 영화들은 TOP5 에 모두 들지 못했다.&lt;/del>&lt;/p>
&lt;p>사실 TOP3 를 뽑으라면 왓챠고 뭐고 보지 않고 이 세 편을 자신있게 꺼낼 수 있었다. 그 중에서 가장 짧은 (!) 초속 5센티미터가 3위이다. 이 영화는 그냥 &amp;lsquo;예쁘다&amp;rsquo;.&lt;/p>
&lt;p>신카이 마코토 감독의 단편 애니메이션 &amp;lsquo;&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%81%BB%E3%81%97%E3%81%AE%E3%81%93%E3%81%88" target="_blank" rel="noopener"
>별의 목소리&lt;/a>&amp;rsquo; 를 투니버스에서 심야에 방영해 준 적이 있었다. 우연히 보게 되었는데, 인체 비율이 좀 아쉽긴 하지만 배경에서 느껴지는 장인정신에 감탄했다. 괜히 &amp;lsquo;빛의 마술사&amp;rsquo; 라고 불리는 게 아니다.&lt;/p>
&lt;p>초속 5센티미터는 어릴적의 풋풋함, 싱그러움, 방황, 사랑을 정말로 예쁜 배경에 담아낸 작품이다. 지금 다시 보라고 하면 오글거릴텐데, 당시의 나는 몇 번이고 돌려봤던 기억이 있다. 물론 스토리 자체에는 호불호가 갈릴 수 있지만, 그렇게 찜찜하게 끝내는 게 이루어질 수 없는 첫사랑을 잘 표현했다고 생각한다.&lt;/p>
&lt;h1 id="2-라라랜드httpsmovienavercommoviebimibasicnavercode134963-2016">2. &lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.naver?code=134963" target="_blank" rel="noopener"
>라라랜드&lt;/a> (2016)&lt;/h1>
&lt;p>&lt;img src="https://interp.blog/my-life-best-5-movies/2022-08-05-16-31-51.png"
width="1978"
height="2835"
srcset="https://interp.blog/my-life-best-5-movies/2022-08-05-16-31-51_hucdbac4fc4ec36ab28ec22edaf2bf4ed9_9347536_800x0_resize_q75_h2_box_3.webp 480w, https://interp.blog/my-life-best-5-movies/2022-08-05-16-31-51_hucdbac4fc4ec36ab28ec22edaf2bf4ed9_9347536_1600x0_resize_q75_h2_box_3.webp 1024w"
loading="lazy"
alt="center"
class="gallery-image"
data-flex-grow="69"
data-flex-basis="167px"
>&lt;/p>
&lt;p>초속 5센티미터가 철없는 20대 초반에 돌려보기를 했다면, 이번엔 요즘 와이프와 자주 돌려보는 영화 &amp;lsquo;라라랜드&amp;rsquo; 가 2위이다. 이 영화는 다들 알다시피 음악에 공을 들였고, 정말로 다시 봐도 좋은 영화임에 틀림없다. 그런데 우리는 돌려볼 때 마다 마지막 장면을 주로 이야기하곤 한다.&lt;/p>
&lt;p>결국 세스와 미아는 서로의 꿈을 응원하고 헤어지는데, 마지막에서 우연히 재회한 장면을 &amp;lsquo;만약에&amp;hellip;?&amp;rsquo; 로 압축된 미니 뮤지컬로 표현하는게 기가 막히고 코가 막힌다. 아쉽게 헤어진 연인에 미련이 남을 때 늘 하는 생각들이 다들 이런 것 아니겠는가. 서로 아련해진 미아와 세스는 마지막 장면에서 눈빛을 주고 받으며 영화는 끝이 난다.&lt;/p>
&lt;h1 id="1-타짜httpsmovienavercommoviebimibasicnavercode57723-2006">1. &lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.naver?code=57723" target="_blank" rel="noopener"
>타짜&lt;/a> (2006)&lt;/h1>
&lt;p>&lt;img src="https://interp.blog/my-life-best-5-movies/2022-08-05-16-33-18.png"
width="900"
height="1289"
srcset="https://interp.blog/my-life-best-5-movies/2022-08-05-16-33-18_hu558361fa2b490f22a8bb1e5aba460d37_1443092_800x0_resize_q75_h2_box_3.webp 480w, https://interp.blog/my-life-best-5-movies/2022-08-05-16-33-18_hu558361fa2b490f22a8bb1e5aba460d37_1443092_1600x0_resize_q75_h2_box_3.webp 1024w"
loading="lazy"
alt="center"
class="gallery-image"
data-flex-grow="69"
data-flex-basis="167px"
>&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>&amp;ldquo;타짜를 아냐구요? 내가 본 영화 중 최고였어요&amp;rdquo;&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>와이프와 친구들은 이제 내가 타짜 대사 드립 좀 그만 쳤으면 좋겠다고 한다. 미안하다, 상황만 맞으면 드립을 치고 싶어 입이 근질거린다. 곽철용이 유행을 타기 훨씬 전부터, 거의 모든 대사를 줄줄이 꿰고 있었다. 왜냐고? 대사 하나하나 거를 타선이 없기 때문이다. 나는 타짜가 최동훈 감독의 역작이라고 생각한다. &amp;lsquo;&lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.naver?code=48227" target="_blank" rel="noopener"
>전우치&lt;/a>&amp;lsquo;도 좋아하고 &amp;lsquo;&lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.naver?code=121048" target="_blank" rel="noopener"
>암살&lt;/a>&amp;rsquo; 도 좋아하지만, 아무래도 타짜 뿐이다.&lt;/p>
&lt;p>소재가 매력적이기도 하지만, 그것보다는 인물들의 개성에 딱 맞는 대사와 그 합을 아주 오밀조밀 잘 짜뒀기 때문이다. 그래서 이 영화는 지루하지가 않다. 다음 장면이 아 그거였지 싶어도 기대가 된다. 그 환상의 티키타카를 볼 생각을 하면 말이다.&lt;/p>
&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>이렇게 모아보니 나는 자주 본 순서대로 순위를 매겼다. 좋아한 만큼 자주 봤을테니 당연한 거 아닌가? 물론 자주 보지 않았음에도 기억에 남는 영화는 많다. 이런 영화를 또 모아서 &amp;lsquo;아차상!&amp;rsquo; 같은 포스팅을 하면 좋겠지만, 언제 시간이 될런지. 어쨌거나, 이렇게 나만의 순위를 매겨보고 그 이유를 탐구해보는 시간도 나쁘지 않은 것 같다. 다른 분들도 한번 해 보길 바라며, 다음에는 다른 분야에서 나만의 순위표를 만들어 볼 생각에 벌써 신났다. 감사해요, 장강명 작가님!&lt;/p></description></item><item><title>저작권 걱정 없는 무료 이미지 사이트 3개</title><link>https://interp.blog/license-free-image-3-sites/</link><pubDate>Thu, 28 Jul 2022 01:39:19 +0000</pubDate><guid>https://interp.blog/license-free-image-3-sites/</guid><description>&lt;img src="https://interp.blog/images/2022-07-28-glenn-carstens-peters-loatw2afdyu-unsplash.jpg" alt="Featured image of post 저작권 걱정 없는 무료 이미지 사이트 3개" />&lt;div style="background-color: var(--body-background); width: 98%; margin:1px; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
😉
&lt;/div>
&lt;div>
이 포스팅의 대표 이미지는 Unsplash 에서 찾은 &lt;a href="https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText">Glenn Carstens-Peters&lt;/a> 의 사진이다. Thanks, Glenn!
&lt;/div>
&lt;/div>
&lt;h2 id="unsplash">Unsplash&lt;/h2>
&lt;p>&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-07-28-unsplash.jpg"/>
&lt;/figure>
&lt;a class="link" href="https://unsplash.com/" title="https://unsplash.com/"
target="_blank" rel="noopener"
>https://unsplash.com/&lt;/a>&lt;/p>
&lt;p>Unsplash 는 노트 서비스인 &lt;a class="link" href="https://www.notion.so/" target="_blank" rel="noopener"
>Notion&lt;/a> 사용자들에게 친숙할 수 있는데, 페이지의 커버 이미지를 선택할 때 Unsplash 에서 손쉽게 검색하고 등록할 수 있는 기능을 제공하기 때문이다. 블로깅 도구인 &lt;a class="link" href="https://ghost.org/integrations/unsplash/" target="_blank" rel="noopener"
>Ghost&lt;/a> 에서는 본문에 이미지를 추가할 때 동일한 기능을 제공하고 있어, 다른 두 곳보다 상대적으로 유명하다 할 수 있겠다.&lt;/p>
&lt;h3 id="저작권">저작권&lt;/h3>
&lt;ul>
&lt;li>✅ 자유롭게 다운로드하고 사용할 수 있음.&lt;/li>
&lt;li>✅ 상업적 사용이 가능함.&lt;/li>
&lt;li>✅ 사용에 어떠한 조건도 없지만, 출처 언급을 해 주면 더욱 좋을 것.&lt;/li>
&lt;li>❌ 수정 없이 재판매 금지&lt;/li>
&lt;li>❌ 다른 스톡/배경화면 모음 서비스에 게재 금지&lt;/li>
&lt;/ul>
&lt;p>자세한 내용은 &lt;a class="link" href="https://unsplash.com/license" title="https://unsplash.com/license"
target="_blank" rel="noopener"
>https://unsplash.com/license&lt;/a> 를 참고한다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="pexels">Pexels&lt;/h2>
&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-07-28-pexels.jpg"/>
&lt;/figure>
&lt;p>&lt;a class="link" href="https://www.pexels.com/" title="https://www.pexels.com/"
target="_blank" rel="noopener"
>https://www.pexels.com/&lt;/a>&lt;/p>
&lt;p>최근에 찾은 또 다른 스톡 서비스인 Pexels 는 한국어 인터페이스를 지원하면서, Unsplash 에서 보던 사진 느낌을 볼 수 있다. 게다가 비디오까지 내려받을 수 있다.&lt;/p>
&lt;h3 id="저작권-1">저작권&lt;/h3>
&lt;ul>
&lt;li>✅ 자유롭게 다운로드하고 사용할 수 있음.&lt;/li>
&lt;li>✅ 상업적 사용이 가능함.&lt;/li>
&lt;li>✅ 수정 가능함.&lt;/li>
&lt;li>✅ 사용에 어떠한 조건도 없지만, 출처 언급을 해 주면 더욱 좋을 것.&lt;/li>
&lt;li>❌ 식별할 수 있는 인물이 부정적 이미지로 소비되는 것 금지&lt;/li>
&lt;li>❌ 식별할 수 있는 인물/브랜드를 통해 홍보 금지&lt;/li>
&lt;li>❌ 수정 없이 재판매 금지&lt;/li>
&lt;li>❌ 다른 스톡/배경화면 모음 서비스에 게재 금지&lt;/li>
&lt;/ul>
&lt;p>자세한 내용은 &lt;a class="link" href="https://www.pexels.com/ko-kr/license/" title="https://www.pexels.com/ko-kr/license/"
target="_blank" rel="noopener"
>https://www.pexels.com/ko-kr/license&lt;/a> 를 참고한다.&lt;/p>
&lt;h2 id="pixabay">Pixabay&lt;/h2>
&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-07-28-pixabay.jpg"/>
&lt;/figure>
&lt;p>&lt;a class="link" href="https://pixabay.com/" title="https://pixabay.com/"
target="_blank" rel="noopener"
>https://pixabay.com/&lt;/a>&lt;/p>
&lt;p>Pexels 에서 사진과 비디오를 제공하는 것에 더해, 여기 Pixabay 에서는 벡터, 일러스트레이터, 음악과 사운드 이펙트까지 내려받을 수 있다. 물론 한국어 인터페이스를 지원한다.&lt;/p>
&lt;h3 id="저작권-2">저작권&lt;/h3>
&lt;p>별도로 저작권 설명 페이지는 없고 FAQ 를 통해 간접 추측이 가능하다.&lt;/p>
&lt;ul>
&lt;li>✅ 자유롭게 다운로드하고 사용할 수 있음.&lt;/li>
&lt;li>✅ 수정을 거친 뒤, 상업적 사용이 가능함. (FAQ 문서를 참고)&lt;/li>
&lt;li>✅ 사용에 어떠한 조건도 없지만, 출처 언급을 해 주면 더욱 좋을 것.&lt;/li>
&lt;li>❌ 식별할 수 있는 인물이 부정적 이미지로 소비되는 것 금지&lt;/li>
&lt;li>❌ 식별할 수 있는 인물/브랜드를 통해 홍보 금지&lt;/li>
&lt;li>❌ 수정 없이 상업적 사용/재판매 금지&lt;/li>
&lt;li>❌ 수정을 하더라도 상표 등록을 할 수 없음.&lt;/li>
&lt;li>❌ 다른 스톡/배경화면 모음 서비스에 게재 금지&lt;/li>
&lt;/ul>
&lt;p>자세한 내용은 &lt;a class="link" href="https://pixabay.com/ko/service/faq/" title="https://pixabay.com/ko/service/faq/"
target="_blank" rel="noopener"
>https://pixabay.com/ko/service/faq/&lt;/a> 를 참고한다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>미디어를 프린팅해서 판매한다거나, 특정 제품을 위한 로고나 브랜딩을 위한 이미지 작업을 위해 사용하는 것이 아니라면야 어떤 식으로 사용해도 상관없을 것 같다. 재판매 역시도 원본 그대로는 불가능하지만, 나름의 창의력을 더한 수정본의 경우엔 판매가 가능하다는 것이 세 사이트의 공통적인 지침이다.&lt;/p>
&lt;p>세 사이트 모두 다량의 사진을 보유하고 있고, 실력있는 작가들의 멋진 작품 투고가 현재까지 누적되고 있으니 유용하다고 생각한다. 블로그를 꾸미거나 프레젠테이션을 꾸밀 때, 단순히 디자인이나 사진 영감을 얻기 위해 둘러보면 좋을 것 같다. 개인적으로는 이미지 자체를 내려받을 때는 Unsplash 를 자주 사용했는데, 다른 두 서비스에는 비디오를 제공하니 같이 써봐야겠다.&lt;/p></description></item><item><title>아메리칸 셰프</title><link>https://interp.blog/chef-2014/</link><pubDate>Sun, 17 Jul 2022 17:41:57 +0000</pubDate><guid>https://interp.blog/chef-2014/</guid><description>&lt;img src="https://interp.blog/images/2022-07-18-untitled.png" alt="Featured image of post 아메리칸 셰프" />&lt;h1 id="줄거리">줄거리&lt;/h1>
&lt;p>셰프라는 직업에 자부심이 강한 주인공 칼은, 파워 블로거 평론가를 맞이하기 위해 자신만의 코스 요리를 준비하지만, 레스토랑에서 늘 만들던 대로 하라는 사장의 만류에 막히고 만다. 평론가에게 혹평을 받게 되고, 트위터를 통해 많은 사람들의 입방아에 오르내리고 만다.&lt;/p>
&lt;p>사업가 아내와 이혼한 뒤, 10살 아들을 주기적으로 돌보던 어느 날, 트위터가 뭔지 몰랐던 칼은 아들을 통해 사용하는 방법을 배우고 계정을 만들게 된다. 그리고 평론가에게 욕설과 함께 다시 와서 먹어보라는 &amp;lsquo;답글&amp;rsquo; 을 남긴다. 이 스레드는 공개되어 세간의 관심을 모으게 되고, 평론가 역시 재도전을 흥미진진하게 받아들이며 레스토랑으로 향한다.&lt;/p>
&lt;p>하지만 다시 한 번, 칼은 만들던 메뉴를 대접하라는 사장의 압박을 받았고, 이 레스토랑은 내 것이지 네 것이 아니란 말과 함께 만들던지 나가던지 선택을 하라고 한다. 결국 칼은 다 집어던지고 나갔다가, &amp;ldquo;이 셰프는 쫄아서 안 나왔네&amp;rdquo; 라는 평론가의 트윗을 보고 다시 찾아가 면전에 욕설을 토해낸다.&lt;/p>
&lt;p>그리고 깔끔하게 망했다. 칼을 불러주는 사람은 없었다. 그 때 마침, 전 아내가 처갓집이 있는 곳에 아들 보모 역할로 같이 가자며, 가면 좋은 수가 생기지 않겠냐고 제안했다. 사실 아내는 그의 독단적인 기질을 살리려면 푸드트럭을 하는게 차라리 낫겠다고 제안한 적이 있었고, 실제로 아내는 전 남편에게 미리 부탁해, 푸드트럭을 하나 받아가게끔 말을 다 맞춰 둔 상태.&lt;/p>
&lt;p>물론 그렇게 받은 트럭은 고물이었지만, 레스토랑에서 자기만 보고 그만두고 따라나온 마틴과 함께 트럭을 치우고 새 출발을 한다. 그리고 아들 역시 큰 도움을 준다. 요리도 하고, 트위터로 홍보도 하면서. 그렇게 집으로 가는 동안 푸드트럭은 가는 곳 마다 성행했고, 세 사람 특히 칼과 아들의 우정도 돈독해진다.&lt;/p>
&lt;h1 id="대사">대사&lt;/h1>
&lt;blockquote>
&lt;p>“그렇다 치고 음식이나 문화 말이야, 베녜 같은거”&lt;br>
”여기서도 팔잖아”&lt;br>
&lt;strong>”완전히 달라. 여기서도 맛있는 건, 거기서 먹었던 기억이 떠오르는 거야”&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>주인공인 칼은 유독 음식의 본고장에서 먹는 것이 진짜 맛이라고 말하는데, 너무 마음에 드는 표현이다. 정말 음식 자체만 놓고 보면 한국에서 똑같이 만들면 맛은 똑같이 나겠지만 지역의 공기, 환경에 크게 좌우한다고 생각한다. 극단적으로 그 때의 기분, 날씨같은 우연의 요소까지 머리가 기억하고, 단지 그 음식이 그 때의 기억을 당기는 방아쇠가 되는 것이라고 믿기 때문이다.&lt;/p>
&lt;p>결국 둘은 뉴올리언스에 가서 베녜를 먹으러 갔다.&lt;/p>
&lt;h1 id="여담">여담&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>존 파브로가 아이언맨 1,2 감독&lt;/strong>이었다니, 영화보기 직전까지 몰랐다. 그래서 로다주와 스칼렛 요한슨이 나온 걸지도 모르겠다. (다른 배우도 쟁쟁하다, 사장님이 더스틴 호프만이라고요?)&lt;/li>
&lt;li>전처로 나온 소피아 베르가라가 정말 예쁘다. 만날 때 마다 입고 있는 옷이 바뀌는데, 패션쇼인가? 스칼렛 요한슨도 물론 예쁘다. 파스타 기다리는데, 왜 어께 다 흘러내리게 누워 계세요?&lt;/li>
&lt;li>로다주가 맡은 캐릭터는 결벽증에 의심병 환자에 전남편끼리 만나서 한다는 소리부터 저질이다. 물론 캐릭터가 그렇다는 것이다.&lt;/li>
&lt;li>결국 영화는 해피엔딩으로 끝난다. 평론가 아조씨는 ‘내가 알던 그 칼이 돌아왔다’ 며 사업제안을 하고, 셰프 전권을 보장해주는 조건으로 레스토랑으로 칼을 스카웃 해간다.&lt;/li>
&lt;/ul></description></item><item><title>A tour of Go: Pointer, Struct, Array, Slice</title><link>https://interp.blog/tour-of-go-pointer-struct-array-slice/</link><pubDate>Sun, 03 Jul 2022 17:06:37 +0000</pubDate><guid>https://interp.blog/tour-of-go-pointer-struct-array-slice/</guid><description>&lt;p>Go 여행 세 번째 시간이다. &lt;a class="link" href="https://interp.blog/tour-of-go-flow-control-stmts/" target="_blank" rel="noopener"
>지난 시간&lt;/a>에는 flow control statement 에 대해서 알아봤다. 이번에는 Go 언어의 다양한 자료형에 대해 정리해 봤다.&lt;/p>
&lt;h2 id="a-tour-of-go">A tour of Go&lt;/h2>
&lt;ul>
&lt;li>English: &lt;a class="link" href="https://go.dev/tour/" title="https://go.dev/tour/"
target="_blank" rel="noopener"
>https://go.dev/tour/&lt;/a>&lt;/li>
&lt;li>한국어판: &lt;a class="link" href="https://go-tour-ko.appspot.com/" title="https://go-tour-ko.appspot.com/"
target="_blank" rel="noopener"
>https://go-tour-ko.appspot.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="pointer">Pointer&lt;/h2>
&lt;ul>
&lt;li>C/C++ 처럼, golang 에도 포인터가 있다.&lt;/li>
&lt;li>NULL 표현은 &lt;code>nil&lt;/code> 이다.&lt;/li>
&lt;li>그 외엔.. 뭐 C pointer 쓰는 거랑 별로 다를게 없다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">42&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2701&lt;/span>
&lt;span class="nx">p&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">i&lt;/span> &lt;span class="c1">// point to i
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// read i through the pointer = 42
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">21&lt;/span> &lt;span class="c1">// set i through the pointer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// see the new value of i = 21
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">j&lt;/span> &lt;span class="c1">// point to j
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">37&lt;/span> &lt;span class="c1">// divide j through the pointer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// see the new value of j = 73
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="struct">Struct&lt;/h2>
&lt;p>C 의 struct 와 동일한, field 들의 모음이다.&lt;/p>
&lt;p>C 였다면 &lt;code>typedef type struct Vertex { ... } Vertex;&lt;/code> 이라고 typedef 를 곁들여야 하지만, 여기서는 &lt;code>type&lt;/code> 만 써도 된다. 사실상 &lt;code>type&lt;/code> 하나가 위의 &lt;code>typedef ...&lt;/code> 전체를 모두 커버한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>var [변수명] [타입]&lt;/code> 처럼 &lt;code>type [타입명] struct&lt;/code> 인 것을 잘 기억해 두자.&lt;/li>
&lt;li>struct 형 변수를 초기화할 때는 &lt;code>{ }&lt;/code> 로 써야 한다.&lt;/li>
&lt;li>각 field 는 &lt;code>.&lt;/code> 을 사용해서 참조할 수 있다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">type&lt;/span> &lt;span class="nx">Vertex&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">X&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="nx">Y&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Vertex&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">})&lt;/span> &lt;span class="c1">// {1, 2} 라고 표시된다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="struct-pointer">Struct Pointer&lt;/h3>
&lt;p>원래 C 같았으면 struct pointer 변수에서 특정 필드를 참조하려면 &lt;code>(*p).X&lt;/code> 이런 식으로, 포인터의 struct 값을 dereference 한 다음에 참조하거나, &lt;code>p-&amp;gt;X&lt;/code> 같은 식으로 &amp;lsquo;포인터 변수&amp;rsquo; 라는 걸 나타내서 참조하는데.. 여기서는 둘 다 귀찮으니까 &lt;code>p&lt;/code> 가 struct pointer 라도 &lt;code>p.X&lt;/code> 로 참조가 가능하게 했다.&lt;/p>
&lt;pre>&lt;code>func main() {
v := Vertex{1, 2}
p := &amp;amp;v
p.X = 1e9 // 이렇게만 참조하고 값까지 할당하는데, 아무런 문제가 없다.
fmt.Println(v) // {1000000000 2}
}
&lt;/code>&lt;/pre>
&lt;h3 id="struct-literals">Struct Literals&lt;/h3>
&lt;p>Struct 형 변수 초기화할 때 취할 수 있는 방법을 소개한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>보통 unnamed list 를 할 것이다. &lt;code>Vertex{1,2}&lt;/code> 처럼&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>named list 도 가능한데, &lt;code>[field name]:&lt;/code> 으로 쓴다. function 의 default parameter 와는 달리, 여기선 순서는 상관없다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>값을 넣지 않으면, 각 필드의 기본값이 들어간다. (여기서는 int 니까 0)&lt;/p>
&lt;p>var (
v1 = Vertex{1, 2} // has type Vertex
v2 = Vertex{X: 1} // Y:0 is implicit
v3 = Vertex{} // X:0 and Y:0
p = &amp;amp;Vertex{1, 2} // has type *Vertex
)&lt;/p>
&lt;p>func main() {
fmt.Println(v1, v2, v3, p) // {12} {1 0} {0 0} &amp;amp;{1 2}
}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="array">Array&lt;/h2>
&lt;p>Slice 와는 달리, 사이즈가 고정된다.&lt;/p>
&lt;ul>
&lt;li>C 처럼 length 가 뒤에 오지 않고, 앞에 온다.&lt;/li>
&lt;li>출력하면 struct 와는 달리 꺽쇠 &lt;code>[ ]&lt;/code> 로 출력된다.&lt;/li>
&lt;li>&lt;strong>하지만 literal 선언은 (slice 와 마찬가지로) &lt;code>{ }&lt;/code> 안에서 원소를 나열해야 한다.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="slice">Slice&lt;/h2>
&lt;p>Array 에서 length number 만 지우면, slice 가 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>array 또는 slice 에서 index range 를 지정할 수 있는데, C array index 를 생각해도 헷갈릴 수 있는 부분이다.
&lt;ul>
&lt;li>수학적으로 정확한 range 표현은 &lt;code>[n:m)&lt;/code> 이다. 마지막 인덱스에 해당하는 원소는 &lt;strong>포함이 안 된다&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">primes&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">13&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">primes&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 3, 5, 7, 11 인가?
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [3 5 7] 만 출력된다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Slice 는 단독으로 쓰이기도 하지만, 보통은 array 의 특정 구간을 나타내기 위해서도 쓰인다. 주의할 점은, Slice 가 바뀌면 연결된 array 도 같이 바뀐다는 것이다 (&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">names&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span> &lt;span class="c1">// 어.. 비틀즈 성님덜?
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="s">&amp;#34;John&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;Paul&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;George&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;Ringo&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">names&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">names&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// [John Paul]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">b&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">names&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// [Paul George]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;XXX&amp;#34;&lt;/span> &lt;span class="c1">// 아니 왜 폴 메카트니 성님을 지워여;;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 폴의 이름이 다 바뀌어 있음.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">names&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 그리고 원래 array 에도 영향이..
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>[n:m]&lt;/code> 으로 구간을 나눌 때 양쪽 end 를 생략할 수도 있고, 둘 다 생략할 수도 있다.
&lt;ul>
&lt;li>왼쪽 생략 = 0&lt;/li>
&lt;li>오른쪽 생략 = 끝까지&lt;/li>
&lt;li>양쪽 생략 = 그냥 그 array/slice 전체 (&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>slice 안에 당연히 struct 를 쓸 수 있다. 그래서 이런 괴상망측한 하지만 자주 보게 될 선언도 있다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="c1">// 이런게 가능합니다...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 이렇게 typed value 를 바로 선언하는 걸 literal 이라고 하는데,
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// slice 건 struct 건 간에 literal 은 [] 가 아니라 {} 로 해야 한다.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="nx">b&lt;/span> &lt;span class="kt">bool&lt;/span>
&lt;span class="p">}{&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>slice 는 length &lt;code>len()&lt;/code> 과 와 capacity &lt;code>cap()&lt;/code> 을 지원한다.
&lt;ul>
&lt;li>&lt;code>len()&lt;/code> : 실제 원소들의 개수&lt;/li>
&lt;li>&lt;code>cap()&lt;/code> : 하위 array 의 개수 (array 는 fixed-width 라고 했다)
&lt;ul>
&lt;li>이게 언제 필요하냐면, slicing 할 수 있는 길이를 가늠할 때 (만약 cap 이 6인데 &lt;code>[:7]&lt;/code> 이렇게 쓰면 에러가 나버린다.&lt;/li>
&lt;li>중요한 건, underlying array 에서, slice 의 first element 가 가리키는 위치 부터 끝까지의 길이이다 (끝 인덱스는 상관없는게 또 헷갈린다..)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">13&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Slice the slice to give it zero length.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 끝이 지정되어 있지 않으니 cap 은 6임. length 는 당연히 0이고.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Extend its length.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 0~4 까지니까 length 는 5이고, 역시 끝이 지정되어 있지 않아서 cap 은 6임.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Drop its first two values.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">:]&lt;/span> &lt;span class="c1">// 마지막 slice 를 또 slicing 하지만, &amp;#39;처음 array&amp;#39; 에서 2번째 element 부터의 array 길이가 cap 이므로
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 5,7,11,13 -&amp;gt; 4임. ㄱ-
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 그런데 또 length 는 &amp;#39;마지막 slice&amp;#39; 에서의 2번째부터니까 5,7,11 만 있어서 3임 (...)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>slice 에 아무 값도 없으면, 그 값은 &lt;code>nil&lt;/code> 과 같다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;nil!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>make()&lt;/code> 로 slice 를 만들 수 있다. 직접 값을 입력하는게 아니라, 변수를 통해 slice 를 선언할 수 있다는 차이가 있다.
&lt;ul>
&lt;li>length, capacity 를 별도로 입력할 수 있는 정도?&lt;/li>
&lt;li>length 가 0이면 비어 있는데, 그걸 잘라내면 0이 채워진다?? ㄱ-&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">b&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;b&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">d&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">d&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> b len=0 cap=5 []
&lt;/span>&lt;span class="cm"> c len=2 cap=5 [0 0]
&lt;/span>&lt;span class="cm"> d len=3 cap=3 [0 0 0]
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>slice 안에 slice 를 담을 수 있음. 이러면 2차원 배열이 됨. 이 때는 &lt;code>[][]string&lt;/code> 처럼 slice type 앞에 slice 를 쓰겠다고 선언하면 됨. (&lt;strong>2차원 배열이 된다&lt;/strong>)
&lt;ul>
&lt;li>그리고 각 원소도 slice literal 임을 명시해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아래는 2차원 배열 예제 프로그램인데, 주목할 건 for 문이 1개만 쓰였단 거다.
&lt;ul>
&lt;li>대신 &lt;code>strings.Join()&lt;/code> 을 써서 내부 원소 (&lt;code>board[i]&lt;/code>) 를 String 으로 만들어 출력했다는 점..&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Create a tic-tac-toe board.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">board&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[][]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// The players take turns.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;X&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;O&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;X&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;O&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;X&amp;#34;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">board&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s\\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">strings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>익히 알겠지만, slice 는 &lt;code>append()&lt;/code> 가 가능하다. 첫 번째 파라메터는 소스 slice, 나머지는 쭉 원소(들) 을/를 입력하면 된다.
&lt;ul>
&lt;li>그럼 cap 은 어떻게 되나요? 직접 실험해보자 (&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// append works on nil slices.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// The slice grows as needed.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// We can add more than one element at a time.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 여기서 재밌는 건 cap 이 5가 아니라 6이 된다는 거다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> len=0 cap=0 []
&lt;/span>&lt;span class="cm"> len=1 cap=1 [0]
&lt;/span>&lt;span class="cm"> len=2 cap=2 [0 1]
&lt;/span>&lt;span class="cm"> len=5 cap=6 [0 1 2 3 4]
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>마지막 줄이 왜 cap 이 6이 되는지는, go blog 에 있는 &lt;a class="link" href="https://go.dev/blog/slices-intro" target="_blank" rel="noopener"
>Slices-intro&lt;/a> 를 살펴보자. 특히 ‘&lt;strong>Growing slices (the copy and append functions)&lt;/strong>’ 처음에 make 하는 부분을 보면 된다.&lt;/p>
&lt;ul>
&lt;li>Slice 에서의 for 는 &lt;code>for each&lt;/code> 같은 구문을 사용할 수 있다.
&lt;ul>
&lt;li>&lt;code>range [slice]&lt;/code> 로 initialize 를 하게 되는데, 리턴되는 게 2개다. 인덱스와 실제 값.&lt;/li>
&lt;li>※ 인덱스를 안 쓰게 되면 (어차피 compile 에서 에러를 내겠지만) &lt;code>_&lt;/code> 처리해야 한다.&lt;/li>
&lt;li>value 를 안 쓰려면, value 자리를 &lt;code>_&lt;/code> 로 감싸도 되지만, 단순히 인덱스’만’ 받아도 된다.
&lt;ul>
&lt;li>인덱스만 받아서 슬라이스를 인덱스+1 로 참조할 용도로 쓰는.. 뭐 그런?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="k">for&lt;/span> &lt;span class="nx">idx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">value&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">slice_var&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// 인덱스만 쓰고 싶으면
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">idx&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">slice_var&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Rough Notation</title><link>https://interp.blog/rough-highlight-js/</link><pubDate>Fri, 24 Jun 2022 03:01:26 +0000</pubDate><guid>https://interp.blog/rough-highlight-js/</guid><description>&lt;img src="https://interp.blog/images/2022-06-24-68747470733a2f2f726f7567686e6f746174696f6e2e636f6d2f696d616765732f736f6369616c2e706e67.png" alt="Featured image of post Rough Notation" />&lt;p>GeekNews 를 보다보니 Atlassian JIRA 와 Bitbucket 서비스가 &lt;span class="rn-underline">너무 구려서 못 써먹겠다&lt;/span>는 코멘트를 모아 둔 사이트를 발견했다. (사이트 주소도 비범하게 &lt;a class="link" href="https://ifuckinghatejira.com/" target="_blank" rel="noopener"
>https://ifuckinghatejira.com/&lt;/a> 이다..!)&lt;/p>
&lt;blockquote>
&lt;p>개인적으로 Confluence 사용에 익숙해져서 큰 불만은 없지만, Issue Tracker 로는 Github/Gitlab 을 쓰는게 백번 낫다는 입장이기는 하다 ㅎㅎ&lt;/p>
&lt;/blockquote>
&lt;p>아무튼, 이 사이트 페이지에 나와있는 강조 표현이 애니메이션으로 차례차례 이뤄지고 있는 게 눈에 띄었다. 그것도 반듯한 모양이 아니라, 마치 사람이 수작업으로 글을 읽어내려가면서 표시하는 것 처럼 친숙해 보였다. 당장 F12 키를 눌러서 어떤 스크립트가 쓰여졌는지 확인해 봤다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/images/2022-06-24-2022-06-24-131516.png"
loading="lazy"
alt="Rough Notation main page"
>&lt;/p>
&lt;p>공식 사이트는 &lt;a class="link" href="https://roughnotation.com/" title="https://roughnotation.com/"
target="_blank" rel="noopener"
>https://roughnotation.com/&lt;/a> 이고, 다양한 효과를 &amp;lsquo;ANNOTATE&amp;rsquo; 버튼을 눌러 라이브로 볼 수 있다. 밑줄, 네모, 동그라미, 하이라이트, 취소선, X선 등의 효과가 가능하며, 애니메이션을 수행하지 않도록 지정할 수도 있다고 한다.&lt;/p>
&lt;p>그리고 &lt;span class="rn-circle">&lt;strong>여기서도&lt;/strong>&lt;/span> 동일한 효과를 적용해 보았다!&lt;/p>
&lt;script type="module">import { annotate } from 'https://unpkg.com/rough-notation?module'; const n2 = document.querySelector('span.rn-circle'); const n4 = document.querySelector('span.rn-underline'); const a2 = annotate(n2, { type: 'circle', color: 'red', padding: 10 }); const a4 = annotate(n4, { type: 'highlight', color: '#ff0066', iterations: 1, multiline: true }); a2.show(); a4.show();&lt;/script></description></item><item><title>Golang struct tag: omitempty</title><link>https://interp.blog/golang-struct-tag/</link><pubDate>Tue, 21 Jun 2022 16:19:07 +0000</pubDate><guid>https://interp.blog/golang-struct-tag/</guid><description>&lt;h2 id="태그">태그?&lt;/h2>
&lt;p>Go 언어의 &lt;code>struct&lt;/code> 타입에는 각 필드마다 태그를 붙일 수 있다. (struct tag 라고도 불린다) 이렇게 아무렇게나 태그를 붙여둘 수 있다. 물론 다른 함수나 패키지에서 이런 태그를 파싱해서 다룰 수 있어야 하겠지만.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`mandatory`&lt;/span>
&lt;span class="nx">ID&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="s">`mandatory`&lt;/span>
&lt;span class="nx">Phone&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`optional`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>encoding/json&lt;/code> 은 &lt;code>json&lt;/code> 으로 시작하는 태그를 지원하는데, 아래와 같이 흔히들 볼 수 있는 것들이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;span class="nx">ID&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="s">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;span class="nx">Phone&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;phone_number&amp;#34;`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 태그를 가지고 있으면, &lt;code>json.Marshal()&lt;/code> 을 할 때 구조체 필드 값을 자동으로 JSON 문서로 변환해준다. 또는 &lt;code>json.Unmarshal()&lt;/code> 을 통해, 입력된 JSON 문서 바이트 배열을 해당 구조체의 각 필드에 맞춰 알아서 변환해 준다.&lt;/p>
&lt;h2 id="omitempty-옵션">omitempty 옵션&lt;/h2>
&lt;p>오늘 알아볼 것은, 이런 태그 뒤에 붙는 옵션들 중에서 &lt;code>omitempty&lt;/code> 에 대한 내용이다. 이 옵션은 말 그대로 &amp;lsquo;비어있는 필드 값은 생략하겠다&amp;rsquo; 라는 뜻이다.&lt;/p>
&lt;p>&lt;strong>결론만 말하면, 이 옵션은 Marshalling 할 때만 효과가 있다.&lt;/strong> &lt;a class="link" href="https://go.dev/play/p/EhzLmox7CYN" target="_blank" rel="noopener"
>Go Playground Link&lt;/a> 에 아래 예제 코드를 넣어뒀으니, 직접 실행해보고 확인해보는 것을 추천한다.&lt;/p>
&lt;h3 id="값이-비어있다">값이 비어있다?&lt;/h3>
&lt;p>Go 언어의 자료형 기본값이 들어가 있으면 값이 비어 있다고 간주한다. 이 부분은 이전 포스팅인 &lt;a class="link" href="https://interp.blog/tour-of-go-package-function-variable/" >Go Tour 문서&lt;/a>에 더욱 자세한 내용이 들어있다.&lt;/p>
&lt;ul>
&lt;li>실수형 = 0&lt;/li>
&lt;li>문자형 = &amp;quot;&amp;quot;&lt;/li>
&lt;li>boolean 형 = false&lt;/li>
&lt;li>포인터형 = nil&lt;/li>
&lt;/ul>
&lt;h3 id="unmarshalling-json---struct">Unmarshalling (JSON -&amp;gt; struct)&lt;/h3>
&lt;p>안 해도 되는데, 일단 의심을 거두기 위해 Unmarshalling 부터 테스트 해보자. 위의 &lt;code>Employee&lt;/code> struct type 에다가, 다음 JSON String 을 Unmarshalling 해보려고 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;John Doe&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">e&lt;/span> &lt;span class="nx">Employee&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unmarshal&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">jsonString&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nb">panic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;[%s]\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Phone&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>그 결과는, 뻔하긴 하지만 대괄호만 나올 것이다. (&lt;code>[]&lt;/code>) 그럼 여기서 &lt;code>e.Phone&lt;/code> 에 값이 있었다면 어떻게 될까? 이 &amp;ldquo;010-&amp;rdquo; 값은 Unmarshalling 을 해도 그대로 남는다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">e&lt;/span> &lt;span class="nx">Employee&lt;/span>
&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Phone&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;010-&amp;#34;&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>그렇다면, 이번에는 &lt;code>omitempty&lt;/code> 를 &lt;code>Employee.Phone&lt;/code> 에 붙이고 위의 두 실험을 해보자. 결과는 같은가? &lt;strong>그렇다.&lt;/strong> 값이 없으면 없는대로, 있으면 있는대로 출력된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;span class="nx">ID&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="s">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;span class="nx">Phone&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;phone_number,omitempty&amp;#34;`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="marshalling-struct---json">Marshalling (struct -&amp;gt; JSON)&lt;/h3>
&lt;p>이번에는 저장된 값을 JSON 으로 나눠보자. 우선, &lt;code>omitempty&lt;/code> 옵션을 다시 빼고, &lt;code>e.Phone&lt;/code> 에는 아무런 값을 넣어보지 않았다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">e&lt;/span> &lt;span class="nx">Employee&lt;/span>
&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;John Doe&amp;#34;&lt;/span>
&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">jsonReturned&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Marshal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nb">panic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">jsonReturned&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;id&amp;quot;:1,&amp;quot;phone_number&amp;quot;:&amp;quot;&amp;quot;}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>phone_number&lt;/code> 라는 필드가 생겼다. struct 필드 값이 비어 있어도 JSON 에는 필드가 보인다는 것이다.&lt;/p>
&lt;p>이걸 방지하기 위해 &lt;code>omitempty&lt;/code> 가 필요하다. 해당 옵션을 다시 &lt;code>Employee.Phone&lt;/code> 에 넣고 동일한 코드를 돌려보면 다음과 같이 출력된다.&lt;/p>
&lt;pre>&lt;code>{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;id&amp;quot;:1}
&lt;/code>&lt;/pre>
&lt;h2 id="사소한-문제">사소한 문제?&lt;/h2>
&lt;p>아까 Go 언어 기본값이 들어있는 필드는 JSON encoding package 에서 비어있는 필드로 간주한다는 말을 했었다. 그런데, 이 값들이 유의미한 값이라면 어떻게 해야 할까? 이 때는 &lt;code>omitempty&lt;/code> 옵션 사용을 자제해야 한다.&lt;/p>
&lt;p>예를 들면, 통장 내역을 나타내는 struct type 에서, 잔고를 나타내는 &lt;code>balance&lt;/code> 필드가 있다고 가정하자. 만약, 이 필드가 정확히 0을 가진다면 이 0이란 숫자는 유효한 숫자다. 그런데 이 필드에 대고 &lt;code>omitempty&lt;/code> 를 붙이게 되면, 사용자가 반환받을 JSON 문서에 &lt;code>balance&lt;/code> 자체가 없게 되고 큰 혼란 (?) 이 올 수 있다. 잔고라는 필드는 프로그램에서 필수적으로 있을 것이라 가정하기 때문에 일종의 &lt;em>AssertionError&lt;/em> 에 빠질 수 있다는 뜻이다.&lt;/p>
&lt;p>Marshalling 할 때 JSON 문서의 다이어트 목적으로 이 옵션을 종종 쓸 텐데, 항상 주의해서 써야 한다는 것으로 끝맺는다.&lt;/p></description></item><item><title>설명할 수 없으면, 아는 것이 아니다</title><link>https://interp.blog/if-you-cannot-explain/</link><pubDate>Mon, 20 Jun 2022 05:30:47 +0000</pubDate><guid>https://interp.blog/if-you-cannot-explain/</guid><description>&lt;img src="https://interp.blog/uploads/2018/07/einstein.jpg" alt="Featured image of post 설명할 수 없으면, 아는 것이 아니다" />&lt;p>다른 사람을 지적하기 위한 것이 아니라 그저 내가 답답해서 페북에도 두번이나 올렸던 건데, 아인슈타인이 이미 한 말이었다. 역시 범인 (凡人)인 내가 생각한 것들은, 누군가가 이미 생각한 것이리라&amp;hellip;&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>쉽게 설명할 수 없으면, 아는 것이 아니다.&lt;/strong>&lt;br>
(혹은, ‘6살 꼬마에게 설명할 수 없으면 아는 것이 아니다’)&lt;/p>
&lt;/blockquote>
&lt;h2 id="변명하느니-모른다고-하자">변명하느니, 모른다고 하자&lt;/h2>
&lt;p>&amp;lsquo;&lt;em>이건 뭐죠?&lt;/em>&amp;rsquo; 라고 물어봤을 때 논리정연하게 설명할 수 없는 경우가 생긴다. 그러면 으레 이런 변명이 나오곤 한다.&lt;/p>
&lt;ul>
&lt;li>아, 이거 전에는 알고 있었는데 말이죠&amp;hellip;&lt;/li>
&lt;li>분명히 공부했거든요 (해 봤거든요). 그런데, 왜 기억이 안 날까요?!&lt;/li>
&lt;li>이런 저런 그런거 같은데 말이죠&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>이렇게 얼버무리느니, 쿨하게 &lt;strong>‘모릅니다’&lt;/strong> 라고 대답하는 게 더 낫다. 저런 변명이 오히려 신뢰를 더 깎는다고 생각한다. 모르면 아는 사람이 알려주기라도 할 텐데, &amp;lsquo;알았는데 까먹었어요&amp;rsquo; 라고 하면 마치 내가 잘못해서 그걸 잃어버린 것 같이 들려서다.&lt;/p>
&lt;h2 id="그럼-다-외워야-하나요">그럼 다 외워야 하나요?&lt;/h2>
&lt;p>그렇다면 어떤 개념의 정의나 역사를 항상 기억하고 외우고 있어야 할까? 외운다기 보다는 이해하고 있어야 할 것이다.&lt;/p>
&lt;p>중요한 건 어떻게 그 목표에 접근하냐는 것일텐데, 오랫동안 기억하려면 무작정 외워서는 안 될 것이다. &lt;strong>그 속에 담긴 원리는 무엇인지, 왜 이런 개념이 필요했는지&lt;/strong>를 이해하지 않고 외우기만 한다면, 금세 기억 저편으로 사라질 것이다.&lt;/p>
&lt;p>그리고 어디까지나 쉽게 설명하는 것이다. 정의를 다 외우고 다니는 것은, 걸어다니는 사전이 되라는 이야기나 다를 바 없다. 상대방이 이해할 수 있는 표현으로 바꿔서 이야기할 수 있어야 &amp;lsquo;쉽게 설명하는 것&amp;rsquo; 이 된다. 그러자면 그 원리를 이해하고, 딸려 나오는 개념들에 대해서도 스스로 이해하고 다시 정의해보는 습관이 필요하다. &amp;lsquo;아웃풋&amp;rsquo; 이 필요한 것이다.&lt;/p></description></item><item><title>A tour of Go: Flow control statements</title><link>https://interp.blog/tour-of-go-flow-control-stmts/</link><pubDate>Mon, 20 Jun 2022 02:36:25 +0000</pubDate><guid>https://interp.blog/tour-of-go-flow-control-stmts/</guid><description>&lt;p>&lt;a class="link" href="https://interp.blog/tour-of-go-package-function-variable/" target="_blank" rel="noopener"
>지난 시간&lt;/a>에 이어서, 여기서는 Flow Control Statement 에 대해 정리해 보았다.&lt;/p>
&lt;h2 id="a-tour-of-go">A tour of Go&lt;/h2>
&lt;ul>
&lt;li>English: &lt;a class="link" href="https://go.dev/tour/" title="https://go.dev/tour/"
target="_blank" rel="noopener"
>https://go.dev/tour/&lt;/a>&lt;/li>
&lt;li>한국어판: &lt;a class="link" href="https://go-tour-ko.appspot.com/" title="https://go-tour-ko.appspot.com/"
target="_blank" rel="noopener"
>https://go-tour-ko.appspot.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="if-else">If, else&lt;/h2>
&lt;p>조건문은 다른 프로그래밍 언어와 마찬가지로 &lt;code>if&lt;/code>, &lt;code>else&lt;/code> 그리고 &lt;code>else if&lt;/code> 의 조합으로 구성된다. 조건 절 (condition clause) 에 있는 수식을 검증 (evaluation 이라고도 한다) 한 결과가 참이면 해당 블록이 수행된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nf">funcTrue&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여러 개의 수식들을 넣어도 되고, 마지막 수식이 boolean 으로 검증되거나 반환되어야 한다. 수식 간에는 세미콜론(&lt;code>;&lt;/code>)으로 구분한다. 이 부분에서 가장 널리 쓰이는 패턴이 바로 &lt;code>error&lt;/code> 객체가 반환되었는지 검증하는 구문이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">funcTest&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// error handling with `err` object
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>참고로 저기 &lt;code>err&lt;/code> 는 조건 블록 안에서만 사용할 수 있다. 바깥에서는 참조할 수 없고, 대신 다른 &lt;code>else if&lt;/code> 나 &lt;code>else&lt;/code> 블록에서는 참조가 가능하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">if&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">testStr&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ok
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ok
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ok
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// error
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>심지어는 &lt;code>else if&lt;/code> 에서 선언된 변수가 있는데 &lt;code>if&lt;/code> 에서 쓸 수 있을까? 된다! hoisting 해서 쓴다. 이 쯤 생각해보니, &lt;strong>if block 전체에 선언된 변수들에 대해 evaluation 을 먼저 하는 것으로 보인다&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">pow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">lim&lt;/span> &lt;span class="kt">float64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">float64&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">lim&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">v&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%g &amp;gt;= %g\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">lim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 여기선 가능
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">lim&lt;/span> &lt;span class="c1">// 여기서 v 를 참조할 수 없다.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>performance 를 중요시한다면 필요한 변수는 inner-block 에서 선언해 쓰는게 좋을 거 같긴 한데.. 아직 언어에 대해 잘 모르겠으니 참고만 하자.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="for">For&lt;/h2>
&lt;h3 id="basic-for">basic for&lt;/h3>
&lt;p>다른 프로그래밍 늘 그렇듯, &lt;code>init; condition; post&lt;/code> 로 이루어져 있다. init 에는 마치 지역 변수 선언과 같은 모양을 한다 (bash 를 떠올리면 된다) 그리고 여타 다른 언어와 달리 (C, Java, &amp;hellip;) 괄호가 없다는 점을 주목하자. 그러나 반드시 브라켓 &lt;code>{ }&lt;/code> 은 필요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="nx">sum&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="nx">i&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="continued-for">Continued for&lt;/h3>
&lt;p>init 과 post 은 optional 이다. 이게 비어 있으면 condition 만 남아 while 과 같은 기능을 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> sum := 0
for ; sum &amp;lt; 10; {
// for sum &amp;lt; 10 { // 둘 중 아무거나 써도 똑같다.
// 그리고 위 처럼 쓴 뒤 go fmt 를 돌리면 세미콜론이 알아서 빠진다.
sum += sum
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>리스트나 맵을 순회할 때도 continued for 의 일종이라고 보면 된다. 이 때는 &lt;code>range&lt;/code> 를 사용한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">myMap&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>
&lt;span class="nx">myMap&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="nx">myKey&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myValue&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">myMap&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="while">While&lt;/h2>
&lt;p>다른 말로, &lt;strong>golang 은 while 이 없다&lt;/strong>&amp;hellip; 대신 &lt;code>for&lt;/code> 만 적으면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="switch">Switch&lt;/h2>
&lt;p>C/C++, Java 의 switch 라고 생각하면 된다. 차이점은,&lt;/p>
&lt;ul>
&lt;li>C 처럼 단일 값 (e.g. int, character) 이 아니라 &lt;strong>string 도 사용이 가능&lt;/strong>하고&lt;/li>
&lt;li>&lt;code>case&lt;/code> 에 &lt;strong>variable 을 넣어도&lt;/strong> 된다.&lt;/li>
&lt;li>각 case 마다 break 를 다 집어넣지 않아도 된다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Go runs on &amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">darwin_os&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;darwin&amp;#34;&lt;/span> &lt;span class="c1">// 이걸 타겟으로 써도.. 된다고?
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="nx">os&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">GOOS&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">os&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">darwin_os&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1">// ㅇㅇ 되네
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;OS X.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;linux&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Linux.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s.\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>참고로 &lt;code>case:&lt;/code> 만 쓰면 &lt;code>case True:&lt;/code> 와 같은 의미가 된다.&lt;/p>
&lt;p>위의 차이점을 생각해보면, 마치 기다란 &lt;code>if-else&lt;/code> 를 &lt;code>switch&lt;/code> 로 치환할 수 있을 것 처럼 보이지만 사실 두 가지 제약을 고려해서 선택해야 한다.&lt;/p>
&lt;ol>
&lt;li>가독성 문제를 고려해야 한다.&lt;/li>
&lt;li>if 안에서 변수 선언/할당이 가능하지만, case 에서는 변수 선언이 안 된다.&lt;/li>
&lt;/ol>
&lt;h2 id="defer">defer&lt;/h2>
&lt;p>이 키워드로 시작하는 구문은 &lt;strong>해당 함수가 끝날 때 까지 실행이 유예된다&lt;/strong>. 이 키워드는 블록에 종속된 개념이 아니라 &lt;em>함수에 종속&lt;/em>된 개념이다. 따라서, 어느 inner block 에서 쓰이건 간에 이 구문을 지난다면, 함수가 끝날 때에야 구문이 수행된다.&lt;/p>
&lt;p>&lt;code>defer&lt;/code> 뒤에 오는 구문은 &lt;strong>반드시 함수 호출이어야 한다&lt;/strong>. 변수 선언이거나 변수 값 할당같은 식은 안 된다. (&lt;code>+=&lt;/code> 도 안 됨)&lt;/p>
&lt;p>재미있는 건, &lt;code>defer&lt;/code> 줄을 만나는 시점에 argument 값이 결정된다. 이후에 argument 로 들어간 variable 이 바뀌더라도, &lt;code>defer&lt;/code> 의 실제 수행 시점에서는 영향이 없는 것을 아래 코드로 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">abc&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>
&lt;span class="c1">// 아래 세 줄을 브라켓으로 감싸 블록으로 만든다 한 들, 결과는 동일함 (함수 레벨이기 때문)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">abc&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="s">&amp;#34; world&amp;#34;&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">abc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 뒤에 느낌표는 여기서 평가가 안 되지만, 출력은 마지막에 된다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">abc&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="s">&amp;#34; !!&amp;#34;&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">abc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 여기서는 전부 출력된다.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm">hello world !!
&lt;/span>&lt;span class="cm">hello world
&lt;/span>&lt;span class="cm">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>defer&lt;/code> 를 하나의 함수 안에서 여러 개 선언할 수 있다. 실행 순서는 LIFO, 즉 먼저 들어간 수식이 나중에 실행된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 맞춰보자. 0이 먼저 나올까 9가 먼저 나올까?
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>미라클 모닝</title><link>https://interp.blog/miracle-morning/</link><pubDate>Sat, 18 Jun 2022 22:48:59 +0000</pubDate><guid>https://interp.blog/miracle-morning/</guid><description>&lt;img src="https://interp.blog/images/2022-06-18-ishan-seefromthesky-ivctht8rajo-unsplash2.jpg" alt="Featured image of post 미라클 모닝" />&lt;p>미라클 모닝을 제대로 공부해 보진 않았지만, 나의 기상 패턴과 일치하는 부분이 많아 내 입맛대로 먼저 적용해보려고 여기저기 찾아봤다. 시작은 무라카미 하루키의 생활 패턴이었는데, 일단 4-5시에 일어나서 창작 작업을 한다. 반드시 그날 정한 정량의 원고를 작성한다. 그리고 나머지 시간은 대부분 달리거나, 가끔 수영하거나 여가시간을 보낸다고 한다. 그마저도 그에게는 일일 수 있지만, 확실한 루틴을 지키고 일을 하는 것이다.&lt;/p>
&lt;h1 id="무엇을-할-것인가">무엇을 할 것인가&lt;/h1>
&lt;p>미라클 모닝 모임을 몇 군데 둘러보면 다들 &amp;lsquo;일어나서 뭘 한다&amp;rsquo; 를 공유하는데 초점이 맞춰져 있다. 일어나는데 초점이 맞춰져 있으면, 일어나는 동기부여가 안 되기 때문에 패턴을 만들기 쉽지 않다. &lt;strong>&amp;lsquo;무엇을 할 것인가&amp;rsquo; 에 초점이 맞춰져 있어야 한다.&lt;/strong>&lt;/p>
&lt;p>알맞은 예인지는 모르겠지만, 나는 학창시절 때 &amp;lsquo;지각이다!&amp;rsquo; 싶으면 일어나는 것과 비슷하지 않을까 생각했다. 자취하고 나서도 결혼을 하고 나서도 쭉 새벽에 잘 일어났는데, 대부분은 하고 있는 게임을 얼른 하고 싶어서 였다. 반대로 할 게임이 없다거나 별로 할 일이 없다면 계속 누워 있었다. 떠오르는 햇살이 일단 내 눈꺼풀을 1mm 라도 열어젖히면, &lt;strong>그 다음은 뇌 안의 할 일 목록이 재빠르게 몸을 일으키게 만들어야 한다.&lt;/strong>&lt;/p>
&lt;h1 id="성공할-수-있는-일인가">성공할 수 있는 일인가&lt;/h1>
&lt;p>지난 번에 &amp;lsquo;스마트폰을 절대 아침에 하지 마세요&amp;rsquo; 라는 말을 들었다고 한 적이 있다. 아침에 무엇을 하는지도 중요하지만, 그것은 하루키의 아침 루틴처럼 &lt;strong>정량적이면서도, 반드시 성공하는 루틴이어야 한다고 생각한다.&lt;/strong> 이게 개인적으로는 &amp;lsquo;미라클 모닝&amp;rsquo; 의 핵심이라 생각한다. 스마트폰을 하게 되면, 뇌의 할 일 목록을 스마트폰에 저당잡히는 셈이다. 그리고 거기에는 성공이나 실패같은 끝 지점이 없다. 다른 일로 전환하지 못하고 하루 종일 스마트폰을 봐야 한다는 것이다.&lt;/p>
&lt;p>그래서 나에게 맞는 작은 루틴은 무엇일까 나열해봤다. 딱 힘들 수준의 운동을 하는 것도 좋을 것 같다. 글쓰기 연습삼아 지금처럼 글을 매일 1개씩 쓰는 것도 방법이다. 매일 30분씩 피아노 연습을 해도 좋을 것 같다. 읽지 못한 책을 잡고 50페이지씩 읽는다는 목표 또한 좋다. 무엇이든지 정량적이고, 끝이 있다.&lt;/p>
&lt;h1 id="아침의-인수인계">아침의 인수인계&lt;/h1>
&lt;p>&lt;strong>내일의 나에게 아침을 온전히 넘겨주려는 노력도 필요하다.&lt;/strong> 야식과 술은 숙면을 방해하기 딱 좋은 친구들이다. 자기 전에 내일 할 일 목록을 종이로 하다못해 머릿속에 어렴풋이라도 남겨 두면 멍모닝을 막을 수 있다. 할 일 목록은 닥치는 대로 살아선 안 되고, 항상 내가 가고자 하는 방향에 맞게 설정되어 있는지 반드시 파악해야 한다.&lt;/p>
&lt;hr>
&lt;p>미라클 모닝 참가자들은 &amp;lsquo;자기 계발&amp;rsquo; 이 아닌 &amp;lsquo;셀프 케어&amp;rsquo; 라는 목적이 더 강하다고들 한다. 이렇게 하면서 원대한 꿈이나 목표를 이룰 수도 있겠지만, &lt;strong>그보다는 하루를 올바르게 시작하는 것으로 더 행복한 삶을 살기 위한 목적이지 않을까&lt;/strong>, 그렇게 난 공감했다.&lt;/p></description></item><item><title>A tour of Go: Package, Function, Variable</title><link>https://interp.blog/tour-of-go-package-function-variable/</link><pubDate>Thu, 16 Jun 2022 10:26:18 +0900</pubDate><guid>https://interp.blog/tour-of-go-package-function-variable/</guid><description>&lt;p>A tour of Go 시리즈를 두 번씩 돌아보고, 나름 배운 것들을 연이어 적어보려 한다. 첫 번째로 패키지, 변수, 함수 정의와 사용에 대한 내용이다. 이 문서는 번역이 아니라서, 개인적으로 중요했던 부분만 있을 수도 있고 투어 예제에서 다루지 않은 부분이 섞여있을 수 있으니 편하게 봐주셨으면 한다. &lt;del>화면 안 넘기고 스크롤만으로 볼 수 있다는 장점 정도?&lt;/del>&lt;/p>
&lt;h2 id="a-tour-of-go">A tour of Go&lt;/h2>
&lt;p>Go 언어의 튜토리얼 페이지라고 보면 된다. 다양한 언어로 번역되어 있으니 영어 원문으로 봐도 좋고 한국어판으로 봐도 좋다.&lt;/p>
&lt;ul>
&lt;li>English: &lt;a class="link" href="https://go.dev/tour/" title="https://go.dev/tour/"
target="_blank" rel="noopener"
>https://go.dev/tour/&lt;/a>&lt;/li>
&lt;li>한국어판: &lt;a class="link" href="https://go-tour-ko.appspot.com/" title="https://go-tour-ko.appspot.com/"
target="_blank" rel="noopener"
>https://go-tour-ko.appspot.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="package">Package&lt;/h2>
&lt;p>모든 &lt;code>*.go&lt;/code> 파일의 첫 줄에는, 이 파일이 속한 &amp;lsquo;패키지&amp;rsquo; 이름을 작성한다. &lt;code>main.go&lt;/code> 는 이렇게 패키지 이름이 지정될 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>다음 줄에는, 이 파일에서 사용할 다른 패키지들을 작성할 수 있다. 이렇게 각각 패키지 이름과 함께 &lt;code>import&lt;/code> 를 해도 되지만,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// separated
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;math&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 뭉쳐서 선언하는게 보통이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// factored (better)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;math&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="function-declaration">Function declaration&lt;/h2>
&lt;p>다양한 방식으로 함수 시그니처를 선언할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// 기본적인 형태. return type 까지 적어야 함.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// input 타입이 다 같으면 이렇게 typing 을 몰아서 할 수도 있음 (가독성은 좀 떨어짐)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// return 도 여러 개 가능함.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// return 에 변수명을 입력해도 됨. 이 때는 변수명이 함수 내부에서 사용되고, naked return 으로 리턴함 (&amp;#39;return&amp;#39; 만 씀)
&lt;/span>&lt;span class="c1">// &amp;lt;&amp;lt; 가독성이 심하게 떨어지므로 짧은 함수일 때만 쓰는걸 추천함.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sum&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="variable-declaration">Variable declaration&lt;/h2>
&lt;p>변수 또한 다양한 방식으로 선언이 가능한데, 크게 두 가지 방법으로 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>var&lt;/code> 키워드를 통한 선언&lt;/li>
&lt;li>&lt;code>:=&lt;/code> 를 사용해 선언+할당 동시에 하기&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="c1">// 여러 변수가 전부 같은 타입이면 이렇게 변수명 리스트와 마지막 타입 한 번만 적어서 정의해도 됨.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 이건 패키지 레벨, 즉, 다른 함수도 c, python, java 를 모두 접근할 수 있다.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 순서는 var [변수명] [타입] 이다. 이건 함수 레벨이다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>변수 선언과 함께 값을 할당하는 initializer 방법도 다양하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="c1">// 지정된 타입에 맞춰 넣는다. 여러 개를 이렇게 동시에 넣어도 된다. (이 경우에 j = &amp;#34;str&amp;#34; 하면 에러 난다)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;no!&amp;#34;&lt;/span> &lt;span class="c1">// 타입 지정이 되어 있지 않아도, 값에 따라 개별로 설정된다. 앞부터 bool, bool, string 이 된다.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 이렇게 factored 방식으로 지정할 수도 있고, 가독성 역시 좋아진다~
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="nx">ToBe&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="nx">MaxInt&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1">// bit-wise operator 조심
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>:=&lt;/code> 도 알아보자. 단, 이 방법은 전역 변수 (=패키지 레벨 변수) 에서는 사용이 불가능하다. 이 때는 &lt;code>var&lt;/code> 로만 선언이 가능하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">blahblah&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">k&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="c1">// var k = 3 과 같다. var == : 라는 뜻.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;no!&amp;#34;&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exported-variablefunction">Exported variable/function&lt;/h2>
&lt;p>첫 문자가 &lt;strong>대문자&lt;/strong>인 함수나 전역 변수 이름은, &lt;code>패키지 이름.이름&lt;/code> 형식으로 다른 패키지에서 참조가 가능하다. 아래와 같이 쓰고 &lt;code>custommath_pi.go&lt;/code> 라고 저장했다고 하면, &lt;code>custommath.hiddenPi&lt;/code> 로는 참조가 안 되고 &lt;code>custommath.Pi()&lt;/code> 는 참조가 가능하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">custommath&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">hiddenPi&lt;/span> &lt;span class="kt">float64&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">Pi&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">float64&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="o">...&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>주목할 부분은,&lt;/p>
&lt;ul>
&lt;li>파일 이름이 아니라 패키지 이름으로 참조한다는 것이다.&lt;/li>
&lt;li>다른 말로, 같은 패키지 안이기만 하면, 다른 파일에서도 모든 변수/함수 참조가 가능하다는 것이다. (같은 패키지에서 중복된 변수/함수 이름은 허용되지 않는 이유..)&lt;/li>
&lt;/ul>
&lt;h2 id="variable-types-default-values">Variable types, default values&lt;/h2>
&lt;pre>&lt;code>bool
string
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
byte // alias for uint8
rune // alias for int32
// represents a Unicode code point
float32 float64
complex64 complex128 // 복소수임.. e.g. 3+2i
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>C/C++ 개발자들에겐 &lt;code>uintptr&lt;/code>, &lt;code>rune&lt;/code>, &lt;code>complex&lt;/code> 타입이 좀 생소할 수 있다. 주석으로 설명해 뒀으니 이해해주면 좋겠다.&lt;/li>
&lt;li>&lt;code>int&lt;/code>, &lt;code>uint&lt;/code>, &lt;code>uintptr&lt;/code> 은 물론, 32-bit system 에서는 4바이트, 64-bit system 에서는 8바이트이다.&lt;/li>
&lt;/ul>
&lt;p>이제 각 타입의 기본값을 알아보자.&lt;/p>
&lt;ul>
&lt;li>정수/실수형은 전부 &lt;strong>0&lt;/strong> (float 역시 0.0 이 아니라 0)&lt;/li>
&lt;li>boolean 은 &lt;strong>false&lt;/strong>&lt;/li>
&lt;li>string 은 &lt;strong>“”&lt;/strong> (empty) (formatting 에서 주목할 부분은 &lt;code>%q&lt;/code> 로 하면 quota 가 붙는다는 거다 (&amp;hellip;))&lt;/li>
&lt;li>포인터형은 전부 &lt;strong>nil&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="variable-type-casting">Variable type-casting&lt;/h2>
&lt;p>Go 언어에서 type casting 은 &lt;em>type conversion&lt;/em> 이라고 불린다. 그냥 캐스팅 하듯 type 을 앞에 쓰고 괄호로 감싸면 형변환이 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">42&lt;/span>
&lt;span class="nx">f&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">float64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">u&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>다른 대부분의 언어에서는 암묵적 캐스팅이 가능한데, Go 언어는 이 부분에서 엄격하다. 따라서 이 구문은 안 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">f&lt;/span> &lt;span class="kt">float64&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="c1">// i 가 int 여서 안 됨. 1.0 으로 들어가지 않음
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="constant">Constant&lt;/h2>
&lt;p>&lt;code>const&lt;/code> 키워드를 쓰면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">const&lt;/span> &lt;span class="nx">Pi&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mf">3.14&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">const&lt;/span> &lt;span class="nx">world&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;세계&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>다음의 특징을 가진다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>패키지 레벨, 함수 레벨 둘 다 가능하다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>var&lt;/code> 이나 &lt;code>:=&lt;/code> 로 선언할 수 없다. 이 말은, &lt;strong>별도의 타입 선언을 하지 않고&lt;/strong> 상수 값과 함께 선언한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>별도 타입 선언이 안 되므로, 정수형 상수 (numeric constant) 를 넣을 때는 내부적으로 필요한 type 을 (마음대로) 결정한다. 예를 들어,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">const&lt;/span> &lt;span class="nx">Big&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">100&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 선언하면 Big 은 &lt;code>int&lt;/code> 형이 아니라 &lt;code>float64&lt;/code> 쯤 될 것이다. 이 말은 &lt;code>Big&lt;/code> 을 int 처럼 쓰려고 들면 type conversion error 를 만날 수 있다는 것이다.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>리터널 (Returnal)</title><link>https://interp.blog/retrunal/</link><pubDate>Sun, 12 Jun 2022 07:06:18 +0900</pubDate><guid>https://interp.blog/retrunal/</guid><description>&lt;img src="https://interp.blog/images/2022-06-12-returnal/featured.jpg" alt="Featured image of post 리터널 (Returnal)" />&lt;h1 id="손맛은-추천">손맛은 추천&lt;/h1>
&lt;p>개인적으로, FPS 는 무엇보다 타격감이 좋아야 한다. 적을 모조리 헤쳐가는 부분에서는 둠 리부트 시리즈가 떠오른다면, 리터널은 (나중에 손이 익으면 무쌍난무를 펼치지만) 리듬 게임을 하듯이 요리조리 돌파하는 맛이 탁월하다. 하나는 과부화 시스템이고, 다른 하나는 접근전을 강제한다는 것이다.&lt;/p>
&lt;center>
&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-06-12-returnal/overload.png"
alt="타이밍에 맞춰 누르다보면 리듬 게임이 따로 없다"/> &lt;figcaption>
&lt;p>타이밍에 맞춰 누르다보면 리듬 게임이 따로 없다&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/center>
&lt;ul>
&lt;li>과부화 시스템은 재장전 시간을 초기화하는 기본적인 기능도 있지만, 무기의 특성이나 아티팩트의 특성에 따라 부가 효과를 가져오기 때문에 이 타이밍을 놓치지 않아야 한다.&lt;/li>
&lt;li>근접 전용 검을 초반부에 얻게 되면 일반 몹을 한 방에 제거할 수 있다. 하지만 그러려면 탄막을 뚫어가며 위험을 무릅쓰고 적에게 접근해야 하므로 집중을 요구한다.&lt;/li>
&lt;/ul>
&lt;h1 id="반복-플레이는-안-추천">반복 플레이는 안 추천&lt;/h1>
&lt;p>로그라이크 답게, &lt;strong>죽으면 모든 아이템, 상태는 초기화되고 처음 스테이지부터 시작한다.&lt;/strong> 단, &amp;lsquo;에테르&amp;rsquo; 라 불리는 영구 화폐와 (스테이지 최초 클리어 할 때 마다 주는) 영구 기술들은 남아있다. 리터널은 6개의 스테이지로 나뉘어 있고, 1-2-3, 4-5-6 의 하나의 시퀀스로 이뤄져 있다. 3스테이지까지 다 깨더라도, 4스테이지에는 아이템과 상태가 초기화 된 채로 시작한다.&lt;/p>
&lt;p>문제는, 6개의 스테이지를 다 깨면 &lt;em>와! 잘 했어요!&lt;/em> 라고 플래티넘 트로피를 주지 않는다. 6스테이지를 다 깨면 게임에서 &amp;lsquo;진엔딩이 있으니 더 해보세욧!&amp;rsquo; 이라고 안내해 준다. 그러면 (집 이벤트를 다 안 봤다면 다 봐야 하고,) 태양의 메달이라는 파편을 1~6 스테이지에 걸쳐 또 다 모은 뒤 6스테이지 보스를 잡아야 진엔딩을 볼 수 있다. 벌써부터 피곤하다.&lt;/p>
&lt;p>그런데 진엔딩을 보고 나서도 게임은 끝나지 않는다. 1~6 스테이지에서 수집할 수 있는 외계 아카이브/외계 문자/정찰 기록을 모두 모으는 골드 트로피 6개가 존재한다. 문제는 이 아이템들이 나오는 맵 파트가 고정되어 있고, 스테이지가 생성될 때마다 (정확히는 문을 열 때 마다) 랜덤이라서 무조건 복불복이다. 그렇다고 맵 파트가 무한정 생성되는 것도 아니고 각 스테이지마다 파트 개수는 고정이기 때문에, 못 찾으면 리셋하고 처음부터 강제로 다시 해야 한다! (1, 4 스테이지는 아무래도 많이 죽다보니 다른 스테이지보다 자주 들르게 되고, 그래서 좀 더 딸 확률이 높긴 하다.)&lt;/p>
&lt;h1 id="플래티넘-트로피-팁">플래티넘 트로피 팁&lt;/h1>
&lt;p>그냥 소소한 팁을 적어둔다.&lt;/p>
&lt;ul>
&lt;li>(PSN 유저 한 정) 세이브 데이터 클라우드 동기화를 끈다. &lt;strong>스테이지 1/4 에서 최대한 탐방해서 원하는 장비/상태를 맞추고, 순환 중지를 한 다음 세이브 파일을 클라우드에 올린다.&lt;/strong> 2-3, 5-6 스테이지 탐방이 실패하면, 이걸 불러서 다시 한다.
&lt;ul>
&lt;li>내 기준으로 스테이지 1/4 를 꼼꼼히 도는데 약 7-10 분 가량 필요했다. 이 시간이 너무 아까워서 작은 꼼수를 썼다.&lt;/li>
&lt;li>중요한 것은 2-3, 5-6 에서 어떤 기록이라도 갱신에 성공했다면, 반드시 그 상태에서 순환 재시작을 눌러 다시 해야 한다. 기쁜 마음에 세이브를 다시 불러오면, 기록 갱신이 날아가버린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 외계 문자, 정찰 기록이 담긴 &lt;a class="link" href="https://psnprofiles.com/guide/13103-returnal-collectible-guide" target="_blank" rel="noopener"
>이 가이드&lt;/a>를 참고해 보자.
&lt;ul>
&lt;li>특정 정찰 기록이 빠져 있다면, 여기서 검색해서 해당 파트의 맵이 뜨는 지역까지만 탐방한다. 다 열어봤는데 안 나오면, 미련없이 더 진행하지 말고 리셋한다.&lt;/li>
&lt;li>여기서 &amp;lsquo;guaranteed spawn&amp;rsquo; 은, 맵 방문 시 반드시 획득 가능하다는 것이다. 반대로 말하면, 같은 맵에 갔더라도 외계 문자가 나오지 않을 가능성도 있다! (이게 가장 힘든 부분&amp;hellip;)&lt;/li>
&lt;li>외계 문자는 번호가 적혀있지 않으므로, 어디가 빠졌는지 게임에서 확인할 길이 없다. 그냥 반복 플레이를 해 보고, 스크린샷을 보고, 눈에 익지 않은 곳이 어디인지 추측해서 플레이하는 길 밖에 없다. (제일 더럽다&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>슈퍼 개발자만 쓸모가 있을까</title><link>https://interp.blog/you-are-not-a-genius-programmer/</link><pubDate>Fri, 03 Jun 2022 06:36:33 +0900</pubDate><guid>https://interp.blog/you-are-not-a-genius-programmer/</guid><description>&lt;p>커뮤니티 글에서 최근 꾸준글로 보이는 한 친구가 있다. 자신을 컴퓨터공학과 학생으로 소개하면서, 알고리즘 문제를 풀다보니 너무 어려워서 전공을 바꿀까, 자신은 보잘것 없는 개발자가 될 것이라며 자학을 꾸준히 하고 있었다. 무슨 문제를 못 풀어서 저러는 건지는 모르겠지만, 갑자기 내 대학원 때 생각이 나서, 주저리 적어본다.&lt;/p>
&lt;h1 id="슈퍼-개발자의-존재">슈퍼 개발자의 존재&lt;/h1>
&lt;p>개발조직 사이에서, &amp;lsquo;100명의 개발자 중 1-2명의 슈퍼 개발자들이 나머지 개발자들보다 일을 잘 한다&amp;rsquo; 라는 말을 흔히들 한다. 이런 슈퍼 개발자를 모셔 와야 조직의 퍼포먼스가 올라간다는 것이다. 그러면 이 &amp;lsquo;나머지 개발자&amp;rsquo; 들의 운명은 어떻게 되는 것인가? 조직의 입장에서, 슈퍼 개발자를 모셔 왔으면, 나머지 중 하위 10명 정도는 잘라내도 괜찮을가? 개인의 입장에서, 내가 슈퍼 개발자가 아니면, 모가지를 내놓고 회사를 다녀야 할까?&lt;/p>
&lt;p>내 생각엔, 이런 뛰어난 개발자는 축구로 치면 스타 플레이어의 크랙 (crack) 이다. 대치 상태를 뒤집고 돌파할 수 있는 천재적인 능력이나 역량을 지닌 선수를 말한다. 프로그래머는 문제를 해결하는 사람들이므로, 어떤 문제에 부딪혔을 때, 누구보다도 문제를 빠르게 해결하거나 그 방법을 제시할 수 있는 사람들이 슈퍼 개발자라면, 괜찮은 비유인 듯 하다. (어렵지만) 축구에서도 스타 플레이어 혼자 끝까지 달려 수비수를 제끼고 골을 넣을 수 있다. 프로그래머도 혼자 끝까지 코딩해서 문제를 풀 수 있다. 이 부분도 어느 정도 맞다.&lt;/p>
&lt;p>하지만 한 골이 아니라 경기 전체, 한 문제가 아니라 조직 비즈니스 전체에서는 실패할 확률을 줄이면서 성공으로 이끌어야 하는 책임이 있다. 한 두번이면 몰라도, 축구선수가 크래킹을 시도 때도 없이 한다던지 독단적으로 볼키핑을 하거나 요구한다면, 상대방이 수비 전술을 바꿔 꽁꽁 묶어버릴 수도 있고, 다른 선수의 사기를 떨어뜨릴 수 있다. 감독은, 그 선수의 뒤에서 볼을 주고 받아 줄 다른 선수들과 긴밀한 유대를 가지도록 독려해야 하며, 스타 플레이어의 역량과 조직 운용에 균형을 맞춰야 한다.&lt;/p>
&lt;p>혼자 하는 프로그래밍도 마찬가지인데, 뒤에서 따라가며 이해하고 테스트를 하거나 리뷰를 해 줄 다른 개발자가 필요하다. 그렇지 않으면, 문제 해결에 혈안이 된 나머지 다른 버그를 놓치거나 코드 품질의 저하, 조직 문화 저하를 가져올 수 있다. &amp;lsquo;혼자 가면 빨리 가고, 함께 가면 멀리 간다&amp;rsquo; 라는 말이 괜히 있는 게 아니다.&lt;/p>
&lt;h1 id="결국-시스템만-남는다">결국 시스템만 남는다&lt;/h1>
&lt;p>하지만 현실적으로, 슈퍼 개발자, 스타 플레이어가 물론 경기를, 비즈니스를 성공적으로 이끄는 모습은 그렇게 놀랄만한 일이 아니다. 그들은 비단 한 골이 아니라, 아예 제품을 일신시켜줄 그런 멋진 도약을 해내곤 한다. 인정한다. 하지만 조직 입장에서는 이럴 때 일 수록 경계해야 한다. 매니저는 항상 &amp;ldquo;저 선수/개발자가 떠나면 우린 어떡하지?&amp;rdquo; 라는 고민을 해야 한다.&lt;/p>
&lt;p>조직은 그 자리에 머문다. 스타 플레이어 뿐만 아니라 일반 개발자, 매니저까지 모조리 떠날 수 &amp;lsquo;있다&amp;rsquo;. &lt;strong>남는 건 바로 제품(코드)와 시스템이다. 이것들이 스타 플레이어에 의존한다면, 떠나고 나서도 제대로 작동할 가능성은 제로에 가깝다.&lt;/strong> 조직 입장에서는, 이 부분이 핵심이다. 그래서 잘 하는 개발자를 모셔오는 것도 좋지만, 이렇게 영입하고서도 조직 시스템을 해치진 않는지 고민해야 한다.&lt;/p>
&lt;h1 id="개발자의-역할">개발자의 역할&lt;/h1>
&lt;p>이제 개발자 개인의 관점에서 생각해보자. 사실 &amp;lsquo;나는 슈퍼 개발자가 아니구나&amp;rsquo; 라는 생각을 늘 하고 있었는데, 이런 고민을 이렇게 글로 풀어보고 싶었다.&lt;/p>
&lt;p>앞서 말했듯이 조직은 슈퍼 개발자에 의존하지 않아도 작동할 시스템과 제품 코드를 유지하고자 한다. 내 결론은, 이 시스템을 &lt;strong>잘&lt;/strong> 이해하고 따르기만 해도, 내부 코드를 &lt;strong>잘&lt;/strong> 이해하고 있기만 해도 조직에서의 가치는 올라갈 수 있다. 더 나아가면, 조직을 너무 잘 이해한 나머지, 문제 해결을 할 수 있는 슈퍼 플레이어에게 패스를 잘 할 수 있는, 플레이메이킹을 할 수 있다. 이런 개발자를, 사일로 (silo) 를 연결해 주는 브릿지 (bridge) 역할을 한다고 한다. 조직에서는 정말 보배같은 존재다.&lt;/p>
&lt;p>그런데 이 부분에서도 경쟁력이 필요하다. 시스템을 잘 이해한다는 것은, 시스템 안에서 정보를 누구보다 빨리 찾아낼 줄 알아야 하고 다른 팀과 소통을 빠르게 할 수 있어야 한다는 뜻이다. 내부 코드를 잘 이해하고 있다는 것은, 자기가 담당하거나 담당했던 부분에 대해서는 누구보다 자신있게 대답할 준비가 되어 있어야 한다는 것이다. 그냥 이해하면 그냥 임금노동자일 뿐이다.&lt;/p>
&lt;p>만약 시스템이 정말 안 맞는다, 코드가 정말 어렵다면 방법은 두 가지다. (야근을 강요하는 것으로 들렸다면 미안하지만) 자투리 시간에 공부를 더 해서 경쟁력을 올리거나, 그렇게 해도 안 되겠으면 자기에게 더 잘 맞을 것 같은 조직으로 이직해야 한다.&lt;/p>
&lt;h1 id="개발도-사람이-한다">개발도 사람이 한다&lt;/h1>
&lt;p>결론은, 개발도 결국 사람이 하는 것이다. (물론 기본은 해야겠지만) 개발 능력이 슈퍼 개발자에 비해 부족하다고 좌절할 필요는 없다. 나도 그런 벽은 꽤나 많이 경험해 봤고, 좌절도 해 보고 노력도 해 봤지만 큰 소용이 없다. 그보다는, 다른 방면으로 조직에 기여할 수 있는 부분이 있는지 찾아보는 편이 훨씬 빠르다.&lt;/p>
&lt;p>나는 개인적으로 문서화하는 걸 즐겨해서 보고 들은 것, 경험한 것을 사내 위키에 정리해 둔다. 한 가지 원칙은 &amp;lsquo;이 문서는 반드시 남들이 볼 것이다&amp;rsquo; 라는 생각으로 탈고해야 한다. 그렇게 하지 않으면 미래의 나 조차 문서를 이해하지 못하기 때문이다. 이런 습관이 커리어에 많은 도움이 되었다.&lt;/p>
&lt;p>회사에 취직하지 않았다고 하더라도, 똑같은 공식을 오픈소스 프로젝트나 동아리, 하다못해 개인 토이 프로젝트에 적용하면 어떨까. 개발조직 세상에는, 코딩 외에 할 일이 너무나도 많다.&lt;/p></description></item><item><title>심플 소프트웨어</title><link>https://interp.blog/simple-software/</link><pubDate>Mon, 09 May 2022 17:43:44 +0900</pubDate><guid>https://interp.blog/simple-software/</guid><description>&lt;img src="https://interp.blog/simple-software/book.jpg" alt="Featured image of post 심플 소프트웨어" />&lt;figure class="align-center ">
&lt;img loading="lazy" src="book.jpg#center" width="40%"/>
&lt;/figure>
&lt;p>&lt;a class="link" href="https://www.gilbut.co.kr/search/search_book_list#code=003000000&amp;amp;sub_code=003000000%3E003001000&amp;amp;view_mode=&amp;amp;list_size=15&amp;amp;order=date&amp;amp;descending=true&amp;amp;page=1" title="길벗 출판사"
target="_blank" rel="noopener"
>길벗 출판사&lt;/a>에서 나온 비슷한 디자인의 책이 몇 권 있다. IT 교양서로 분류된 책 중에서 어두운 표지색을 내려오는 세로 제목 사이에 아이콘이 끼워져 있는데, &amp;lsquo;소프트웨어 장인&amp;rsquo;, &amp;lsquo;소프트 스킬&amp;rsquo;, &amp;lsquo;커리어 스킬&amp;rsquo; 세 권이 있다. 우연히도 세 권을 다 읽어봤는데, 이 시리즈 (?) 에서 한 권 더 추가된 &amp;lsquo;심플 소프트웨어&amp;rsquo; 를 최근에 도서관에서 빌려보게 되었다.&lt;/p>
&lt;p>앞선 세 권과 비슷하게, 이 책 역시 작가의 블로그 내용을 엮어 낸 것이다. (&lt;a class="link" href="https://www.codesimplicity.com/" target="_blank" rel="noopener"
>https://www.codesimplicity.com/&lt;/a>)&lt;/p>
&lt;p>하지만 책에서만 소개되는 챕터가 존재하고, 챕터 간에 흐름이 끊기거나 하지 않고 나름 긴밀히 엮여있기 때문에 단순한 번역본으로 보기엔 무리가 있다. 한 챕터의 내용이 길지 않기 때문에, 가볍게 끊어 읽기에도 좋다. (무엇보다 다른 책들에 비해 책이 얇다. 아주 큰 차이점이다!)&lt;/p>
&lt;h2 id="이왕-할-거면-잘-하려고-노력하자">이왕 할 거면, 잘 하려고 노력하자.&lt;/h2>
&lt;p>책 뒷면에 보면 &amp;lsquo;할 거면 잘 해라!&amp;rsquo; 라고 적혀있다. 나는 처음에 이 뒷면을 보고, 자뭇 도발적이라고 생각했다. 하지만 읽다 보니, &amp;lsquo;못 하면 안 돼!&amp;rsquo; 라는 뜻이 아니었다. 이왕 개발자를 할 거라면 잘 하고 싶은 마음으로 책을 펼쳤으면 하는 저자의 바람이라고 이해해주면 좋겠다.&lt;/p>
&lt;h2 id="단순한-개발을-해야-하는-이유">단순한 개발을 해야 하는 이유&lt;/h2>
&lt;p>모든 챕터의 시작은 바로 &amp;lsquo;단순함&amp;rsquo; 에서 출발한다. 단순해지면, 아래 목표들을 이루기가 수월하다는 것이다.&lt;/p>
&lt;ol>
&lt;li>테스팅이 쉽다.&lt;/li>
&lt;li>버그가 적다.&lt;/li>
&lt;li>기능 추가를 해도 코드 품질이 크게 떨어지지 않는다.&lt;/li>
&lt;li>(다른) 개발자가 이해하기 쉽다.&lt;/li>
&lt;li>보안이 향상된다.&lt;/li>
&lt;/ol>
&lt;h2 id="먼저-이해하고-공부하기">먼저, 이해하고 공부하기&lt;/h2>
&lt;p>저자는 먼저, 개발자는 자신이 뭘 개발하는지 완벽히 이해하려고 노력해야 한다고 한다. 그동안 만나왔던 개발자의 10% ~ 20% 만이, 무엇을 개발하고 있는지 이해하고 있었다고 한다. 만약 무엇을 개발하고 있는지, 내가 보는 코드에 있는 개념이나 기법, 단어 중 어느 하나라도 모르고 있다면, 내가 참고하고 있는 설계에서 모르는 것이 하나라도 있다면, 무조건 그 부분을 이해하고 개발을 계속하라고 조언한다.&lt;/p>
&lt;p>이해가 잘 안되면, 공부를 해야 한다. 더 자세한 설명을 해 주는 매뉴얼이나 참고서를 보거나, 프로그래밍 언어를 다시 배워야 할 수도 있다. 다른 사람에게 물어봐야 할 수도 있다. 이해가 되지 않았는데 일을 하는 것은 일종의 헛일이 될 수 있다고, 저자는 몇 번이고 지적한다. 당장은 문제가 해결될 지 몰라도, 결국 유지보수와 설계 변경으로 인한 비용을 몇 배나 지불하고 나서야 잘못됐다는 것을 깨닫는다고 말이다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h3 id="생산성-향상을-조직에-불어넣기">생산성 향상을 조직에 불어넣기&lt;/h3>
&lt;p>리펙터링이나 생산성 향상을 위한 도구나 기법 도입은, 심플 소프트웨어를 지향하기 위한 수단이므로 항상 염두에 둬야 하는 부분이다. 하지만 현실은 씁슬하게도, 다른 개발자나 상사에 의해 반려되는 아이디어이기도 하다. &amp;ldquo;다 좋은 거 알지, 그런데 제품 출시부터 먼저 해야 하지 않을까?&amp;rdquo;&lt;/p>
&lt;p>맞는 말이다. 그래서 저자가 남긴 조언은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>개발자가 생각하는 진짜 문제를 확인해라. 혼자 생각하거나, 다른 사람이 지적한 생산성 관련 문제를 가지고 가지 마라. 개발자가 짜증난다고 생각한 부분이 어디인지 파악해라.&lt;/li>
&lt;li>암달의 법칙을 적용해서, 가장 쉽게 할 수 있으면서 효과가 가장 좋은 문제를 먼저 해결하라. 그러면 개발자의 신뢰를 얻을 수 있고, 보다 큰 리펙터링 업무를 지지해 줄 우군을 만들 수 있다.&lt;/li>
&lt;li>이 계획을 막는 사람이 소수 남아있을 수 있다. 하지만 대부분은 업무를 효율적으로 처리하고 싶어하므로, 다수의 의견이 될 수 있다. 그렇다고 소수를 맹목적으로 비난하면 안 된다. 항상 친절하게 대하되, 회유하거나 협상하거나, 아니면 무시해라.&lt;/li>
&lt;/ul>
&lt;h2 id="단순한-개발을-위한-것-리펙터링">단순한 개발을 위한 것: 리펙터링&lt;/h2>
&lt;p>리펙터링으로 돌아가면, 기능 추가를 하기 전에 리펙터링을 먼저 해두라고 조언한다. 그래야지만, 기능 추가에 따르는 코드 품질 저하를 막을 수 있다는 것이다.&lt;/p>
&lt;p>전적으로 동의한다. 내 생각을 덧붙이자면, 나는 이 과정이 &lt;strong>기능을 추가하기 전에 코드를 이해하는 과정이라고 생각&lt;/strong>한다. (앞서 말했던 &amp;lsquo;이해하고 공부하기&amp;rsquo; 와 연결된다.) 비유를 섞자면, 일종의 집안일이다. 귀찮지만, 그리고 티는 별로 안나지만, 꼭 해야 하는 일. 하지 않으면 삶이 팍팍해지고, 치우지 않은 것들이 장애물이나 위협이 되지만, 하고 나면 효율적으로 삶을 영위할 수 있는 그런 일 말이다.&lt;/p>
&lt;p>물론 저자는 무분별한 리펙터링을 경계한다. 집에 불이 났는데 정원을 가꾸는 꼴이란다. 리펙터링은 항상 기능 중심에서 이뤄져야 한다. 그리고 리펙터링은 해도 해도 끝이 없기 때문에, 한계를 정해두라고 한다. 어느 정도 해야 다른 사람들이 알아볼 수 있을지를 생각한다면, 그 쯤 했을 때 그만 둘 수 있을 것이다.&lt;/p>
&lt;h2 id="사용자는-문제를-알려주고-개발자는-문제를-해결한다">사용자는 문제를 알려주고, 개발자는 문제를 해결한다.&lt;/h2>
&lt;p>나는 이 책의 초입에 &amp;lsquo;설계 2원칙&amp;rsquo; 이라고 말한 것 보다, 이 1원칙만 고수해야 한다고 생각한다. (참고로 설계 2원칙이란 것은 별게 없고, 개발 비용이 크더라도 유지보수 비용이 훨씬 크게 줄어들면 반드시 해야 한다는 것과, 유지보수 비용과 코드 복잡성은 비례한다는 것이었다.)&lt;/p>
&lt;p>아마 저자가 (간접적이나마) 가장 많이 언급한 개념이 이것이 아닐까 한다. 사용자가 제기한 문제만 효율적으로 풀어도, 훌륭한 개발자이다. 개발자가 문제를 만들어 알아서 해결하려 들면, 그것은 개발자의 오만이고, 코드 복잡성을 비정상적으로 증가시키는 요인이 된다.&lt;/p>
&lt;p>위에서 &amp;lsquo;리펙터링&amp;rsquo; 이야기를 할 때, 개발자가 겪는 진짜 문제를 수집하란 말을 했었다. 이 경우에는 &amp;lsquo;개발자&amp;rsquo; 가 사용자가 된다.&lt;/p>
&lt;h2 id="마지막으로">마지막으로&lt;/h2>
&lt;p>이 외에도 &amp;lsquo;테스트할 때 고려해야 할 것&amp;rsquo; 이나 &amp;lsquo;오픈 소스 프로젝트를 성공적으로 이끌었던 경험담&amp;rsquo; 등을 같이 공유하고 있으니, 쉽게 읽히는 책이니만큼 다른 개발자 분들에게 추천하고픈 책이다.&lt;/p>
&lt;p>마지막으로 언급하고픈 챕터가 하나 있는데, 내용은 짧지만 메시지는 강력하다. 하지만 개발에 국한된 내용은 아니어서 짧게 소개하고자 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>성공은 혁신이 아니라 실행에서 온다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>이 제목을 보자마자, &amp;lsquo;생활의 달인&amp;rsquo; 에서 어떤 맛집 사장님이 음식을 준비하는 과정이 전파를 탄 기억이 어렴풋이 났다. 새벽 5시에 일어나 몇 시간 동안 갖가지 재료들로 음식을 준비고 있노라면, PD 가 &amp;lsquo;이런거 다 보여주셔도 돼요?&amp;rsquo; 라고 묻는데, 사장님이 자신만만한 미소를 지으시던 것 같다. 마치 &lt;strong>&amp;lsquo;할 수 있으면 해보시던가&amp;rsquo;&lt;/strong> 같은 느낌.&lt;/p>
&lt;p>아무리 좋은 아이디어라도 실행하지 않으면 쓸모가 없다. 이론가는 이론가일 뿐이고, 발명가는 발명가일 뿐이다라고 저자는 말한다. 전혀 다른 각도로 큰 교훈을 얻은 것 같아서, 이 책이 큰 도움이 되었다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="6929871144"
data-ad-format="auto"
data-full-width-responsive="true">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/></description></item><item><title>VSCodeVim: 분리된 줄 위/아래로 커서 이동하기</title><link>https://interp.blog/vim-wrapping-line-cursor-up-down/</link><pubDate>Fri, 15 Apr 2022 02:45:00 +0900</pubDate><guid>https://interp.blog/vim-wrapping-line-cursor-up-down/</guid><description>&lt;p>VSCode 에서도 Vim 환경을 쓰고 싶어서 &lt;a class="link" href="https://github.com/VSCodeVim/Vim" target="_blank" rel="noopener"
>VSCodeVim&lt;/a> 을 설치해서 쓰고 있다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/images/2022-04-15-vscodevim.png"
loading="lazy"
>&lt;/p>
&lt;p>그런데 위와 같이 markdown 편집을 할 때 처럼 줄 분리가 이뤄져서 (line wrapping) 사실 한 줄인데 여러 줄로 보여지는 경우에는, 커서를 아래로 내릴 경우에 &lt;em>실제&lt;/em> 다음 줄 로 이동한다. &lt;strong>화면에 보이는 줄이 아니라, 실제 줄로 이동하기 때문에&lt;/strong>, 커서를 옮길 때 여간 불편한 게 아니다.&lt;/p>
&lt;h2 id="해결-방법">해결 방법&lt;/h2>
&lt;p>Vim 도 사실 line wrapping 이 되었을 때 같은 문제가 있고, (문제라기 보다는 특성인데) 원하는 방법대로 우회할 수 있는 방법을 &lt;a class="link" href="https://vim.fandom.com/wiki/Move_cursor_by_display_lines_when_wrapping" target="_blank" rel="noopener"
>여기&lt;/a>서 찾았다. 이 방법을 그대로 VSCode 에도 적용한 것이다.&lt;/p>
&lt;p>먼저 Settings 를 열어서 &lt;strong>Vim: Normal Mode Key Bindings&lt;/strong> 로 이동하면, Edit in settings.json 링크가 있다. 이걸 눌러서 다음을 추가하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;vim.normalModeKeyBindings&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;Up&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;g&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;k&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;Down&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;g&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;j&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>적용하고 곧바로 편집 중인 파일로 돌아오면 적용이 되어 있는 걸 볼 수 있다. 이제 커서를 위/아래로 움직여도 화면에 보이는 윗줄/아랫줄로 이동한다!&lt;/p></description></item><item><title>k8s Operator vs. Controller</title><link>https://interp.blog/kubernetes-operator-vs-controller/</link><pubDate>Tue, 15 Mar 2022 02:44:57 +0000</pubDate><guid>https://interp.blog/kubernetes-operator-vs-controller/</guid><description>&lt;p>쿠버네티스에서 서비스를 개발하거나 운영하다 보면 자주 접하게 될 개념 중 하나가, 바로 이 Controller 와 Operator 일 것이다. 어떤 경우에는, 동일한 서비스를 두고 &amp;lsquo;이건 Controller 야&amp;rsquo; 라고 말 할 때도 있고 &amp;lsquo;이 Operator 는&amp;hellip;&amp;rsquo; 이라고 불릴 때도 있어서 헷갈릴 수 있다. 심지어 공식 문서에서도 두 개념에 대한 비교는 하지 않고 있어서 명확한 구분이 필요한 것 같다.&lt;/p>
&lt;p>와중에 &lt;a class="link" href="https://blog.marcnuri.com/kubernetes-operator-vs-controller" target="_blank" rel="noopener"
>이 문서&lt;/a>를 발견했는데, 요약하자면 이렇다.&lt;/p>
&lt;h3 id="controller">Controller&lt;/h3>
&lt;blockquote>
&lt;p>So in the Kubernetes world, a controller will basically &lt;strong>monitor and measure the cluster resources state to adjust those resources that diverge from the desired state&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>더 줄여보면, Controller 는 (1) K8s 리소스 (중 일부) 의 상태를 체크하고 (2) 이 리소스들의 상태를 &amp;lsquo;목표 상태 (desired state)&amp;rsquo; 로 조정하는 역할을 한다.&lt;/p>
&lt;p>&lt;code>ReplicaSet&lt;/code>, &lt;code>StatefulSet&lt;/code>, &lt;code>DaemonSet&lt;/code> 이 대표적인 Controller 들이다. 속해 있는 Pod 들의 상태를 &amp;lsquo;목표한 상태&amp;rsquo; 로 조정하려고, Pod 을 추가하거나 삭제한다.&lt;/p>
&lt;h3 id="operator">Operator&lt;/h3>
&lt;p>CoreOS 에서 정의하는 Operator 는 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>An Operator is &lt;strong>a method of packaging, deploying and managing a Kubernetes application.&lt;/strong>&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>그런데 이 개념을 구현하기 위해서는 필연적으로 Controller 가 들어가게 된다. 그렇다면 Controller 와 비교했을 때 Operator 의 차이점은 무엇일까?&lt;/p>
&lt;p>저 &amp;lsquo;Kubernetes application&amp;rsquo; 에서 말하는 것은, 사용자가 직접 지정할 수 있는 CRD (Custom Resource Definition) 과 거기서 파생된 CR (Custom Resource) 까지 포함하고 있는 것이다. 아니면 정말 bare application 형태로 특정 microservice 를 관리할 때도 Operator 라고 부를 수 있겠다.&lt;/p>
&lt;p>예를 들면, Orange 라는 CRD 를 하나 만들었고, 이 Orange CR 에는 1개의 &lt;code>Service&lt;/code> 와 1개의 &lt;code>Pod&lt;/code> 이 만들어져야 한다고 해보자. 그러면 Orange CR 을 관리하는 application 을 가리킬 때는 Orange *&lt;strong>Operator*&lt;/strong> 라고 부를 수 있다. 하지만 내부에 구현된 Reconcile Loop Code 는 일종의 Orange *&lt;strong>Controller*&lt;/strong> 라고도 부를 수 있는 것이다. 실제로 Service 와 Pod 을 만드는 역할은 이 Controller 에서 이뤄지지만, 전체적으로 Orange CR 의 명세를 관리하는 것은 전체 Operator 가 담당하는 것이다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h3 id="정리하면">정리하면&lt;/h3>
&lt;p>나에게 Controller 는 기술적인 개념이고, Operator 는 좀 더 포괄적이면서 논리적인 개념으로 받아들여진다. &lt;a class="link" href="https://blog.marcnuri.com/kubernetes-operator-vs-controller" target="_blank" rel="noopener"
>문서&lt;/a>에서도 &amp;lsquo;모든 Operator 는 CR 을 관리하기 위해 쓰이는 Controller 라고 부를 수 있다.&amp;rsquo; 라고 하고 있으니까 말이다.&lt;/p>
&lt;p>그리고 Controller 나 Operator 모두 어떤 프레임워크일 뿐이지, 언어에 국한된 것은 아니라고 언급한다. Go 언어와 Python 으로 모두 구현해 본 경험이 있는 나 역시, 이 부분에 동의한다.&lt;/p>
&lt;p>다만 용어를 선택하거나 접할 때 좀 더 이해를 확실히 할 목적으로 정리하는게 더욱 낫지 않을까 하는 마음에, 이 비교글을 마친다.&lt;/p></description></item><item><title>Archives</title><link>https://interp.blog/archives/</link><pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate><guid>https://interp.blog/archives/</guid><description/></item><item><title>나의 부모님이 이 책을 읽었더라면</title><link>https://interp.blog/the-book-you-wish-your-parents-had-read/</link><pubDate>Wed, 02 Mar 2022 00:00:06 +0000</pubDate><guid>https://interp.blog/the-book-you-wish-your-parents-had-read/</guid><description>&lt;img src="https://interp.blog/the-book-you-wish-your-parents-had-read/book.jpg" alt="Featured image of post 나의 부모님이 이 책을 읽었더라면" />&lt;figure class="align-center ">
&lt;img loading="lazy" src="book.jpg#center" width="60%"/>
&lt;/figure>
&lt;p>책 제목이 나에겐 조금 자극적이었는데, 마치 이렇게 지내는 내가 나의 부모님 때문이라는 일종의 책임전가 같은 느낌이 들어서였다. 물론 실제 내용은 그렇진 않고 무던하면서도 세세하게 양육법에 대한 상담 내용이나 저자의 생각을 공유한다.&lt;/p>
&lt;p>당장 생각나는 것은 이 정도이다.&lt;/p>
&lt;ul>
&lt;li>(전부는 아니지만) &lt;strong>대개 양육에서 어려움을 느끼는 부분은, 내가 자라면서 겪은 부분이 반영된 것이다.&lt;/strong> 그 부분이 나의 부모님의 잘못일 수도 있고, 환경적인 문제일 수도 있고, 시대 또는 집안에서 요구한 (혹은 묵인한) 양육법의 문제일 수도 있다.&lt;/li>
&lt;li>사람은 누구나 실수를 하고, 상대방에게 (의도했건 의도치 않았건 간에) 상처를 줄 수 있다. 그것은 자연스러운 것이니, 과거를 후회하며 좌절하면 안 된다. 중요한 것은, &lt;strong>상처를 줄 수 있다는 사실을 인정하고 상처를 치유할 노력을 지속적으로 하는 것이다.&lt;/strong> 치유는 당장 될 수도, 오랜 시간이 걸릴 수도 있지만, 중요한 건 그 노력 자체다.&lt;/li>
&lt;li>&lt;strong>아이는 감정의 동물이다.&lt;/strong> 성인은 이성적으로 감정을 제한할 능력이 어느 정도 있어도, 아이는 그렇지 못하기 때문에 이해를 구하거나 동일한 사고로 문제를 판단하면 안 된다.&lt;/li>
&lt;li>&lt;strong>부모는 아이의 감정을 받아줄 그릇이 되려고 노력해야 한다.&lt;/strong> 당연히 모든 감정을 받아줄 수는 없겠지만, 그렇게 노력을 해야 한다. 그래야 아이가 불안해하지 않는다.&lt;/li>
&lt;li>&lt;strong>부모 역시 부모의 감정을 공유하고 나눌 수 있는 사람이 반드시 필요하다.&lt;/strong> 배우자가 되면 가장 좋고, 여건이 안 된다면 보모나 양육자의 부모가 그 역할을 해야 한다. 여기에서 중요한 건, 상대방을 감정 쓰레기통으로 만들면 안 된다는 점이다. 서로 감정을 쪼개 환원할 수 있는 관계를 반드시 구축해야 한다.&lt;/li>
&lt;li>&lt;strong>아이에게 놀이나 배움의 선택지를 제한하는 방법은 좋다.&lt;/strong> 선택지가 많아지면 더욱 산만해진다.&lt;/li>
&lt;li>&lt;strong>갓난 아이를 울리면서까지 방치하는, 그러다 이내 잠들게 만드는 소위 &amp;lsquo;수면 교육&amp;rsquo; 은 반대한다.&lt;/strong> 아이는 그 동안 느꼈던 외롭고 두려운 감정을 체념해 버리기 때문에 대개 자라면서 문제가 불거지게 된다. 정 하고 싶다면 대신 &amp;lsquo;수면 유도&amp;rsquo; 를 추천한다.&lt;/li>
&lt;li>&lt;strong>아이가 원하는 것이 있다면 최대한 들어주자.&lt;/strong> 집안일을 해야 하는데 놀아달라고 하면, 정말 급한 게 아닌 이상 놀아주자. 아이가 부모와 같이 잠들고 싶다면 잠을 자도록 하자.&lt;/li>
&lt;li>&lt;strong>아이가 이상한 집착을 할 때가 있는데, 그 집착은 평생 가지 않는다.&lt;/strong> 그런 버릇을 일부러 고치려 들지 말고, 아이가 불안하지 않은 상태로 유지해주는 게 중요하다. (실제로 공감이 많이 가는 내용이었다)&lt;/li>
&lt;/ul>
&lt;p>저자가 여성이라 임신 과정에서 느낀 심경의 변화를 잘 묘사한 부분도 있는데, 임산부를 도와주는 남편 입장에서 참고할 부분이 많기 때문에 허투루 봐선 안 된다는 생각도 든다. 나는 가족계획상 더 이상 참고할 일은 없지만, 그 때 그랬지 하기도 하고, 어루만져주지 못한 감정에 대해선 반성도 할 수 있었다.&lt;/p>
&lt;p>아이는 감정을 언어화할 능력이 매우 부족하기 때문에, &amp;lsquo;왜 그랬니&amp;rsquo; 나 &amp;lsquo;무슨 생각으로 그랬니&amp;rsquo; 같은 주관식에 답을 하지 못한다. (대개 딴청을 피운다) 그래서 양육하는 사람이 너는 이런 감정일지도 모른다고 언어로 묘사해 줘야 한다. 그래야 아이가 이 감정과 그 문장을 일치시켜서 배우게 되는 것이다. 울거나 떼 쓰는 감정을 명확히 해 주면, 아이가 이해하고 악용하거나 해서 상황이 악화되진 않을까 생각할 순 있다. 하지만, 앞서 말했듯 다 한 때인 데다가 오히려 감정을 이해하면 최소한 울거나 떼를 쓰지는 않는다.&lt;/p>
&lt;p>그리고 아이는 미래를 염두에 두는 능력 또한 부족하기 때문에, 무작정 혼을 내거나 &amp;lsquo;이렇게 되면 이렇게 할거야&amp;rsquo; 같은 협박에 무신경하다. 부모의 목소리와 기분만 상할 뿐이다. 따라서 현재의 감정 상태를 이해하려 노력하고 어루만져주는 게 훨씬 낫다고 조언한다.&lt;/p></description></item><item><title>엘든 링, 10시간 리뷰</title><link>https://interp.blog/elden-ring-10h-review/</link><pubDate>Mon, 28 Feb 2022 08:53:20 +0000</pubDate><guid>https://interp.blog/elden-ring-10h-review/</guid><description>&lt;img src="https://interp.blog/images/2022-02-28-elden-ring/featured.jpg" alt="Featured image of post 엘든 링, 10시간 리뷰" />&lt;p>메타크리틱과 오픈크리틱에서 GOTY 급 평점을 받은 그 게임, 그 때문인지 모든 스트리머와 게이머의 기대를 한 몸에 받아 수 많은 이슈를 한 몸에 받아내고 있는 &amp;lsquo;프롬 소프트웨어&amp;rsquo; 의 2022년 신작 &amp;lsquo;엘든 링&amp;rsquo; 을 10시간 가량 해 보고 난 소감을 적어본다.&lt;/p>
&lt;p>10시간 가량 했지만, 이제 겨우 멀기트를 잡았다. 새로운 지역을 싸돌아 다니면서 맵 아이템만 줍줍하고 보이는 축복들만 밝혔더니 스톰빌 전은 거진 다 밝혔다. (보스 잡은게 몇 없어서 그렇지&amp;hellip;)&lt;/p>
&lt;h1 id="스카이림--블러드본">스카이림 + 블러드본&lt;/h1>
&lt;p>인생 게임에 대한 이야기를 시작하게 되면, &amp;lsquo;엘더 스크롤 5: 스카이림&amp;rsquo; 과 &amp;lsquo;블러드본&amp;rsquo; 은 항상 나에게 두 손가락 안에 드는 게임으로 꼽힌다. 이 두 개를 합친 듯하다. 혹자는 &amp;lsquo;젤다:야생의 숨결&amp;rsquo; 의 오픈월드가 느껴진다고도 하고, &amp;lsquo;베르세르크&amp;rsquo; 에서 모티브를 따온 만큼 그 느낌이 잘 살아있다고도 하던데&amp;hellip; 둘 다 접해보지 않아서 잘 모르겠다. 그보다는, 북유럽 풍의 디자인을 공유하면서 오픈월드였던 스카이림이 개인적으로 먼저 떠올랐다.&lt;/p>
&lt;p>블러드본은 좀 늦게 시작했는데, PS4 구입 자체가 늦어서 발매된지 2년 좀 안되어서 했던 기억이 난다. 그런데도 나는 잠을 줄여가면서 필드와 보스를 하나씩 넘겼다. (출근은 해야 하니까) 신혼 초에 그 때는 아이도 없어서 가능했던 것 같다.&lt;/p>
&lt;p>갑자기 블러드본 한 이야기를 꺼낸 이유는, 그 때의 느낌을 엘든 링에도 받고 있기 때문이다. 지금은 두 아이가 있어 육아도 신경써야 하고 집안일의 양도 월등히 많고 해야 할 다른 일들이 많은데도 말이다. 다크소울 3나 세키로는 정해진 시간에 하고 종료 버튼을 누르기가 수월했는데, 왜 그럴까&amp;hellip;&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-02-28-elden-ring/image.png"
alt="임의로 생성할 수 있는 성배 던전은, 블러드본 고유의 특징이다."/> &lt;figcaption>
&lt;p>임의로 생성할 수 있는 성배 던전은, 블러드본 고유의 특징이다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>블러드본은 회차를 넘기고 나면 할 수 있는 일이 좀 더 많은데, 바로 성배던전으로 파밍하는 것이다. 물론 초회차 유저에게는, 이렇게 무수히 많은 비석이 부담으로 다가올 수 있다. 나도 그랬으니까. 이것이 다크 소울과 세키로와 다른 점인데, 아무리 화톳불/불상을 넘나들며 스토리를 진행한다 하더라도 일종의 선형적 구조를 지닐 수 밖에 없는 점보다는, 사이드 퀘스트인 성배 던전으로 추가 업그레이드와 모험을 할 수 있는 선택지를 넓혔다는 것이다.&lt;/p>
&lt;p>엘든 링이 딱 이런 식인데, 더 이상 스토리 진행이 안 되겠거든 &amp;lsquo;강해져서 돌아와라&amp;rsquo; 식의 진행이 가능하다는 것이다. 그러다 새로운 이벤트를 마주하기도 하고, 또 다른 보스를 만나기도 하고, 탐험을 진행하다가 돌아와서 다시 말을 걸면 전혀 다른 정보를 주기도 하고, 아이템을 줍고 만들고 모험을 계속 하는 것이다.&lt;/p>
&lt;p>하나 더 곁들이자면, 엘든 링 지하 던전 중에 &amp;lsquo;시프라 강&amp;rsquo; 이란 곳이 있다. 여기 엘리베이터 타고 내려가면 첫 인상은 마치 스카이림의 &amp;lsquo;블랙 리치&amp;rsquo; 에 다다른 듯한 인상을 준다.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-02-28-elden-ring/Untitled-2.jpg"
alt="왼쪽이 시프라 강, 오른쪽이 블랙 리치. 그야말로 지하의 몽환세계&amp;amp;hellip;"/> &lt;figcaption>
&lt;p>왼쪽이 시프라 강, 오른쪽이 블랙 리치. 그야말로 지하의 몽환세계&amp;hellip;&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h1 id="지적되는-단점들에-대해서">지적되는 단점들에 대해서&lt;/h1>
&lt;p>이렇게 흡인력이 강하지만 최초 스팀 평가는 &amp;lsquo;복합적&amp;rsquo; 이었다. 기대에 대비해 실망한 사용자가 많았다는 것이다. 물론 PC 판에서 특히 심한 &amp;lsquo;스터터링&amp;rsquo; 문제는 무조건 고쳐야 하는 문제이고 백번 까여야 한다. (다행히 나는 보스전에서 그런 문제를 마주하지 않아서 덜 화나긴 하지만)&lt;/p>
&lt;p>그런데 그 외의 논란거리에 대해선 &amp;lsquo;글쎄&amp;rsquo; 다. 너무 큰 관심을 한 몸에 받아서 그런지, 엄청나게 높은 평론가 평점과 별개로 퍼포먼스 부분에서 심각하게 까이고 있다고 생각한다.&lt;/p>
&lt;p>대표적으로 그래픽이 다른 AAA 게임에 비해 낮다는 것은, 마치 &amp;lsquo;포켓몬스터 : 아르세우스&amp;rsquo; 와 &amp;lsquo;야숨&amp;rsquo; 의 필드 배경을 비교하는 것 같은 느낌이 강하게 들었다. 내부 사정이야 잘 모르겠지만, 알음알음 공개된 개발사 규모를 생각해 보면, 제한된 자원으로 선택과 집중을 했다고 너그러이 봐줄 수도 있지 않을까.&lt;/p>
&lt;p>물론 이런 건 있겠지. 소위 &amp;lsquo;&lt;strong>망자들&lt;/strong>&amp;rsquo; 로 지칭되는 다크소울 시리즈를 즐겨하는 게이머 풀의 외연 확장을 위해, &amp;lsquo;엘든 링은 좀 더 쉬울거가, 오픈월드 같은 느낌으로다가 발매합니다&amp;rsquo; 라고 홍보를 했으니 말이다. 마치 메타크리틱에서 붙이는 &lt;em>MUST PLAY&lt;/em> 딱지를 꼭 받고, 너도 나도 이 게임을 안 사고는 못 배기는 킬러 타이틀로 부상시키려는 노력이 없었다고는 말 못하겠다. 그래서 일반 게이머들이 보니까 &amp;lsquo;뭐야, 이거 평점은 그렇게 높더니 버그도 있고 그래픽도 별로고 게임은 어렵고 불친절하고&amp;hellip;&amp;rsquo; 가 되는 것일 수도?&lt;/p>
&lt;center>
&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-02-28-elden-ring/mustplay222.png"
alt="이게 붙으면, 너도나도 찍먹하게 되는데 문제는&amp;amp;hellip;"/> &lt;figcaption>
&lt;p>이게 붙으면, 너도나도 찍먹하게 되는데 문제는&amp;hellip;&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/center>
&lt;p>문제는, 아직도 이 게임은 다크소울 시리즈를 즐겨하는 게이머만 좋아할 법하다는 것이다. 그러니까, 실제 홍보와 게임 진행은 좀 다른 양상이라는 것이다.&lt;/p>
&lt;p>그런데 돌이켜보면, 이게 정말 문제일까? 몬스터 헌터가 일반 게이머도 손쉽게 접근할 수 있는 게임이 아니듯이, 다크소울 시리즈 역시 그렇다고 생각한다. 그런 테이스트 강한 게임을 하나 더 출시했는데, 좀 더 다양한 선택지를 줘서 게이머가 도전할 수 있는 옵션을 많이 제공해 준 것만으로도 게임 자체는 일신했다고 생각한다. 평론가들은 아마 (게임을 많이 하다보니) 대부분 &amp;lsquo;망자&amp;rsquo; 일 가능성이 크고, 거기에 비춰서 &amp;lsquo;그래픽이 후져도 졸잼이네요&amp;rsquo; 하고 평점을 높게 주진 않았을지.&lt;/p>
&lt;p>그런데 정말 스터터링은 문제다. 주변에서 들어보니 1060에서도 발생하고 3080ti 에서도 발생하는데 이게 대체 뭐람?&lt;/p>
&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>결론은 예약 구매는 하면 안 된다 (&amp;hellip;) 취향에 맞는지는 출시 직후 실황이나 클립을 통해서 얼마든지 확인할 수 있다. 정 찍먹을 하고 싶다면, 스팀에서 구매한 다음 한 시간만 빡세게 돌리고 아니다 싶으면 환불을 하는 방법이 있다. 농담이 아니라 정말이다.&lt;/p>
&lt;p>다크소울 시리즈를 (잘 못해도) 좋아한다면, 이 게임은 최적의 선택이 될 것이다. 나름대로 친절하고 돌아다닐 구석이 너무 많고, 의외의 발견에 희열을 느낄 수 있을 것이니.&lt;/p>
&lt;p>시리즈 전문 공략 유튜버/방송인 &amp;lsquo;이클리피아&amp;rsquo; 님의 첫날 실황 방송을 아주 잠깐 봤는데, 그 때 들었던 이 게임의 평이 다음과 같았다. 딱 열시간 하면서 이 평론이 뇌리에서 떠나질 않아서 붙여둔다.&lt;/p>
&lt;blockquote>
&lt;p>이거, &lt;strong>다크소울 올스타&lt;/strong> 같아요.&lt;/p>
&lt;/blockquote></description></item><item><title>바쁜 것도 습관입니다</title><link>https://interp.blog/being-busy-habit/</link><pubDate>Sun, 13 Feb 2022 22:26:07 +0900</pubDate><guid>https://interp.blog/being-busy-habit/</guid><description>&lt;img src="https://interp.blog/being-busy-habit/book.jpg" alt="Featured image of post 바쁜 것도 습관입니다" />&lt;figure class="align-center ">
&lt;img loading="lazy" src="book.jpg#center" width="65%"/>
&lt;/figure>
&lt;p>저자인 아리카와 마유미는 50가지 이상의 직업을 가져 본 40대의 베스트셀러 작가라고 한다. 이 책은 자기계발서이긴 하지만, 시간을 효율적으로 쓰는 기술을 알려주는 책은 아니다.&lt;/p>
&lt;p>책에서 이야기하는 &amp;lsquo;8가지 기술&amp;rsquo;이란 사실, 마음가짐에 대한 조언이다.&lt;/p>
&lt;ol>
&lt;li>시간을 보내는 기분에 집중한다.&lt;/li>
&lt;li>목적의식을 갖고 시간을 쓴다.&lt;/li>
&lt;li>나만의 철학으로 우선순위를 매긴다.&lt;/li>
&lt;li>지금 하고 싶은 일을 미루지 않는다.&lt;/li>
&lt;li>너무 깊은 생각은 행동으로 끊는다.&lt;/li>
&lt;li>나를 행복하게 만드는 관계에 집중한다.&lt;/li>
&lt;li>지속가능한 삶을 위해 시간을 쌓는다.&lt;/li>
&lt;li>일상의 호사스러움을 놓치지 않는다.&lt;/li>
&lt;/ol>
&lt;p>그러나 이 항목은 어쩐지 억지로 끼워 맞춘 듯 해 보이고, 아마 저자가 한편씩 내키는대로 (?) 썼다가, 마지막에야 분류를 할 때 &amp;lsquo;그나마 이 정도면 구색이 괜찮다&amp;rsquo; 고 판단한 것일지도 모르겠다. 나름대로 다시 정리해 보자면 이 책은 이런 걸 이야기하고 싶었던 것 같다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>내가 하고 싶은 게 있으면 무조건&lt;/strong> 그걸 할 시간을 할당해라. 그 다음 나머지를 할당해라.&lt;/li>
&lt;li>&lt;strong>중요한 일인데 기한이 없는 일&lt;/strong> vs. 중요하지 않은데 기한이 있는 일 -&amp;gt; 무조건 전자!&lt;/li>
&lt;li>내가 하는 행동에는 반드시 합당한 목적이 있어야 한다. 목적이 없으면 당장 중단하라.&lt;/li>
&lt;li>여러 조건으로 내가 하기 싫어도 해야 할 일이 있다면, &lt;strong>이왕 할 거 즐겁게 해라&lt;/strong>.&lt;/li>
&lt;li>마음만 즐겁게 하지 말고, 이왕 할 거 제대로, 좀 기분 좋아지라고 데코레이션을 가미해서라도 누려라.&lt;/li>
&lt;li>&lt;strong>미루지 마라&lt;/strong>.&lt;/li>
&lt;li>그렇다고, 내일 해도 될 일을 오늘 하란 소리가 아니다. 내일 할 일은 내일 꼭 하자.&lt;/li>
&lt;li>아직도 뭐가 중요한지 내 마음의 소리를 잘 모르겠으면, 참고해라.&lt;/li>
&lt;li>내가 행복한 걸 먼저 찾는다. 나는 불행한데, 남&amp;rsquo;만&amp;rsquo; 행복한 건 하지 마라.&lt;/li>
&lt;li>내가 불행하면 반드시 떨쳐내라. 내 감정을 상하게 하는 사람, 일은 꼭 피해 다녀라.&lt;/li>
&lt;li>나도 행복하고 남도 행복한 것, 바로 좋은 관계의 시작과 유지는 꼭 하라.&lt;/li>
&lt;li>모든 일에는 때가 있다. 지금 할 수 있고 나중에 못 할 일이라고 생각되면, 지금 최우선으로 해라.&lt;/li>
&lt;/ol>
&lt;p>사실상 1, 2, 3 번이 대전제에 가깝고, 4번에 대한 내용이 곳곳에 퍼져있는 식이다. 마음의 소리를 잘 들어보고 1-2-3 을 생각해서 시간을 계획하고 보내야 한다는 것이다.&lt;/p>
&lt;p>사실 이 책을 선택한 이유는 (도서관에서 빌려왔는데), 책을 우연히 펼쳐보다 한 눈에 딱 들어오는 구절이 있어서다.&lt;/p>
&lt;blockquote>
&lt;p>시간이라는 것은 &amp;lsquo;상자&amp;rsquo; 와 같습니다. 누구나가 가지고 있는 같은 크기의 상자에 시간이라는 &amp;lsquo;돌&amp;rsquo;을 넣는다고 생각하면 이해하기 쉽겠지요. 그 돌을 넣는 방법은 크게 두 가지로 나눌 수 있습니다.&lt;/p>
&lt;ol>
&lt;li>우선 큰 돌을 넣고 빈틈에 작은 돌을 넣는 사람&lt;/li>
&lt;li>작은 돌부터 넣어서 큰 돌을 넣지 못하는 사람그래서 우리는 시간이라는 상자에 제일 빛나는 돌을 먼저 담아야 합니다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>시간을 어떻게 보낼까? 보다는 &lt;strong>내가 보내는 시간은 나에게 의미가 있는가? 없다면 어떻게 진지하고 재미있게 그 시간을 보낼 수 있을까?&lt;/strong> 를 되돌아볼 수 있는 소중한 시간이 될 수 있을 것이다.&lt;/p>
&lt;p>&lt;strong>무엇보다도, 책이 정말&amp;hellip; 정말 술술 읽힌다&lt;/strong>. 222페이지라 많지는 않은데, 여기에 여백도 많고 한 페이지에 적힌 글자 수도 적었기 때문도 있지만, 아무래도 어려운 내용 없이 옆에서 조언하는 걸 듣는 마음으로 가볍게 읽을 수 있었던 것 같았다. 😊&lt;/p></description></item><item><title>카카오/네이버 메일 아이폰 연동</title><link>https://interp.blog/kakao-naver-email-iphone-connect/</link><pubDate>Fri, 04 Feb 2022 16:35:37 +0000</pubDate><guid>https://interp.blog/kakao-naver-email-iphone-connect/</guid><description>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/feature-image.jpg" alt="Featured image of post 카카오/네이버 메일 아이폰 연동" />&lt;div style="background-color: var(--body-background); width: 98%; margin:1px; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
🚧
&lt;/div>
&lt;div>
이미지 정렬이 필요합니다&amp;hellip;!
&lt;/div>
&lt;/div>
&lt;h2 id="요약">요약&lt;/h2>
&lt;ul>
&lt;li>원래는 홈페이지에서 하라는 대로 하면 된다.&lt;/li>
&lt;li>비밀번호를 잘 입력했는데 서버 접속이 안 된다면, 혹시 2단계 인증을 쓰고 있지는 않은지?&lt;/li>
&lt;li>2단계 인증을 쓰는 경우라면, &lt;strong>앱 비밀번호&lt;/strong>를 별도로 발급받는다.&lt;/li>
&lt;/ul>
&lt;h2 id="참고">참고&lt;/h2>
&lt;p>카카오 메일 뿐만 아니라 네이버 메일이나 네이버 캘린더 동기화도 비슷하다. 아래에 ‘부록’ 으로 달아뒀으니 참고하면 된다.&lt;/p>
&lt;h2 id="설정-방법">설정 방법&lt;/h2>
&lt;ol>
&lt;li>PC 에서 브라우저를 열고, 카카오 메일을 접속한다.
&lt;ul>
&lt;li>모바일 브라우저에서 카카오 메일을 접속하면 카카오톡으로 리다이렉트 되는데, 카카오톡에서는 해당 설정을 진행할 수 없다. 반드시 PC 로 접속한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>환경설정 &amp;gt; IMAP/POP3&lt;/strong> 을 클릭해서, IMAP 사용을 체크하고 저장한다.&lt;/li>
&lt;li>설정 앱으로 가서 ‘메일 &amp;gt; 계정’ 을 차례대로 누른다.&lt;/li>
&lt;/ol>
&lt;p>
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-1.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-2.jpeg" width="200px" style="display: inline;"/>
&lt;/p>
4. 그 다음 ‘계정 추가’ 를 누른 다음 ‘기타’ 를 선택한다. 이후에 'Mail 계정 추가' 를 선택한다.
&lt;p>
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-3.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-4.jpeg" width="200px" style="display: inline;" />
&lt;/p>
5. 기본 정보를 입력한다. 이메일과 암호는 쓰던 걸 쓰면 되고 이름이나 설명은 자유롭게 입력한다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-5.png" width="300px" />
6. IMAP 또는 POP 을 선택하는 탭이 있는데, 어느 것을 선택하던 상관없지만 IMAP 으로 진행한다.
&lt;br/> &lt;br/>
&lt;p>이제 안내된 대로 주소를 설정한다. &lt;a class="link" href="https://cs.kakao.com/helps?articleId=1073195244&amp;amp;service=156&amp;amp;category=519&amp;amp;device=&amp;amp;locale=ko" target="_blank" rel="noopener"
>공식 FAQ 문서&lt;/a>, 7번 항목)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">- 아이디 : 카카오메일 아이디 (ooooo@kakao.com 에서 앞 부분)
- 비밀번호 : 카카오 계정 비밀번호
- IMAP (받는서버) : imap.kakao.com:993 (SSL)
- SMTP (보내는서버) : smtp.kakao.com:465 (SSL)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>SSL 은 아마 처음 설정할 때 바로 시도할 것이다. 포트 번호는 당장 신경 쓰지 않아도 되는데, 나중에 계정 저장을 한 다음에 포트 세부설정이 가능한 곳이 있긴 하다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="비밀번호가-맞는데-되지-않아요">비밀번호가 맞는데 되지 않아요&lt;/h2>
&lt;p>혹시 2단계 인증을 쓰고 있지 않은지? 그렇다면 기존 비밀번호로는 인증을 할 수 없다. 사람이 로그인을 했다면 카카오톡에 들어가서 인증하기를 눌러줬겠지만, 이건 아이폰이니까.&lt;/p>
&lt;p>그래서 ‘앱 비밀번호’ 라는 걸 발급받아야 한다. PC 에서도 발급이 가능하지만, 어차피 아이폰에서 복사해서 바로 붙여넣을 예정이니, 모바일로 해 보자.&lt;/p>
&lt;ol>
&lt;li>이번에는 모바일 기기에서 ‘카카오톡’ 앱을 실행한다.&lt;/li>
&lt;li>‘&amp;hellip;’ 버튼을 누르고, 오른쪽 위에 있는 톱니바퀴를 누른다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-1.jpeg" width="300px" />&lt;/li>
&lt;li>개인/보안 → ‘카카오 계정’을 누르고, 나오는 화면에서 ‘2단계 인증’ 을 누른다.&lt;/li>
&lt;/ol>
&lt;p>
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-2.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-3.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-4.jpeg" width="200px" style="display: inline;"/>
&lt;/p>
4. 비밀번호를 입력한 뒤, ‘앱 비밀번호’를 누른다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-5.jpeg" width="300px" />
5. 앱 이름을 원하는 대로 입력하고, ‘생성’ 을 누르면 앱 비밀번호가 뜬다. 앱 비밀번호는 다시 볼 수 없기 때문에, 복사해 두거나 메모해 둬야 한다. 비밀번호를 놓쳤다면, 삭제했다가 다시 만들면 되니까 걱정하지 말자.
&lt;br/> &lt;br/>
&lt;p>이 앱 비밀번호를, 원래 비밀번호 대신 입력하면 서버 접속이 가능하다.&lt;/p>
&lt;h2 id="네이버는-어디서">네이버는 어디서?&lt;/h2>
&lt;p>이번에도 모바일 환경에서 해 볼 것이다. 네이버 앱으로 해도 되고, 일반 브라우저 에서 해도 상관없다.&lt;/p>
&lt;ol>
&lt;li>네이버에 로그인 한다.&lt;/li>
&lt;li>오른쪽 위에 있는 프로필 아이콘을 누른 뒤, 다시 왼쪽 위에 있는 프로필 아이콘을 누른다.&lt;/li>
&lt;li>&amp;lsquo;내 정보 및 프로필 관리&amp;rsquo; 에 있는 본인 계정을 누른다.&lt;/li>
&lt;li>보안 설정 및 비밀번호 변경을 클릭한다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/naver-3.jpeg" width="300px" />&lt;/li>
&lt;li>2단계 인증 항목에서 관리하기를 클릭한다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/naver-4.jpeg" width="300px" />&lt;/li>
&lt;li>조금 스크롤을 내리면, 애플리케이션 비밀번호 관리 항목이 보인다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/naver-5.jpeg" width="300px" />
&lt;ul>
&lt;li>종류에서 아이폰을 선택해도 되지만, 카카오에서의 이름 설정에 지나지 않기 때문에, 아무거나 입력해도 된다.&lt;/li>
&lt;li>생성하기 버튼을 누르면 비밀번호가 보인다. 마찬가지로, 지금 복사하거나 메모해두지 않으면 나중에 다시 볼 수 있는 방법이 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>CKA 시험 후기</title><link>https://interp.blog/cka-exam-review/</link><pubDate>Tue, 18 Jan 2022 22:38:42 +0000</pubDate><guid>https://interp.blog/cka-exam-review/</guid><description>&lt;img src="https://interp.blog/images/featured/cka-exam.jpg" alt="Featured image of post CKA 시험 후기" />&lt;p>CKA (Certified K8s Administrator) 를 2021년 12월 말에 합격 통지를 받았다. 합격을 받고 나서 정리한 팁을 공유하고자 한다.&lt;/p>
&lt;h1 id="강의">강의&lt;/h1>
&lt;p>매우 유명한 Udemy 의 Mumshard 강의를 완강했다. 내가 너무 초보여서 그런지는 몰라도, 기초 강의도 기본을 다지고 한번 더 리마인드 하자는 차원에서 완강을 했고, 결론적으로는 시험 뿐만 아니라 업무에도 큰 도움이 되고 있다.&lt;/p>
&lt;ul>
&lt;li>이해가 쏙쏙 되는 강의&lt;/li>
&lt;li>지속적인 업데이트&lt;/li>
&lt;li>KodeCloud 를 통한 인터렉티브 연습 문제 (엄청 많다!)&lt;/li>
&lt;li>3개의 모의고사 (요점은 다 나온다)&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>유료 (이긴 한데 상시 할인이라 큰 부담은 없다. 등록하면 평생 수강이니, 할인율이 높을 때를 노려 구매해 두는 것을 추천.)&lt;/li>
&lt;li>영어 (수준이 높다기 보다는 그냥 귀찮다. 영어 자막은, 거의 자동 생성인 경우가 많기 때문에 별 도움이 안 된다.)&lt;/li>
&lt;/ul>
&lt;h2 id="시험-등록">시험 등록&lt;/h2>
&lt;p>보통 시험을 Linux Foundation 에서 볼 텐데, 그럼 아래와 같은 절차로 시험을 준비한다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Global Candidate Agreement&lt;/strong> 를 읽고 &amp;lsquo;동의&amp;rsquo; 를 누른다.&lt;/li>
&lt;li>&lt;strong>이름을 확인한다&lt;/strong>. 반드시 신분증에 있는 영어이름과 일치해야 한다. (여권이나 국제운전면허증 등등) 일치하지 않거나 하면 피곤해진다고 한다.&lt;/li>
&lt;li>&lt;strong>시험에 사용될 OS 를 지정한다&lt;/strong>. 보통 우분투를 사용한다.&lt;/li>
&lt;li>&lt;strong>시험 일정을 예약한다&lt;/strong>. 한번 시험 등록에 들어오면 시험 일정을 잡는데 유효기간이 있다. 그래서 가급적 스케줄을 확인하고 얼른 시험 일정을 예약해야 한다.&lt;/li>
&lt;li>시스템 환경을 체크할 수 있다.
&lt;ul>
&lt;li>&lt;strong>Chrome 확장 프로그램&lt;/strong> 을 반드시 설치하고 시험을 시작해야 한다.&lt;/li>
&lt;li>비인가된 프로그램을 사용하는지 감독관이 반드시 체크한다. 작업관리자를 &amp;lsquo;간단히&amp;rsquo; 버전으로 띄우도록 요청한다.&lt;/li>
&lt;li>책상은 컴퓨터/노트북 외엔 깨끗해야 하며 (외부 모니터는 된다고 하던데 나는 치웠다) 책상 아래도 깨끗해야 한다. 이걸 증명하기 위해 웹캠이 필요하다. 노트북 내장 웹캠도 가능하다 (내가 그랬으니까)&lt;/li>
&lt;li>방 안엔 누구도 있어선 안 되고, 밝고 조용한 환경이어야 한다. 단, 수험자 뒤에서 밝은 빛이 나오면 안 된다 (감독관 방해)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>다음 글을 읽어 본다&lt;/strong>. 만약 시간이 없으면 Important Instructions 만 읽어 보자.
&lt;ul>
&lt;li>&lt;a class="link" href="https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad" target="_blank" rel="noopener"
>Important Instructions: CKA, CKAD&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.linuxfoundation.org/tc-docs/certification/lf-candidate-handbook" target="_blank" rel="noopener"
>Handbook&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>시험 준비가 모두 끝났다고 생각되면, &lt;a class="link" href="http://killer.sh" target="_blank" rel="noopener"
>killer.sh&lt;/a> 에 들어가서 모의고사 세션을 시작해보자.&lt;/li>
&lt;/ol>
&lt;h2 id="killersh">killer.sh&lt;/h2>
&lt;p>Linux Foundation 에서 제공하는 마지막 모의고사 성격의 mock-up exam 환경이다.&lt;/p>
&lt;ul>
&lt;li>저기서도 경고하지만, 실제 시험보다 훨씬 까다롭고 광범위한 질문이 나온다. 좌절할 필요 없다.&lt;/li>
&lt;li>2개의 세션이 제공되는데, 한 개당 36시간의 유효기간이 있다. 2시간 타이머가 돌긴 하지만, 타이머가 끝난다고 시험이 닫히진 않는다. 심리적인 압박 용이니, 2시간 시간관리 한다 생각하고 신경 써가며 풀어보자.&lt;/li>
&lt;li>2개 세션 모두 같은 문제 세트를 가지고 있다. 하나는 시험 치듯 풀고, 끝나면 정답과 함께 채점을 해 주기 때문에 두 번째 세션은 오답노트 풀듯이 훓는 걸 추천한다.&lt;/li>
&lt;/ul>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h1 id="팁">팁&lt;/h1>
&lt;h2 id="시험-환경-준비">시험 환경 준비&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>감독관은 말 하지 않는다&lt;/strong>. 대신 채팅으로 말한다.
&lt;ul>
&lt;li>시험 전 20분부터 입장이 가능한데, 감독관이 준비되어야 사실 입장이 가능하다 (&amp;hellip;)&lt;/li>
&lt;li>감독관을 만나면 하는 일은, 신분증으로 신원 확인, 방 주위를 둘러보기, 책상 보기, 책상 아래보기.. 정도만 했다.&lt;/li>
&lt;li>시험 중간에는 웬만하면 어떤 채팅도 올라오지 않는다. 내가 본 건 딱 ‘15분 남았습니다’ 였다.&lt;/li>
&lt;li>(내가 겪어 본 건 아니지만) 만약 허용되지 않은 웹 사이트를 실수로라도 방문하면, 경고성 채팅창이 올라올 것이다. 그런데 같은 짓을 4번 (3번?) 더 하면 시험이 그냥 종료되니 주의.
(자세한 내용은 위 문서에서 인스트럭션을 읽어보면 된다)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>북마크 사용은 가능하다&lt;/strong>, 물론 허용된 사이트 안의 웹 페이지만이다.&lt;/li>
&lt;li>&lt;strong>크롬이나 엣지 브라우저로 문제가 생길 수 있다는 이야기가 있다.&lt;/strong> 그러면 감독관이 &lt;a class="link" href="https://vivaldi.com/" target="_blank" rel="noopener"
>&lt;strong>비발디 (Vivaldi)&lt;/strong>&lt;/a> 브라우저를 권한다고 한다.
&lt;ul>
&lt;li>문제는, 환경설정에 시간을 다 뺏기고 (준비에 시간을 주긴 할테지만 2 시간 스케쥴이 틀어진다) 준비해 간 북마크 호환하기 어려울 수 있으므로 당황할 여지가 생긴다.&lt;/li>
&lt;li>추천: &lt;strong>그냥 ‘Vivaldi’ 브라우저를 설치하고, 거기다 환경을 구성해 두자.&lt;/strong> (물론 크롬 확장 프로그램 미리 깔아두는 것 잊지 말고)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>영어 해석에 애를 먹는다면, Google 번역 크롬 확장 프로그램을 설치해서 써도 된다.
&lt;ul>
&lt;li>K8s Docs 의 한글 번역본을 읽어도 아무런 제지가 없다.&lt;/li>
&lt;li>문제 몇 개는 해석이 조금만 틀려도 산으로 가는 것들이 있다. (NetworkPolicy 를 생성할 때 라던지)&lt;/li>
&lt;li>하지만 번역기는 만능이 아니다. 참고용으로만 쓰는 걸 추천한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="시험칠-때">시험칠 때&lt;/h2>
&lt;ul>
&lt;li>클러스터 몇 개가 주어지고, 매 문제마다 처음에 context 를 바꾸라고 한다. &lt;strong>안 바꿔도 된다는 확신이 있어도 반드시 바꾸자&lt;/strong>. 안 바꾸면 정답이 엉뚱한 클러스터에 반영되고 채점도 안 된다.&lt;/li>
&lt;li>15-20 개의 문제가 주어진다고 하고, 각 문제마다 배점이 있다. 컷 라인은 66점이니 &lt;strong>쉬운 것을 먼저 푸는게 좋다&lt;/strong>.&lt;/li>
&lt;li>다른 합격 후기에서는, &lt;code>kubectl&lt;/code> 자동 완성을 위해 cheat sheet 를 적용하라고 하는데, 나는 이게 시험 환경에 이미 적용이 되어 있었다.
&lt;ul>
&lt;li>&lt;code>kubectl&lt;/code> = &lt;code>k&lt;/code>&lt;/li>
&lt;li>명령어 자동 완성 가능 (예) &lt;code>k des&amp;lt;tab&amp;gt;&lt;/code> → &lt;code>k describe&lt;/code>&lt;/li>
&lt;li>리소스 이름 자동 완성 가능 (예) &lt;code>interp&lt;/code> 라는 ns 가 있다고 하면, then &lt;code>k get pod -n int&amp;lt;tab&amp;gt;&lt;/code> → &lt;code>k get pod -n interp&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>리소스를 지우거나 업데이트 하기 전에, &lt;strong>반드시 그 리소스를 백업해 두자.&lt;/strong> 혹시 그 리소스를 원상복구 시킬 때가 있을 수 있는데, 백업 없이는 다른 방법이 없다.&lt;/li>
&lt;/ul>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="6929871144"
data-ad-format="auto"
data-full-width-responsive="true">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="공부할-때">공부할 때&lt;/h2>
&lt;ul>
&lt;li>오픈북 시험에서 가장 중요한 건, 어떤 문제를 마주쳤을 때 어디를 봐야 하는지 기억해 두는 것이다.
&lt;ul>
&lt;li>좀 더 구체적으로, 어떤 키워드로 K8s docs 를 검색해야 하는지를 기억하는 것이 중요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하지만 아래 키워드는 찾아보기도 전에 타이핑할 수 있도록 기억해두는 게 좋다.
&lt;ul>
&lt;li>Pod 을 생성할 때: &lt;code>k run {name} --image= ... --dry-run=client -o yaml&lt;/code> 로 YAML 파일을 얻어서 수정한 뒤 &lt;code>k apply -f {yaml_file}&lt;/code> 로 입력&lt;/li>
&lt;li>리소스를 생성할 때 (가능하다면):
&lt;ul>
&lt;li>&lt;code>k create&lt;/code> 명령어로 어떤 리소스를 만들 수 있는지 보고,&lt;/li>
&lt;li>&lt;code>k create {resource} --help&lt;/code> 로 해당 리소스를 만들 수 있는 다양한 예제를 확인한 뒤,&lt;/li>
&lt;li>역시 &lt;code>--dry-run=client -oyaml&lt;/code> 을 붙여 YAML 파일을 얻을 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Hugo SCSS Rebuild</title><link>https://interp.blog/hugo-scss-rebuild/</link><pubDate>Fri, 31 Jan 2020 00:35:23 +0900</pubDate><guid>https://interp.blog/hugo-scss-rebuild/</guid><description>&lt;p>Tale 테마로 블로그를 처음 시작하려고 보고 있는데, 여기서 SCSS 내용을 변경해도 &lt;code>hugo server -D&lt;/code> 를 하니까 변경 내용이 적용이 되지 않았다. &lt;a class="link" href="https://gohugo.io/hugo-pipes/scss-sass/" target="_blank" rel="noopener"
>여기선&lt;/a> 잘 된다고 나와 있는데, 어떻게 해결했는지 자세히 적어본다.&lt;/p>
&lt;ul>
&lt;li>자세히 보니 이미 컴파일이 완료된 CSS 파일이 &lt;code>resources/_gen/assets/scss/scss/&lt;/code> 에 존재하고 있었다.&lt;/li>
&lt;li>설마 이것 때문인가? 삭제를 하고 다시 &lt;code>hugo server -D&lt;/code> 를 해보면 다음 문구가 반겨준다.
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">Building sites … ERROR 2020/01/31 00:27:39 Transformation failed: TOCSS: failed to transform &amp;#34;scss/tale.scss&amp;#34; (text/x-scss): this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information
Built in 16 ms
Error: Error building site: logged 1 error(s)
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>그렇다, &lt;strong>extension version 이 아닌 일반 hugo 를 설치한 것이었다!&lt;/strong> &lt;a class="link" href="https://gohugo.io/getting-started/installing" target="_blank" rel="noopener"
>Install Hugo&lt;/a> 페이지에 다시 들어가 재설치하니 잘 되었다.&lt;/p></description></item><item><title>프로세서의 우선순위 값 : nice</title><link>https://interp.blog/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EA%B0%92-nice/</link><pubDate>Thu, 28 Nov 2019 01:53:59 +0000</pubDate><guid>https://interp.blog/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EA%B0%92-nice/</guid><description>&lt;p>&lt;a class="link" href="https://docs.datafabric.hpe.com/70/ReferenceGuide/node-metrics.html?hl=cpunice" target="_blank" rel="noopener"
>MapR (현재는 HPE Data Fabric) 의 Monitoring (Node) Metric&lt;/a> 문서를 보다가, &lt;code>CPUNICE&lt;/code> 라는 컬럼 이름에 다음과 같은 설명이 있다. &lt;em>Amount of CPU time used by processes with a positive nice value.&lt;/em> 오잉, 프로세스의 CPU 사용 시간인 것 까진 알겠는데, 양(positive) 의 좋은 값이라니?&lt;/p>
&lt;p>실은, nice value가 다음과 같은 뜻이라고 한다.&lt;/p>
&lt;blockquote>
&lt;p>Nice 값은 CPU의 스케줄링 우선순위를 의미합니다. 값의 범위는 +19 ~ -20으로, &lt;strong>숫자가 높을 수록 우선 순위는 낮습니다&lt;/strong>. &lt;code>man 2 getpriority&lt;/code> 를 참고하시면, 더 자세한 정보가 나와 있습니다. 프로세스를 실행할 때 &lt;code>nice&lt;/code> 명령어로 우선 순위를 부여할 수 있고, &lt;code>renice&lt;/code> 명령어로 우선 순위를 조정할 수 있습니다. 우선 순위를 높이기 위해선, 슈퍼 유저 권한이 (root) 필요합니다. (&lt;a class="link" href="http://serverfault.com/questions/116950/what-does-nice-mean-on-cpu-utilization-graphs" target="_blank" rel="noopener"
>출처&lt;/a>)&lt;/p>
&lt;/blockquote>
&lt;p>참고로, &lt;code>getpriority()&lt;/code> 는 프로세스의 현재 우선순위를 반환하는 인터페이스 이다. &lt;code>setpriority()&lt;/code> 역시 존재하는데, 이 함수를 실행할 때 값을 낮추려면 sudoer 권한이 있어야 한다고 한다.&lt;/p></description></item><item><title>바보가 되고 있다</title><link>https://interp.blog/%EB%B0%94%EB%B3%B4%EA%B0%80-%EB%90%98%EA%B3%A0-%EC%9E%88%EB%8B%A4/</link><pubDate>Thu, 29 Aug 2019 22:41:30 +0000</pubDate><guid>https://interp.blog/%EB%B0%94%EB%B3%B4%EA%B0%80-%EB%90%98%EA%B3%A0-%EC%9E%88%EB%8B%A4/</guid><description>&lt;p>생각이 글이 되고 글이 정제된 다른 글이 되는 연계를 계속 해야 하는데. 어느 샌가 단편적인 이미지, 몇 분짜리 동영상, 흘러가는 명언에 시간을 소비하고 있는 것은 아닌지, 양심의 가책을 느낀다. 생각의 소스가 되는 것들이 저급한 것이라고 할 순 없겠지만, 그게 내 손에서 일궈진 것이 아니라서 값지지 않게 느껴진다. 유망주 투수의 현란한 로케이션이 담긴 GIF, 대중 매체를 알지 못하면 이해할 수 없는 드립, 당신을 움직이게 만들 것이라고 광고하는 몇 컷 짜리 자기계발서 요약 슬라이드들이 그런 것이다.&lt;/p>
&lt;p>이전에 내가 후배들에게 이런 말을 한 적이 있다.&lt;/p>
&lt;blockquote>
&lt;p>시장의 궁극적인 목적은 너의 돈을 소비하게 만드는 것이다. 그러려면 먼저 너의 시간을 사들이는 것에 혈안이 되어 있다. 그것이 바겐 세일, 심지어 공짜라 할 지라도. 한번 소비하기 시작하면, 너의 의지와 방향은 돈을 쓰지 않으면 안 될 지경으로 만든다. 와닿지 않는다고? 조금 완곡하게 말하자면, 조금의 불편함을 느끼게 만든다는 것이고, 마치 내가 이런 소비를 해서 내 인생에 도움이 될 것이라고 착각하게 만든다. 이전에는 없이도 잘 살았는데. 마치 욕구가 개방된 것 처럼.&lt;/p>
&lt;/blockquote>
&lt;p>사실 전혀 다른 주제 같아 보이는데, 인터넷과 유튜브는 정말이지 이런 자유시장에서 더욱 첨예하게 사람의 욕구를 개방하기 시작했다는 점에서 이어진다. 인터넷이란 것이 없었을 때, 집전화를 먹통으로 만들고 PC통신에 접속했을 때, ADSL 이 개통되었을 때, 지식인으로 모든 것을 묻고 답할 때, 싸이월드에서 일촌평을 남길 때, 그리고 지금 모든 인플루언서들과 모든 개인들이 저마다의 소리를 내며 자유시장에서 자리를 잡으려고 할 때. 시간의 흐름은 생산자와 소비자의 간격을 무너뜨리고, 정보 독점 체제를 무력화시킨 것 처럼 느껴지게 한다. 모두가 생산자이며 모두가 소비자가 되는 &lt;strong>더욱 복잡하고 현란하고 귀찮은 세상이 되었다.&lt;/strong>&lt;/p>
&lt;p>AI 와 로봇이 결합된 4차 산업혁명에 우려를 나타내는 많은 학자와 저자들이 한 목소리로 이야기하는 대안이 &amp;lsquo;&lt;span style="text-decoration: underline;">자아성찰&lt;/span>&amp;rsquo; 이라고 하는데, 나는 이게 이미 필수라고 생각한다. 나를 아는 방법 역시 쉽지 않고, 그런 걸 찾기 위한 수단으로 기술을 쓰는 것에 결코 반대하지 않는다. 하지만, 여기서 이야기하고 싶은 것은, 기술이 수단을 집어삼켜 나를 휘두르게 놔두지 말자는 것일 뿐. 그런 바보가 되지 말자.&lt;/p></description></item><item><title>Visual Studio Code Remote Deployment</title><link>https://interp.blog/visual-studio-code-remote-deployment/</link><pubDate>Wed, 26 Jun 2019 05:11:21 +0000</pubDate><guid>https://interp.blog/visual-studio-code-remote-deployment/</guid><description>&lt;p>Vim 과 SSH 에 찌들어 있었는데, 이번 Visual Studio Code 의 베타 기능인 Remote Deployment 를 연결해 보고 나서, 학생 때 쓰던 IDE 로 돌아간 것 같아 너무 좋았다. 언제까지고 구식 도구를 쓰며 부심을 부릴 수만은 없다. 설치 과정이 조금 험난했지만, 간단히 요약해서 써본다.&lt;/p>
&lt;p>클라이언트 OS 는 윈도우 10 (빌드 1809), 서버 OS 는 Cent OS 7 기준으로 작성한다.&lt;/p>
&lt;h2 id="클라이언트-윈도우-준비">클라이언트 (윈도우) 준비&lt;/h2>
&lt;p>처음에 준비할 때는 &lt;a class="link" href="https://code.visualstudio.com/insiders/" target="_blank" rel="noopener"
>Visual Studio Code Insider&lt;/a> 버전을 설치하라고 되어 있었는데, 이제는 꼭 그럴 필요 없는 것 같다. 일반 &lt;a class="link" href="https://code.visualstudio.com/Download" target="_blank" rel="noopener"
>Visual Studio Code&lt;/a> 를 설치해도 된다.&lt;/p>
&lt;p>다음으로, SSH 클라이언트를 설치한다. &lt;strong>윈도우 10 빌드 1807 이상 버전&lt;/strong>의 윈도우 OS 라면 &lt;a class="link" href="https://docs.microsoft.com/ko-kr/windows-server/administration/openssh/openssh_install_firstuse" target="_blank" rel="noopener"
>여기 링크&lt;/a> 안내를 따르거나, 아래 요약된 스크린샷을 보면 된다.&lt;/p>
&lt;p>시작 &amp;gt; 설정 앱에서, &amp;lsquo;앱&amp;rsquo; 을 클릭한 뒤 &amp;lsquo;앱 및 기능&amp;rsquo; 탭의 &amp;lsquo;선택적 기능 관리&amp;rsquo; 를 클릭한다. 그 다음 아래 &amp;lsquo;OpenSSH 클라이언트&amp;rsquo; 를 찾아 설치한다. OpenSSH 서버는 설치할 필요가 없다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/uploads/2019/06/img_5d11df55e7f29.png"
loading="lazy"
>
&lt;img src="https://interp.blog/uploads/2019/06/img_5d11df39e0722.png"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>만약에 여러분이 윈도우 10 빌드 1807 이하 버전의 윈도우 OS 라면… 조금 귀찮아진다. &lt;a class="link" href="%22https://code.visualstudio.com/docs/remote/troubleshooting#_installing-a-supported-ssh-client%22" >이 문서&lt;/a> 에 따르면, &lt;a class="link" href="%22https://git-scm.com/download/win%22" >Git for windows&lt;/a> 를 설치하면서 옵션에서 &lt;strong>Use Git and optional Unix tools from the Command Prompt &lt;/strong>를 선택하면 된다.&lt;br>
그러면, 같이 설치된 mingw 내부의 SSH 를 클라이언트로 사용한다고 한다. 물론 난 테스트해 보진 않았다! 권한 문제 등등으로 생각보다 꼬일 가능성이 있으므로, 조심해야 한다.&lt;/p>
&lt;/blockquote>
&lt;p>이제 ssh key 를 만들어야 한다. 비대칭 키에 대한 지식이 없다면 &lt;a class="link" href="https://arsviator.blogspot.com/2015/04/ssh-ssh-key.html" target="_blank" rel="noopener"
>암호 대신 SSH Key 로 인증하기&lt;/a> 포스팅을 참고하면 된다. 혹시 PuTTY 에서 생성한 비공개 키를 등록하고 쓰고 있으니 이걸로 충분하지 않을까? 그렇게 준비하면.. 실제 접속할 때 아마 잘 안 될 것이다.&lt;/p>
&lt;p>Visual Studio Code 는 OpenSSH (또는 Git 의 ssh) 클라이언트를 쓰기 때문에, Key 호환성 문제로 &amp;lsquo;invalid format&amp;rsquo; 에러를 발생시킬 수 있다. 그러니 순순히 (?) &lt;strong>실행 명령 창 (cmd) 을 열어서&lt;/strong> 다음을 입력하자. 기존에 쓰던 키 저장 경로가 존재한다면, 다른 경로로 설정하는 것을 추천한다. 이 방법은 &lt;a class="link" href="https://code.visualstudio.com/docs/remote/troubleshooting#_quick-start-ssh-key" target="_blank" rel="noopener"
>Visual Studio Code 페이지의 Troubleshooting&lt;/a> 에 등록된 내용이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">ssh-keygen -t rsa -b  &lt;span class="m">4096&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="서버-리눅스-준비">서버 (리눅스) 준비&lt;/h2>
&lt;p>원활한 서비스가 가능한 리눅스 OS 목록은 &lt;a class="link" href="https://code.visualstudio.com/docs/remote/linux" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하면 된다. Cent OS 7 은 잘 되므로 별 다른 설정 없이 가능하다. 지원이 안 되는 리눅스들은 workaround 가 있는데 (특시 Cent OS 6) 생각보다 까다롭고 원치 않는 상황이 발생할 수 있기 때문에 신중해야 한다.&lt;/p>
&lt;p>접속하고자 하는 계정의 &lt;code>~/.ssh/authorized_keys&lt;/code> 파일에다가, 아까 만들었던 Key Pair 중 &amp;lsquo;공개 키&amp;rsquo; 정보를 입력해야 한다. 해당 파일이 없으면 만들면 되고, 있으면 파일 끝에 추가 (append) 해주면 된다.&lt;/p>
&lt;p>&lt;code>~/.ssh/authorized_keys&lt;/code> 파일의 권한이 600 (계정에서만 읽기/쓰기가 가능) 인지 반드시 체크하고, 아니라면 &lt;code>chmod&lt;/code> 명령으로 바꿔주도록 한다. (이건 SSH 일반 접속 때문에 하는 작업이지, Visual Studio Code 라서 하는 것이 아니다.)&lt;/p>
&lt;h2 id="visual-studio-code-준비">Visual Studio Code 준비&lt;/h2>
&lt;p>우여곡절 끝에 준비를 다 했으면, Visual Studio Code 를 열어서 &lt;a class="link" href="https://aka.ms/vscode-remote/download/extension" target="_blank" rel="noopener"
>Remote Deployment&lt;/a> 를 설치하자. 그 다음, 명령 팔레트를 열어서 (Shift + Ctrl + P) &lt;strong>Remote-SSH: Open Configuration File…&lt;/strong> 을 선택한다. 설정 파일 경로는 수정하거나 기존에 잡아주는 경로를 쓰건 상관없다.&lt;/p>
&lt;p id="KhDFgvb">
&lt;img class="alignnone size-full wp-image-1524 " src="https://interp.blog/uploads/2019/06/img_5d12fc88e148b.png" alt="" srcset="https://interp.blog/uploads/2019/06/img_5d12fc88e148b.png 622w, https://interp.blog/uploads/2019/06/img_5d12fc88e148b-300x45.png 300w" sizes="(max-width: 622px) 100vw, 622px" />
&lt;/p>
&lt;p>예시는 이렇다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Host 192.168.0.10
HostName 192.168.0.10
User interp
IdentityFile &amp;#34;C:\Users\interp\ssh_key\id_rsa&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Host : 목록에 나올 이름이다. 보통은 HostName 과 같이 지정해주거나 Username@HostName 으로 지정한다.&lt;/li>
&lt;li>HostName : 실제 접속할 호스트 주소&lt;/li>
&lt;li>User : 접속할 사용자 계정 이름&lt;/li>
&lt;li>IdentifyFile : 생성한 Key Pair 중 &amp;lsquo;비공개 키&amp;rsquo; 경로&lt;/li>
&lt;/ul>
&lt;h2 id="remote-로-접속">Remote 로 접속!&lt;/h2>
&lt;p>이제 설정 파일을 저장하고, 명령 팔레트를 열어서 (Shift + Ctrl + P) &lt;strong>Remote-SSH: Connect to Host…&lt;/strong> 을 선택한다. 아까 저장한 Host 가 1개만 떠 있을텐데, 접속하면 아예 새로운 Visual Studio Code 창이 하나 더 뜨게 된다.&lt;/p>
&lt;p>이것저것 하는 것 같으니 잠시 기다리면, 접속이 되었다는 메시지와 함께 &amp;lsquo;절대로 저 작은 터미널을 닫지 말아주세요&amp;rsquo; 라는 경고문이 뜬다. 최소화시키고 작업을 하면 된다!&lt;/p></description></item><item><title>경력직 면접의 단상</title><link>https://interp.blog/%EA%B2%BD%EB%A0%A5%EC%A7%81-%EB%A9%B4%EC%A0%91-%EB%8B%A8%EC%83%81/</link><pubDate>Sun, 12 May 2019 12:40:26 +0000</pubDate><guid>https://interp.blog/%EA%B2%BD%EB%A0%A5%EC%A7%81-%EB%A9%B4%EC%A0%91-%EB%8B%A8%EC%83%81/</guid><description>&lt;p>처음에는 경력직을 선호했고, 나도 그랬다.&lt;/p>
&lt;p>개발자를 충원하자는 계획에 맞춰, 공고를 등록하고 경력직 이력서를 받으면서 이 정도 커리어면 뭐든지 붙을 수 있을거라고 생각했을 것이다. 하지만 그 때의 실패들이 쌓여 이제는 경력직이나 신입이나 동일 선상에 놓고 평가하고 있다.&lt;/p>
&lt;p>내가 몸 담고 있는 필드는 국내에서 잘 하지 않는 분야다. 없진 않지만, 사용자 경험과 컴퓨터 구조를 동시에 신경 써야 하는 조직이다. (물론 개발자 1인이 모두 신경 쓰는 것은 아니다.) 그런데, 소위 SI 업체나 프리랜서 개발자들의 면접을 보면 괜히 미안해진다. 면접이 매끄럽지 못해서 미안한게 아니고, 이미 그들의 표정에서 &amp;lsquo;이걸 대체 왜 물어보는 건지&amp;rsquo; 싶은 느낌이 표정에 드러나기 때문이다.&lt;/p>
&lt;p>이야기를 나눠보면, 지원자 중 절반은 말 그대로 &amp;lsquo;잘못 왔다&amp;rsquo;. 그냥 솔루션 개발 쯤으로 알고 왔는데, 열어보니 이건 이상하다 싶었겠지. 나머지 반은 본인 실력을 다 못 보여준다. 왜냐하면 전혀 새로운 분야에서 요구되는 능력들이 자기가 일궈온 것과 좀 다르니까 거부감이 드는 것이다. 그래서 나도, 그들도 같이 지친다.&lt;/p>
&lt;p>어느 대기업 연구원 관리직의 댓글을 봤다. 오히려 박사/포닥 후 입사한 친구들이 너무 협소한 시각으로 보고서를 작성하기 때문에 설득력이 떨어진다는 것이다. 자기 분야에서만 논거를 찾아서 주장하거나, 다른 분야 사람이 오펜스라도 할라 치면 &amp;lsquo;당신이 뭘 알아&amp;rsquo; 라는 스탠스를 취한 경우를 많이 봤단다. 학교에서는 비즈니스나 의사소통을 가르쳐주지 않기 때문이라고 하면서. 차라리 회사에서 신나게 구르던 동일 경력의 친구들이 더 뛰어난 경우를 많이 봐왔다고 한다.&lt;/p>
&lt;p>이 이야기를 왜 꺼냈을까. 박사과정을 마친 사람들을, 하이 커리어를 쌓으신 많은 경력 개발자를 폄훼하기 위해서인가. 아니다. 그냥, 좋은 능력을 가지신 분들이 보인 부적응 현상들이 안타까워서 그랬다. 이제는 경력과 신입을 동일선상에 놓고 보고 있다. 기술 질문도 차이가 거의 없어졌다. 다만 한 가지, 소통하는 능력이 있는지를 본다. 달리 말하면 배우고자 하는 열의가 있는지 반드시 보고 다음 면접으로 올린다.&lt;/p>
&lt;p>나는 꼬리에 꼬리를 무는 질문을 좋아한다. 그래야 이 사람의 대응 방식을 볼 수 있다. 꼬리를 물렸을 때 대개는 따가워한다. 싫은 거다. 그래도 답하고 되물어봐야 한다. 힌트를 달라고 해도 좋다. 시험이 아니라 면접인데, 좀 물어보면 어떤가. 나와 논쟁을 한 지원자도 있었다. 내용이 좀 틀려도 괜찮았다. 둘 모두 기술면접을 통과했다.&lt;/p>
&lt;p>비즈니스는, 의사소통은 학교에서 가르쳐주지 않는다. 그런데… 경력은 이미 경험한 것들이다. 경력을 뽑는 가장 큰 이유는, 적응력이 신입보다 좋을 거라 기대하기 때문이다. 그것이 기술적이건 의사소통 능력이건 간에 말이다. 둘 다 못하면, 지금처럼 동일 선상에 세울 수 밖에 없을 것이다.&lt;/p>
&lt;p>최소한  자신이 가진 아집 정도는 벗어주면 좋겠다. 그래야 저런 소리 안 듣고 귀한 평가를 받을 것이다.&lt;/p></description></item><item><title>리더의 1원칙</title><link>https://interp.blog/%EB%A6%AC%EB%8D%94%EC%9D%98-1%EC%9B%90%EC%B9%99/</link><pubDate>Thu, 09 May 2019 06:29:40 +0000</pubDate><guid>https://interp.blog/%EB%A6%AC%EB%8D%94%EC%9D%98-1%EC%9B%90%EC%B9%99/</guid><description>&lt;p>메모로 남긴다.&lt;/p>
&lt;ul>
&lt;li>사람은 모두 다르다. 아주 많이.&lt;/li>
&lt;li>각자의 장점이 드러나도록 경험하게 해주고 발전하게 하라. 그리고, 장점과 그 성과를 열심히 칭찬해줘라.&lt;/li>
&lt;li>&lt;strong>무언가를 잘하는 사람은 결국 그걸 좋아하게 되어 있다.&lt;/strong>&lt;/li>
&lt;li>무언가를 잘하고 좋아하게 되면, 자신의 자존감이 올라간다.&lt;/li>
&lt;li>자존감이 올라간 후엔, 자존감을 지키지 위해서 알아서 움직인다.&lt;/li>
&lt;/ul>
&lt;p>이 말을 관통하는 TODO 는 딱 하나. &lt;strong>장점이 드러나도록 밀어주고, 칭찬해줘라.&lt;/strong>&lt;/p>
&lt;p>철칙처럼 지켜야 한다는 생각이 들었다. 여기에 내 생각을 덧붙인다.&lt;/p>
&lt;ul>
&lt;li>뭘 잘하는지 찾는 건 굉장히 어렵다. 잘 한다고 생각했는데 통수맞을 확률이 생각보다 높다.&lt;/li>
&lt;li>잘 하는데 하기 싫어하는 경우에 대한 과정도 중요하다.&lt;/li>
&lt;li>일이란게 늘 그렇듯, 그 사람이 잘 하는 것만 시킬 수 없다. 이에 대한 과정 역시 중요하다.&lt;/li>
&lt;li>사람이 늘 그렇듯, 단점이 크게 보인다. 못 본 척 하려고 노력하는 것도 쉽지 않을 정도로.&lt;/li>
&lt;/ul>
&lt;p>결론은, 이 철칙을 쉽게 지킬 수 없지만 지키기 위해 노력해야 된다는 것.&lt;/p>
&lt;p>참고로, 이 원칙은 육아에도 적용된다고 한다. 덧붙인 내 생각도 육아에 적용되겠단 생각을 해 본다.&lt;/p></description></item><item><title>공측도와 무리수</title><link>https://interp.blog/%EA%B3%B5%EC%B8%A1%EB%8F%84%EC%99%80-%EB%AC%B4%EB%A6%AC%EC%88%98/</link><pubDate>Sat, 27 Apr 2019 11:32:38 +0000</pubDate><guid>https://interp.blog/%EA%B3%B5%EC%B8%A1%EB%8F%84%EC%99%80-%EB%AC%B4%EB%A6%AC%EC%88%98/</guid><description>&lt;p>&amp;lsquo;알고리즘 산책&amp;rsquo; 책 요약이다. 공측도라는 개념이나, 귀류법을 사용한 증명 등의 내용을 까먹지 않으려고 정리한다. 물론 이미 다 어릴 적 배웠겠지만, 다시 공부한다는 마음으로 정리하는 것이다.&lt;/p>
&lt;p>최대공측도는 최대공약수 같은 개념이다. 선분 A와 B가 특정한 길이로 측정이 가능할 때, 이 길이 중 가장 긴 길이를 최대공측도라고 하는 것이다. 이 값을 코딩으로 구하려면, 최대공약수를 계산하는 방법과 다르지 않을 것이다. (여기서 공측도 값이 되는 선분 길이는 자연수여야 한다.)&lt;/p>
&lt;p>그런데 19세기 조지 크리스털이 증명한 것은, 정사각형의 변과 대각선의 변을 동시에 측정할 수 있는 선분은 &lt;strong>없다&lt;/strong>는 것이다. 왜일까? (다시 말하지만 공측도는 자연수이다.)&lt;/p>
&lt;p>귀류법을 통해, 정사각형의 변과 대각선의 변을 동시에 측정할 수 있는 선분이 있다고 가정해보자. 요약하자면, 이 선분으로 정사각형을 그리고, 또 그 정사각형에서 한 변과 대각선을 측정할 수 있는 선분 (공측도) 이 있고, 계속 이런 식으로 정사각형을 그려나가다 보면, 어느 순간 &lt;span style="text-decoration: underline;">가장 작은 정사각형&lt;/span>이 나올 것이다. 하지만 가정에 따르면, 이 경우에도 대각선과 공측도가 되는 선분이 존재할 수 있게 된다. 그렇다면 더 작은 정사각형을 그릴 수 있게 되므로 모순이 생긴다.&lt;/p>
&lt;p>그래서 대각선은 자연수가 아니라는 단서가 되었고, 이로 인해 무리수 $\sqrt{2}$ 를 발견할 수 있게 되었다고 한다.&lt;/p></description></item><item><title>예쁜 낙서장을 원했던 걸까</title><link>https://interp.blog/%EC%98%88%EC%81%9C-%EB%82%99%EC%84%9C%EC%9E%A5%EC%9D%84-%EC%9B%90%ED%96%88%EB%8D%98-%EA%B1%B8%EA%B9%8C/</link><pubDate>Tue, 23 Apr 2019 21:46:13 +0000</pubDate><guid>https://interp.blog/%EC%98%88%EC%81%9C-%EB%82%99%EC%84%9C%EC%9E%A5%EC%9D%84-%EC%9B%90%ED%96%88%EB%8D%98-%EA%B1%B8%EA%B9%8C/</guid><description>&lt;p>정갈한 한정식도 아니고, 욕쟁이 할머니가 내어 주는 재미있는 맛이 담긴 한 끼도 아니고, 그냥 쓱쓱 싹싹 콩나물과 보리밥에 눈물 참기름 한 방울, 매운 인생 맛 큰 숟갈 넣어 아구와구 비벼먹을 건데. 일기장은 이뻐봤자 나만 만족하는 것이다. 그런데 난 그게 중요하다고 보거든.&lt;/p>
&lt;p>개인적인 이야기와 바깥의 이야기를 구분했으면 해서 만든 것이 블로그였는데, 이제는 그 경계가 모호해진 것 같다. 그 외줄타기를 잘 해야 내 아이덴티티가 쇼윈도에 걸리는 것이긴 하지만, 난 양산형 마네킹이 아니니까 으레 생각하는 사람들과는 다른 기괴한 포즈를 취할 수 있다. 혐오감을 줄 수도 있고, 저놈 저거 노력하네 같은 행인들의 빈말 몇 마디 정도는 듣겠지.&lt;/p>
&lt;p>어릴 적에 그림을 그리거나 글을 쓰면 반 친구들 몇몇이 우루루 와선 돌려보곤 했다. 별 것 없는 내용, 뻔한 전개지만 내 나름 가장 활발한 리뷰어 (Reviewer) 들이었노라고 자부할 수 있다. 칭찬과 비난이 뚜렷이 섞인 말들은 이내 비난도 지쳐버린 자들의 과거속으로 숨어버렸다. 나도 그랬으니까. 그리고 내 글도 숨었다.&lt;/p>
&lt;p>숨기 싫어서 나온건데, 아직도 예쁜 일기장을 고르려 핫트랙스를 기웃거리는 중학생의 심정에서 벗어나질 못했다. 플랫폼은 뭘 하지? NAS 를 사서 내 개인 서버를 꾸며볼까? 책을 읽으려면 아이패드를 사야지? (글 쓰는데 왜 갑자기 아이패드야) 정신을 차려보니, 고민은 목적을 한참 벗어나서 멋대로 날뛰고 있었다.&lt;/p>
&lt;p>이제 이런 고민 다 필요가 없다. 묵묵히 쓰는게 짱이다. 예쁜 낙서장은 이제 그만 골라야겠다.&lt;/p></description></item><item><title>더욱 오늘을 의미있게 살자</title><link>https://interp.blog/%EB%8D%94%EC%9A%B1-%EC%98%A4%EB%8A%98%EC%9D%84-%EC%9D%98%EB%AF%B8%EC%9E%88%EA%B2%8C-%EC%82%B4%EC%9E%90/</link><pubDate>Thu, 18 Apr 2019 01:33:12 +0000</pubDate><guid>https://interp.blog/%EB%8D%94%EC%9A%B1-%EC%98%A4%EB%8A%98%EC%9D%84-%EC%9D%98%EB%AF%B8%EC%9E%88%EA%B2%8C-%EC%82%B4%EC%9E%90/</guid><description>&lt;img src="https://interp.blog/uploads/flying_bg.jpg" alt="Featured image of post 더욱 오늘을 의미있게 살자" />&lt;p>좌우명이 뭐냐고 물으신다면, 곁에 두고 보는 말 같은 진부한 설명 대신에 &amp;lsquo;예상치 못한 상황에서 생각이나 행동의 근거가 되는 첫 번째 기준이나 신념을 말로 표현한 것&amp;rsquo; 이라고 하고 싶다. 우리는 모든 상황을 가정하고 살 수도 없고, 모든 것을 경험하며 살 수도 없다. 모든 것이라는 집합 자체가 유한하지 않은 것이 첫번째고, 우리의 생 또한 무한하지 않은 것이 그 다음이다.&lt;/p>
&lt;p>그래서 내 좌우명은 무어냐고 또 물으신다면, 조금 생각을 해 봐야겠다. 내 초등학교 시절은 으레 다른 친구들이 그랬듯 위인전에서 나온 명언 중 마음에 드는 하나를 골라 좌우명이라고 정하고 다녔기 때문에, 당시 내 좌우명도 &amp;lsquo;시간을 금 같이 보라&amp;rsquo; 였다. 어, 이거 최영 장군은 조금 다르게 이야기한 것 같은데, 아무튼 난 이게 마음에 들었다. 시간은 소중히 써야 한다. 지나간 시간은 저축할 수 없기 때문에 매 순간 의미가 있어야 한다고 생각했나보다. 일기를 읽어보면 그런 것 같다.&lt;/p>
&lt;p>어린 시절의 어떤 치기로 선택받은 이 좌우명에 기름칠을 조금 해서, 지금의 내 좌우명을 정해본다. &amp;lsquo;더욱 오늘을 의미있게 살자&amp;rsquo;. 너무 달라졌는데? 하지만 의미는 확실히 살았다고 말하고 싶다. 시간이라는 단어는 단위로 설명할 수 없는 추상화된 개념이다. 시간을 소중히 써야 한다면, 특정 시간 단위를 집중해서 살자고 말하는게 더 설득력있어 보였다. 매 초 열심히 살자? 그렇다면 이미 성공한 횟수보다 실패한 횟수가 더 많다. 좌절 느끼기 딱 좋은 말이구만. 단위를 넓게 잡아 &amp;lsquo;하루&amp;rsquo; 라고 지었다.&lt;/p>
&lt;p>그냥 의미있게 살면 되지, 더욱은 뭘까. &amp;lsquo;어제의 나&amp;rsquo;를 통해 반성하고 칭찬하면서 &amp;lsquo;오늘의 나&amp;rsquo;를 더 의미있게 살게 할 수는 없을까? 하는 뜻이다. 이 말 대로 엄밀히 구분하자면, 어제와 오늘은 연속성이 없다. 하지만 인생이라는 끈 위에서는 모두 이어져있으니까. 그 위에서 줄타기를 해야 한다면 어제의 내가 했던 의미를 발전시켜 갈 수도 있고 잘못된 방향을 바로 잡아 앞으로 나아갈 수 있지 않을까.&lt;/p>
&lt;p>뜬금없지만, 영화 &amp;lsquo;아저씨&amp;rsquo; 에서 차태식 대사 중 유명한 것이 있다. &amp;lsquo;너흰 내일만 보고 살지.. 난 오늘만 보고 살아..&amp;rsquo; (뒷 말은 욕이니까 생략하고) 내일을 보고 사는 것은 오늘을 희생해서 내일의 불확실한 나에게 짐을 덜어주는 의미도 되겠지만, 오늘을 소비하고 내일의 나에게 책임을 떠넘긴다는 이중적인 의미로도 해석할 수 있다. 나는 둘 다 마음에 들지 않는다. 오늘의 내가 내일의 나에게 방향을 제시하고 이뤄놓은 것에 대한 설명은 해 줄 수 있겠지만, (계획에 없는데 의도적으로) 내일 해야 할 일을 오늘 몰아 하는게 과연 맞는가? 신용 카드를 긁으면서 내일의 내가 좌절해 줄 거라고 충동적으로 결정하는 게 과연 맞는가 말이다.&lt;/p>
&lt;p>그래서, 미래의 내가 덜 부끄럽게 과거의 내가 제시한 방향이 헛되지 않게 오늘은 의미있게 살아야 한다. 그 의미가 뭐냐? 글쎄, 그건 매일 달라질 수 있겠다. 위기를 극복하고, 성취를 만끽하고, 사고에 대처하고, 기쁠 때 기쁘고 슬플 때 슬퍼하고…&lt;/p>
&lt;p>물론 의미없는 날을 보낼 수도 있다. 내 의지와 다르게 흘러가는 날이 있을 것이고, 아니 오히려 그런 날들이 한 해에 더 많이 일어날 것이다. 그래도 지켜야 하는 것은, 그렇지 않은 날까지 내 의지와 무관하게 흘러가는 것 처럼 간주해서는 안 되는 소중한 시간들이기 때문이다. 지금 이 시간도 그렇다.&lt;/p>
&lt;p> &lt;/p>
&lt;p>덧. 이걸 하려면 반드시 해야 할 일이 있다. &lt;strong>일기를 써야 한다.&lt;/strong> 무슨 내용이든 좋지만, 칭찬 6에 반성 3, 감상 1 정도의 비율로 적어주면 가장 좋다. 기분에 따라 감상 10이 될 수도 반성 10이 될 수도 있지만 너무 한 쪽으로 치우쳐 적으면 나중에 읽을 때 좀 오글거리고 읽기 싫어진다.&lt;/p></description></item><item><title>Windows SSH RSA Key 문제 해결</title><link>https://interp.blog/windows-ssh-rsa-key-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/</link><pubDate>Mon, 18 Mar 2019 04:50:30 +0000</pubDate><guid>https://interp.blog/windows-ssh-rsa-key-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/</guid><description>&lt;img src="https://interp.blog/images/featured/ssh-rsa.jpg" alt="Featured image of post Windows SSH RSA Key 문제 해결" />&lt;p>Windows Server 2016에서 OpenSSH 를 설치하고, cmd 에서 다음과 같이 RSA 키를 생성한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ ssh-keygen -t rsa
&lt;/code>&lt;/pre>&lt;/div>&lt;p>그러고 Public Key 를 SSH Server 에 위치한 authorized_keys 파일에 추가하고 접속을 시도하면?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: UNPROTECTED PRIVATE KEY FILE! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Permissions &lt;span class="k">for&lt;/span> &lt;span class="s1">&amp;#39;C:\\Users\\interp/.ssh/id_rsa&amp;#39;&lt;/span> are too open.
It is required that your private key files are NOT accessible by others.
This private key will be ignored.
Load key &lt;span class="s2">&amp;#34;C:\\Users\\interp/.ssh/id_rsa&amp;#34;&lt;/span>: bad permissions
interp@192.168.0.30&lt;span class="err">&amp;#39;&lt;/span>s password:
&lt;/code>&lt;/pre>&lt;/div>&lt;p>오잉? 내 파일이 맞는데 이게 뭘까. Private Key 파일에 마우스 우클릭을 하고 봤더니 여러 사용자가 읽기 권한으로 걸려 있는 것을 확인할 수 있었다. 이건 아니다… 등록된 사용자를 전부 지우고 현재 사용자에게 모든 권한을 준 다음에, 확인을 눌러 권한 변경을 해 준다.&lt;/p>
&lt;p id="euLmFtS">
&lt;img class="alignnone size-full wp-image-1518 " src="https://interp.blog/uploads/2019/06/img_5d11dcea1b41a.png" alt="" srcset="https://interp.blog/uploads/2019/06/img_5d11dcea1b41a.png 421w, https://interp.blog/uploads/2019/06/img_5d11dcea1b41a-218x300.png 218w" sizes="(max-width: 421px) 100vw, 421px" />
&lt;/p>
&lt;p>&amp;lsquo;편집&amp;rsquo; 에 가서 등록된 사용자를 지우려고 하면, 상속으로 인해 지울 수 없다는 괴상한 에러가 뜰 것이다. 그러니까 위 화면에서 &amp;lsquo;고급&amp;rsquo; 으로 간 다음, 아래 캡처에 있는 &amp;lsquo;상속 사용 안 함&amp;rsquo; 을 클릭하면 자동으로 지워진다. 그 다음 시도하면, 잘 된다!&lt;/p>
&lt;p id="bzFxOJb">
&lt;img class="alignnone size-full wp-image-1519 " src="https://interp.blog/uploads/2019/06/img_5d11dd707fe99.png" alt="" srcset="https://interp.blog/uploads/2019/06/img_5d11dd707fe99.png 293w, https://interp.blog/uploads/2019/06/img_5d11dd707fe99-216x300.png 216w" sizes="(max-width: 293px) 100vw, 293px" />
&lt;/p>
&lt;p>출처 : https://superuser.com/questions/1296024/windows-ssh-permissions-for-private-key-are-too-open&lt;/p></description></item><item><title>우리의 이상적인 순간</title><link>https://interp.blog/%EC%9A%B0%EB%A6%AC%EC%9D%98-%EC%9D%B4%EC%83%81%EC%A0%81%EC%9D%B8-%EC%88%9C%EA%B0%84/</link><pubDate>Mon, 11 Feb 2019 06:44:30 +0000</pubDate><guid>https://interp.blog/%EC%9A%B0%EB%A6%AC%EC%9D%98-%EC%9D%B4%EC%83%81%EC%A0%81%EC%9D%B8-%EC%88%9C%EA%B0%84/</guid><description>&lt;p>햇살이 드리우는 책상 앞에 따뜻한 아메리카노 한 잔을 두고, 논문을 집어들어 책갈피 너머의 페이지로 넘겨 보는 나 자신을 상상하는 모습을 그려본 적이 있다. 학창 시절 때는, 집중해서 공부하는 지금 이 순간의 내 모습을 내가 본다면 어떤 기분일지 상상한 적도 있다. 그러면 이내 흐트러지고, 방금 전 몰두하던 이는 찾아볼 수 없게 되었다.&lt;/p>
&lt;p>자신이 그리는 이상을 직접 행하고 있을 때는, 그 상황을 자신이 그려왔던 것인지 알 수 없는 경우가 많다. 왜냐하면, 실제로는 그 장면이 아름답거나 만족하는 순간이 될 수 없기 때문이다. 바로 이런 장면을 보려고 하는 나 자신이 잠시 사라지는 순간이다. 숙제를 하거나, 일을 하거나, 연습을 하거나, 게임을 하거나, 그 장면 자체는 멋져보일 수 있겠지만 그 속에 있는 정신은 이루 말할 수 없는 수 많은 것들에 신경을 쓴다. 그것들은, 안에 들어있는 것들은 결코 아름답거나 원한 것이 아니다. 물론 이 과정, 이 결과를 상상하는 사람이 돌리는 쳇바퀴일 수 있다. 하지만 이 순간을 바라보는 사람은 동시에 존재하지 않는다.&lt;/p>
&lt;p>알아차리게 되더라도, 그 순간의 심적 평화는 깨지기 마련이다. 마치 유체이탈이라도 한 양, 관찰자로 빠져나간 빈 껍데기 같은 정신은 그 순간을 유지할 힘을 잃어버린다.&lt;/p>
&lt;p>우리는 사실 뒹굴거리고 싶고, 닥치는 대로 먹고 마시고 싶다. 그러나 우리가 계속 &amp;lsquo;우리의 이상적인 순간&amp;rsquo;을 그려야 하는 이유는, 객관화라고 착각하지만 사실 사회에서 배워 온 &amp;lsquo;편견&amp;rsquo; 속에서 우리를 가두고자 하는 희미한 의지 때문이다. 그 편견의 이미지를 지키는 이유는, 바로 주위 사람들 때문이다. 내 시선이 아닌 다른 시선에 의존한다. 왜? 우리는 언제나 외롭기 때문이다.&lt;/p>
&lt;p>외로움을 선택한 사람들이 있다. 햇살도 없는 바로 그 곳에서.&lt;/p></description></item><item><title>나쁜 건 당연한게 아니다</title><link>https://interp.blog/%EB%82%98%EC%81%9C-%EA%B1%B4-%EB%8B%B9%EC%97%B0%ED%95%9C%EA%B2%8C-%EC%95%84%EB%8B%88%EB%8B%A4/</link><pubDate>Thu, 15 Nov 2018 04:15:23 +0000</pubDate><guid>https://interp.blog/%EB%82%98%EC%81%9C-%EA%B1%B4-%EB%8B%B9%EC%97%B0%ED%95%9C%EA%B2%8C-%EC%95%84%EB%8B%88%EB%8B%A4/</guid><description>&lt;blockquote>
&lt;p>The world will not be destroyed by those who do evil but by those who watch and do nothing.
세상은 악당들 때문에 망하는 게 아니라, 악한을 보고도 아무것도 하지 않는 자들 때문에 망한다.&lt;/p>
&lt;p>– Albert Einstein&lt;/p>
&lt;/blockquote>
&lt;p>이 말을 선거철에 쓰면 투표를 독려하는 것이고, 경찰서 앞에 붙어있으면 투철한 신고정신을 고취시키는 것이다. 책상 앞에 붙인다면 어떻게 될까. 나쁜 습관이나 언행, 과오를 그냥 보고 넘기면 내가 망한다. The life will not be destroyed by wrong things I did but  by me who watch and do nothing afterward.&lt;/p>
&lt;p>이게 내 천성이고 고치기 힘든 것이라서 쉽게 포기하는 것이다. 악당은 원래 더 똑똑하고 힘 세다. 하지만 우리는 힘을 모아서 신고도 하고 투표도 한다. 그 과정이 하루 아침에 이뤄지지도 않는다. 뜻을 모으고, 힘을 모으고, 계획을 세운다. 결과가 잘 안될 수도 있다. 하지만 노력한다. 만약 성공하면, 통제 불가능해 보였던 악한이 사라지고 평화를 맞을 수 있다는 그 기대감으로.&lt;/p>
&lt;p>인생도 마찬가지다. 끊임없이 나와 투쟁해야 한다. 사실 힘든 것도 잘 안다. 하지만 우리는 기대한다. 통제 불가능한 내 약점이 사라지고 좀 더 멋진, 그리고 더 나은 인간으로서 인정받으면서, 나에게도 다음 과업을 처리할 수 있는 시간을 주는 것.&lt;/p>
&lt;p>이 스트레스는 필연적으로 부여받은 하나의 업보일 뿐이다. 피하려 하면 할수록 절대로 피할 수 없다는 사실을 깨닫게 될 것이다. 가만히 지켜보고 아무것도 하지 않는 자는 인생을 망친다.&lt;/p></description></item><item><title>Gitlab merge request 옵션 기본으로 두기</title><link>https://interp.blog/set-gitlab-merge-request-checked/</link><pubDate>Tue, 13 Nov 2018 05:03:22 +0000</pubDate><guid>https://interp.blog/set-gitlab-merge-request-checked/</guid><description>&lt;p>Gitlab Community 에서 필요로 하는 기능인데, 이렇게 수동으로 할 수 있어서 간단히 남긴다. Gitlab 에 있는 merge request 에 보면 다음 옵션이 있는데, 전부 체크가 해제되어 있다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/uploads/2018/11/%ec%a0%9c%eb%aa%a9-%ec%97%86%ec%9d%8c.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>Merge Request 에 성공한 Source Branch 를 삭제&lt;/li>
&lt;li>Merge Request 할 때 Commit 을 하나로 뭉쳐서 Merge (=Squash Merge)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>이 체크박스를 개발자가 일일해 해 줘야 하는 문제&lt;/strong>가 있다. 그래서 어떤 개발자는 체크하는 것을 까먹었다가 master branch 의 commit tree 를 엉망으로 만들기도 한다. 이 문제를 그냥 없애기 위해, 체크박스 표시를 그대로 두도록 하면 어떨까 고민하던 차에, 해결방법을 알아냈다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>/opt/gitlab/embedded/service/gitlab-rails/app/views/shared/issuable/form/_merge_params.html.haml&lt;/code> 을 편집기로 연다.&lt;/li>
&lt;li>&lt;code>check_box_tag&lt;/code> 항목으로 시작하는 줄이 &lt;span style="text-decoration: underline;">두 군데&lt;/span> 있는데, 아래와 같이 다음 내용을 &amp;lsquo;추가&amp;rsquo; 한다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">= check_box_tag &amp;#39;merge_request[force_remove_source_branch]&amp;#39;, &amp;#39;1&amp;#39;, issuable.force_remove_source_branch?, class: &amp;#39;form-check-input&amp;#39;&amp;lt;span style=&amp;#34;color: #ff0000;&amp;#34;&amp;gt;, checked: &amp;#39;checked&amp;#39;&amp;lt;/span&amp;gt;
&amp;lt;span style=&amp;#34;color: #0000ff;&amp;#34;&amp;gt;# ... blahblah&amp;lt;/span&amp;gt;
= check_box_tag &amp;#39;merge_request[squash]&amp;#39;, &amp;#39;1&amp;#39;, issuable.squash, class: &amp;#39;form-check-input&amp;#39;&amp;lt;span style=&amp;#34;color: #ff0000;&amp;#34;&amp;gt;, checked: &amp;#39;checked&amp;#39;&amp;lt;/span&amp;gt;```
&lt;/code>&lt;/pre>&lt;/div>&lt;p>다 했다면 &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 로 Gitlab 서버를 재시작한다.&lt;/p></description></item><item><title>무더운 낮과 밤</title><link>https://interp.blog/%EB%AC%B4%EB%8D%94%EC%9A%B4-%EB%82%AE%EA%B3%BC-%EB%B0%A4/</link><pubDate>Wed, 15 Aug 2018 04:06:31 +0000</pubDate><guid>https://interp.blog/%EB%AC%B4%EB%8D%94%EC%9A%B4-%EB%82%AE%EA%B3%BC-%EB%B0%A4/</guid><description>&lt;p>무더위가 찾아온 일상, 낮과 밤의 하늘은 여전히 아름답다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/uploads/2018/08/20180730_125354.jpg"
loading="lazy"
alt="Daylight"
>
낮 / 구로디지털단지&lt;/p>
&lt;p>&lt;img src="https://interp.blog/uploads/2018/08/20180730_215032.jpg"
loading="lazy"
alt="Night"
>
밤 / 온수역&lt;/p></description></item><item><title>Powerpoint 에서 방향키 이동이 너무 느릴 때</title><link>https://interp.blog/powerpoint-shape-move-faster/</link><pubDate>Sun, 12 Aug 2018 06:53:39 +0000</pubDate><guid>https://interp.blog/powerpoint-shape-move-faster/</guid><description>&lt;p>객체를 움직일 때 방향키로 이동하면, 예전에는 한 칸씩 움직이는 것 처럼 느껴졌는데 최근에 들어서는 정말 1픽셀 만큼만 이동해서 귀찮음을 유발하곤 한다. 이렇게 답답하게 움직이는 걸 되돌리기 위한 해결 방법이다. 별 건 없지만&amp;hellip;&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="https://interp.blog/images/2018-02-12-powerpoint-shape-move-faster/screen1.jpg#center"/>
&lt;/figure>
&lt;ol>
&lt;li>보기 탭으로&lt;/li>
&lt;li>표시 항목에서 &amp;lsquo;확장 아이콘&amp;rsquo;이 아주 작게 보인다.&lt;/li>
&lt;li>&amp;lsquo;눈금 및 안내선&amp;rsquo; 이란 제목의 창이 뜨며, 여기서 &amp;lsquo;개체를 눈금에 맞춰 이동&amp;rsquo; 을 클릭한다.&lt;/li>
&lt;/ol>
&lt;p>끝이다. 참고로 개체 이동 간격을 제어하려면 (3) 번에서 눈금 간격을 조정하면 된다!&lt;/p></description></item><item><title>고요한 마음에 조약돌 하나</title><link>https://interp.blog/%EA%B3%A0%EC%9A%94%ED%95%9C-%EB%A7%88%EC%9D%8C%EC%97%90-%EC%A1%B0%EC%95%BD%EB%8F%8C-%ED%95%98%EB%82%98/</link><pubDate>Mon, 16 Jul 2018 02:46:58 +0000</pubDate><guid>https://interp.blog/%EA%B3%A0%EC%9A%94%ED%95%9C-%EB%A7%88%EC%9D%8C%EC%97%90-%EC%A1%B0%EC%95%BD%EB%8F%8C-%ED%95%98%EB%82%98/</guid><description>&lt;img src="https://interp.blog/uploads/2018/07/lake.jpg" alt="Featured image of post 고요한 마음에 조약돌 하나" />&lt;p>고요한 호숫가에 조약돌을 던지면, 주위에서 파장이 일어나지만 이내 움직이지 않는 수심 속으로 들어간다. 작은 물웅덩이에 조약돌을 던지면, 존재를 잃어버릴 만큼 가지고 있던 흙탕물을 사방으로 튀겨낸다. 물웅덩이의 입장에서는 날아오는 돌의 의미를 알 수 없다. 자신의 존재가 부정당하기 직전인데 그럴 여유가 없을 것이다. 하지만 호수는 여유가 있다. 일단 의미를 파악하는데 약간의 시간이 걸리긴 하겠지만, 어느샌가 돌을 받아주고는 깊숙한 어딘가에 넣어둔다.&lt;/p>
&lt;p>자신에게 잔소리하지 않았으면 하는 태도로 일관하는 사람이 있다. 필요한 커뮤니케이션도 잔소리로 받아서 문제다. 마치 그 지적을 받아들면 자신의 과업이 부정당하는 것 처럼. 그냥 문제가 있으면 그런가보다 하고 받아들이면 되고, 오해하고 있다면 해명해주면 된다. 그게 전부다. 화내고, 우울해하고, 보복할 준비를 하는 등의 불필요한 행동은 에너지 낭비다.&lt;/p>
&lt;p>조직 생활에서는 하나의 목표를 위해 지적도 당하고 지적도 하며 살아야 한다. 동상이몽라고 할 만큼 사람은 생각하는 바가 전혀 다르다. 그 사이를 메꾸기 위한 고통스런 의사소통은 피할 수 없다. 예민하게 굴거나, 아예 기만하는 행동은 의사소통에 도움이 되지 않는다. 지적을 받을 때는 최대한 고요하게, 필요한 대응만 하고 묻어두는 것이 차라리 좋다.&lt;/p></description></item><item><title>돌이킬 수 없는 약속</title><link>https://interp.blog/%EB%8F%8C%EC%9D%B4%ED%82%AC-%EC%88%98-%EC%97%86%EB%8A%94-%EC%95%BD%EC%86%8D/</link><pubDate>Sat, 14 Jul 2018 15:16:15 +0000</pubDate><guid>https://interp.blog/%EB%8F%8C%EC%9D%B4%ED%82%AC-%EC%88%98-%EC%97%86%EB%8A%94-%EC%95%BD%EC%86%8D/</guid><description>&lt;img src="https://interp.blog/uploads/inevitablepromise.jpg" alt="Featured image of post 돌이킬 수 없는 약속" />&lt;p>이 책은, 접근부터 굉장히 쉬웠다. 리디북스&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>에서 무료 대여 기간이 있었고, 동시에 많은 북 큐레이션 페이지에서 이 줄거리를 카드 뉴스나 동영상&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>으로 홍보했기 때문이다. 그리고 줄거리가 충분히 구미가 당길 만한 내용이었다. 과거를 버리고 평범한 삶을 살아가는 남자에게 들이닥친 불행한 과거로부터의 편지 한 통. 악한을 죽여달라는 그 때의 약속을 반드시 지켜달라는 내용이란다. 이 남자의 과거는? 편지의 발신인은? 궁금한 나머지 빠르게 읽어내려갔다.&lt;/p>
&lt;h2 id="줄거리">줄거리&lt;/h2>
&lt;p>도입부는 주인공의 평범한 일상을 소개한다. 레스토랑과 바를 겸하는 식당의 공동 창업자이자 바텐더로, 사랑하는 아내와 초등학교를 다니는 귀여운 딸을 둔 가장으로. 하지만 그는 어두운 과거를 꽁꽁 숨겨둔 채 살아간다.&lt;/p>
&lt;p>그는 사실 &lt;strong>얼굴에 다 드러날 정도의 큰 멍을 가진 사내&lt;/strong>로, 어릴적 멸시와 동정을 이기지 못하고 강도짓을 일삼는다. 그러다 시비가 붙어 야쿠자에게 쫓기는 신세가 되었고, 그 와중에 한 노인을 만난다.&lt;/p>
&lt;p>노인은, 자신의 딸이 파렴치한 두 남성에게 납치되어 겁탈당한 뒤 살해당했다고 한다. 그런데 그 두 피의자에게 사형 선고가 아닌 15년형이 내려진 것에 분노하며, 자신은 이제 기력이 다 했으니 &lt;span style="color: #0000ff;">원하는 대로 돈을 받고 두 사람을 죽여달라는 약속을 하나 해줄 수 없겠느냐고 한다. 주인공은 심하게 갈등하지만, 야쿠자에게 붙잡혀 송장이 되기 싫었던 주인공은 &amp;lsquo;지키지 않아도 될 약속&amp;rsquo; 쯤으로 생각하고 약속을 한 뒤 돈을 받는다.&lt;/p>
&lt;p>그 뒤 성형수술과 무연고자의 호적을 통해, 가족이 생기고 전혀 다른 삶을 이어나가고 있었는데&amp;hellip; 15년 후 집으로 편지 한 통. 바로 &lt;strong>그들이 출소했다는 소식.&lt;/strong> 약속을 지키지 않으면 가족을 해치고 똑같은 고통을 느끼게 해주겠다고 협박한다. 주인공은 어떻게 해야 할까.&lt;/p>
&lt;h2 id="복선-회수">복선 회수&lt;/h2>
&lt;p>드라마를 즐겨 본다면, 책에서 다발성 &lt;strong>복선&lt;/strong>을 느낄 수 있다. 이런 장면들은 자체로는 별 의미가 없거나 생뚱맞은 장면들이 많지만, 전개 과정에서 이 숨겨둔 힘이 마치 콤보처럼 터진다. &lt;em>아니 왜 갑자기 생판 남의 자식과 남자 주인공을 오버랩 시키지?  남자가 사귀자는데 여자의 저 오묘한 표정은 뭐지?&lt;/em>&lt;/p>
&lt;p>&lt;strong>그런데 역으로, 누가 봐도 복선같이 보이는 장면들이 사실은 아무런 의미없는 장면이 되는 경우가 간혹 있다.&lt;/strong> 메인 커플을 훼방놓기 위해 유학길에서 돌아온 남자 주인공의 소꿉동생이, 질투 몇 번 하더니만 둘 사이를 축하해주는 들러리로 전락한다든지.&lt;/p>
&lt;p>아무튼, 이 책은 복선 회수라는 점에선 소홀히 하려 들진 않는다. 결말에 도착하면 뭔가 &amp;lsquo;아, 잠깐만. 그래서 그때?!&amp;rsquo; 라는 느낌표가 계속 뜬다. 아쉬운 것은,  갑자기 이 모든 원흉이 된 &lt;span style="text-decoration: underline;">숨겨진 과거사를 드러내는 시점이 갑작스럽다&lt;/span>는 것이다. 마치 (작가는 절대 그렇게 쓰지 않았겠지만) &lt;strong>&amp;lsquo;자, 이 사건으로 내가 결말을 다 설명할건데, 사실은 앞에 뿌려둔 복선을 회수하고 싶어서 ㅎㅎ&amp;rsquo;&lt;/strong> 라고 하는 것 같았다.&lt;/p>
&lt;h2 id="몰입도">몰입도&lt;/h2>
&lt;p>그렇다고 이게 &amp;lsquo;결말을 이끄는 힘이 부족하다&amp;rsquo; 라고는 할 수 없다. 다음 내용이 사실 궁금해질 수 밖에 없도록 만들었으니까.&lt;/p>
&lt;p>주인공은 편지를 받고 편지의 발신인을 찾기 위해 (밤에 일을 하니까) 낮에 돌아다니다가 와이프에게도 의심받고 동업자에게도 의심받는 상황에 처한다. 그런데 편지를 보낸 사람은, &amp;lsquo;나는 영혼이다. 너가 뭘 하는지 다 보고 있다. 뭐하냐, 출소했다니까 그때 했던 약속대로 죽여달라&amp;rsquo; 라고 한다. 그러면서 (그 영혼은) 회사에도 전화를 하고, 안 받으니까 스마트폰을 배달해서 지시를 하고, 상황은 점점 더 옥죄어 오는데 누가 이러는지는 전혀 갈피를 못 잡는 것이다.&lt;/p>
&lt;p>&lt;span style="color: #800000;">&lt;strong>스포일러&lt;/strong> : &lt;/span>&lt;span style="color: #fefefe;"> : 정말 영혼인가? 날 쫓던 야쿠자인가? 같이 나쁜 짓을 했던 녀석 중 한명의 짓인가? 그 노인이 자주 간다던 &amp;lsquo;억울한 피해자 모임&amp;rsquo; 의 사람 중 한명인가? 그 와중에 타겟 두 명 중 한명에게 찾아가지만 차마 죽이지 못했는데, 다음날 타겟은 살해당하고 자신은 누명을 썼다.&lt;/span>&lt;/p>
&lt;p>이제 정말 끝인가, 벼랑 끝으로 내모는 속도가 빠르다. 결말에 다다르면 전부 ta-da 하고 보여주지만, 그 전까지는 독자들도 끝자락으로 내몬다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>교보문고에 갔더니 이 책이 소설 베스트셀러 4위더라. 솔직히 많이 놀랐다. 절박한 주인공으로 만들어버리면서 동시에 주인공의 기민한 위기대응을 보여주는 빠른 전개, 주인공 주변에 흩뿌려진 많은 주변인들 사이에서 벌어지는 복선들의 철저한 회수에는 점수를 후하게 주지만 스토리 전체를 놓고 봤을 때는 끝에서 힘을 다 빼버리는 느낌이 강했기 때문이다. 좀&amp;hellip; 실소가 나올 정도로.&lt;/p>
&lt;p>마치기 전에, 나는 엉뚱한 곳에 시선이 갔다. 주인공이 동료에게 돈을 주고 새로운 호적을 받는 장면이 있다. 주인공이 &amp;lsquo;이 사람은 누구야?&amp;rsquo; 라고 묻자, &amp;lsquo;그 사람은 연고도 없고, 지금 어떻게 됐는지는 묻지마&amp;rsquo; 라고 답한다. &lt;strong>이 호적의 원래 주인이 범인이었으면 어땠을까.&lt;/strong> 너무 뻔했을까. 나는 결말을 알기 전에는 이 장면이 보이지 않았으니, 나에겐 꽤나 신선했을 것 같다.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://ridibooks.com/v2/Detail?id=1013000004" target="_blank" rel="noopener"
>https://ridibooks.com/v2/Detail?id=1013000004&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://www.youtube.com/watch?v=2AZjY5PGPhg" target="_blank" rel="noopener"
>https://www.youtube.com/watch?v=2AZjY5PGPhg&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>중독적 습관</title><link>https://interp.blog/%EC%A4%91%EB%8F%85%EC%A0%81-%EC%8A%B5%EA%B4%80/</link><pubDate>Sun, 03 Jun 2018 15:18:03 +0000</pubDate><guid>https://interp.blog/%EC%A4%91%EB%8F%85%EC%A0%81-%EC%8A%B5%EA%B4%80/</guid><description>&lt;p>요즘 말하는 욜로(YOLO) 에 가까운 삶을 사는 친구가 있다. 일단 불안한 계약직인데다 계약 텀도 굉장히 짧은 직종에 근무한다. 그런데도 잘 놀러 다닌다. 너무나도. 그러면서 늘 걱정을 늘어놓는다. 좋은 남자 만나 결혼해야지, 정규직도 되면 좋겠지, 계속 놀러 다니고는 싶지…&lt;/p>
&lt;p>이런, 쓰고 보니 이 친구는 욜로가 아니다. 내일 살 걱정을 하기는 하니까. 아무튼, 이 친구의 문제는 뭘까, 혹시 쾌락의 끝자락에서 내려오기 싫은 발버둥을 치는 것은 아닐까, 아니면 더 큰 것을 가질 수 없는 공허함을 느낀 걸까.&lt;/p>
&lt;p>술을 마시던 게임을 하던, 그 때만 즐거을 뿐이다. 숙취에 고통받을 때, 게임 종료 버튼 앞에 있을 때, 우리는 다시 비어있음을 느낀다. &lt;strong>쾌락의 순간에는 더 큰 역치를 넘어서지 못하는 한계에 부딪히며 파열을 발생시키는 게 아닐까.&lt;/strong> 그것이 허무감인지, 어떤건지 잘 모르겠다.&lt;/p>
&lt;p>더 큰 보상을 바라는 뇌의 요구와, 중독적인 일 외에 할 수 있는 일을 하나씩 배제시키는 습관의 힘이 합쳐진 것을 우리는 중독이라고 한다. 올바른 (적어도 사회적으로 올바르다고 여겨지는) &amp;lsquo;성취&amp;rsquo;의 대부분은, 즉각적인 보상으로 이어지지 않는다. 그래서 상벌이 바로 튀어나오는 행위에 우리는 열광한다. 시간을 들여 보상이 주어지는 성취에 점점 관심을 잃는 것이다. 하는 방법도, 버틸 힘도 잃어버린다.&lt;/p>
&lt;p>습관은 더 무서운데, 뇌의 보상기제가 작동하건 말건 이 녀석은 항상 LRU (Least Recently Used) 리스트처럼 행위를 관리한다는 것이다. 자주 한 일일수록 쉽게 선택되고, 전혀 해보지 않은 일 (하지만 한번 쯤 해봐야지 하며 버킷리스트에 채워넣었던 일) 은 선택되기 힘들게 한다. 즉, 새로운 도전은 그만큼의 비용이 들지만, 곁에 둔 습관은 그렇지 않다는 것이다. 반복적인 행동은, 그것이 나쁘건 좋건 간에, 여유 시간에 &amp;lsquo;그냥 할 만한 것들&amp;rsquo;의 유력한 후보로 항상 존재할 것이다. 그 후보는 2선, 3선을 밥먹듯이 할테고, 질 나쁜 행동이 고착화되면 언젠가는 부패할 것이다.&lt;/p>
&lt;p>&lt;strong>잘못된&lt;/strong> 습관과 보상기제로 인해 정해진 중독적 행위가 과연 현재를 즐기자라는 다소 낙관적인 말로만 포장될 수 있는지에 대해 숙고해 봐야 한다는 것이다. (잘못됐다는 말을 쓰는걸 별로 좋아하지 않지만, 뭔가 내가 하는 일이 이상하다고 생각된다면 그건 잘못된 거다. 애석하게도.)&lt;/p>
&lt;p>&lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.nhn?code=71509" target="_blank" rel="noopener"
>소미의 옆집 아저씨&lt;/a>도 &amp;lsquo;오늘만 산다&amp;rsquo;고 말하지만, 욜로라고 하지 않는다. 다음을 걱정을 하는 자에게, 중독을 이어가는 이 허무함은 더 고통스럽지 않을까? 그래서 이 신조어는, 실제로 그런 극단적인 허무감을 회피하지 못한 비웃음의 단어는 아닌지, 아니면 정말 해탈했다고 자랑하고 싶은건지 의심스럽기만 하다.&lt;/p></description></item><item><title>암보스 (ambos)</title><link>https://interp.blog/%EC%95%94%EB%B3%B4%EC%8A%A4-ambos/</link><pubDate>Tue, 24 Apr 2018 13:44:54 +0000</pubDate><guid>https://interp.blog/%EC%95%94%EB%B3%B4%EC%8A%A4-ambos/</guid><description>&lt;img src="https://interp.blog/uploads/2018/04/010-2.jpg" alt="Featured image of post 암보스 (ambos)" />&lt;p>두 여자가 서로 다른 방향을 보고 있지만, 그 얼굴 안에서는 마주보기도 하는 듯, 흑심을 품고 있는 듯한 이미지가 프랙탈처럼 나타나 있는 기괴한 표지에 담긴 내용은 대체 어떤 사연일까?&lt;/p>
&lt;p>출판사 &amp;lsquo;황금가지&amp;rsquo;에서 만든 새로운 라인업 &amp;lsquo;수상한 서재&amp;rsquo; 시리즈의 첫 작품인 김수안 작가의 암보스&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>를 읽어봤다. 시간이 없어 서울-대구를 오가는 KTX 안에서 읽었는데, 다소 두꺼운 외형과는 달리 꽤나 빨리 따라갈 수 있었다.&lt;/p>
&lt;p>암보스 (ambos)&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 는 스페인어로 &amp;lsquo;양쪽, 두 사람&amp;rsquo; 이란 뜻이다. 두 여자가 주인공인 것을 표현하고자 했겠으나, 실제로 스페인어는 남성형/여성형 명사가 따로 존재한다. 그래서 표지만 보고는 왜 암바스 (ambas) 라는 여성형 명사를 채택하지 않았을까 자뭇 궁금해졌다. &lt;del>arm boss 같은 느낌도 있어서&lt;/del> 나중에 &lt;a class="link" href="%22http://ch.yes24.com/Article/View/35770%22" >작가 인터뷰&lt;/a>를 보니, 두 주인공만을 위한 제목이 아닌 여러 인물들의 관계 자체를 암보스로 봤기 때문이라고 한다.&lt;/p>
&lt;h2 id="줄거리">줄거리&lt;/h2>
&lt;p>신문 기자 &lt;strong>이한나&lt;/strong>는 어느 날 방화사건 현장에 있었고, 목격한 모든 정보를 회사에 전달한 뒤 의식을 잃었다. 이대로 죽는건가? 아니, 죽는 것도 나쁘지 않겠지. 무능하고 철면피인 아버지가 진 빚이며, 헤어진 남자친구며, 내가 잘못 굴린 펜으로 사람이 곤란에 겪었으니까. 깨어나보니, 이한나는 다른 사람이 되어 있었다. 같은 날 옥상에서 뛰어내렸지만 가까스로 목숨을 건졌던 강유진이란 사람으로. 이한나는 퇴원하자 마자 강유진의 집을 찾아갔는데, 별안간 이한나의 모습을 한 누군가가 뒤따라 찾아왔다. 그는 &lt;strong>강유진&lt;/strong>이었다. 몸이 뒤바뀐 것이다. 어떻게 된 일일까.&lt;/p>
&lt;h2 id="초자연은-중요한-게-아니다">초자연은 중요한 게 아니다&lt;/h2>
&lt;p>하지만 책은 &lt;strong>왜 이들의 몸이 바뀌었는지는 독자들에게 이야기해주지 않는다.&lt;/strong> 누군가가 상대방의 몸을 원했다면, 영화 &amp;lsquo;더 게임&amp;rsquo;&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> 의 강회장 (변희봉 扮) 같은 캐릭터가 나와야 하겠지만, 여기선 어느 누구도 그런 역을 자처하지 않는다. 그보다는, 서로의 삶에서 느끼는 &amp;lsquo;잃은 것과 얻은 것의 의미&amp;rsquo;를 알아가고 행동하는 데에 많은 부분을 할애한다. 강유진은 비만에 집에 틀어박혀 지내기 일쑤지만 돈이 많았고, 이한나는 예쁜데다 활기차고 자기주관이 강했지만 안하무인 아버지로 인해 많은 빚을 졌다.&lt;/p>
&lt;p>설마 강유진의 모습을 한 이한나가 &amp;lsquo;나는 열심히 운동해서 살을 빼야지&amp;rsquo; 라거나 &amp;lsquo;이제부터 사람들과 잘 어울려야지&amp;rsquo; 같은 뭐 이런 희망적인 스토리를 기대하지는 말자. 그들은 언젠가 다시 본래의 상태로 돌아갈 것이라고 확신하고 있었다. 정확히 말하자면 강유진이 &amp;lsquo;그렇게 될 것&amp;rsquo;이라고 이야기했지만. 아무튼 그렇게 돌아가버린다고 가정했을 때 이들은 어떤 행동을 하게 될 것인가. 상대방의 미스터리한 행적이 서로의 시선을 통해 서술되기 시작한다.&lt;/p>
&lt;h2 id="갑자기-교차되는-사건">갑자기 교차되는 사건&lt;/h2>
&lt;p>시간이 지나면서 연쇄살인사건, 그리고 그 범인을 찾는 형사가 교차되어 나타난다. 일면 관련없어 보이는 사건 이야기가 갑자기 주인공 일행의 서사와 겹치면서 충돌하기 시작한다. 그것도 아주 빠르게. 파열음은 의외로 강하고, 당사자들의 추리 게임은 꼬리에 꼬리를 문다.&lt;/p>
&lt;p>이 시점에서 가장 눈에 띄는 것은 단연 박선호 형사일 것이다. 우락부락한 체격과 어울리지 않게 집요하리만치 파고드는 집중력이 소설 내내 돋보인다. 그 옆을 따르는 부사수 칠범 역시 파트너 역할에 충실한다. 이한나의 가족과 주변인, 그리고 강유진의 증언 등을 토대로, 사건 이후 사람이 뭔가 달라졌다는 의혹을 끝까지 물고 늘어지는데, 이 부분에서 주인공 일행과의 긴박한 밀당이 계속 이뤄진다. 결국 살인사건은 실마리를 찾고 해결되지만, 이게 정말 끝일까?&lt;/p>
&lt;h2 id="소설이-이야기-하는-방식">소설이 이야기 하는 방식&lt;/h2>
&lt;p>소설이 가지는 강점은 심리 묘사와 비유에 많은 에너지를 쏟았고 그걸 고스란히 전달하려고 노력했단 점이다. 사건의 진위가 아니라, 사건에 휘말린 인물의 세세한 면면을 나타내려고 애를 썼다. 그래서 스토리 자체에 태클을 걸면서 본다면 자칫 넘어지기 쉬울 것 같아 보이긴 하지만, 그런 세세한 부분을 너그러이 이해해준다면 재밌게 읽힐 소설이 될 것이다.&lt;/p>
&lt;p>작중 이한나의 시점, 박선호 (를 포함한 외부)의 시점에서는 이한나와 강유진을 지칭하는 자아가 서로 다른 것이 신선했다. 이한나의 시점에서 서술될 때는 &amp;lsquo;나&amp;rsquo; 와 &amp;lsquo;(내 모습을 한) 강유진&amp;rsquo; 이지만, 그 외에는 외모대로 &amp;lsquo;강유진&amp;rsquo; 과 &amp;lsquo;이한나&amp;rsquo; 로 서술된다. 박선호가 이를 눈치챈 종반부에서는 서술이 다시 뒤바뀌긴 하지만. 그래서 이 부분을 따라가기가 조금 피곤해 질 수는 있겠다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>독자에게 추리할 여지를 많이 주는 것 같지만, 사실 복선은 야속하게 정류장을 지나치는 시내버스 같이 지나간다. 어느샌가 소설 속 인물들의 추리보다 한발 앞서 나간게 아닐까, 그랬던 거였어! 라고 생각하고 있다면, 조심해야 한다. 끈적한 손으로 뒤통수를 후려갈겨서 뒷맛이 찜찜하다. 이게 뭐야, 꼭 그렇게 했어야만 했냐! 같은 느낌. 하지만, 역으로 생각해보면 책을 한번 더 돌려보게 만드는 매력을 지니고는 있다고 볼 수 있다.&lt;/p>
&lt;p>소설 중에 이런 내용이 있다. &lt;strong>강유진의 모습을 한 이한나가 창문을 바라본다. 창문에는 강유진이 보인다. 내가 정말 나인지, 상대방이 내 모습을 하고 유리창에 나타난건지, 정말로 상대방이 내가 된건지. 나는 누구일까.&lt;/strong>&lt;/p>
&lt;p>사람의 몸이 뒤바뀐다는 초자연적인 전개에만 관심을 가지면 이 소설은 거기서 끝난다. 상대방의 거죽을 쓰고 자신도 몰랐던 민낯이 드러나는 것을 보고 나면 다른 생각이 들 것이다.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://www.yes24.com/24/goods/59681102" target="_blank" rel="noopener"
>http://www.yes24.com/24/goods/59681102&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://spdic.naver.com/#/entry/esko/2890825" target="_blank" rel="noopener"
>http://spdic.naver.com/#/entry/esko/2890825&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://movie.naver.com/movie/bi/mi/basic.nhn?code=66617" target="_blank" rel="noopener"
>https://movie.naver.com/movie/bi/mi/basic.nhn?code=66617&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Atomic Operation 으로 하는 동시성 제어</title><link>https://interp.blog/atomic-operation-%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/</link><pubDate>Tue, 24 Apr 2018 02:31:38 +0000</pubDate><guid>https://interp.blog/atomic-operation-%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/</guid><description>&lt;h2 id="test-and-set-tas">Test-And-Set (TAS)&lt;/h2>
&lt;p>TAS 를 이용해서 간단한 동시성 제어를 할 수 있다. testAndSet 이라는 function 을 가지고 아래의 &lt;code>do...while&lt;/code> 문을 쓰레드 A, B 에서 동시에 호출한다고 해 보자. 이 때 lock 은 같은 변수이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">function&lt;/span> &lt;span class="nf">TestAndSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">boolean_ref&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">boolean&lt;/span> &lt;span class="n">initial&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">lock&lt;/span>
&lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">initial&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TestAndSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">amp&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">;&lt;/span> &lt;span class="c1">// do nothing
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// critical section
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// remainder section
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>우선 TestAndSet() 은 다음과 같은 일을 한다. 말 그대로 &amp;lsquo;지금 값이 무엇인지 검사하고, 값을 바꾼다&amp;rsquo; 는 것이다.&lt;/p>
&lt;ol>
&lt;li>lock의 현재 값을 저장해 둔다.&lt;/li>
&lt;li>lock의 값을 true 로 설정한다.&lt;/li>
&lt;li>저장한 lock 의 값을 반환한다.&lt;/li>
&lt;/ol>
&lt;p>그럼 이걸로 어떻게 아래 block 의 critical section 에 대한 동시성 제어를 할 수 있을까? Thread A 가 먼저 실행했다고 가정하면, 이런 시나리오가 된다.&lt;/p>
&lt;ol>
&lt;li>A : TestAndSet() 의 반환값이 false 이다. while 문을 빠져나온다.&lt;/li>
&lt;li>B : TestAndSet() 의 반환값이 true 이다. (A가 true로 두고 나왔기 때문에) while 문에서 계속 돈다.&lt;/li>
&lt;li>A : Critical Section 수행 후, lock 을 false 로 바꾼다.&lt;/li>
&lt;li>B : 여러 번의 TestAndSet() 호출 후에, 드디어 반환값이 false 가 되었다&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>(A가 false 로 두고 나왔기 때문에) while 문을 빠져나온다.
&lt;/code>&lt;/pre>
&lt;p>자, 그런데 뭔가 이상하다. 이렇게 이상적으로 동작하지 않을 것 같다. TestAndSet() 함수를 라인별로 동시에 실행한다고 하면 이런 사단이 날 수 있다.&lt;/p>
&lt;ol>
&lt;li>A : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다.&lt;/li>
&lt;li>B : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다.&lt;/li>
&lt;li>A : TestAndSet() 에서 lock 값을 true 로 바꾼다.&lt;/li>
&lt;li>B : TestAndSet() 에서 lock 값을 true 로 바꾼다.&lt;/li>
&lt;li>A : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다.&lt;/li>
&lt;li>B : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다.&lt;/li>
&lt;li>A &amp;amp; B : 모두 동시에 critical section 을 수행한다.&lt;/li>
&lt;/ol>
&lt;p>그럼 어떡하나? TestAndSet() 은 그래서 저런 함수만으로는 안 되고 Test-And-Set 의 연산이 일관되도록 조정해야 한다. 함수 안에 spinlock 을 쓰면 되겠네요? 싶겠지만 lock 구현하자고 lock 을 또 만드는 건 아닌 것 같다. 그래서 Test-And-Set 은 CPU에서 지원하는 Atomic Instruction 을 사용한다.&lt;/p>
&lt;h2 id="fetch-and-add--ticket-lock">Fetch-And-Add : Ticket Lock&lt;/h2>
&lt;p>Atomic Operation 으로 구현할 수 있는 Lock 중에 Ticket Lock 이 있는데, Fetch-And-Add 로 구현할 수 있는 방법을 알아보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">ticketLock_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next_ticket&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next_ticket&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">ticketLock_acquire&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next_ticket&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">my_ticket&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fetch_and_inc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">next_ticket&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">my_ticket&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">ticketLock_release&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">now_serving&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>TAS 의 케이스를 이해하고 본다면 별 다른 설명이 필요 없을 것 같다.&lt;/p>
&lt;ol>
&lt;li>Table Lock 초기화를 한다.&lt;/li>
&lt;li>A : Table Lock 을 얻으려 한다. 이미 얻었던 &lt;code>my_ticket (0)&lt;/code> 과 &lt;code>now_serving (0)&lt;/code> 이 같은 값이므로 곧바로 빠져나온다.&lt;/li>
&lt;li>B : Table Lock 을 얻으려 한다. 이미 얻었던 &lt;code>my_ticket (1)&lt;/code> 과 &lt;code>now_serving (0)&lt;/code> 이 다른 값이므로 while 문에서 대기한다.&lt;/li>
&lt;li>C : Table Lock 을 얻으려 한다. 이미 얻었던 &lt;code>my_ticket (2)&lt;/code> 과 &lt;code>now_serving (0)&lt;/code> 이 다른 값이므로 while 문에서 대기한다.&lt;/li>
&lt;li>A : Table Lock 을 해제한다. &lt;code>now_serving (0)&lt;/code> 을 증가시켜 &lt;code>now_serving (1)&lt;/code> 을 만든다.&lt;/li>
&lt;li>B : 비로소 Table Lock 을 얻었다. (C는 여전히 대기 중이다.)&lt;/li>
&lt;/ol>
&lt;p>여기서 핵심은 &lt;code>fetch_and_inc&lt;/code> 인데, 마찬가지로 얻어오는 루틴과 값을 증가시키는 루틴이 따로 떨어져 있으면 중복된 티켓을 들고 기다리는 쓰레드들이 발생할 수 있다. 따라서 이것도 atomic operation 이 되어야 한다.&lt;/p></description></item><item><title>Timsort</title><link>https://interp.blog/timsort/</link><pubDate>Mon, 23 Apr 2018 01:36:57 +0000</pubDate><guid>https://interp.blog/timsort/</guid><description>&lt;p>알고리즘 강의를 들었다면, &lt;strong>가장 빠른 정렬 알고리즘이 뭐냐&lt;/strong>는 질문에 곧장 &lt;a class="link" href="https://www.toptal.com/developers/sorting-algorithms/quick-sort" target="_blank" rel="noopener"
>Quicksort&lt;/a> 라고 답할 수 있을 것이다. 실제로 현업에서도 적용하기 가장 편하기 때문에 많이 차용되는 편이다. 그런데 모든 문제를 쉽게 풀 수 있는 은탄은 세상에 존재하지 않듯, Quicksort 역시 특정 케이스에서는 성능이 낮게 나오는 경우가 있다. 더 심각한(?) 것은, 이 특정 케이스가 현실에서는 꽤나 자주 발생한다는 것이다.&lt;/p>
&lt;p>그 케이스란 바로 &amp;lsquo;거의 정렬된 데이터&amp;rsquo; 이다. 거의 정렬된 데이터라면 pivoting – partitioning 을 반복할 필요도 없이 Bubble Sort 나, 심지어는 Insertion Sort 를 해도 된다. &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC" target="_blank" rel="noopener"
>Bubble Sort&lt;/a> 의 경우엔 알고리즘 복잡도가 n&lt;sup>2 &lt;/sup>이지만 compare 과정에서 조기에 끝날 가능성이 매우 높아 비용이 거의 발생하지 않을 것이고, Insertion Sort 도 비슷한 이유로 빠르게 끝날 것이다. 하지만 모든 정렬 케이스가 거의 정렬된 데이터만 있지 않기 때문에 쓰지 않는 것일 뿐이다.&lt;/p>
&lt;p>만약에 데이터 순열이 &amp;lsquo;**거의 정렬된 데이터의 N 벌&amp;rsquo;**이라고 하자. &lt;span style="color: #3366ff;">1, 2, 3, …, 10&lt;/span>, &lt;span style="color: #800000;">2, 3, 4, …, 20&lt;/span> 이런 식으로 말이다. (여기서는 2벌) 그림을 그리자면 산이 N 개 생긴 것 처럼 보일 것이다. 이런 경우에는 Bubble Sort 가 큰 힘을 쓰지 못한다. 특정 원소가 산의 제 위치에 찾아가야 하는데, 조기에 끝났던 아까의 경우와는 달리 재수가 없다면 거의 모든 원소 개수와 비교해 봐야 하기 때문이다. 이럴 경우 역시 특효약이 있는데, 산마다 Mergesort 를 하면 쉽다.&lt;/p>
&lt;p>오늘 이야기할 &lt;a class="link" href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener"
>Timsort&lt;/a> 는 Mergesort 의 변형이라고 보면 된다. 아까 &amp;lsquo;산마다 Mergesort&amp;rsquo; 를 한다고 했는데, 어느 지점부터 산으로 봐야할지를 판단하는 알고리즘이 선행된다. 그리고 Mergesort 도 단순히 1개씩 건너뛰는 방법에서 좀 더 나은 방법을 제시한다.&lt;/p>
&lt;p>결론부터 말하자면 Timsort 는 무작위 데이터에서 Quicksort 보다 뒤쳐진다. 프로젝트할 때 적용해 본 결과로는 30~50% 정도 느렸다. 하지만 말했다시피, 현실 데이터는 어느 정도 정렬된 데이터의 덩어리를 가지고 있는 경우가 매우 많기 때문에, 그 부분에서는 확실한 성능 차이를 보였다.&lt;/p>
&lt;p>자, 이제 한 번 알아보자.&lt;/p>
&lt;h2 id="1단계--run">1단계 : Run&lt;/h2>
&lt;p>데이터 순열에서 &lt;strong>&lt;span style="color: #0000ff;">이미 정렬이 끝난 부분 데이터들을 Run&lt;/span>&lt;/strong> 이라고 한다. 1, 2, 1, 2, 3, 1, … 같이 주어졌을 때, 1, 2 와 1, 2, 3 을 Run 으로 인식하는 것이다. Timsort 에서는, 데이터 순열을 이런 Run 들로 찾거나 만들어서 확보하는 과정을 거친다. 이게 1단계이다.&lt;/p>
&lt;p>Timsort 는 &lt;span style="text-decoration: underline;">Run 이 너무 짧으면 나중에 의미가 없으므로, 최소 길이를 정해서 Run 을 만들도록 한다&lt;/span>. 보통은 길이가 16인 Run 부터 의미있게 쓰길래, 나도 똑같이 16으로 조건을 설정했다.&lt;/p>
&lt;p>Run 은 데이터 처음부터 정렬되어 있는 위치까지를 찾는다. 이 길이가 16 미만이라면, 해당 범위는 기억해 두고 다음 Run 을 찾는다. 이렇게 길이가 16 이상의 Run 을 만들 수 있는데, 이 때 쓰는 알고리즘은 사실 아무거나 가져다 써도 된다. 길이가 짧을 때의 정렬 알고리즘은 어느 것을 쓰나 대동소이하기 때문에, 나는 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC" target="_blank" rel="noopener"
>Insertion Sort&lt;/a>를 썼다.&lt;/p>
&lt;h2 id="2단계--merge">2단계 : Merge&lt;/h2>
&lt;p>1단계 이후로는, 이제 데이터 순열에 Run 여러개가 연속되어 있다. 만약 Run 이 1개뿐이라면? 축하한다. 아주 작은 원소 개수를 정렬하려 했거나, 이미 정렬된 데이터를 넣었단 것이니 이번 단계를 하지 않아도 된다.&lt;/p>
&lt;p>앞의 두 Run 을 불러서 Mergesort 하면 되는데, 여기서 Timsort 만의 트릭이 두 개 존재한다.&lt;/p>
&lt;p>하나는, Merge 에 참여할 두 Run 의 최소값/최대값을 서로 비교해서, &lt;span style="text-decoration: underline;">아예 이긴 구간이나 아예 진 구간을 미리 산정해 두는 것&lt;/span>이다. 이 부분은 사실상 Mergesort 과정에서 비교 대상이 될 필요가 없다. 괜한 compare 연산만 낭비하지 말고 처음에 (혹은 나중에) 순순히 들어와주기만 하면 된다. 이 전처리 과정이 끝나면, 남아있는 Run 끼리 Merge 과정을 거친다.&lt;/p>
&lt;p>두 번째는, Merge 과정에서 만약 한 쪽이 계속 이기는 상황 (오름차순 정렬이라고 가정했을 때, 한 쪽의 Run 이 계속 작은 원소를 가지고 있을 때) 라면 더 이상의 비교는 무의미하다. &lt;span style="text-decoration: underline;">이런 연속 위닝 회수를 정해서, 이후에는 &amp;lsquo;어디까지 이기는지 binary search 로 찾아서 한 번에 그냥 옮기자&amp;rsquo; 라는 건너뛰기 모드 (galloping mode) 로 전환된다.&lt;/span> 코드를 참조했을 땐, 이 위닝 회수는 3이었다. &lt;span style="color: #999999;">&lt;del>스윕승?&lt;/del>&lt;/span>&lt;/p>
&lt;p>건너뛰기 모드 (galloping mode) 에서는, 지고 있던 Run 의 첫 번째 원소가 이기고 있던 Run 의 어느 원소에서 비로소 이기는지를 찾는 것이다. 처음엔 한 칸, 다음엔 두 칸, 그 다음엔 네 칸씩 뛰며 이길 때 까지 찾는다. 그러다가 찾았다면, 직전 구간 사이를 Binary Search 를 통해 최초로 이긴 위치를 찾아내면 된다.&lt;/p>
&lt;p>그 다음은? 이기고 있던 Run 의 처음부터 발견된 위치 직전까지를 통째로 &lt;code>memcpy&lt;/code> 하면 된다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>이걸 구현할 때는 급한 나머지 그냥 구현했었는데, (물론 어딘가에선 하고 있겠지만) Mergesort 자체가 병렬 구현이 가능하므로 Timsort 역시 병렬 구현이 가능하리라 본다. Run 을 만드는 작업은 병렬로 할 수 있을까 고민이 되지만, Merge 과정은 작업 큐만으로도 쉽게 그려낼 수 있다.&lt;/p>
&lt;p>역시 이것도 만병통치약이 될 수 없다. 상황에 맞춰 적절히 섞어써야 한다. 이런 정렬 알고리즘도 있구나 하며 배웠던 소중한 기회로 여기고 있다.&lt;/p></description></item><item><title>정리는 비움으로, 그리고 마음부터</title><link>https://interp.blog/%EC%A0%95%EB%A6%AC%EB%8A%94-%EB%B9%84%EC%9B%80%EC%9C%BC%EB%A1%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%A7%88%EC%9D%8C%EB%B6%80%ED%84%B0/</link><pubDate>Thu, 19 Apr 2018 02:57:40 +0000</pubDate><guid>https://interp.blog/%EC%A0%95%EB%A6%AC%EB%8A%94-%EB%B9%84%EC%9B%80%EC%9C%BC%EB%A1%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%A7%88%EC%9D%8C%EB%B6%80%ED%84%B0/</guid><description>&lt;p>마음이 붕.&lt;/p>
&lt;p>몸은 여기 있는데, 어디로 가고 있는지조차 모를 정도로 격랑(激浪)에 떠밀려 가는 것처럼.&lt;/p>
&lt;p>조각난 지식들은 어딘가에 있겠지만, 약에 쓰려고 하면 개똥도 찾을 수 없는 것 처럼 내 단편의 끄적임을 찾기 힘들 때마다 드는 생각이 있다. 이걸 전부 모아뒀다면. 다짐은 용오름처럼 솟구치지만 이내 잠잠한 바다 속으로 꺼져버린다. 정리할 시간이 없진 않았을 텐데, 하면서.&lt;/p>
&lt;p>정리와 분류는 결국 데이터를 다루는 사람, 데이터 소프트웨어를 만드는 개발자 둘 모두에게 있어 경쟁력이자 기본이라고 생각한다. 어떻게 효율적으로 정리를 할 것인지 매번 고민한다. 사무실에서도, 집에서도, 혼자 스탠드등에 앉아 있으면서도. 정리해 두면, 잘 꺼내 쓸 수 있을거란 기대가 있으니까. 이 때 또 물어본다. 정말 꺼내 쓸만한 것들인지는 확인해 보았느냐고. 설마 폐지를 정리하려 드는 것은 아닐까 하고. 그래서 정리에는 비움이 필요하다.&lt;/p>
&lt;p>지금 이 생각에도 비움이 필요하다. 마음 속에 부는 바람줄을 하나씩 잠재워야 한다. 초가 타지 않도록, 그나마 따뜻한 이 믿음이 꺼지지 않도록. 이걸 먼저 정리해야겠다. 그래야 지금 앉아있는 곳으로 마음이 돌아올테니까.&lt;/p>
&lt;p> &lt;/p></description></item><item><title>조직 철학과 고객의 요구사항</title><link>https://interp.blog/%EC%A1%B0%EC%A7%81-%EC%B2%A0%ED%95%99%EA%B3%BC-%EA%B3%A0%EA%B0%9D%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/</link><pubDate>Sat, 10 Mar 2018 12:30:51 +0000</pubDate><guid>https://interp.blog/%EC%A1%B0%EC%A7%81-%EC%B2%A0%ED%95%99%EA%B3%BC-%EA%B3%A0%EA%B0%9D%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/</guid><description>&lt;p>회사가 고객에게 제공해야 할 것을 개념적으로 정의할 때 제품의 철학이라는 말을 사용한다. 제품의 시그니처이자 조직 내부를 움직이는 시금석이 되는데, 이걸 등한시하면 발생하는 문제에 대해 이야기하려고 한다.&lt;/p>
&lt;p>철학이라면 어떤 것을 말하는 걸까. &amp;lsquo;탐색 속도가 빨라야 한다, 로그인 없이도 정보 제공이 되어야 한다, 고객의 소리에 즉각적으로 귀를 기울인다&amp;rsquo; 같은 개념이 철학이지, &amp;lsquo;탐색 속도의 TPS 목표치, 로그인 폼의 형태, 고객이 원하는 것을 나열하는 것&amp;rsquo; 자체로 철학이라고 하지 않는다. 이건 요구사항이지, 철학이 아니다.&lt;/p>
&lt;p>그런데 후술한 구체적인 것들이 실제로 중요하기 때문에 (특히 고객이 원하는 것) 철학을 도외시하게 된다. 이래서는 안 된다. 조직이 하나로 뭉칠 수 있는 것은 그 철학에 있는데, 결정권자가 그걸 무시한 채 업무를 단장하는 순간 조직이 와해되는 것은 정말 시간문제다. 회사가 소규모이고, 창립멤버이며, 모두 새로운 이정표로 나아가는 데 동의를 하면 모르겠지만 조직이 커질수록 그런 함정에 빠지기 쉽다.&lt;/p>
&lt;p>당장의 이익이나 트렌드를 급히 따라가는 것은, 이유를 막론하고 숙고해야 할 문제이다. 단순히 예측되지 않은 미래에 대한 불안만으로 이야기하는 것이 아니다. 배의 크기가 클수록 키를 급하게 돌리면 배 자체에 문제가 발생하기 쉽다. 그걸 막기 위한 것이 조직이 동의한 (혹은 입사 때부터 배웠거나 인정했던) 가치인 것이다. 방향을 틀었다면, 조직 내부에서 큰 합의가 필요한데, 여기에 드는 비용을 무시할 수 없다. 그런데, 아무런 합의 없이 진행한다면 더 큰 비용을 감수하는 것이다. 다만, 문제가 터지기 전까진 보이지 않을 뿐.&lt;/p>
&lt;p>이걸 지켜내는 것이 정말 어려운 것임을 나는 안다. 초반에는 이걸 지킬 수 있었고, 유연하게 움직이기도 쉬웠을 것이다. 하지만 무작정 강요로 이끌어나간다면, 언젠가는 더 큰 이자를 내야 한다는 사실을 기억해야 할 것이다.&lt;/p></description></item><item><title>메타인지 – 적을 알기 전에 나를 알자</title><link>https://interp.blog/%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80-%EC%A0%81%EC%9D%84-%EC%95%8C%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%82%98%EB%A5%BC-%EC%95%8C%EC%9E%90/</link><pubDate>Tue, 06 Mar 2018 06:43:00 +0000</pubDate><guid>https://interp.blog/%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80-%EC%A0%81%EC%9D%84-%EC%95%8C%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%82%98%EB%A5%BC-%EC%95%8C%EC%9E%90/</guid><description>&lt;p>「완벽한 공부법」&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> 과 「일취월장」&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 두 책에서 언급되는 &amp;lsquo;메타인지&amp;rsquo; 라는 개념이 있다. &amp;lsquo;자신의 생각에 대해 판단하는 능력&amp;rsquo; 이라는 것인데, 나무위키 에서는 다음과 같이 쪼개놓았다.&lt;/p>
&lt;ul>
&lt;li>선언 지식 – 자신이 학습하는 부분에 대해서 얼마만큼의 지식과 능력을 가지고 있는지 아는 것.&lt;/li>
&lt;li>절차 지식 – 어떤 일을 하는 데 얼마만큼의 노력과 시간이 들어갈 지 아는 것.&lt;/li>
&lt;li>전략 지식 – 지식을 습득 할 때 어떤 방법을 선택해야 할지 아는 것.&lt;/li>
&lt;/ul>
&lt;p>사실 우등생은 다른 학생들보다 기억력이나 연산력이 월등히 좋거나 하진 않지만, 이 &amp;lsquo;메타인지&amp;rsquo; 능력에서 월등한 차이를 보인다고 한다. (정확히 기억나진 않지만) 어떤 실험을 하나 했는데, 학생들에게 제한 시간 안에 전부 외울 수 없는 영어단어들을 외우게 했다.&lt;/p>
&lt;p>그리고는 시험을 쳤다. 시험 결과는 우등생이나 다른 학생들이나 별다른 차이가 없었다. 그런데, 시험 후 채점을 하지 않고 몇 개나 맞췄을까라고 물어 본 결과는 달랐다. &lt;strong>우등생으로 분류된 학생들이 정확히 채점 결과와 일치하는 답을 내놨지만, 다른 학생들은 잘 모르겠다고 했단다.&lt;/strong>&lt;/p>
&lt;p>적을 아는 것도 중요하지만 또 나도 알아야 백전불태(百战不殆)&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>다. 혹시 적만 알아가는데 지치진 않았는지? 시험 문제를 그저 풀기 위해 학원에 가서 유형 분석을 하고 인강을 듣는건 아닌지 생각해 볼 필요가 있다. 내가 어디가 부족한지를 알고, 부족한 부분을 채우려는 전략적인 행동이 중요하다.&lt;/p>
&lt;p>「완공」 을 읽다가 이 대목에서 눈에 띄었던 이야기는, 메타인지를 키우려면 결국 혼자만의 공부를 해야 한다는 거다. 우등생들은 보통 혼자 공부하는 시간을 적어도 세시간 이상 둔다고 한다.&lt;/p>
&lt;p>일도 그렇지 않을까. 회사에서 주어진 일을 처리하는 것도 밥벌이로서 중요한 일이지만, 업무와 무관하게 내가 부족한 점은 무엇인지, 내가 쌓아야 하는 것은 어떤 지식인지를 스스로 탐구할 시간이 필요하다고 생각한다. 그것이 업무를 도와주는 지식이건 향후의 커리어에 도움이 되는 것이건 간에 말이다.&lt;/p>
&lt;div style="max-width: 854px;">
&lt;div style="position: relative; height: 0; padding-bottom: 56.25%;">
&lt;iframe style="position: absolute; left: 0; top: 0; width: 100%; height: 100%;" src="https://embed.ted.com/talks/lang/ko/dan_pink_on_motivation" frameborder="0" scrolling="no" allowfullscreen="allowfullscreen">&lt;/iframe>
&lt;/div>
&lt;/div>
&lt;br/>
&lt;p>책 「드라이브」&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> 의 저자 다니엘 핑크의 TED 강연&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>에서는, 협업 도구를 만드는 호주의 회사 Atlassian 을 소개한다. (내가 너무나 잘 쓰고 있는 Confluence 를 만든 회사이다.) 여기서는 업무 시간의 일정 부분을 떼서, 맡은 업무와 아무 상관없는 일을 해서 발표하는 시간을 가져 왔다고 한다. 거기서 놀라운 기능들이 나오기 시작했고, 회사는 이 비율을 20% 가까이 올렸다고 한다. 우리가 잘 알고 있는 구글 역시 이런 방식으로 새로운 기능을 자율적으로 얻을 수 있었고, Gmail 과 같은 놀라운 앱이 나온 것이다.&lt;/p>
&lt;p>이런 법칙을 개인에게도 적용해서, 외부의 과제를 잠시 내려놓고 내가 부족한 것은 없는지, 내가 비효율적으로 했거나 잘못 가고 있는 것은 아닌지 살펴보고 행동하는 시간을 가지는 것이 중요하지 않을까.&lt;/p>
&lt;p>(여담으로, 위의 강연은 양초 문제, 위키피디아의 성공 등과 같은 흥미로운 이야기를 하니 한번 보길 권한다.)&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://www.yes24.com/24/goods/34569935?scode=032&amp;amp;OzSrank=1" target="_blank" rel="noopener"
>http://www.yes24.com/24/goods/34569935?scode=032&amp;OzSrank=1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://www.yes24.com/24/Goods/57501187?Acode=101" target="_blank" rel="noopener"
>http://www.yes24.com/24/Goods/57501187?Acode=101&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://cndic.naver.com/zh/entry?entryID=c_38f7bfe4d2" target="_blank" rel="noopener"
>http://cndic.naver.com/zh/entry?entryID=c_38f7bfe4d2&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>&lt;a class="link" href="http://www.yes24.com/24/goods/5819980?scode=032&amp;amp;OzSrank=5" target="_blank" rel="noopener"
>http://www.yes24.com/24/goods/5819980?scode=032&amp;OzSrank=5&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://www.ted.com/talks/dan_pink_on_motivation?language=ko" target="_blank" rel="noopener"
>https://www.ted.com/talks/dan_pink_on_motivation?language=ko&lt;/a>&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>먼저 다가가 도와주기</title><link>https://interp.blog/%EB%A8%BC%EC%A0%80-%EB%8B%A4%EA%B0%80%EA%B0%80-%EB%8F%84%EC%99%80%EC%A3%BC%EA%B8%B0/</link><pubDate>Fri, 02 Mar 2018 06:56:41 +0000</pubDate><guid>https://interp.blog/%EB%A8%BC%EC%A0%80-%EB%8B%A4%EA%B0%80%EA%B0%80-%EB%8F%84%EC%99%80%EC%A3%BC%EA%B8%B0/</guid><description>&lt;p>맡은 일을 하려면 쭉쭉 할 수 있을 것 같은데, 그럴 의지가 텅 비어버린 것 같다. 이 의지라는 것은 커피나 술 같은 것으로 긴급 보충이 가능하겠지만 그러기도 싫다. 그냥, 삼일절과 토요일 사이의 한가로운 근무일을 몇 가지 단상으로 때우다 보면 고것이 조금 고여있지 않을까? 그걸로 다시 일을 재개하겠노라 다짐하면서 블로그에 글을 하나 더 얹어 본다.&lt;/p>
&lt;p>어떻게 살 것인가? 라는 주제에 대해 이야기한 적이 있는데, 주변 사람들에게 긍정적인 영향을 줄 수 있는 사람이 되고 싶구나 라고 문득 생각난 적이 있다. 누군가에게 도움을 주고 웃어도 주고 들어도 주는. 그래서 처음에는 웃는 연습을 하고 지식을 채웠었다. (그것이 전문적인 것이던 가십거리가 되었던 간에) 그런데 이상했다. 여전히 날 찾는 사람이 별로 없는 것 같았다. 뭐가 문제지? 아, 마케팅을 잘 못했구나. 1인 기업이니 셀프 마케팅이니 그런 개념을 잊고 있었구나, 라고 생각했었다. 며칠 전까지는.&lt;/p>
&lt;p>마케팅 같은 거창하고 전문적인 개념으로 이 문제를 대하면 피로감이 몰려왔다. 와이프의 선배는 인맥을 관리하기 위해 분기에 한 번씩 아무런 일이 없는데도 주변 사람에게 전화를 한다고 했다. 아무런 일이 없는데도 말이다. 시시껄렁한 말이 오가면 그대로 통화는 끝난다. 이 이야길 처음 들었을 때도 비슷한 피곤이 느껴졌다. 왜 그래야 하지? 저 선배는 마케팅을 참으로 잘 하는구나.&lt;/p>
&lt;p>그런데 완전히 잘못 생각하고 있었단 생각이 들었다. 도움을 필요로 하는 사람은 &amp;lsquo;도와달라&amp;rsquo; 고 말하는 경우가 거의 없다. 처한 환경이 극단적인 경우이거나 술에 취했거나 한다면 조금 이야기가 다르겠지만, 대개는 도움을 줄 사람이 아주 명확한데다 질문하기가 거리낌이 없는 상태라야 저 말이 나온다. 그런데, 도움을 줄 사람이 명확한 경우도 거의 없고, 그 사람이 호의적으로 나올지도 모른다면? 반대로, 호의는 가지고 있는데 뭘 도와줘야 할지 모르겠다면?&lt;/p>
&lt;p>어떤 사람에게 도움이 되고자 한다면, 그 &amp;lsquo;사람&amp;rsquo; 이라는 것이 특정 타겟이 아닌 주변 사람 전부를 의미하는 거라면 접근법이 완전히 달라져야 한다. 내 문에 노크를 하며 도와달라고 말할 때 까지 기다려서도 안 되고, 주변인들이 필요해 보이는 것을 미리 준비하려고 해도 안 된다. 나도 그 사람에게 도움이 될지 안 될지 모르고, 그 사람도 나를 필요로 하는지 그렇지 않은지 모른다.&lt;/p>
&lt;p>그러니 먼저 가서, 위의 그 선배가 한 것처럼 시답잖은 이야기를 늘어놓으며 나의 존재를 알린다. 그 과정이 불편하다면 어쩔 수 없다. 하지만 적어도 그대가 뭘 필요로 하고 내가 뭘 해 줄 수 있는지 알아볼 기회가 생긴다. 그리고 내가 할 수 있는 일을 찾아서 도와줘라. 고민을 들어주고 웃어줘라. 뭔가 더 준비하지 말고, 갖춰진 상태에서 최대한 도와줘라.&lt;/p>
&lt;p>설령 도움이 안 되더라도, 적어도 나의 호의는 그대가 느낄 수 있게.&lt;/p>
&lt;p>다시 일을 시작해야겠다.&lt;/p></description></item><item><title>gdb commands 이용하기</title><link>https://interp.blog/gdb-commands-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/</link><pubDate>Tue, 06 Feb 2018 08:46:05 +0000</pubDate><guid>https://interp.blog/gdb-commands-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/</guid><description>&lt;p>gdb/ddd 에서 commands 를 사용하면 간편하게 breakpoint 의 상태를 출력할 수 있다. 물론 다양하게 응용이 가능하겠지만, 매뉴얼에서 제시한 케이스가 굉장히 편해서 따로 정리한다.&lt;/p>
&lt;p>참고 : &lt;a class="link" href="http://sourceware.org/gdb/onlinedocs/gdb/Break-Commands.html" target="_blank" rel="noopener"
>http://sourceware.org/gdb/onlinedocs/gdb/Break-Commands.html&lt;/a>&lt;/p>
&lt;h2 id="breakpoint-상황을-출력하기">Breakpoint 상황을 출력하기&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="mi">10&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sAddr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">aSize&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="mi">11&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">sAddr&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">12&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드에서 if 문에 breakpoint 를 걸고, 할당받은 시작 주소와 그 크기를 보고자 한다. 한두번 발생하는 거라면 breakpoint 를 걸어 둔 다음 print 나 graph display (ddd 전용) 으로 띄워서 관찰하면 된다. 그런데 이게 100번 200번이면 하염없이 엔터를 치게 된다.&lt;/p>
&lt;p>이럴 때 다음과 같이 입력한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> b &lt;span class="m">10&lt;/span> &lt;span class="c1"># 10번째 라인에 breakpoint&lt;/span>
&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> commands &lt;span class="c1"># 아무 것도 입력하지 않으면 최근 breakpoint 에 대한 command 입력&lt;/span>
&amp;gt; silent &lt;span class="c1"># breakpoint 에 멈췄단 메시지를 출력하지 말아달라&lt;/span>
&amp;gt; &lt;span class="nb">printf&lt;/span> &lt;span class="s2">&amp;#34;alloc address is %p\n and its size is %ld&amp;#34;&lt;/span>, *sAddr, aSize
&amp;gt; cont &lt;span class="c1"># 흔히 입력하는 cont 와 동일하다.&lt;/span>
&amp;gt; end &lt;span class="c1"># command 입력 종료&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이러고 cont 를 날리면.. breakpoint 에서 멈추는 대신 해당 command 가 수행된다! 즉, 계속해서 주소와 할당 크기가 출력된다. 아주 편하다…&lt;/p>
&lt;h2 id="call-stack-보기">Call Stack 보기&lt;/h2>
&lt;p>일종의 응용인데, commands 내부에는 우리가 흔히 쓰는 명령어를 입력하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> commands
&amp;gt; silent
&amp;gt; bt &lt;span class="m">5&lt;/span> &lt;span class="c1"># backtrace (callstack) 을 출력하되, 안쪽에서 5개 까지만 출력&lt;/span>
&amp;gt; cont
&amp;gt; end
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="commands-의-초기화">Commands 의 초기화&lt;/h2>
&lt;p>commands 명령어를 입력한 다음, 바로 end 로 끝내면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> commands
&amp;gt; end
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Intel VTune Memory Bandwidth 분석하기</title><link>https://interp.blog/vtune-memory-bandwidth/</link><pubDate>Mon, 22 Jan 2018 05:19:48 +0000</pubDate><guid>https://interp.blog/vtune-memory-bandwidth/</guid><description>&lt;p>Intel VTune 으로 Memory Bandwidth 를 분석하려면, 분석할 수 있는 커널 드라이버를 로딩시켜야 한다. (참고로 메모리 분석은 리눅스에서만 가능하다.) 해당 작업을 하지 않고 &amp;lsquo;General Exploration &amp;gt; Analyze memory bandwidth&amp;rsquo; 를 체크하면 엄한 경고창이 반길 것이다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/uploads/2018/01/before.jpg"
loading="lazy"
>&lt;/p>
&lt;p>&lt;a class="link" href="https://software.intel.com/en-us/vtune-amplifier-help-building-and-installing-the-sampling-drivers-for-linux-targets" target="_blank" rel="noopener"
>이 문서&lt;/a>를 참고해도 좋지만, VTune 이 설치된 경로에서 &lt;code>sepdk/src/README.txt&lt;/code> 를 보는 게 더 쉽다. 이 내용을 요약하면,&lt;/p>
&lt;ol>
&lt;li>커널 환경변수를 체크한다. 프로파일링이 가능하고 모듈 로딩이 가능해야 한다.
&lt;ul>
&lt;li>&lt;code>CONFIG_MODULES=y&lt;/code>&lt;/li>
&lt;li>&lt;code>CONFIG_MODULE_UNLOAD=y&lt;/code>&lt;/li>
&lt;li>&lt;code>CONFIG_PROFILING=y&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>커널 드라이버를 컴파일시킬 헤더파일이 필요하다. Linux 배포판에 따라, 커널 개발용 패키지를 내려받아 설치한다.&lt;br>
(언급한 Linux 배포판이 없으면 소스를 직접 받아둔다.)
&lt;ul>
&lt;li>Redhat 5/Fedora/CentOS : &lt;code>yum install kernel-devel&lt;/code>&lt;/li>
&lt;li>Ubuntu/Debian : &lt;code>apt-get install build-essential linux-headers-`uname-r`&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>VTune이 필요로 하는 커널 드라이버를 컴파일하고 로드시킨다.
&lt;ul>
&lt;li>&lt;code>cd ${VTune Directory}/spedk/src&lt;/code>&lt;/li>
&lt;li>&lt;code>./build_driver&lt;/code> (이 때 2번에서 설치한 커널 헤더파일의 위치를 정확히 입력해야 한다.)&lt;/li>
&lt;li>&lt;code>./insmod-sep3&lt;/code>
&lt;ul>
&lt;li>로딩 확인을 위해서는 &lt;code>./insmod-sep3 -q&lt;/code> 라고 입력해 보자.&lt;/li>
&lt;li>언로딩 시키려면 &lt;code>./rmmod-sep3&lt;/code> 이라고 입력하자.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Office 2016 커서 애니메이션 끄기</title><link>https://interp.blog/office-2016-%EC%BB%A4%EC%84%9C-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%81%84%EA%B8%B0/</link><pubDate>Tue, 16 Jan 2018 12:14:29 +0000</pubDate><guid>https://interp.blog/office-2016-%EC%BB%A4%EC%84%9C-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%81%84%EA%B8%B0/</guid><description>&lt;img src="https://interp.blog/images/2018-01-16-office-animation-off/office-animation.jpg" alt="Featured image of post Office 2016 커서 애니메이션 끄기" />&lt;p>Office 2016 부터인지 모르겠지만, 커서가 부드럽게 움직이는 애니메이션이 추가되었다. 실제 입력 속도는 같을지 모르겠는데, 문서 작업을 하고 있자니 조금 답답한 느낌이 들었다. 조금 느리게 입력되는 느낌? 처음에는 엑셀에서 셀 이동 할 때만 그런 줄 알았더니, 파워포인트나 워드를 작업할 때도 신경이 쓰였다. 그래서 이걸 끌 수 있는 방법을 두 가지 찾았는데, 하나는 레지스트리를 수정하는 방법이라 엄청나게 귀찮았다. 다른 하나는 그 것보단 간단했다.&lt;/p>
&lt;p>아래 스크린샷 순서대로 따라가 체크를 해제하면 된다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;ol>
&lt;li>제어판 &amp;gt; 시스템으로 들어간 다음, 고급 시스템 설정으로 들어간다.&lt;/li>
&lt;li>고급 탭에서, 성능 항목에 &amp;lsquo;설정…&amp;rsquo; 을 클릭한다.&lt;/li>
&lt;li>&amp;lsquo;시각 효과&amp;rsquo; 탭에서, 창의 제어 및 요소에 애니메이션 효과 추가 항목의 체크를 해제한다. 그리고 확인.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://interp.blog/images/2018-01-16-office-animation-off/blog.png"
loading="lazy"
>&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="6929871144"
data-ad-format="auto"
data-full-width-responsive="true">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/></description></item><item><title>Gitlab 아바타/첨부파일 상대 경로 설정</title><link>https://interp.blog/gitlab-%EC%95%84%EB%B0%94%ED%83%80-%EC%83%81%EB%8C%80-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95/</link><pubDate>Mon, 08 Jan 2018 02:35:20 +0000</pubDate><guid>https://interp.blog/gitlab-%EC%95%84%EB%B0%94%ED%83%80-%EC%83%81%EB%8C%80-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95/</guid><description>&lt;p>사내 사정으로 인해 Gitlab의 &lt;code>External_Url&lt;/code> 을 실제 서버 주소와 다르게 설정해서 쓰고 있다.&lt;/p>
&lt;p>물론 실제 nginx 에도 해당 도메인으로 접근할 수 있도록 설정해야 하는 게 맞다. 그렇지 않으면, 첨부파일과 아바타 이미지가 모두 깨져나온다. 하지만 그러기 전에 Gitlab 차원에서 상대 경로로 아바타를 출력할 수 있도록 수정하는 방법 &amp;lsquo;도&amp;rsquo; 있으니 편법으로 수정했다. 아래는 그 편법 내용을 다룬다.&lt;/p>
&lt;h2 id="아바타-상대-경로-설정">아바타 상대 경로 설정&lt;/h2>
&lt;p>&lt;code>/opt/gitlab/embedded/service/gitlab-rails/app/models/concerns/avatarable.rb&lt;/code> 파일에서 절대 경로로 수정하는 코드가 있는데, url_base 에 덧붙이는 코드들을 전부 주석처리하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">module&lt;/span> &lt;span class="nn">Avatarable&lt;/span>
&lt;span class="kp">extend&lt;/span> &lt;span class="no">ActiveSupport&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Concern&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">avatar_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">only_path&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">unless&lt;/span> &lt;span class="nb">self&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="ss">:avatar&lt;/span>&lt;span class="o">].&lt;/span>&lt;span class="n">present?&lt;/span>
&lt;span class="n">asset_host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">ActionController&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Base&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">asset_host&lt;/span>
&lt;span class="n">use_asset_host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">asset_host&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">present?&lt;/span>
&lt;span class="c1"># Avatars for private and internal groups and projects require authentication to be viewed,&lt;/span>
&lt;span class="c1"># which means they can only be served by Rails, on the regular GitLab host.&lt;/span>
&lt;span class="c1"># If an asset host is configured, we need to return the fully qualified URL&lt;/span>
&lt;span class="c1"># instead of only the avatar path, so that Rails doesn&amp;#39;t prefix it with the asset host.&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">use_asset_host&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">respond_to?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:public?&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="kp">public&lt;/span>&lt;span class="p">?&lt;/span>
&lt;span class="n">use_asset_host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;span class="n">only_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="n">url_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
&lt;span class="c1"># if use_asset_host&lt;/span>
&lt;span class="c1"># url_base &amp;lt;&amp;lt; asset_host unless only_path&lt;/span>
&lt;span class="c1"># else&lt;/span>
&lt;span class="c1"># url_base &amp;lt;&amp;lt; gitlab_config.base_url unless only_path&lt;/span>
&lt;span class="c1"># url_base &amp;lt;&amp;lt; gitlab_config.relative_url_root&lt;/span>
&lt;span class="c1"># end&lt;/span>
&lt;span class="n">url_base&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">avatar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>당연히 &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 를 해 줘야 한다.&lt;/p>
&lt;p>참고 : &lt;a class="link" href="https://gitlab.com/gitlab-org/gitlab-ce/merge" target="_blank" rel="noopener"
>https://gitlab.com/gitlab-org/gitlab-ce/merge&lt;/a>_requests/11001/diffs#note_28659864&lt;/p>
&lt;h2 id="첨부파일-상대-경로-설정">첨부파일 상대 경로 설정&lt;/h2>
&lt;p>단서가 없어서 맨땅에 헤딩하듯이 뒤지고 다녔다. Markdown 언어에서 링크를 담당하는 라이브러리가 있는데, 이름이 &amp;lsquo;&lt;strong>banzai&lt;/strong>&amp;rsquo; 이다 (…) &lt;span style="color: #808080;">&lt;del>무슨 생각으로 이름을 지은건지 도저히 모르겠지만&lt;/del>&lt;/span> 여기를 수정해야 한다.&lt;/p>
&lt;p>&lt;code>filter/upload_link_filter.rb&lt;/code> 를 보면, &lt;code>build_url()&lt;/code> 이란 함수가 있다. 여기서 Geo node 여부에 따라 base_path 를 설정하는 코드가 있는데, 여기서 원하는 내부 주소로 변경하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">def&lt;/span> &lt;span class="nf">build_url&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uri&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">base_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="no">Gitlab&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Geo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">secondary?&lt;/span>
&lt;span class="no">Gitlab&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Geo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">primary_node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="c1"># Gitlab.config.gitlab.url&lt;/span>
&lt;span class="s2">&amp;#34;http://your.address.com/&amp;#34;&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">group&lt;/span>
&lt;span class="n">urls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">Gitlab&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Routing&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url_helpers&lt;/span>
&lt;span class="c1"># we need to get last 2 parts of the uri which are secret and filename&lt;/span>
&lt;span class="n">uri_parts&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">uri&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">File&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">SEPARATOR&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">file_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">urls&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">show_group_uploads_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">group&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uri_parts&lt;/span>&lt;span class="o">[-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uri_parts&lt;/span>&lt;span class="o">[-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="no">File&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">base_path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">file_path&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="no">File&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">base_path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">project&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">full_path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uri&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Gitlab 11 버전 으로 업그레이드 되면서부터 해당 파일은 삭제되고, &lt;code>absolute_link_filter.rb&lt;/code> 와 &lt;code>external_link_filter.rb&lt;/code> , &lt;code>relative_link_filter.rb&lt;/code> 가 남아있다. 여기 있는 &lt;code>Gitlab.config.gitlab.url&lt;/code> 을 원하는 주소로 바꿔주면 가능하다. (relative.rb 의 경우 &lt;code>Gitlab.config.gitlab.base_url&lt;/code>)&lt;/p></description></item><item><title>대화는 필요해</title><link>https://interp.blog/%EB%8C%80%ED%99%94%EB%8A%94-%ED%95%84%EC%9A%94%ED%95%B4/</link><pubDate>Fri, 05 Jan 2018 04:48:10 +0000</pubDate><guid>https://interp.blog/%EB%8C%80%ED%99%94%EB%8A%94-%ED%95%84%EC%9A%94%ED%95%B4/</guid><description>&lt;img src="https://interp.blog/uploads/2018/01/exhibition_see_visitors_gallery_museum_art-1035105.jpgd_.jpg" alt="Featured image of post 대화는 필요해" />&lt;p>매니저 자리에 처음 앉았을 때와 다르게, 언젠가부터 남과 대화하는 것을 기피하는 내 모습을 자주 발견하게 되었다. 의욕이 넘쳐서 이거저거 캐묻고 알아가던 때가 있었는데, 그러면서 반발도 부딪히고 구성원들이 나만큼 의욕적이지 않은 것 같고, 의심하고 실망하고를 반복하다 보니 이렇게 된 것 일까. &amp;lsquo;지쳤다&amp;rsquo; 나 &amp;lsquo;질렸다&amp;rsquo; 라고 해도 괜찮을 수준이었다.&lt;/p>
&lt;p>그런데 대화를 그만두면 더 좋지 않은 것 같다. 그냥 시간을 버리는 것 같다. 대화가 멈추면, 서로가 원하는 것을 모르고 각자 하고 싶은 대로 흘러간다.&lt;/p>
&lt;p>대화를 해서 손해를 보는 경우도 있다. 감정이 상할 수도 있다. 하지만 그 차이를 나도 양보하고 너도 양보해서 맞춰야 한다. 대화를 자주 해서 업무 방해가 일어난다거나, 쓸데없는 일이라고 여겨질 수도 있겠는데… 서로 대화하지 않고 흘러가게 두는 것이, 더 큰 손해를 끼칠 가능성이 높다고 생각한다.&lt;/p>
&lt;p>그래서 오늘도, 대화하기 싫어하는 나를 달래가며 다른 사람들에게 말해야 할 가장 적절한 질문과 주제를 찾고 있다.&lt;/p></description></item><item><title>Gitlab Markdown Parser 고치기</title><link>https://interp.blog/gitlab-markdown-parser-configuration/</link><pubDate>Wed, 03 Jan 2018 02:29:21 +0000</pubDate><guid>https://interp.blog/gitlab-markdown-parser-configuration/</guid><description>&lt;p>Github 과 비슷한 서비스인 &lt;a class="link" href="https://about.gitlab.com/" target="_blank" rel="noopener"
>Gitlab&lt;/a> 은 오픈소스이기 때문에 Community Edition 을 쓰건, Enterprise Edition 을 쓰건 on-premise 환경에서 설치한 뒤 마음대로 수정해서 사용이 가능하다. 수정하는 범위를 한정하지 않는다면, 루비 (&lt;code>*.rb&lt;/code>) 파일까지 건드릴 수 있다.&lt;/p>
&lt;p>여기서는 Gitlab에서 문서 작성에 필요한 Markdown 의 Parser 부분을 미세하게 수정해서, 입맛에 맞게 바꾸기 위한 방법을 정리해 둔다. Ruby 개발자가 아니라서 전체 순서가 정공법처럼 보이진 않겠지만.&lt;/p>
&lt;h1 id="그런데-뭘-수정하나요">그런데 뭘 수정하나요?&lt;/h1>
&lt;p>내가 수정하고 싶었던 내용은, E&lt;strong>nter 키를 한 번만 쳐도 줄이 바뀌도록 보이게 하는 것&lt;/strong>이었다. 원래 Markdown 문법에선 Enter 키를 두 번 치면 문단 바꿈, 줄 끝에 스페이스를 두 번 넣으면 줄바꿈이 된다. 그런데 Enter 키를 한 번만 쳐도 줄바꿈이 되면 좋겠다는 개발자가 많았다. &lt;del>저기요, Markdown 안 써보셨어요? 라고 따질 순 없었다&lt;/del>&lt;/p>
&lt;h1 id="gitlab-10x--redcarpet">Gitlab 10.x : Redcarpet&lt;/h1>
&lt;p>Gitlab 10.x 에서는 Markdown Parser 를 &lt;a class="link" href="https://github.com/vmg/redcarpet" target="_blank" rel="noopener"
>Redcarpet&lt;/a> 으로 사용한다. 아마 &lt;a class="link" href="https://jekyllrb-ko.github.io/" target="_blank" rel="noopener"
>Jekyll&lt;/a> 도 기본적으로 Redcarpet 을 사용하는 것으로 알고 있다. 만약 Ruby의 Redcarpet 을 Markdown Parser 로 쓰는 경우라면 똑같이 적용이 가능하다.&lt;/p>
&lt;h2 id="parser-c-파일-수정하기">Parser C 파일 수정하기&lt;/h2>
&lt;p>&lt;code>/opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/redcarpet-3.4.0/&lt;/code> 으로 들어가면 Redcarpet의 소스코드가 존재한다. 여기서 &lt;code>ext/redcarpet&lt;/code> 디렉토리가 Parser C 파일들이 위치한 곳이다.&lt;/p>
&lt;p>여기 &lt;code>markdown.c&lt;/code> 파일을 보니 &lt;code>char_linebreak()&lt;/code>  라는 함수가 존재한다. 여기서 해당 부분을 주석처리했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="cm">/* char_linebreak • &amp;#39;\n&amp;#39; preceded by two spaces (assuming linebreak != 0) */&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="n">size_t&lt;/span>
&lt;span class="nf">char_linebreak&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">buf&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="nc">sd_markdown&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rndr&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">uint8_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">size_t&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">size_t&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//if (offset &amp;lt; 2 || data[-1] != &amp;#39; &amp;#39; || data[-2] != &amp;#39; &amp;#39;)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// return 0; /* removing the last space from ob and rendering */
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">rndr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">cb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">linebreak&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rndr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">opaque&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="라이브러리-생성복사">라이브러리 생성/복사&lt;/h2>
&lt;p>수정이 끝나면 반드시 &lt;code>ext/redcarpet&lt;/code> 디렉토리에서 &lt;code>make&lt;/code> 를 수행해 주도록 하자. 그러면 Shared Library 파일인 &lt;code>redcarpet.so&lt;/code> 이 생성된다.&lt;/p>
&lt;p>이 파일을, 다음 경로에 모두 복사해주도록 하자.&lt;/p>
&lt;ul>
&lt;li>&lt;code>/opt/gitlab/embedded/lib/ruby/gems/2.3.0/extensions/x86_64-linux/2.3.0/redcarpet-3.4.0/&lt;/code>&lt;/li>
&lt;li>&lt;code>/opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/redcarpet-3.4.0/lib/&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="gitlab-재부팅">Gitlab 재부팅&lt;/h2>
&lt;p>마지막으로 &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 를 실행시켜 Gitlab 을 재부팅 하자.&lt;/p>
&lt;h1 id="gitlab-11x-이후--commonmark">Gitlab 11.x 이후 : Commonmark&lt;/h1>
&lt;p>11.x 부터는 Redcarpet 이 아니라 Commonmark 를 기본 파서로 사용한다. 구조가 달라져서 찾는게 귀찮아서 그렇지, 기본 원리는 비슷하다. 2칸 이상의 space 를 준 채로 줄바꿈하게 되면 &lt;code>CMARK_NODE_LINEBREAK&lt;/code>, 그렇지 않고 줄바꿈하면 &lt;code>CMARK_NODE_SOFTBREAK&lt;/code> 상태로 전이된다.&lt;/p>
&lt;p>옵션을 알아보고 정확히 적용했다면 더 없이 깔끔했겠지만, 나는 마음이 급했기 때문에 참고할 만한 소스코드만 붙이고 그만두기로 했다.&lt;/p>
&lt;p>&lt;code>html.c:283&lt;/code> 부터다. 여기서 직접 줄바꿈을 하도록 강제했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">case&lt;/span> &lt;span class="nl">CMARK_NODE_SOFTBREAK&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">options&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">amp&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">CMARK_OPT_HARDBREAKS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">cmark_strbuf_puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;br/&amp;gt;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">options&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">amp&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">CMARK_OPT_NOBREAKS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// cmark_strbuf_putc(html, &amp;#39; &amp;#39;); // 수정 전
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cmark_strbuf_puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;br/&amp;gt;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 수정 후
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">cmark_strbuf_putc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 하고 make 를 쳤더니, 어라? 빌드가 안 된다. 이 때는 banzai filter 가 위치한 곳의 ruby 파일을 수정하면 된다. &lt;code>/opt/gitlab/embedded/service/gitlab-rails/&lt;/code> 까지 들어간 다음 &lt;code>lib/banzai/filter/markdown_engines/common_mark.rb&lt;/code> 을 편집한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="no">RENDER_OPTIONS&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>
&lt;span class="ss">:DEFAULT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1"># default rendering system. Nothing special.&lt;/span>
&lt;span class="ss">:HARDBREAKS&lt;/span> &lt;span class="c1"># Treat `\n` as hardbreaks (by adding `&amp;lt;br/&amp;gt;`). # 이 옵션을 추가한다.&lt;/span>
&lt;span class="o">].&lt;/span>&lt;span class="n">freeze&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>반드시, Gitlab 재부팅을 잊지말자! &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 이다. Commonmark 는 라이브러리를 수정한 것이 아니라서 &lt;code>make&lt;/code> 같은 건 안 해도 된다.&lt;/p>
&lt;p>이 방법으로 했을 때 한 가지 아쉬운 점은(?) 일부러 soft break 를 시도하는 경우에, 내부에서 line break 까지 겹쳐서 인식하기 때문에 결론적으로 &lt;code>&amp;lt;br/&amp;gt;&lt;/code> 이 두번 붙는 사태가 일어난다. 깔끔하게 &lt;code>&amp;lt;p&amp;gt;&lt;/code> 로 감싼 문단을 얻고 싶을 때는 이 방법이 소용이 없어서, 어쩔 수 없이 commonmark 를 한번 빌드하는 수밖에 없나.. 하는 생각이 들었다.&lt;/p></description></item><item><title>oh-my-zsh 색깔 고르기</title><link>https://interp.blog/oh-zsh-%EC%83%89%EA%B9%94-%EA%B3%A0%EB%A5%B4%EA%B8%B0/</link><pubDate>Wed, 13 Dec 2017 05:43:01 +0000</pubDate><guid>https://interp.blog/oh-zsh-%EC%83%89%EA%B9%94-%EA%B3%A0%EB%A5%B4%EA%B8%B0/</guid><description>&lt;p>oh-my-zsh 테마 작업을 agnoster 를 기반으로 고쳐서 사용 중이다. 그런데 주석을 보면 다음 색깔만 지원하는 것 처럼 나온다.&lt;/p>
&lt;blockquote>
&lt;p>white, black, red, blue, green, yellow, cyan, magenta&lt;/p>
&lt;/blockquote>
&lt;p>위의 색깔 외에 다른 색상을 설정하려면, 다음 작업이 필요하다.&lt;/p>
&lt;ul>
&lt;li>터미널 종류가 xterm-256color 여야 한다. (xterm 으로 설정되어 있으면 제대로 출력이 안된다.)&lt;/li>
&lt;li>oh-my-zsh 에서, &lt;code>%{%K{---}%}&lt;/code> 또는 &lt;code>%{%F{---}%}&lt;/code> 를 가지고 색깔을 찾는다. 이 때 &lt;code>---&lt;/code> 대신 0~255 사이의 숫자를 입력한다.&lt;/li>
&lt;li>0~255 숫자와 대응되는 색상을 찾아야 하는데, &lt;a class="link" href="https://jonasjacek.github.io/colors/" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/li>
&lt;/ul></description></item><item><title>‘왜’에서 찾는 특별한 나</title><link>https://interp.blog/%EC%99%9C%EC%97%90%EC%84%9C-%EC%B0%BE%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%EB%82%98/</link><pubDate>Mon, 11 Dec 2017 03:20:57 +0000</pubDate><guid>https://interp.blog/%EC%99%9C%EC%97%90%EC%84%9C-%EC%B0%BE%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%EB%82%98/</guid><description>&lt;p>이제 자기계발서들은, 목표에 대한 진척을 강요하거나 쥐어짜려는 설득을 더 이상 하지 않게 되었다. 아니면, 그런 글귀와 말을 사람들이 더 이상 찾지 않는 것일지도 모른다. 사람들이 열광하는 주제가, 맹목적인 믿음이나 노력을 채찍질하는 것에서 벗어나 자신에 대한 탐구로 옮겨가고 있는 것처럼 보인다. &amp;lsquo;어떻게&amp;rsquo; 라기 보다는 &amp;lsquo;왜&amp;rsquo; 에 좀 더 가까운 것 같다.&lt;/p>
&lt;h3 id="어떻게-가-아닌-왜">&amp;lsquo;어떻게&amp;rsquo; 가 아닌, &amp;lsquo;왜&amp;rsquo;&lt;/h3>
&lt;p>조금만 시간을 거슬러 올라가도 공부에 대한 방법론, 단기간에 끝내기, 맹목적으로 바라보기, 노력은 배신하지 않는 등의 주제가 가득했다. 공부 잘 하면 좋고, 노력은 배신하지 않는 것도 동의한다. 그런데 그걸 왜 하냐고, 설마 남 좋으라고 하는건가? 그 흐름에 나를 넣어야 하는데, 그렇지 않다면 과연 자기계발이 맞는 걸까?&lt;/p>
&lt;p>최근 자기계발서의 내용들은 그렇지가 않다. 남 눈치보지 말자, 내 인생은 내가 책임진다, 모두가 날 좋아할 수는 없다, 뭐 이런 거다. 일종의 위로이자 응원이다. &lt;a class="link" href="https://www.youtube.com/watch?v=VnSMIgsPj5M" target="_blank" rel="noopener"
>베네딕트 컴베비치가 레터스라이브에서 매우 격앙된 어조로 낭독한 영상&lt;/a>을 줄이면 &lt;em>&amp;lsquo;남에게 눈치보지 말고 그냥 해라고!'&lt;/em> 라는 것이었다. 화난 듯 말하지만, 사실은 위로이자 응원이다. 남에게 눈치보고 있다는 것은, 말 그대로 내가 아닌 남이 원하는 삶을 살고 있는 것이다. 그냥 해보라는 말도, 뭘 하고 싶고 뭘 할 수 있는지 찾아서 하라는 것이다.&lt;/p>
&lt;h3 id="내가-한-일은-남들도-다-할-수-있다">내가 한 일은 남들도 다 할 수 있다&lt;/h3>
&lt;p>목 마른 사람이 우물을 파겠지만, 지금껏 우리는 우물을 어떻게 파느냐, 어디에 우물이 잘 나오느냐만 들었을 뿐이다. 정말 목이 마른지, 배가 고픈지, 잠이 오는지는 생각해보지 못한 게 아닐까. 다른 사람과 다른 &amp;lsquo;나&amp;rsquo; 이기 때문에.&lt;/p>
&lt;p style="text-align: left;">
내가 할 수 있는 일은, 남들도 다 할 수 있다.&lt;br /> &lt;strong>그렇지만, 남들이 하지 않기 때문에 내가 특별하다.&lt;/strong>
&lt;/p>
&lt;p>이런 장황한 이야기를 한 이유는 두 가지이다. 다른 모든 사람이 각자 누리고 있는 우물을 나도 파내서 마시기엔 시간이 부족하다는 점을 인정하기 위해, 그리고 나만의 특별함을 강조하기 위해서다. 살면서 느꼈던, 소중한 경험을 잘 간직하고 계속 행복할 수 있는 방법을 찾아나가는 것을, &amp;lsquo;어떻게&amp;rsquo; 라는 주위에 널린 해답에서는 찾지 말길 바란다.&lt;/p></description></item><item><title>X11 on Windows Linux Subsystem</title><link>https://interp.blog/x11-windows-linux-subsystem/</link><pubDate>Wed, 29 Nov 2017 08:32:52 +0000</pubDate><guid>https://interp.blog/x11-windows-linux-subsystem/</guid><description>&lt;p>먼저, Windows 10 에서 지원하는 Linux Subsystem 기능에 대해 이야기한다. 잘 모르겠다면 &lt;a class="link" href="https://msdn.microsoft.com/en-us/commandline/wsl/install-win10" target="_blank" rel="noopener"
>이 글&lt;/a>을 읽고 설치에 도전해 보자. &lt;span style="color: #999999;">&lt;del>그런데 글 내용을 보면 이거랑 관련 없다. Babun, Mintty, Git on Bash, Putty 전부 포함이다&lt;/del>&lt;/span>&lt;/p>
&lt;ul>
&lt;li>SSH에 접속한 서버에서 X11 Forwarding 을 받고 싶은 경우를 이야기한다. 단적으로, 접속한 서버에서 파이어폭스 브라우저를 실행하면 내 윈도우 화면에 브라우저 창이 실행되는 거다. 이걸 따로 이야기하고 싶지 않으니 &lt;a class="link" href="https://www.google.co.kr/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=0ahUKEwj1yoOCrePXAhWCG5QKHeIRCkEQFggkMAA&amp;amp;url=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fxming%2F&amp;amp;usg=AOvVaw2r18vOyEGzisW0WiHH4ksg" target="_blank" rel="noopener"
>Xming&lt;/a> 이나 &lt;a class="link" href="https://www.google.co.kr/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=0ahUKEwj-y9aGrePXAhUJoZQKHXKpB2IQFggkMAA&amp;amp;url=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fvcxsrv%2F&amp;amp;usg=AOvVaw2UIxI0S4LFsqeqk9A47MSR" target="_blank" rel="noopener"
>VcXsrv&lt;/a> 을 참고해 설치해보자.&lt;/li>
&lt;/ul>
&lt;p>참고로, 이 방법은 Client측 PC의 X Server로 접근하는 무식한 방법이므로, 일반 데스크탑 PC에서 서버로 접속했을 때엔 사용할 수 없을 것 같다. 좀 더 알아보고 보충해야겠다.&lt;/p>
&lt;p>그리고, ssh_config 에서 &lt;code>X11ForwardTrusted&lt;/code> 를 확인하지 않았었다. 이걸 설정하니까 Server에서 DISPLAY를 따로 설정하지 않아도 잘 된다? &lt;code>xauth generate&lt;/code> 를 한번 더 해보긴 했는데.. 한번 더 실험이 필요하다.&lt;/p>
&lt;h2 id="windows에서-한-일">Windows에서 한 일&lt;/h2>
&lt;p>클라이언트 PC에서 작업한 일이다. 참고로 나는 Ubuntu 를 Linux Subsystem 으로 설치했는데, 어느 리눅스 버전이어도 상관 없을 것이다.&lt;/p>
&lt;ol>
&lt;li>Xming 또는 VcXsrv 를 설치해서 실행시켰다. 트레이 아이콘에 &amp;lsquo;X&amp;rsquo; 라고 떠 있으면 완료. (이걸 X Server 라고 부른다)&lt;/li>
&lt;li>Ubuntu Console을 하나 열어서,&lt;code>/etc/ssh/ssh_config&lt;/code> (sshd_config 가 아니다) 파일을 확인했다. 여기에서 ForwardX11 yes, ForwardX11Trusted yes 를 확인했다. (주석 처리되어 있다면 주석을 제거, sudo 권한 필요)&lt;/li>
&lt;li>SSH 접속을 하면, 다음 에러 메시지가 떠서 보기 싫었다.
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">No xauth data; using fake authentication data for X11 forwarding.
&lt;/code>&lt;/pre>&lt;/div>그래서 다음과 같이 처리했다.
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ xauth list &lt;span class="c1"># ~/.Xauthority 파일이 없었다!&lt;/span>
$ xauth generate :0 . trusted &lt;span class="c1"># ~/.Xauthority 파일을 만들어준다고 한다..&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>(Optional) Xming 또는 VcXsrv 의 설치 디렉토리에 가면 &lt;code>X0.hosts&lt;/code>라는 파일이 있다. 여기서 Server의 Hostname 또는 IP를 적어줘야 한다.&lt;/li>
&lt;/ol>
&lt;h2 id="server에서-한-일">Server에서 한 일&lt;/h2>
&lt;p>직접 SSH로 접속하고 나서 설정해야 할 것을 적었다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>/etc/ssh/sshd_config&lt;/code> 에서 &lt;code>X11UseLocalHost&lt;/code> 가 yes 로 되어 있거나, 활성화되어 있지 않아야 한다. 만약 no로 되어 있으면 yes 로 변경해야 한다.&lt;/li>
&lt;li>&lt;code>$DISPLAY&lt;/code> 환경 변수를 아예 Windows (클라이언트 PC) 의 Hostname 또는 IP 주소로 설정해버린다.
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">export&lt;/span> &lt;span class="nv">DISPLAY&lt;/span>&lt;span class="o">=&lt;/span>192.168.0.xxx:0
&lt;/code>&lt;/pre>&lt;/div>참고로, 뒤에 :0 또는 :10 같이 여러 예제가 인터넷에 나도는데, Windows 에서 X 아이콘에 마우스를 가져다 대면 &lt;code>Hostname:X.X&lt;/code> 라고 나올 것이다. X.X 를 저기에 쓰는 것이다. (나는 0.0 이라고 떠서 그냥 0만 적었다.)&lt;/li>
&lt;li>firefox 를 실행해 보자. 끝.&lt;/li>
&lt;/ol></description></item><item><title>C# xUnit 실습</title><link>https://interp.blog/csharp-xunit-practice/</link><pubDate>Wed, 29 Nov 2017 03:28:03 +0000</pubDate><guid>https://interp.blog/csharp-xunit-practice/</guid><description>&lt;p>대학생 때 팀 프로젝트로 윈도우 어플리케이션을 끄적이던 때가 있었다. 그 때 C# 기반으로 진행했었는데, 나는 뷰에 집중했던지라 디자인하고 프로퍼티 만지기 바빴고 뼈대는 다른 친구가 만들어 줬었던 기억이 난다. 그 때부터 C/C++ 와는 다르지만 비슷한 이름의 이 언어에 왠지 모를 끌림이 있었다. 하지만 배울 기회는 없었지..&lt;/p>
&lt;p>바로 그 언어, C#을 현업에서 당장 써먹어야 하는 상황이 발생했다. (이런 상황이 왜 발생했는지 한탄은 나중에 일단 하기로 하고) 어쩔 수 없이 배움의 기회로 삼는 수 밖에 없다.&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.microsoft.com/ko-kr/dotnet/core/testing/unit-testing-with-dotnet-test" target="_blank" rel="noopener"
>dotnet test 및 xUnit을 사용하여 .NET Core에서 C# 유닛 테스트&lt;/a>라는 MS 문서를 기반으로 실습을 했는데, 여기서 중요한 것은, 내가 만들어야 하는 라이브러리의 Target Framework가 .NET Core 가 아니라 .NET Framework 4.0 이다. xUnit은 최소 .NET Framework 4.5 이상에서만 돌아간다.&lt;/p>
&lt;p>그럼 나는 테스트를 못 하는 것인가? 실제론 그렇지는 않았다. xUnit 프로젝트만 .NET Framework 4.5 로 두고, 라이브러리 프로젝트는 .NET Framework 4.0 으로 설정해서 테스트를 진행해 봤다. 대부분의 내용은 위의 문서를 요약한 것에 지나지 않지만, 중간에 Target Framework를 설정하는 부분에 대해서도 설명하겠다.&lt;/p>
&lt;h2 id="사전-준비">사전 준비&lt;/h2>
&lt;p>혹시나 해서 적어둔다. 다 필요없고 .NET Core SDK 를 설치해주자.&lt;/p>
&lt;ul>
&lt;li>.NET Framework 4.0, .NET Framework 4.5 SDK 가 설치되어 있어야 한다. (Visual Studio 설치하면서 같이 설치하는게 속편하다)&lt;/li>
&lt;li>.NET Framework 4.5 이후의 TargetFramework를 가져가는 경우엔 .NET Core SDK 를 설치하는 것으로 끝날지도 모른다는 어렴풋한 추측을 해 본다. (Target Framework를 수정한 다음 dotnet restore 를 하면?)&lt;/li>
&lt;/ul>
&lt;p>그리고 아래 실습은 Visual Studio 가 아니라 Powershell 에서 진행한다. 사내 빌드할 때 Visual Studio를 안 쓰기 때문이다. 단지 그 뿐이다..&lt;/p>
&lt;h2 id="솔루션프로젝트-준비">솔루션/프로젝트 준비&lt;/h2>
&lt;ol>
&lt;li>디렉토리를 하나 만든다. 여기서는 &lt;code>testSolution&lt;/code> 라고 하자.&lt;/li>
&lt;li>&lt;code>dotnet new sln&lt;/code> 을 실행한다. 솔루션 파일이 생성된다.&lt;/li>
&lt;li>내부에 디렉토리를 하나 만든다. 여기서는 &lt;code>projLibrary&lt;/code> 라고 하자.&lt;/li>
&lt;li>&lt;code>projLibrary&lt;/code> 에 들어가서 &lt;code>dotnet new classlib&lt;/code> 명령으로 프로젝트를 만든다. &lt;br>
&lt;code>classlib&lt;/code> 라고 입력하면 해당 프로젝트는 라이브러리를 생성하는 것이 된다.&lt;/li>
&lt;li>다시 &lt;code>testSolution&lt;/code> 디렉토리로 돌아와서, &lt;code>dotnet sln add projLibrary/projLibrary.csproj&lt;/code> 를 입력한다.&lt;br>
이제 솔루션에 해당 프로젝트가 등록된다.&lt;/li>
&lt;li>&lt;code>testSolution&lt;/code>내부에 테스트용 디렉토리를 하나 만든다. 여기서는 &lt;code>projTest&lt;/code> 라고 하자.&lt;/li>
&lt;li>&lt;code>projTest&lt;/code> 에 들어가서 &lt;code>dotnet new xuint&lt;/code> 를 입력해 테스트용 프로젝트를 만든다.&lt;br>
&lt;code>xuint&lt;/code> 라고 입력하면, 해당 프로젝트는 테스트를 위한 것이 된다.&lt;/li>
&lt;li>다시 &lt;code>testSolution&lt;/code> 디렉토리로 돌아와서, &lt;code>dotnet sln add projTest/projTest.csproj&lt;/code> 를 입력한다. 이제 솔루션에 해당 프로젝트가 등록된다.&lt;/li>
&lt;li>마지막으로 테스트 프로젝트에 라이브러리 프로젝트를 참조할 수 있도록 연결해야 한다.&lt;br>
&lt;code>projTest&lt;/code> 에 들어가서 &lt;code>dotnet add reference ../projLibrary/projLibrary.csproj&lt;/code> 를 입력한다.&lt;/li>
&lt;/ol>
&lt;p>그러면 아래와 같이 디렉토리와 파일이 구성되어야 한다. (자동으로 생성되는 &lt;code>Class1.cs&lt;/code> 는 제외했다.)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">/testSolution
testSolution.sln
/projLibrary
projLibrary.csproj
/projTest
&lt;span class="c1"># other referenced files (xunit)&lt;/span>
projTest.csproj
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="test-framework-수정">Test Framework 수정&lt;/h2>
&lt;p>&lt;code>projLibrary&lt;/code> 에 있는 &lt;code>projLibrary.csproj&lt;/code>를 열어서 아래를 수정한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;TargetFramework&amp;gt;&lt;/span>net40&lt;span class="nt">&amp;lt;/TargetFramework&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>만들고자 하는 프레임워크 버전을 명시하면 되고, 버전은 [여기][2]를 참고한다. 여러 개의 버전을 명시할 경우에는 세미콜론(;) 으로 구분하면 된다.&lt;/p>
&lt;p>역으로, &lt;code>projTest&lt;/code> 에 있는 &lt;code>projTest.csproj&lt;/code> 는 이렇게 수정해야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;TargetFramework&amp;gt;&lt;/span>net45&lt;span class="nt">&amp;lt;/TargetFramework&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>기본적으로 netcore2.0 으로 설정되어 있을텐데, 이러면 net40 과 호환이 안되어서 참조조차 안되는 불상사가 발생한다. net45 또는 그 이상의 .NET Framework를 지정하되, netcore1.x 에 대응되는 버전으로만 지정하면 될 것으로 보인다.&lt;/p>
&lt;h3 id="테스트-작성">테스트 작성&lt;/h3>
&lt;p>&lt;code>projLibrary&lt;/code>에서 Class1.cs 에 다음을 추가하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="k">using&lt;/span> &lt;span class="nn">System&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">namespace&lt;/span> &lt;span class="nn">ProjLibrary&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Class1&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">IsPrime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">candidate&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">NotImplem&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">span&lt;/span> &lt;span class="n">style&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="s">&amp;#34;display: inline-block; width: 0px; overflow: hidden; line-height: 0;&amp;#34;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="n">mce&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="s">&amp;#34;bookmark&amp;#34;&lt;/span> &lt;span class="n">class&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="s">&amp;#34;mce_SELRES_start&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="n">span&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="n">entedException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Please create a test first&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>아직 구현을 안 한 거다. 이제 &lt;code>projTest&lt;/code>에서 Class1.cs에 다음을 추가한다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="k">using&lt;/span> &lt;span class="nn">Xunit&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">using&lt;/span> &lt;span class="nn">ProjLibrary&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">namespace&lt;/span> &lt;span class="nn">Prime.UnitTests.Services&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">TestClass1&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">Class1&lt;/span> &lt;span class="m">_&lt;/span>&lt;span class="n">service&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="n">Class1_IsPrimeShould&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="m">_&lt;/span>&lt;span class="n">service&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Class1&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="na">
&lt;/span>&lt;span class="na"> [Fact]&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">ReturnFalseGivenValueOf1&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">var&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">_&lt;/span>&lt;span class="n">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">IsPrime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">Assert&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">False&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;1 should not be prime&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="테스트">테스트&lt;/h3>
&lt;p>다 끝났다. 이제 솔루션 디렉토리에서 &lt;code>dotnet test&lt;/code> 를 힘차게 불러보자.&lt;/p>
&lt;p>에러가 날 것이다. 당연히 테스트 코드에서 result 값이 FALSE가 나오기를 기대하는데, 지금은 그냥 Exception 으로 떨어지기 때문이다.&lt;/p>
&lt;p>&lt;code>projLibrary&lt;/code>에서 &lt;code>IsPrime()&lt;/code> 함수의 리턴을 FALSE로 바꿔주면 테스트가 성공하는 것을 확인할 수 있다.&lt;/p>
&lt;p>[1]:
[2]: &lt;a class="link" href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard" target="_blank" rel="noopener"
>https://docs.microsoft.com/en-us/dotnet/standard/net-standard&lt;/a>&lt;/p></description></item><item><title>Gitlab 10.x 삽질기</title><link>https://interp.blog/gitlab-%EC%82%BD%EC%A7%88%EA%B8%B0/</link><pubDate>Wed, 15 Nov 2017 09:17:58 +0000</pubDate><guid>https://interp.blog/gitlab-%EC%82%BD%EC%A7%88%EA%B8%B0/</guid><description>&lt;h2 id="upgrade">Upgrade&lt;/h2>
&lt;p>8.x 로 쓰다가 10.x 로 업그레이드를 진행했다. 아니.. 그런데 Postgresql Database 버전이 다르다고? 알고보니 이렇게 대격변을 일으키면 안 되던 거였다. 그래서 겸사겸사 9.5.10 으로 다시 설치하니까 된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>gitlab-ctl reconfigure&lt;/code> 를 설치 직후에 반드시 해 줘야 한다.&lt;/li>
&lt;li>가끔 &lt;code>gitlab-ctl pg-upgrade&lt;/code> 를 꼭 하라는 말이 있던데, 내가 해보니까 &lt;code>gitlab-ctl reconfigure&lt;/code> 할 때 알아서 한다 (…) 했던 거 또 하는 느낌.&lt;/li>
&lt;li>&lt;code>gitlab-ctl restart&lt;/code> 를 할 때 postgresql 이나 다른 곳에서 &amp;lsquo;down, up, want up&amp;rsquo; 이런 게 뜨면 서비스가 온전히 수행될 수 없는 상황이다. &lt;code>gitlab-ctl tail&lt;/code> 을 실행시켜 로그를 뒤져봐야 한다. 에러가 났거나, 무한히 반복되는 메시지가 없는지 확인하자.&lt;/li>
&lt;/ul>
&lt;h2 id="runner">Runner&lt;/h2>
&lt;p>우리 회사 Gitlab 구조는 웹 서비스 주소와 내부 공유 주소가 다르다. (도메인을 거의 리다이렉트 비슷하게 해놨기 때문이기도 하지만) 비공개 저장소다 보니, 웹 접속은 외부에서 되었면서 Clone 은 똑같은 주소로 절대 받을 수 없게 해 놨다. 이게 Gitlab Runner 를 바보로 만들었다 (…)&lt;/p>
&lt;p>Gitlab Runner는 &lt;code>.gitlab-ci.yml&lt;/code> 의 구성에 상관없이, 선작업으로 해당 저장소를 Cloning 하거나 Fetching 하게 된다. (양자택일은 웹 페이지의 Runner 관리 페이지에서 설정이 가능하다.) 이건 Runner의 Executer를 Docker를 하던 Shell 을 하던 똑같다. 문제는 내가 언급했던 대로, 이 저장소 주소를 웹 주소에 기반해서 가져가기 때문에, 항상 실패했다는 것이다.&lt;/p>
&lt;p>짜증이 치밀 즈음, 아예 이 작업을 끌 수는 없을까 하고 봤더니… 역시나 답은 있었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">variables:
GIT_STRATEGY: none
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 두면, Runner의 옵션을 Cloning 으로 줬건 Fetching 으로 줬건 간에 &lt;strong>하지 않는다&lt;/strong>.&lt;/p>
&lt;p>즉, 모든 작업을 온전히 CI 명령에 맡기는 것이다. 위험하기도 하고, 캐싱도 안 되고 약점이 많지만, 나는 상관이 없었다. 직접 내부 주소의 저장소로 접근해서 받아오면 그만!&lt;/p>
&lt;h3 id="repository-에-ssh-key-등록">Repository 에 SSH Key 등록&lt;/h3>
&lt;p>그런데, 문제가 생겼다. 아래와 같이 &amp;lsquo;gitlab-runner&amp;rsquo; 사용자로 Runner Service를 등록하고, 실행시켰다고 가정하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">gitlab-runner install --user gitlab-runner
gitlab-runner start
ps aux &lt;span class="p">|&lt;/span> grep gitlab-runner &lt;span class="c1"># gitlab-runner run 이 잘 되고 있어야 한다.&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>나는 Executer를 Shell 로 쓰고 있는데, 이 친구가 내부 저장소로 (그것도 SSH 주소로) 접근하려면… SSH Public Key를 넣어줘야 된다. 넣지 않으면 인증에서 실패한다. 그런데 Gitlab Runner 의 Shell 사용자는 위에서 보이는 것 처럼 &amp;lsquo;gitlab-runner&amp;rsquo; 인데.. 얘는 Gitlab 계정도 없는 가상 사용자다. 어떻게 Public Key를 등록할까?&lt;/p>
&lt;p>Gitlab은, 각 사용자 계정의 SSH Public Key를 관리해 주기도 하지만 Project 별로 SSH Key를 등록할 수도 있다. &lt;em>Project 페이지의 Settings &amp;gt; Repository&lt;/em> 에서 Deploy Keys 부분을 펼쳐보자. 그러면 익숙한 SSH Key 등록 폼이 나온다. 여기에, 아까 언급한 &amp;lsquo;gitlab-runner&amp;rsquo; 의 SSH Key를 등록하면 된다. (당연히 gitlab-runner 계정에서 SSH Key 생성을 해야한다.)&lt;/p>
&lt;p>그러면&lt;code>.gitlab-ci.yml&lt;/code> 에 마구잡이로 &lt;code>'git clone git@~~~~:&amp;lt;user or group&amp;gt;/&amp;lt;project&amp;gt;.git'&lt;/code> 이런 식으로 스크립트를 적어도 아주 잘 clone 되는 걸 확인할 수 있다!&lt;/p>
&lt;h2 id="create-new-branch-의-기본-branch-바꾸기">&lt;em>Create New Branch&lt;/em> 의 기본 Branch 바꾸기&lt;/h2>
&lt;p>Issue 페이지에서 Create New Branch (9.x 에서는 New Branch) 를 하면, Branch의 이름이 &amp;lsquo;421 – invalid table error&amp;rsquo; 이런 식으로 뜬다. 이슈 번호와 이슈 제목.&lt;/p>
&lt;p>그런데 내부적으로는 이슈 제목에 한글을 많이 써서 Branch 이름을 출력하고 싶지 않았다. 그리고 규격화된 이름 (ISSUE#XXXX) 으로 Branch를 생성하고픈 욕구가 치밀었다. (참고로 Push Rule 에서 Branch Naming Rule에 저렇게 규칙을 쓰고, Create New Branch 를 누르면 절대로 Branch가 생기지 않는다.)&lt;/p>
&lt;p>Gitlab에 이미 &lt;a class="link" href="https://gitlab.com/gitlab-org/gitlab-ce/issues/21143" target="_blank" rel="noopener"
>#21143&lt;/a> 으로 이슈가 등록되었고, 10.3 에서 업데이트가 된다지만… 이렇게 되면 사용자가 매번 Push Rule을 피하려고 Branch 이름을 일일이 쳐넣는 어처구니없는 상황이 계속된다. 그래서 코드를 찾아내서 고치는 편이 낫다고 생각했다.&lt;/p>
&lt;p>Ruby는 쥐뿔도 모르지만 코드는 코드일 뿐.&lt;/p>
&lt;p>이슈에 대한 브랜치를 생성하는 작업은 &lt;a class="link" href="https://gitlab.com/gitlab-org/gitlab-ce/merge_requests/2808/diffs" target="_blank" rel="noopener"
>이 Merge Request&lt;/a> 에서 반영된 것이다. 여기 Diff를 쭉 봤더니 &lt;code>to_branch_name&lt;/code> 이 눈에 띈다. 오호라. 하지만 어디서 수정해야 할까?&lt;/p>
&lt;p>Gitlab을 Omnibus 로 정직하게 설치했다면 소스코드 경로는 &lt;code>/opt/gitlab/embedded/service/gitlab-rails/&lt;/code> 에 있다. 여기서 grep으로 &lt;code>to_branch_name&lt;/code> 을 검색해 보면?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">cd&lt;/span> /opt/gitlab/embedded/service/gitlab-rails/
grep to_branch_name . -rn
&lt;span class="c1"># ./embedded/service/gitlab-rails/app/models/issue.rb:XXX def to_branch_name&lt;/span>
&lt;span class="c1"># 이하 생략&lt;/span>
vi app/models/issue.rb
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 &lt;code>&amp;quot;#{iid}-#{title.parameterize}&amp;quot;&lt;/code> 라고 정의된 부분을 적절히 바꿔주자. 나는 &lt;code>&amp;quot;ISSUE##{iid}&amp;quot;&lt;/code> 로 심플하게 바꿨다.&lt;/p>
&lt;p>이것만 바꾸면 &amp;lsquo;Create New Branch&amp;rsquo; 를 누를 때 잘 될 것 같다. 하지만 Issue 페이지에서 &amp;lsquo;연관된 Issue Branch&amp;rsquo; 목록에 연결되지 않는다. 수정한 파일 &lt;code>/opt/gitlab/embedded/service/gitlab-rails/app/models/issue.rb&lt;/code> 에서, 더 수정할 것이 남아있다. 다음 함수를 수정해야 한다.&lt;/p>
&lt;ul>
&lt;li>has_related_branch&lt;/li>
&lt;li>related_branches&lt;/li>
&lt;/ul>
&lt;p>수정 방법은 간단한데, Branch와 비교하는 Regular Expression 의 문법을 찾아보자. &lt;code>/\A${iid}-(?!\d+-stable)/i&lt;/code> 라고 되어 있을 것이다. 이걸 실제로 &lt;code>irb&lt;/code> 에서 테스트해 보면, &lt;code>420-title&lt;/code> 같은 건 되는데 &lt;code>420-0-stable&lt;/code> 은 인식이 안 되는 것을 알 수 있다. (뭔가.. 이상하다) 아무튼 이걸 적절한 Regular Expression 으로 바꿔 주도록 하자. Ruby의 Regexp 에 익숙치 않다면 &lt;a class="link" href="http://rubular.com/" target="_blank" rel="noopener"
>Rubular 사이트&lt;/a>의 도움을 받아보도록 하자. (내 경우는 간단하게 &lt;code>/\AISSUE#{iid}/i&lt;/code> 라고 했다.)&lt;/p>
&lt;p>수정을 했다. 하지만 끝이 아니다. 마무리를 해 줘야 한다. 실제 Gitlab이 서비스되고 있는 경로는 &lt;code>/var/opt/gitlab&lt;/code> 이므로, 해당 경로로 적용을 시켜줘야 한다. 어떻게?&lt;/p>
&lt;p>간단하다. &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 를 입력하자.&lt;/p></description></item><item><title>Linux 에서 CPU/Memory/Disk 확인</title><link>https://interp.blog/linux-%EC%97%90%EC%84%9C-cpumemorydisk-%ED%99%95%EC%9D%B8/</link><pubDate>Mon, 30 Oct 2017 08:31:03 +0000</pubDate><guid>https://interp.blog/linux-%EC%97%90%EC%84%9C-cpumemorydisk-%ED%99%95%EC%9D%B8/</guid><description>&lt;p>자주 쓰긴 하지만, 곧바로 생각나지 않을 것을 대비해서&amp;hellip; 서버실 서버 사양을 전부 체크하려다 보니 어쩔 수 없이 정리했다.&lt;/p>
&lt;h2 id="cpu--memory-확인">CPU / Memory 확인&lt;/h2>
&lt;p>CPU / Memory 는 사실 쉽다. &lt;code>/proc/cpuinfo&lt;/code> 와 &lt;code>/proc/meminfo&lt;/code> 안에 들어있기 때문이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat /proc/cpuinfo &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;model name&amp;#34;&lt;/span>  &lt;span class="p">|&lt;/span> sort -u
model name : Intel&lt;span class="o">(&lt;/span>R&lt;span class="o">)&lt;/span> Core&lt;span class="o">(&lt;/span>TM&lt;span class="o">)&lt;/span> i3-4160 CPU @ 3.60GHz
$ cat /proc/meminfo &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;MemTotal&amp;#34;&lt;/span>
MemTotal: &lt;span class="m">8040588&lt;/span> kB
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="disk-확인">Disk 확인&lt;/h2>
&lt;p>&lt;code>df&lt;/code> 는 mount 된 것만 확인이 가능해서 별로고, &lt;code>lsblk&lt;/code> 를 하면 마운트되지 않은 것까지 나온다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda 8:0 &lt;span class="m">0&lt;/span> 477G &lt;span class="m">0&lt;/span> disk
├─sda1 8:1 &lt;span class="m">0&lt;/span> 468.8G &lt;span class="m">0&lt;/span> part /
└─sda2 8:2 &lt;span class="m">0&lt;/span> 8.2G &lt;span class="m">0&lt;/span> part &lt;span class="o">[&lt;/span>SWAP&lt;span class="o">]&lt;/span>
sdb 8:16 &lt;span class="m">0&lt;/span> 2.7T &lt;span class="m">0&lt;/span> disk
&lt;span class="c1">## df 는 sdb가 보이지 않는다.&lt;/span>
$ df -h
Filesystem Size Used Avail Use% Mounted on
/dev/sda1 462G 8.4G 430G 2% /
tmpfs 79G 224K 79G 1% /dev/shm
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>현상을 통찰하는 방법</title><link>https://interp.blog/%ED%98%84%EC%83%81%EC%9D%84-%ED%86%B5%EC%B0%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</link><pubDate>Thu, 12 Oct 2017 01:09:33 +0000</pubDate><guid>https://interp.blog/%ED%98%84%EC%83%81%EC%9D%84-%ED%86%B5%EC%B0%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</guid><description>&lt;p>게임 &amp;lsquo;배틀그라운드&amp;rsquo; 에서, 어떻게 해야 상위 랭크에 도달할 수 있는지를 &lt;a class="link" href="http://blog.naver.com/kyuminsim/221115164331" target="_blank" rel="noopener"
>수학적인 접근으로 잘 풀어낸 네이버 블로그 글&lt;/a>을 봤다. 누군가에겐 그저 즐기는 게임이 될 수 있지만, 누군가에게는 연구대상이 된다. 사물이나 현상을 어떻게 바라보느냐, 얼마나 관심있느냐에 따라서 통찰이 생겨난다. 이것은 모두에게 열려있다. 반대로 생각하면, 논문을 쓰는 사람들은 결단코 고상한 사람들이 아니다.&lt;/p>
&lt;p>&amp;lsquo;수학적인 접근&amp;rsquo;이라는 말 때문에 설득력이 떨어질 수는 있다. 하지만 어느 분야나 자신의 경험을 녹여 전혀 다른 곳에서 적응하는 사람들을 우리는 일상에서 많이 봤다. 그것이 상식이 될 수도 있고, 연륜이 될 수도 있다. (개인적으로는, &amp;lsquo;나이를 먹어감에 따라 현명해지는 것은 잘못된 생각이다&amp;rsquo; 라는 누군가의 말에 동의하지만…)&lt;/p>
&lt;p>그런 사람이 되어야 하지 않을까, 생각한다.&lt;/p></description></item><item><title>mmap : 메모리를 파일처럼</title><link>https://interp.blog/mmap-memory-block-like-file/</link><pubDate>Wed, 20 Sep 2017 13:29:57 +0000</pubDate><guid>https://interp.blog/mmap-memory-block-like-file/</guid><description>&lt;p>&lt;code>mmap&lt;/code> 은 memory map 의 줄임말이다. 메모리의 특정 영역을 파일 디스크립터로 인식하게 만드는 것이다.&lt;/p>
&lt;blockquote>
&lt;p>map or unmap files or devices into memory&lt;br>
(메모리 영역을 파일이나 디바이스로 인식하게 합니다)&lt;/p>
&lt;p>– manpage of mmap&lt;/p>
&lt;/blockquote>
&lt;h2 id="사용">사용&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">mmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">size_t&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">prot&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">off_t&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 의미가 있는 건 Length, Prot (Protection), Flag 뿐이다.&lt;/p>
&lt;ul>
&lt;li>Start 는, Kernel이 아무 곳이나 지정해도 좋다면 NULL을 입력한다.&lt;/li>
&lt;li>Offset 은, 보통 0으로 둔다. (MAP_ANONYMOUS 또는 MAP_ANON Flag가 있는 경우엔 무시된다)&lt;/li>
&lt;li>Fd 는, 연결할 파일 디스크립터를 지정한다. (MAP_ANONYMOUS 또는 MAP_ANON Flag를 통해서 &amp;lsquo;파일로 사용하지 않는다&amp;rsquo; 라고 한다면 -1을 넣어줘야 한다. (사실 안 넣어주고 무시해도 되지만 몇몇 구현에서는 넣어야 한다 카더라)&lt;/li>
&lt;/ul>
&lt;h2 id="protection">Protection&lt;/h2>
&lt;p>매핑된 메모리 영역의 사용 권한 같은 것을 정하는 것이라고 이해하자. 리눅스 파일 시스템의 권한과 비슷한 분류로 이해하면 더욱 쉽다. (물론 똑같지는 않지만)&lt;/p>
&lt;ul>
&lt;li>PROT_NONE : 메모리 영역은 아무것도 할 수 없다.&lt;/li>
&lt;li>PROT_READ : 메모리 영역을 읽을 수 있다.&lt;/li>
&lt;li>PROT_WRITE : 메모리 영역을 쓸 수 있다.&lt;/li>
&lt;li>PROT_EXEC : 메모리 영역이 실행될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이 때, 연결된 파일 디스크립터의 모드와 절대 충돌해서는 안 된다. 예를 들어 파일 디스크립터를 획득할 때는 &lt;code>w+&lt;/code> 라고 해놓고 여기서 PROT_READ 라고 하면, 예상치 못한 무언가가 일어나지 않을까?&lt;/p>
&lt;p>메모리 영역의 보호에 관련된 자세한 내용은 &lt;a class="link" href="http://man7.org/linux/man-pages/man2/mprotect.2.html" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/p>
&lt;h2 id="flag">Flag&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Flag&lt;/th>
&lt;th>사용 가능 커널&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MAP_SHARED&lt;/td>
&lt;td>–&lt;/td>
&lt;td>이 매핑을 다른 프로세스들이 공유할 수 있다. (실제 파일과 연결되어 반영된다. 하지만 자동으로 반영하지는 않고 &lt;code>msync&lt;/code> 나 &lt;code>munmap&lt;/code> 을 호출해야 반영된다.)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_PRIVATE&lt;/td>
&lt;td>–&lt;/td>
&lt;td>이 매핑을 다른 프로세스들과 공유하지 않는다. 실제 파일과도 연결되지 않으므로, &lt;code>mmap&lt;/code> 이후에 파일에 반영되는 변경 내역이 매핑된 영역에 반영되는지는 확신할 수 없다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_32BIT&lt;/td>
&lt;td>~2.4.20, 2.6&lt;/td>
&lt;td>첫 2GB 안에서 영역을 잡는다. x86-64 프로그램에서만 사용이 가능하다.&lt;br /> (초기 64-bit 프로세서에서는 context-switch 비용 절감을 위해 사용할 수 있는 옵션이겠지만, 지금은 그렇지 않으므로 굳이..)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_ANONYMOUS&lt;br /> MAP_ANON&lt;/td>
&lt;td>–&lt;/td>
&lt;td>파일 디스크립터로 인식하지 않는다. fd와 offset은 무시되지만, 몇몇 구현에서는 fd를 반드시 -1로 입력해야 한다. &lt;br/> ※ SHARED와 같이 사용하려면 Kernel Version 이 2.4 이하여야 한다.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>헉헉.. 아래에 더 있는데 여기까지만 해야겠다. 내가 사용하고자 하는건 사실 ANONYMOUS Flag 만 있으면 되는데 말이지.&lt;/p></description></item><item><title>pthread_yield vs. sleep</title><link>https://interp.blog/pthread_yield-vs-sleep/</link><pubDate>Thu, 24 Aug 2017 05:35:24 +0000</pubDate><guid>https://interp.blog/pthread_yield-vs-sleep/</guid><description>&lt;p>&lt;code>pthread_yield()&lt;/code> 와 &lt;code>sleep()&lt;/code> 의 차이를 묻는 &lt;a class="link" href="https://stackoverflow.com/questions/936993/pthread-what-is-the-difference-between-time-hsleep-and-pthread-hpthread" target="_blank" rel="noopener"
>Stack Overflow 글&lt;/a> 의 답을 발췌한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>pthread_yield()&lt;/code> 는, 호출한 쓰레드가 프로세서 사용을 그만두고, 스케쥴링이 될 때 까지 작업 큐(run queue)에서 기다립니다. 만약 호출되었을 때 작업 큐가 비어 있다면, 즉시 스케쥴링이 되겠죠.&lt;/p>
&lt;p>&lt;code>sleep()&lt;/code> 은 X초만큼 지나거나, 무시할 수 없는 시그널이 도착할 때 까지 (다른 쓰레드를 포함한) 호출 프로세스를 재웁니다.&lt;/p>
&lt;p>현재 쓰레드를 실제로 지연시키고 싶지 않지만 (호출 쓰레드 대신) 다른 쓰레드에게 실행권을 넘겨주고 싶은 경우라면, &lt;code>sleep()&lt;/code> 보단 &lt;code>pthread_yield()&lt;/code> 가 적합할 것 같습니다.&lt;/p>
&lt;/blockquote>
&lt;p>sleep 자체가 프로세스를 아예 멈추게 하니까 pthread_yield 를 통해서 나는 잠시 빠져주는 상태로 만드는 거였다. 코드를 보면서 감으로만 &amp;lsquo;아 저건 sleep() 같진 않지만 뭔가 이럴 때 쓰는거야&amp;rsquo; 라고만 어렴풋이 알고 있었는데, 무엇이든 확실히 알아야 한다.&lt;/p></description></item><item><title>Search</title><link>https://interp.blog/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://interp.blog/search/</guid><description/></item></channel></rss>
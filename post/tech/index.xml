<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tech 🛠️ on InterP Blog</title><link>https://interp.blog/post/tech/</link><description>Recent content in Tech 🛠️ on InterP Blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 23 Dec 2024 09:30:00 +0900</lastBuildDate><atom:link href="https://interp.blog/post/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>성능 관찰 및 시스템 분석을 위한 OpenTelemetry</title><link>https://interp.blog/opentelemetry-introduction/</link><pubDate>Mon, 23 Dec 2024 09:30:00 +0900</pubDate><guid>https://interp.blog/opentelemetry-introduction/</guid><description>&lt;p>OpenTelemetry는 소프트웨어의 성능과 동작을 분석하기 위한 텔레메트리 데이터(메트릭, 로그, 트레이스)를 생성하고 수집하며 내보내는 데 도움을 주는 API, SDK 및 도구 모음이다. 이는 개발자와 운영팀이 소프트웨어 시스템을 관찰하고 문제를 해결하는 데 필수적인 정보를 제공한다. OpenTelemetry는 여러 프로그래밍 언어에 걸쳐 일반적으로 사용할 수 있으며, 생산 환경에서도 안정적으로 사용할 수 있도록 설계되었다.&lt;/p>
&lt;h1 id="opentelemetry의-핵심-요소">OpenTelemetry의 핵심 요소&lt;/h1>
&lt;h2 id="트레이스traces">트레이스(Traces)&lt;/h2>
&lt;p>트레이스는 요청이 시스템을 통해 이동하는 경로를 기록한다. 트레이스를 통해 애플리케이션의 각 서비스가 어떻게 상호작용하는지, 성능 병목 현상은 어디에 있는지를 파악할 수 있다. 이는 문제 해결에 필수적인 정보를 제공한다.&lt;/p>
&lt;h2 id="메트릭metrics">메트릭(Metrics)&lt;/h2>
&lt;p>메트릭은 시스템의 성능 지표를 수집하고 이를 분석하는 데 도움을 준다. 예를 들어, 요청 처리 시간, 시스템 리소스 사용량, 응답 속도 등을 모니터링할 수 있다. 이를 통해 시스템의 상태를 주기적으로 평가하고, 비정상적인 상태를 빠르게 감지할 수 있다.&lt;/p>
&lt;h2 id="로그logs">로그(Logs)&lt;/h2>
&lt;p>로그는 시스템에서 발생한 사건을 기록한 텍스트 데이터를 의미한다. 오류 메시지나 경고를 포함한 로그는 시스템의 문제를 추적하는 데 매우 유용하다. OpenTelemetry는 로그 데이터를 수집하여 관련된 트레이스나 메트릭과 결합하여 보다 명확한 관찰 정보를 제공한다.&lt;/p>
&lt;h1 id="opentelemetry의-특징">OpenTelemetry의 특징&lt;/h1>
&lt;h2 id="통합성-및-호환성">통합성 및 호환성&lt;/h2>
&lt;p>OpenTelemetry는 여러 인기 있는 라이브러리와 프레임워크와 쉽게 통합된다. 코드 기반의 계측뿐만 아니라 제로 코드 계측도 지원하므로 개발자는 쉽게 OpenTelemetry를 기존 시스템에 적용할 수 있다.&lt;/p>
&lt;h2 id="오픈-소스-및-공급업체-중립성">오픈 소스 및 공급업체 중립성&lt;/h2>
&lt;p>OpenTelemetry는 100% 무료이며 오픈 소스이다. OpenTelemetry의 가장 큰 특징 중 하나는 바로 &lt;strong>제품 불가지론적(product agnostic)&lt;/strong> 이라는 점이다. 이는 특정 제품이나 플랫폼에 종속되지 않고, 다양한 시스템과 기술 스택에서 동일한 방식으로 사용할 수 있음을 의미한다.&lt;/p>
&lt;p>&amp;ldquo;불가지론(不可知論)&amp;rdquo; 이란 특정한 명제에 대해 의견을 강하게 주장하지 않는 태도를 의미한다. 이 말을 적용해 보면, OpenTelemetry는 특정 벤더나 도구에 의존하지 않고 다양한 환경에서 독립적으로 작동할 수 있는 특성을 가진다는 것을 의미한다. 이로 인해 OpenTelemetry는 여러 기업이나 팀들이 서로 다른 기술 스택을 사용하고 있더라도 손쉽게 통합할 수 있는 장점을 제공한다.&lt;/p>
&lt;h2 id="cncf-인큐베이팅-프로젝트">CNCF 인큐베이팅 프로젝트&lt;/h2>
&lt;p>OpenTelemetry는 클라우드 네이티브 컴퓨팅 재단(CNCF)에서 &lt;a class="link" href="https://www.cncf.io/projects/opentelemetry/" target="_blank" rel="noopener"
>인큐베이팅 중인 프로젝트&lt;/a>로, 업계의 여러 주요 기업들이 채택하고 지원하고 있다.&lt;/p>
&lt;h1 id="실제-예제">실제 예제&lt;/h1>
&lt;h2 id="instrumentation-sdk-예제">Instrumentation SDK 예제&lt;/h2>
&lt;p>OpenTelemetry를 사용하여 애플리케이션에 계측을 추가하는 첫 번째 단계는 &lt;strong>Instrumentation SDK&lt;/strong>를 사용하는 것이다.&lt;/p>
&lt;p>아래는 Python을 예로 든 간단한 코드이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">opentelemetry&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">trace&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">opentelemetry.ext&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">requests&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">opentelemetry.sdk.trace&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">TracerProvider&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">opentelemetry.sdk.trace.export&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">ConsoleSpanExporter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">SimpleSpanProcessor&lt;/span>
&lt;span class="c1"># 트레이서 프로바이더 설정&lt;/span>
&lt;span class="n">trace&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">set_tracer_provider&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TracerProvider&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="n">tracer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">trace&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get_tracer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="vm">__name__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># Span을 추적하고 로그를 출력하는 예제&lt;/span>
&lt;span class="k">with&lt;/span> &lt;span class="n">tracer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start_as_current_span&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;foo&amp;#34;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello from OpenTelemetry!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드는 OpenTelemetry SDK를 사용하여 &amp;ldquo;foo&amp;quot;라는 트레이스를 시작하고, 그 트레이스 내에서 print 명령을 실행한다. 이를 통해 애플리케이션에서 트레이스를 추적할 수 있다.&lt;/p>
&lt;h2 id="otel-collector-예제">OTel Collector 예제&lt;/h2>
&lt;p>OpenTelemetry Collector는 여러 출처에서 수집된 텔레메트리 데이터를 중앙화하여 내보내는 데 사용된다. 아래는 OTel Collector를 설정하는 간단한 예제이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">receivers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">otlp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocols&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">grpc&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">exporters&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">logging&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">loglevel&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">debug&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pipelines&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">traces&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">receivers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">otlp]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exporters&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">logging]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 설정 파일은 OTLP(OpenTelemetry Protocol) 수신기를 설정하여 데이터를 수집하고, 수집된 트레이스를 로깅으로 출력한다. OTel Collector를 통해 여러 데이터 출처에서 수집된 데이터를 중앙에서 관리할 수 있다.&lt;/p>
&lt;h1 id="장점과-한계점">장점과 한계점&lt;/h1>
&lt;p>OTel 의 장점은 다음과 같다:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>효율적인 관찰 가능성&lt;/strong>: OpenTelemetry를 통해 시스템의 모든 동작을 상세히 추적하고 모니터링할 수 있다. 이는 성능을 최적화하고 문제를 빠르게 해결하는 데 중요한 역할을 한다.&lt;/li>
&lt;li>&lt;strong>다양한 언어 지원&lt;/strong>: OpenTelemetry는 여러 프로그래밍 언어를 지원하며, 각 언어의 특징에 맞는 SDK와 도구들을 제공한다.&lt;/li>
&lt;li>&lt;strong>확장성&lt;/strong>: OpenTelemetry는 대규모 시스템에서도 문제없이 사용할 수 있도록 설계되어, 분산 환경에서의 관찰 가능성을 극대화한다.&lt;/li>
&lt;/ul>
&lt;p>그러나, OpenTelemetry에는 다음과 같은 한계점도 존재한다:&lt;/p>
&lt;ul>
&lt;li>높은 학습 곡선: OpenTelemetry는 많은 기능을 제공하지만, 이를 제대로 활용하기 위한 학습 곡선이 존재한다. 다양한 구성 요소와 설정이 있기 때문에 처음 시작할 때 복잡할 수 있다. 특히, 분산 시스템에서 여러 서비스를 모니터링하려면 관련 개념과 툴에 대한 충분한 이해가 필요하다.&lt;/li>
&lt;li>자원 소모: OpenTelemetry는 많은 데이터를 수집하고 처리하기 때문에 시스템 자원을 소모할 수 있다. 대규모 애플리케이션에서는 데이터 수집량이 많아지며, 그에 따라 네트워크 대역폭, CPU, 메모리 등을 많이 사용할 수 있다. 따라서 OpenTelemetry를 설정할 때 성능을 고려해야 한다.&lt;/li>
&lt;li>데이터 정확도: OpenTelemetry는 다양한 소스에서 데이터를 수집하고 이를 통합하지만, 모든 환경에서 정확한 데이터를 보장하지는 않는다. 일부 환경에서는 계측이 제대로 작동하지 않거나, 데이터 누락이 발생할 수 있다. 이는 OpenTelemetry가 아직 발전 중인 기술이기 때문에 발생할 수 있는 문제다.&lt;/li>
&lt;li>설정 복잡성: OpenTelemetry는 매우 유연하지만, 그만큼 설정이 복잡해질 수 있다. 특히 대규모 분산 시스템에서는 각 서비스마다 별도의 설정과 구성이 필요할 수 있으며, 여러 시스템과의 통합이 점점 더 어려워질 수 있다.&lt;/li>
&lt;/ul>
&lt;h1 id="결론">결론&lt;/h1>
&lt;p>OpenTelemetry는 소프트웨어 시스템의 성능을 관찰하고 문제를 해결하는 데 필수적인 도구이다. 트레이스, 메트릭, 로그 데이터를 종합적으로 분석할 수 있어 시스템의 상태를 명확하게 파악하고, 효율적으로 성능을 개선할 수 있다. 오픈 소스이며 다양한 언어와 통합이 가능하다는 점에서 개발자와 운영팀에게 매우 유용한 도구이다.&lt;/p></description></item><item><title>yq: YAML Parser</title><link>https://interp.blog/yq-yaml-parser/</link><pubDate>Fri, 13 Dec 2024 14:07:39 +0900</pubDate><guid>https://interp.blog/yq-yaml-parser/</guid><description>&lt;p>&lt;strong>yq&lt;/strong>는 &lt;code>jq&lt;/code> 에서 쓸 수 있는 jsonpath 를 YAML 파일에 구사할 수 있는 CLI 도구이다. 여기서 소개하는 yq 는 &lt;a class="link" href="https://github.com/mikefarah/yq" target="_blank" rel="noopener"
>mikefarah/yq&lt;/a> 를 뜻한다.&lt;/p>
&lt;p>이 글에서는 yq의 설치 방법과 기본적인 사용법을 간단히 살펴본다.&lt;/p>
&lt;h1 id="yq-설치-방법">yq 설치 방법&lt;/h1>
&lt;h2 id="homebrew로-설치-macoslinux">Homebrew로 설치 (macOS/Linux)&lt;/h2>
&lt;p>Homebrew를 사용하면 yq를 간단히 설치할 수 있다. 터미널에서 아래 명령어를 입력하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">brew install yq
&lt;/code>&lt;/pre>&lt;/div>&lt;p>설치가 끝난 뒤에는 &lt;code>yq --version&lt;/code> 명령어로 설치 여부를 확인할 수 있다.&lt;/p>
&lt;h2 id="기타-설치-방법">기타 설치 방법&lt;/h2>
&lt;p>Homebrew 외에도 yq는 여러 가지 방법으로 설치할 수 있다. 운영 체제와 환경에 맞는 방법을 선택하면 된다.&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/mikefarah/yq/releases/latest" target="_blank" rel="noopener"
>공식 다운로드 링크&lt;/a>: 바이너리를 직접 다운로드해서 설치&lt;/li>
&lt;li>Snap 패키지 (Linux): &lt;code>snap install yq&lt;/code>&lt;/li>
&lt;li>Windows: Chocolatey 또는 Scoop으로 설치&lt;/li>
&lt;/ul>
&lt;p>더 자세한 설치 방법은 &lt;a class="link" href="https://mikefarah.gitbook.io/yq" target="_blank" rel="noopener"
>공식 문서&lt;/a>에서 확인할 수 있다.&lt;/p>
&lt;h1 id="yq의-주요-기능">yq의 주요 기능&lt;/h1>
&lt;p>yq는 YAML 데이터를 쉽게 관리할 수 있는 다양한 기능을 제공한다.&lt;/p>
&lt;h2 id="yaml-읽기">YAML 읽기&lt;/h2>
&lt;p>YAML 파일에서 특정 데이터를 읽는 것은 아주 간단하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">yq &lt;span class="s1">&amp;#39;.person.name&amp;#39;&lt;/span> file.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 명령어는 &lt;code>file.yaml&lt;/code> 파일에서 &lt;code>person&lt;/code> 아래 &lt;code>name&lt;/code> 값을 출력한다.&lt;/p>
&lt;h2 id="yaml-수정">YAML 수정&lt;/h2>
&lt;p>YAML 데이터를 업데이트할 수도 있다. &lt;code>-i&lt;/code> 옵션을 사용하면 파일을 직접 수정할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">yq -i &lt;span class="s1">&amp;#39;.person.name = &amp;#34;인터피&amp;#34;&amp;#39;&lt;/span> file.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="json과-yaml-간-변환">JSON과 YAML 간 변환&lt;/h2>
&lt;p>yq는 JSON과 YAML을 손쉽게 변환할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">yq -Poy sample.json
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 명령어는 &lt;code>sample.json&lt;/code> 파일을 YAML 형식으로 변환한다.&lt;/p>
&lt;h2 id="4-여러-파일-병합">4. 여러 파일 병합&lt;/h2>
&lt;p>여러 YAML 파일을 병합하는 것도 가능하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">yq -n &lt;span class="s1">&amp;#39;load(&amp;#34;file1.yaml&amp;#34;) * load(&amp;#34;file2.yaml&amp;#34;)&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-환경-변수-사용">5. 환경 변수 사용&lt;/h2>
&lt;p>환경 변수를 활용할 때는 &lt;code>strenv()&lt;/code> 를 사용해야 한다. &lt;code>$...&lt;/code> 는 먹지 않으므로 주의. 아래 예제는 환경변수 &lt;code>$NAME&lt;/code> 을 가지고 YAML 데이터를 업데이트한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">bash
NAME=&amp;#34;인터피&amp;#34;
yq -i &amp;#39;.person.name = strenv(NAME)&amp;#39; file.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="yq-의-장점">yq 의 장점&lt;/h1>
&lt;ol>
&lt;li>&lt;strong>다양한 형식 지원&lt;/strong>: YAML뿐만 아니라 JSON, XML, CSV 등도 다룰 수 있다.&lt;/li>
&lt;li>&lt;strong>유연한 구문&lt;/strong>: &lt;code>jq&lt;/code> 에서 쓸 수 있는 jsonpath syntax 로 간단히 작업할 수 있다.&lt;/li>
&lt;li>&lt;strong>데이터 보존&lt;/strong>: YAML 의 주석과 포맷을 유지하면서 데이터를 수정할 수 있다.&lt;/li>
&lt;li>&lt;strong>개발자 친화적&lt;/strong>: CI/CD 파이프라인에도 쉽게 통합할 수 있다.&lt;/li>
&lt;/ol>
&lt;h1 id="공식-문서와-커뮤니티">공식 문서와 커뮤니티&lt;/h1>
&lt;p>yq에 대해 더 알고 싶다면 공식 문서를 확인해 보자. 명령어 사용법과 고급 기능에 대한 예제가 잘 정리되어 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a class="link" href="https://mikefarah.gitbook.io/yq" target="_blank" rel="noopener"
>공식 문서&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>GitHub Repository&lt;/strong>: &lt;a class="link" href="https://github.com/mikefarah/yq" target="_blank" rel="noopener"
>mikefarah/yq&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Helm Template 공백 유지하는 방법</title><link>https://interp.blog/helm-template-preserve-space/</link><pubDate>Thu, 08 Aug 2024 21:57:01 +0900</pubDate><guid>https://interp.blog/helm-template-preserve-space/</guid><description>&lt;p>&lt;a class="link" href="https://interp.blog/helm-template-value-preserve-string/" >지난 포스팅&lt;/a> 에 이어, 오늘은 Template 내부에 생성되는 공백을 유지하는 방법을 알아보자. 사실 이 부분 역시 &lt;a class="link" href="https://helm.sh/docs/chart_template_guide/control_structures/#controlling-whitespace" target="_blank" rel="noopener"
>Helm 문서&lt;/a>에 나와있는 내용을 요약한 것이다.&lt;/p>
&lt;h1 id="준비">준비&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">helm create tempchart
rm -rf tempchart/charts tempchart/templates/* tempchart/values.yaml
cat &lt;span class="s">&amp;lt;&amp;lt;EOF &amp;gt; tempchart/templates/test.yaml
&lt;/span>&lt;span class="s">data:
&lt;/span>&lt;span class="s"> drink: {{ .Values.drink }}
&lt;/span>&lt;span class="s"> {{ if eq .Values.drink &amp;#34;coffee&amp;#34; }}
&lt;/span>&lt;span class="s"> mug: &amp;#34;true&amp;#34;
&lt;/span>&lt;span class="s"> {{ end }}
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 만든 &lt;code>test.yaml&lt;/code> 파일을 보면, &lt;code>.Values.drink&lt;/code> 값이 &lt;code>coffee&lt;/code> 일 때에는 추가로 &lt;code>data.mug&lt;/code> attribute 를 &lt;code>true&lt;/code> 로 추가한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">drink&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{{&lt;span class="w"> &lt;/span>&lt;span class="l">.Values.drink }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>{{&lt;span class="w"> &lt;/span>&lt;span class="l">if eq .Values.drink &amp;#34;coffee&amp;#34; }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mug&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>{{&lt;span class="w"> &lt;/span>&lt;span class="l">end }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="공백이-그대로-남아요">공백이 그대로 남아요!&lt;/h1>
&lt;p>drink 가 coffee 가 아닌 경우라면, 아래와 같이 &lt;code>data.drink&lt;/code> 만 가지는 yaml 파일이 생성된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">helm template tempchart --set &lt;span class="nv">drink&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;tea&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c"># Source: tempchart/templates/test.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">drink&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tea&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>coffee 로 설정하면 &lt;code>data.mug&lt;/code> attribute 가 추가될텐데..&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">helm template tempchart --set &lt;span class="nv">drink&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;coffee&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>뭔가 이상하다. 저 공백은 무엇인가?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c"># Source: tempchart/templates/test.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">drink&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">coffee&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mug&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="해결방법">해결방법&lt;/h1>
&lt;p>&lt;a class="link" href="https://helm.sh/docs/chart_template_guide/control_structures/#controlling-whitespace" target="_blank" rel="noopener"
>Helm 문서&lt;/a>의 설명은 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>First, the curly brace syntax of template declarations can be modified with special characters to tell the template engine to chomp whitespace. {{- (with the dash and space added) indicates that whitespace should be chomped left, while -}} means whitespace to the right should be consumed. Be careful! Newlines are whitespace!&lt;/p>
&lt;p>먼저, 템플릿 선언의 중괄호 (&lt;code>{&lt;/code> 와 &lt;code>}&lt;/code>) 구문은 특수 문자를 사용하여 템플릿 엔진에 공백을 제거하도록 지시할 수 있습니다. &lt;code>{{-&lt;/code> (대시와 공백이 추가된 경우) 는 왼쪽의 공백을 제거해 달라는 것이고, &lt;code>-}}&lt;/code> 는 오른쪽의 공백을 제거해 달라는 것을 의미합니다. &lt;strong>주의하세요! 줄 바꿈도 공백입니다!&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>따라서 이 줄바꿈을 제거하기 위해 &lt;code>{{-&lt;/code> 를 사용하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">drink&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{{&lt;span class="w"> &lt;/span>&lt;span class="l">.Values.drink }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>{{- &lt;span class="l">if eq .Values.drink &amp;#34;coffee&amp;#34; }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">mug&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>{{- &lt;span class="l">end }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>양쪽에 다 사용하면 안 된다. 이렇게 에러가 발생한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">Error: YAML parse error on tempchart/templates/test.yaml: error converting YAML to JSON: yaml: line 2&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mapping values are not allowed in this context&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="l">Use --debug flag to render out invalid YAML&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Helm Template Value 의 문자열 값 보존하기</title><link>https://interp.blog/helm-template-value-preserve-string/</link><pubDate>Wed, 07 Aug 2024 09:59:24 +0900</pubDate><guid>https://interp.blog/helm-template-value-preserve-string/</guid><description>&lt;p>Helm Templating 을 하다 보면, 값에 들어가 있는 따옴표를 그대로 보존해야 하는 상황이 발생한다. 다음과 같은 경우엔 어떻게 할 것인가?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{{&lt;span class="w"> &lt;/span>&lt;span class="l">.Values.password }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">helm template mychart --set &lt;span class="nv">password&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;my&amp;#39;password&amp;#34;&lt;/span> &lt;span class="c1"># 성공&lt;/span>
helm template mychart --set &lt;span class="nv">password&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;my\&amp;#34;&amp;#39;password&amp;#34;&lt;/span> &lt;span class="c1"># YAML parse error&lt;/span>
helm template mychart --set &lt;span class="nv">password&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;my&amp;#34;password&amp;#39;&lt;/span> &lt;span class="c1"># YAML parse error&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="--사용하기">&lt;code>&amp;gt;-&lt;/code> 사용하기&lt;/h1>
&lt;p>처음으로 할 일은 &lt;code>spec.data.password&lt;/code> 을 다음과 같이 &lt;code>&amp;gt;&lt;/code> (angle bracket, greater-than-sign 이라고 부르더라) 와 &lt;code>-&lt;/code> 의 조합으로 바꾸는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="w"> &lt;/span>&lt;span class="nt">password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;-&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>{{&lt;span class="w"> &lt;/span>&lt;span class="l">.Values.password }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이게 뭔가요? 이건 Helm Template Engine 기술이 아니라 YAML 테크닉의 일종이고, 문자열 보존을 위한 목적도 아니다. &lt;a class="link" href="https://helm.sh/docs/chart_template_guide/yaml_techniques/#folded-multi-line-strings" target="_blank" rel="noopener"
>Helm 문서&lt;/a>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>를 먼저 보면,&lt;/p>
&lt;blockquote>
&lt;p>Sometimes you want to represent a string in your YAML with multiple lines, but want it to be treated as one long line when it is interpreted. This is called &amp;ldquo;folding&amp;rdquo;. To declare a folded block, use &lt;code>&amp;gt;&lt;/code>.&lt;/p>
&lt;p>YAML에서 문자열을 여러 줄로 표현하고 싶지만, 하나의 긴 줄로 나타내고 싶을 때가 있습니다. 이것을 &amp;ldquo;&lt;em>접기(folding)&lt;/em>&amp;ldquo;라고 부르죠. 접혀야 할 블록을 선언하려면, &lt;code>&amp;gt;&lt;/code> 를 사용하세요.&lt;/p>
&lt;/blockquote>
&lt;p>더 정확한 설명을 해 주는 &lt;a class="link" href="https://yaml-multiline.info/" target="_blank" rel="noopener"
>YAML Multiline 문서&lt;/a>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>를 요약해 보면,&lt;/p>
&lt;ul>
&lt;li>Block 을 유지하려면 &lt;code>|&lt;/code>, 한 줄로 접으려면 &lt;code>&amp;gt;&lt;/code>&lt;/li>
&lt;li>Block 마지막에 줄바꿈을 넣는 것이 기본값, 넣지 않으려면 &lt;code>-&lt;/code> 를 붙이고, 모든 줄바꿈을 유지하려면 (&lt;code>|&lt;/code> 일 때만) &lt;code>+&lt;/code> 를 붙인다.&lt;/li>
&lt;/ul>
&lt;p>그래서 &lt;code>&amp;gt;&lt;/code> 만 사용하면 줄바꿈이 들어간 값을 얻기 때문에, 정확히 우리가 원하는 것은 아니다. &lt;code>&amp;gt;-&lt;/code> 를 써야 한다.&lt;/p>
&lt;h1 id="예제-적용하기">예제 적용하기&lt;/h1>
&lt;p>앞서 &lt;code>helm template&lt;/code> 결과는 다음과 같이 나오는데,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="c"># helm template mychart --set password=&amp;#34;my\&amp;#34;&amp;#39;password&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;-&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my&amp;#34;&amp;#39;password&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="c"># helm template mychart --set password=&amp;#39;my&amp;#34;password&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;-&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my&amp;#34;password&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="c"># helm template mychart --set password=&amp;#34;my&amp;#39;password&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;-&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my&amp;#39;password&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>어? &lt;code>spec.data.password&lt;/code> 에 여전히 &lt;code>&amp;gt;-&lt;/code> 가 남아있고, 값 앞에 줄바꿈도 되어 있는데 읽으면 이상한거 아니예요? 그렇지 않다.&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/mikefarah/yq/" target="_blank" rel="noopener"
>mikefarah/yq&lt;/a>&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>을 사용해서 쿼리해 보면 정상적으로 나오는 것을 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">helm template mychart --set &lt;span class="nv">password&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;my\&amp;#34;password&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> yq &lt;span class="s1">&amp;#39;.spec.data.password&amp;#39;&lt;/span> -r
my&lt;span class="s2">&amp;#34;password
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">helm template mychart --set &lt;span class="nv">password&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;my\&amp;#34;&amp;#39;password&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> yq &lt;span class="s1">&amp;#39;.spec.data.password&amp;#39;&lt;/span> -r
my&lt;span class="s2">&amp;#34;&amp;#39;password
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">helm template mychart --set &lt;span class="nv">password&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;my&amp;#34;password&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> yq &lt;span class="s1">&amp;#39;.spec.data.password&amp;#39;&lt;/span> -r
my&lt;span class="s2">&amp;#34;password
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://helm.sh/docs/chart_template_guide/yaml_techniques/#folded-multi-line-strings" target="_blank" rel="noopener"
>https://helm.sh/docs/chart_template_guide/yaml_techniques/#folded-multi-line-strings&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://yaml-multiline.info/" target="_blank" rel="noopener"
>https://yaml-multiline.info/&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>&lt;a class="link" href="https://github.com/mikefarah/yq/" target="_blank" rel="noopener"
>https://github.com/mikefarah/yq/&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Github Workflow 로 PR Comment 등록하기</title><link>https://interp.blog/github-workflow-pr-comment/</link><pubDate>Tue, 09 Jul 2024 09:56:16 +0900</pubDate><guid>https://interp.blog/github-workflow-pr-comment/</guid><description>&lt;p>현재 하고 있는 작은 프로젝트는, 변경 내용을 main branch 에 반영하고 나서 추가 작업이 이루어지는 구조를 하고 있다. 문제는 이 &lt;em>&amp;lsquo;추가 작업&amp;rsquo;&lt;/em> 을 Pull Request 에서 진행하더라도, main branch 와 working branch 사이에 어떤 결과물 차이가 있는지 눈으로 확인하기가 쉽지 않았다. 그래서, 아예 두 branch 에서 작업을 진행시키고, 진행한 결과를 diff 로 확인하면 어떨까 싶었다.&lt;/p>
&lt;p>Pull Request (PR) 를 등록할 때, Github Workflow 를 이용해서 PR Comment 를 등록하는 방법을 찾아보았다. 이 글에서는, Github Workflow 에서 실행한 결과물을 그대로 PR Comment 로 등록하는 방법을 소개한다.&lt;/p>
&lt;h1 id="언제-실행되어야-할까">언제 실행되어야 할까&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Data Check on PR&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pull_request&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s1">&amp;#39;data/**&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>data/**&lt;/code> 내용이 변경되는 PR 인 경우에만 해당 Workflow 가 작동하도록 했다.&lt;/p>
&lt;h1 id="두-개의-checkout">두 개의 checkout&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">check-data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">self-hosted&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Checkout main branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v4&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ref&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main-branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Checkout PR branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v4&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pr-branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>두 개 버전으로 checkout 을 받아, &lt;code>main-branch&lt;/code> 와 &lt;code>pr-branch&lt;/code> 경로에 각자 두기로 했다. 그리고 아래와 같이 &lt;code>working-directory&lt;/code> 로 구분된 &amp;lsquo;추가작업&amp;rsquo; 을 실행했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Run &amp;#39;task&amp;#39; on main branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">... do something ...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">working-directory&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./main-branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Run &amp;#39;task&amp;#39; on PR branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">... do something ...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">working-directory&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./pr-branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="diff-출력하기">Diff 출력하기&lt;/h1>
&lt;p>두 결과가 각각 &lt;code>main-branch/result&lt;/code> 와 &lt;code>pr-branch/result&lt;/code> 에 저장되었다면, 이를 diff 로 출력해보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Diff&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">diff&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> diff -bur main-branch/result pr-branch/result &amp;gt; diff.txt || true
&lt;/span>&lt;span class="sd"> if [ -s diff.txt ]; then
&lt;/span>&lt;span class="sd"> echo &amp;#34;diff_exists=true&amp;#34; &amp;gt;&amp;gt; $GITHUB_ENV
&lt;/span>&lt;span class="sd"> else
&lt;/span>&lt;span class="sd"> echo &amp;#34;diff_exists=false&amp;#34; &amp;gt;&amp;gt; $GITHUB_ENV
&lt;/span>&lt;span class="sd"> fi
&lt;/span>&lt;span class="sd"> echo &amp;#39;DIFF_REPORT&amp;lt;&amp;lt;EOF&amp;#39; &amp;gt; $GITHUB_OUTPUT
&lt;/span>&lt;span class="sd"> echo &amp;#34;\`\`\`diff&amp;#34; &amp;gt;&amp;gt; $GITHUB_OUTPUT
&lt;/span>&lt;span class="sd"> cat diff.txt &amp;gt;&amp;gt; $GITHUB_OUTPUT
&lt;/span>&lt;span class="sd"> echo &amp;#34;\`\`\`&amp;#34; &amp;gt;&amp;gt; $GITHUB_OUTPUT
&lt;/span>&lt;span class="sd"> echo &amp;#39;EOF&amp;#39; &amp;gt;&amp;gt; $GITHUB_OUTPUT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>하나씩 설명하면,&lt;/p>
&lt;ul>
&lt;li>&lt;code>diff -bur&lt;/code> 은 디렉토리 내부 파일들을 재귀적으로 비교해서 (&lt;code>-r&lt;/code>) 공백은 무시하고 (&lt;code>-b&lt;/code>) Unified diff 로 (&lt;code>-u&lt;/code>) 출력한다.&lt;/li>
&lt;li>&lt;code>|| true&lt;/code> 는 diff 결과가 없어서 종료코드가 1 이 되는 경우를 무시한다. 이게 없다면, 해당 Step 은 실패한다!&lt;/li>
&lt;li>&lt;code>if [ -s diff.txt ]&lt;/code> 는 diff 결과가 있으면, &lt;code>diff_exists=true&lt;/code> 를 환경변수로 저장한다. 이 때 사용하는 &lt;code>$GITHUB_ENV&lt;/code> 는 Workflow 내에서 사용할 수 있는 환경변수를 저장하는 공간이다. (&lt;a class="link" href="https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#example-of-writing-an-environment-variable-to-github_env" target="_blank" rel="noopener"
>예제&lt;/a>)&lt;/li>
&lt;li>&lt;code>echo 'DIFF_REPORT&amp;lt;&amp;lt;EOF'&lt;/code> 이하 내용들은, &lt;code>$GITHUB_OUTPUT&lt;/code> 에 저장된 내용을 &lt;code>$DIFF_REPORT&lt;/code> 라는 사용자 환경변수에 저장한다는 의미이다. 이는 Workflow 내에서 출력할 수 있는 변수로, 이를 이용해서 PR Comment 에 출력할 수 있다. (&lt;a class="link" href="https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#example-masking-a-generated-output-within-a-single-job" target="_blank" rel="noopener"
>예제&lt;/a>)
&lt;ul>
&lt;li>여기서 markdown syntax 를 한꺼번에 적용하기 위해서 ```diff 와 ``` 를 앞뒤로 미리 출력했다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="pr-comment-등록">PR Comment 등록&lt;/h1>
&lt;p>이번에는 &lt;code>github-script&lt;/code> 를 사용한다. 그렇기 때문에 &lt;code>GITHUB_TOKEN&lt;/code> 등록이 필요하다. 자세한 내용은 &lt;a class="link" href="https://zeddios.tistory.com/1047" target="_blank" rel="noopener"
>이 블로그&lt;/a>에 정리가 잘 되어 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Upload diff to PR comment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">if&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">env.diff_exists == &amp;#39;true&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/github-script@v7&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">DIFF_CONTENTS&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{steps.diff.outputs.DIFF_REPORT}}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">github-token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ GITHUB_TOKEN }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> github.rest.issues.createComment({
&lt;/span>&lt;span class="sd"> issue_number: context.issue.number,
&lt;/span>&lt;span class="sd"> owner: context.repo.owner,
&lt;/span>&lt;span class="sd"> repo: context.repo.repo,
&lt;/span>&lt;span class="sd"> body: process.env.DIFF_CONTENTS
&lt;/span>&lt;span class="sd"> })&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Microsoft AI Tour 후기</title><link>https://interp.blog/microsoft-ai-tour-review/</link><pubDate>Tue, 30 Apr 2024 21:23:23 +0900</pubDate><guid>https://interp.blog/microsoft-ai-tour-review/</guid><description>&lt;img src="https://interp.blog/microsoft-ai-tour-review/feature.jpeg" alt="Featured image of post Microsoft AI Tour 후기" />&lt;p>개발자들에게 위기인지 기회인지 모를 물결을 이해하기 위해 OpenAI 관련 내용을 보여줄 수 있는 Microsoft AI Tour 에 신청해 다녀왔다. 코로나 위기가 찾아오기 이전에 열렸던 MS Ignite 행사를 코엑스에 다녀온 이후로, 두 번째 MS 컨퍼런스 행사에 참석한 것이다. 이번에는 코엑스가 아닌, 양재 aT 센터이다.&lt;/p>
&lt;p>우선 초대장에 선착순이라는 문구가 몇 번이고 보였다. 늦으면 아침도 없다는 것 처럼 들렸기 때문에, 7시 30분 정도에 도착해서 등록하고 기다렸다. 아침은 다양한 빵과 우유/커피. 마들렌과 고구마 파이가 맛있었다. 아침이 컨퍼런스의 목적은 아니었지만, 맛있으면 기분 좋게 들을 수 있으니까!&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="breakfast.jpeg"
alt="브런치?" width="80%"/> &lt;figcaption>
&lt;p>브런치?&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>장소가 코엑스에 비해 넓지 않아서인지, 사람이 적었음에도 꽤나 북적였다. aT 센터 1, 3층만 사용하고 그마저도 에스컬레이터 만으로 이동이 가능했기 때문이다. 그래서 원하는 세션을 들으러 가려면 타임테이블을 잘 보고 이동해야 하는 건 기본에, 현재 듣고 있는 세션이 조금 늦을라치면 도중에 나와야 할 정도였다. 불만이라기 보다는, 어쩔 수 없다고 생각한다.&lt;/p>
&lt;p>정말로 불만이었던 점은 워크샵 세션 (핸즈온) 이나 브레이크아웃 (일반) 세션에서 알려주는 &lt;strong>지식 수준&lt;/strong>이었다. &lt;del>내가 RAG 워크샵을 못 들어서 이러는게 아니다&lt;/del> 아무래도 청중의 수준을 가늠할 수 없다보니 가능한한 쉽게 했으리라 이해는 가지만, 그래도 개발자 세션이면 입문 코스보다는 심화 코스 위주로 알려줬으면 하는 바램은 솔직히 있었다.&lt;/p>
&lt;p>아무튼, 씨어터 세션 (부스 세션) 을 제외하고 오늘 들은 걸 간단히 정리하고 싶었다.&lt;/p>
&lt;h1 id="키노트">키노트&lt;/h1>
&lt;p>그 넓고 넓은 키노트 강연장에 모든 사람이 들어갈 수 없어서, 1층 워크샵 세션장에서 스트리밍으로 보았다. 통역기도 자리마다 제공해 줬는데, 왜 통역사가 말하는 걸 스피커로도 틀었는지 의문이다. &lt;a class="link" href="https://www.linkedin.com/in/shanselman" target="_blank" rel="noopener"
>스콧&lt;/a>의 스피치를 듣는게 훨씬 더 나았는데 말이다.&lt;/p>
&lt;p>키노트 내용은 별다른게 없었고, 곧 MS 365 Copilot 이 한국어 지원을 한다는 내용과 LG전자, 엔비디아, SK이노베이션 순으로 Azure AI 사용 사례를 이야기한 게 전부였다. LG전자 상무님은 동굴 목소리에 언변이 좋으셔서 &amp;lsquo;저정도는 해야 저런 자리에 가는구나&amp;rsquo; 싶었다..&lt;/p>
&lt;h1 id="github-copilot">Github Copilot&lt;/h1>
&lt;p>스콧이 키노트 세션장에서 이어서 진행한 세션이었다. 이번에는 3층에 올라가서 들을 수 있어서 좋았고, Copilot 의 무궁무진함을 느껴볼 수 있어서 좋았다.&lt;/p>
&lt;p>주목할만한 구절이 두 개 있었는데, Github Copilot 의 목적은 &amp;lsquo;&lt;strong>Focusing on your own code&lt;/strong>&amp;rsquo; 이라고 한다. 달리 말하면, 여러분만이 짤 수 있는 코드를 작성하는 일 외에 나머지 일들 (구글링을 하거나, 코드를 읽고 이해하거나, 코드 작업으로 다시 돌아오는 과정) 을 도와주기 위한 것이라는 말이다.&lt;/p>
&lt;p>그리고 이 서비스는 &lt;strong>Autopilot 이 아니라 Copilot 이라는 점&lt;/strong>을 많이 강조했다. 알아서 다 해주는 것이 아니라, 여러분이 요청한 것에 맞춰 도움을 줄 수 있도록 제안하는 것이다. 자율주행 차에 올라타서도 핸들을 잡아야 하는 것에 비유하긴 했다.&lt;/p>
&lt;h1 id="azure-ai-search">Azure AI Search&lt;/h1>
&lt;p>워크샵 세션에서 밀려서 듣긴 했는데, 나름 유익했다. Architect 분께서 현업에서 겪었던 일화는 슬라이드에 적혀있지 않았지만 슬쩍슬쩍 보따리에서 꺼내주셔서 재밌었던 것 같다. &lt;del>고객님들은 데이터만 던져주시곤 &amp;lsquo;해줘&amp;rsquo; 하세요 ㅠㅠ&lt;/del>&lt;/p>
&lt;p>RAG 개념을 모르는 사람은 초반부가 흥미가 있었을지 모르겠지만 나는 좀 지루했고, 되려 RAG 의 품질을 올리기 위해 어떤 방법을 쓰는지가 더 궁금했다. 몇 가지 인사이트는, vector search 뿐만 아니라 exact keyword search 를 섞은 hybrid search 가 더 좋은 결과를 낸다는 것이었다. Azure AI Search 는 여기에 더해 Semantic re-ranking 을 제공해서 그 정확도를 올렸다고 한다. 어쨌거나 중요한 건, 프롬프팅에 실어야 할 원천 데이터를 잘 선택하는 일일 것이다.&lt;/p>
&lt;hr>
&lt;p>불만이 있다면 있고 없다면 없겠지만, 그래도 개발자들을 위해서 무료로 컨퍼런스를 열고 지식을 공유받은 입장에서는 훌륭한 시간이었다. 다음에도 기회가 된다면 다른 형태의 컨퍼런스라도 참석하고 싶다!&lt;/p>
&lt;p>오늘 점심 도시락 사진으로 마무리한다. 맛있었다!&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="lunch.jpeg" width="80%"/>
&lt;/figure></description></item><item><title>Git Branch 이름 바꾸기</title><link>https://interp.blog/git-branch-rename/</link><pubDate>Fri, 05 Jan 2024 17:41:29 +0900</pubDate><guid>https://interp.blog/git-branch-rename/</guid><description>&lt;img src="https://interp.blog/git-branch-rename/feature.png" alt="Featured image of post Git Branch 이름 바꾸기" />&lt;p>Git 에서 Branch 이름을 바꾸는 방법에 대해 제대로 정리가 안 되어 있는 것 같아서, 짧지만 예제와 함께 확실히 정리해 보려고 한다.&lt;/p>
&lt;h1 id="상황">상황&lt;/h1>
&lt;p>Github, Gitlab 같은 원격 저장소에 있는 &lt;code>internal&lt;/code> 이란 이름의 branch 가 있다고 가정하자. 이 branch 를 로컬 환경에서 (예: PC, 개발 서버) checkout 받아서 작업을 하고 있었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">git checkout internal
&lt;span class="c1"># do something&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>어? 갑자기 &lt;code>internal&lt;/code> 에서 작업하던 내용이 &lt;strong>Issue#10&lt;/strong> 으로 등록되었다. 이제 이 작업은 &amp;lsquo;내부적&amp;rsquo;인 작업이 아니게 된 것이다. 그래서 Issue 번호를 붙인 branch 이름, &lt;code>issue-10&lt;/code> 으로 바꾸고 싶다.&lt;/p>
&lt;p>즉, 이런 상황이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Local branch = internal
Remote branch = internal
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="local-branch-이름-바꾸기">Local branch 이름 바꾸기&lt;/h1>
&lt;p>아직 원격 저장소에는 반영하기 싫고, 로컬에서만 이름을 바꾸고 싶다면.. 아주 간단하게 바꿀 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># (1) on `internal`` branch&lt;/span>
git branch -m issue-10
&lt;span class="c1"># (2) not on `internal` branch&lt;/span>
git branch -m internal issue-10
git checkout issue-10
git rev-parse --abbrev-ref HEAD &lt;span class="c1"># issue-10&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Local branch = issue-10
Remote branch = internal
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 상태에서 그대로 push 하면 바뀌겠지? 라는 순진한 생각을 실험으로 옮겨보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">git push origin issue-10
Enumerating objects: 1, &lt;span class="k">done&lt;/span>.
Counting objects: 100% &lt;span class="o">(&lt;/span>1/1&lt;span class="o">)&lt;/span>, &lt;span class="k">done&lt;/span>.
Writing objects: 100% &lt;span class="o">(&lt;/span>1/1&lt;span class="o">)&lt;/span>, &lt;span class="m">181&lt;/span> bytes &lt;span class="p">|&lt;/span> 181.00 KiB/s, &lt;span class="k">done&lt;/span>.
Total &lt;span class="m">1&lt;/span> &lt;span class="o">(&lt;/span>delta 0&lt;span class="o">)&lt;/span>, reused &lt;span class="m">0&lt;/span> &lt;span class="o">(&lt;/span>delta 0&lt;span class="o">)&lt;/span>, pack-reused &lt;span class="m">0&lt;/span>
remote:
remote: Create a pull request &lt;span class="k">for&lt;/span> &lt;span class="s1">&amp;#39;issue-10&amp;#39;&lt;/span> on GitHub by visiting:
remote: https://github.com/test/test-project/pull/new/issue-10
remote:
To https://github.com/test/test-project.git
* &lt;span class="o">[&lt;/span>new branch&lt;span class="o">]&lt;/span> issue-10 -&amp;gt; issue-10
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>와! 바뀐거 아니예요?&lt;/em> 그럴리가요!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">git fetch origin
git branch -a
* issue-10
main
remotes/origin/internal
remotes/origin/issue-10
remotes/origin/main
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Local branch = issue-10
Remote branch = issue-10, internal
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>remotes/origin/internal&lt;/code> 이 여전히 남아있다. 깔끔하지 못하다!&lt;/p>
&lt;h1 id="remote-branch-이름-바꾸기">Remote branch 이름 바꾸기&lt;/h1>
&lt;p>원격 저장소에 있는 branch 까지 이름을 바꾸려면 어떻게 해야 할까?&lt;/p>
&lt;p>이미 눈치챘겠지만 그냥 옛날 Remote branch 를 삭제하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># (1)&lt;/span>
git push origin :internal
&lt;span class="c1"># (2)&lt;/span>
git push origin --delete internal
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="이러면-끝-upstream-의-함정">이러면 끝? Upstream 의 함정&lt;/h1>
&lt;p>지금 예제에서는 &lt;em>다행히&lt;/em> 새로운 이름의 branch 가 그대로 Remote branch 로 업로드 된 경우이다. 위의 결과를 다시 가져와보면, &lt;code>issue-10&lt;/code> 은 원격 저장소에 없었는데 이 Push 작업을 통해 새로 생긴 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">To https://github.com/test/test-project.git
* [new branch] issue-10 -&amp;gt; issue-10
&lt;/code>&lt;/pre>&lt;/div>&lt;p>다시 돌아가서, Local branch 이름만 바꾸고 Push 를 했는데 다음과 같은 상황이 발생했다면?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">To https://github.com/test/test-project.git
38b2c6e..7489f75 issue-10 -&amp;gt; internal
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>음?&lt;/em> 기존 Remote branch 인 &lt;code>internal&lt;/code> 에 그대로 반영되었다.&lt;/p>
&lt;p>이러면 Remote branch &lt;code>internal&lt;/code> 을 &lt;code>git push origin --delete&lt;/code> 로 지워본들, &lt;code>issue-10&lt;/code> branch 를 계속 push 할 때 마다 &lt;code>internal&lt;/code> 이란 이름으로 계속 Remote branch 가 생길 것이다.&lt;/p>
&lt;p>왜 이렇게 된 것일까? 답은 Upstream 때문이다. 다음 명령으로 branch 의 상태를 확인해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">git branch -vv &lt;span class="p">|&lt;/span> grep issue-10
* issue-10 7489f75 &lt;span class="o">[&lt;/span>origin/internal&lt;span class="o">]&lt;/span> hello commit
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>[]&lt;/code> 안에 표시된 내용이 Upsteam 이며, 연결된 Remote branch 내용이 들어가 있다. 이 부분이 아예 없다면 Upstream 이 없으니, 새로운 branch 를 Push + 옛날 branch 는 Remote 에서 삭제하는 위 방법만으로 이름을 바꿀 수 있다. 반대로 말하면, Upstream 이 존재하면 추가 조치가 필요하다.&lt;/p>
&lt;h1 id="마지막-조치">마지막 조치&lt;/h1>
&lt;p>이름을 바꾼 Local branch 를 Push 하기 전에, Upstream 을 삭제하는 과정이 필요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">git branch --unset-upstream issue-10
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;div style="background-color: var(--pre-background-color); width: 95%; margin:2rem; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
💡
&lt;/div>
&lt;div>
참고로, &lt;code>git branch --set-upstream-to=&lt;/code> 명령으로 기존 Remote branch 에 Upstream 을 연결하는 방법도 있지만, Remote branch 가 존재하지 않으면 에러가 발생한다.
&lt;/div>
&lt;/div>
그리고 Upstream 을 연결하기 위해 다음과 같이 &lt;code>-u&lt;/code> 옵션을 써서 &lt;code>git push&lt;/code> 하면 된다!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">git push -u origin issue-10
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="한-번에-하기">한 번에 하기&lt;/h1>
&lt;p>귀찮으신 분들을 위해 한 번에 하는 방법을 소개한다. 그냥 변수를 바꾸시면 되겠다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nv">NEW_BRANCH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;internal&amp;#34;&lt;/span>
&lt;span class="nv">OLD_BRANCH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;issue-10&amp;#34;&lt;/span>
&lt;span class="c1"># Local branch&lt;/span>
git checkout &lt;span class="si">${&lt;/span>&lt;span class="nv">OLD_BRANCH&lt;/span>&lt;span class="si">}&lt;/span>
git branch -m &lt;span class="si">${&lt;/span>&lt;span class="nv">NEW_BRANCH&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="c1"># Unset existing upstream and push with new upstream&lt;/span>
git branch --unset-upstream
git push -u origin &lt;span class="si">${&lt;/span>&lt;span class="nv">NEW_BRANCH&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="c1"># Check whether new branch is okay on the remote&lt;/span>
&lt;span class="c1"># Delete old remote branch&lt;/span>
git push origin --delete &lt;span class="si">${&lt;/span>&lt;span class="nv">OLD_BRANCH&lt;/span>&lt;span class="si">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="당부">당부&lt;/h1>
&lt;p>어떻게 하든 예전 Remote branch 를 삭제하는 것은 동일하다. 하지만, Local branch 가 존재하는 로컬 환경이 어떻게 될지 아무도 모른다. 사람 일은 모르기 때문에 Remote branch 를 먼저 삭제해버렸더니, Local branch 를 못 쓰게 될 수도 있다. (disk 가 고장나거나 PC 가 먹통이 되거나!)&lt;/p>
&lt;p>따라서 &lt;strong>반드시 Local branch 를 먼저 Push 한 다음에 Remote branch 를 삭제해야 한다.&lt;/strong>&lt;/p></description></item><item><title>iCloud Obsidian 주기적으로 백업하기</title><link>https://interp.blog/backup-from-icloud-obsidian/</link><pubDate>Sun, 17 Dec 2023 13:27:40 +0900</pubDate><guid>https://interp.blog/backup-from-icloud-obsidian/</guid><description>&lt;img src="https://interp.blog/backup-from-icloud-obsidian/feature.png" alt="Featured image of post iCloud Obsidian 주기적으로 백업하기" />&lt;p>나는 개인 노트 작성에 &lt;a class="link" href="https://obsidian.md/" target="_blank" rel="noopener"
>옵시디언 (obsidian)&lt;/a> 을 사용한다.&lt;/p>
&lt;p>작년까지는 &lt;a class="link" href="https://www.notion.so/" target="_blank" rel="noopener"
>노션 (Notion)&lt;/a> 을 주로 사용했지만, 노션은 데이터베이스 형태로 기록할 만한 것들만 남겨두고, 실제 글들을 아이디어로 엮는 작업은 옵시디언에서 하고 있다. 주로 Macbook 앞에서 작성하지만, 컴퓨터를 쓰지 않을 때는 iPhone 에서 끄적이고 싶을 때 옵시디언 앱을 연다. 어느 쪽에서 쓰더라도, iCloud 를 통해 동기화가 이루어지므로 끊임없이 적을 수 있는 장점도 있다. (최근 워크스페이스가 늘어나면서 모바일 로딩 속도가 느려지는 문제가 있는 듯 하다. 이 때문에 임시 메모장 용도로만 다시 노션을 써야하나 고민 중이긴 하다.)&lt;/p>
&lt;p>아무튼, 옵시디언은 정제된 메모들과 아이디어가 있는 공간이기 때문에, 몇년이고 잘 보존되어야 한다는 욕심이 생겼다. 대학원 시절 잘 &lt;a class="link" href="https://www.joongang.co.kr/article/9019118" target="_blank" rel="noopener"
>사용하던 스프링노트가 서비스 종료&lt;/a>되면서, 백업을 받아두긴 했지만 재활용하기가 너무 힘든 부분이 있었다. 백업을 해 두면, iCloud 를 더 이상 사용하지 않는다거나, 불의의 사고가 생기더라도 저장장치에서 새출발 할 수 있지 않을까 해서 이리저리 알아봤다.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="springnote.png"
alt="추억의 스프링노트.." width="50%"/> &lt;figcaption>
&lt;p>추억의 스프링노트..&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>옵시디언 저장소를 (옵시디언에서는 &lt;em>Vault&lt;/em> 라고 부른다) 아예 OneDrive 나 다른 저장소에 두면 되겠지만, &lt;u>모바일용 옵시디언에서는 외부 파일 클라우드 서비스를 지원하지 않는다.&lt;/u> iPhone 에서만 쓰거나, iCloud 에 동기화하거나.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="obsidian_mobile.jpeg"
alt="모바일 옵시디언에서 저장소 동기화는 iCloud 에서만 가능하다" width="30%"/> &lt;figcaption>
&lt;p>모바일 옵시디언에서 저장소 동기화는 iCloud 에서만 가능하다&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h1 id="문제">문제&lt;/h1>
&lt;p>iCloud 로 동기화 중인 옵시디언 저장소를 다른 파일 동기화 서비스에도 백업해 둘 순 없을까?&lt;/p>
&lt;h1 id="디자인">디자인&lt;/h1>
&lt;p>우선 내 작업 환경을 고려해서 다음 아이디어를 생각해 냈다.&lt;/p>
&lt;ul>
&lt;li>Macbook 이 꺼질 일은 없고, 매일 Macbook 을 사용하니까 Macbook 에서 iCloud 내용을 복사하는 반복 작업을 만들면?&lt;/li>
&lt;li>대부분의 파일 동기화 서비스는 Mac OS 를 지원하니까, Macbook 내부 특정 위치를 동기화하게 만든 다음 그곳으로 iCloud 내용을 복사하면?&lt;/li>
&lt;/ul>
&lt;p>생각보다 간단하게 문제 해결 방법이 정리되었고, 단순 &lt;code>cp&lt;/code> 명령어보다 훨씬 더 좋은 방법을 적용할 수 있었다. (이번에 새로 알게 된 것은 아니고 원래 알고 있었지만&amp;hellip;)&lt;/p>
&lt;h1 id="rsync-를-써보자">rsync 를 써보자!&lt;/h1>
&lt;p>&lt;code>rsync&lt;/code> 는 파일 타임스탬프를 기반으로 (원격 시스템을 포함한) 두 경로 사이를 동기화하는데 사용된다. 당연히 로컬 환경에서도 사용이 가능하다! 하지만 MacOS 에 기본적으로 설치된 버전은 2.x 이기 때문에 인코딩 문제같은 자잘한 걸림돌이 많다. 그래서 먼저, 3.x 버전으로 업그레이드 해보자.&lt;/p>
&lt;p>무릇 MacOS 유저라면 &lt;a class="link" href="https://brew.sh/" target="_blank" rel="noopener"
>Homebrew&lt;/a> 를 설치했으리라 믿는다. 그럼 바로 설치해보자!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">brew install rsync
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Homebrew 에서 설치한 바이너리 명령어들의 설치 경로가 Intel/Silicon Mac 마다 다르다. 해당 경로가 &lt;code>$PATH&lt;/code> 최상단에 있는지 확인하자.&lt;/p>
&lt;ul>
&lt;li>Intel: &lt;code>/usr/local/bin&lt;/code>&lt;/li>
&lt;li>Silicon (M1, M2..): &lt;code>/opt/homebrew/bin&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">export&lt;/span> &lt;span class="nv">PATH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">HOMEBREW_BIN_PATH&lt;/span>&lt;span class="si">}&lt;/span>:&lt;span class="si">${&lt;/span>&lt;span class="nv">PATH&lt;/span>&lt;span class="si">}&lt;/span>
which rsync &lt;span class="c1"># 확인&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>자, 이제 다음 명령어로 동기화를 해보자!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">rsync -uva --delete &lt;span class="si">${&lt;/span>&lt;span class="nv">source&lt;/span>&lt;span class="si">}&lt;/span>/ &lt;span class="si">${&lt;/span>&lt;span class="nv">destination&lt;/span>&lt;span class="si">}&lt;/span>/
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>man rsync&lt;/code> 를 통해서도 얻을 수 있는 정보이지만, 정리해두면 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>-u&lt;/code>: 업데이트 된 파일만 destination 으로 복사&lt;/li>
&lt;li>&lt;code>-v&lt;/code>: 동기화되는 파일 목록과 결과 통계 출력&lt;/li>
&lt;li>&lt;code>-a&lt;/code>: archive mode (recursive + symbolic link + preserve metadata)&lt;/li>
&lt;li>&lt;code>--delete&lt;/code>: 관계없는 파일은 destination 에서 삭제&lt;/li>
&lt;/ul>
&lt;p>반드시 &lt;code>--dry-run&lt;/code> 을 추가해서, 저장 경로에 어떤 파일이 생성되고 삭제되는지 직접 테스트를 해 보자.&lt;/p>
&lt;h1 id="crontab-에-등록">Crontab 에 등록&lt;/h1>
&lt;p>이제는 매일 동기화하도록 해보자. 그런데 주의할 점은, 반드시 바이너리와 두 디렉토리를 모두 절대경로로 작성해야 한다는 것이다. &lt;code>crontab&lt;/code> 은 &lt;code>PATH&lt;/code> 를 인식하지 못하기 때문이며, 실행하는 위치를 특정할 수 없기 때문에 상대경로로 쓸 수 없다.&lt;/p>
&lt;p>말하자면 이런 식이다. (매일 오전 11시에 돌아간다)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 이러면 안 되고&lt;/span>
&lt;span class="m">0&lt;/span> &lt;span class="m">11&lt;/span> * * * rsync -uva --delete src/ dest/
&lt;span class="c1"># 이래야 한다.&lt;/span>
&lt;span class="m">0&lt;/span> &lt;span class="m">11&lt;/span> * * * /opt/homebrew/bin/rsync -uva --delete /Users/username/src/ /Users/username/dest/
&lt;/code>&lt;/pre>&lt;/div>&lt;p>날짜와 함께 로그를 남기고 싶다면, 이렇게 &lt;code>log.log&lt;/code> 에 내용을 쌓는 방법도 있다. 더 좋은 방법이 있겠지만, 간단하니 우선은 이렇게 확인 중이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="m">0&lt;/span> &lt;span class="m">11&lt;/span> * * * date &amp;gt;&amp;gt; /Users/username/log.log &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> /opt/homebrew/bin/rsync -uva --delete /Users/username/src/ /Users/username/dest/ &amp;gt;&amp;gt; /Users/username/log.log
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="operation-not-permitted">Operation not permitted&lt;/h2>
&lt;p>혹시 위 명령어를 보게 된다면 다음을 참고하자.&lt;/p>
&lt;ol>
&lt;li>&amp;lsquo;설정&amp;rsquo; 열기&lt;/li>
&lt;li>검색에서 &amp;lsquo;디스크&amp;rsquo; 를 입력해서, &amp;lsquo;응용 프로그램이 모든 사용자 파일에 접근하는 것을 허용&amp;rsquo; 선택&lt;/li>
&lt;li>목록 맨 아래에 더하기 (+) 기호 클릭&lt;/li>
&lt;li>Command + Shift + G 를 눌러서, &lt;code>/usr/sbin/cron&lt;/code> 입력&lt;/li>
&lt;li>&lt;code>cron&lt;/code> 이 활성화되어 있는지 확인 후, 설정 창 닫기&lt;/li>
&lt;/ol>
&lt;p>🔗 참고 : &lt;a class="link" href="https://apple.stackexchange.com/questions/378553/crontab-operation-not-permitted" target="_blank" rel="noopener"
>https://apple.stackexchange.com/questions/378553/crontab-operation-not-permitted&lt;/a>&lt;/p>
&lt;hr>
&lt;p>&lt;code>/Users/username/dest&lt;/code> 부분은 파일 동기화 클라이언트로 지정해 두면 클라우드/NAS 로 동기화가 자동으로 이뤄질 것이다!&lt;/p></description></item><item><title>Github Pull Request 리뷰 요청 자동화하기</title><link>https://interp.blog/github-actions-pr-review-request/</link><pubDate>Wed, 22 Nov 2023 21:38:53 +0900</pubDate><guid>https://interp.blog/github-actions-pr-review-request/</guid><description>&lt;img src="https://interp.blog/github-actions-pr-review-request/feature.jpg" alt="Featured image of post Github Pull Request 리뷰 요청 자동화하기" />&lt;p>Github 에서 Pull Request 를 생성하면, CI/CD 파이프라인을 통과해서 리뷰 받을 준비를 마쳤음에도 여전히 오픈되어 있는 경우가 있다. 스크럼 회의 시간에 리뷰를 요청해 보기도 하고, 직접 메시지를 보내기도 하지만.. Pull Request 가 많은 경우엔 이런 작업이 여간 귀찮은 일이 아니다.&lt;/p>
&lt;p>&lt;del>답답해서 내가 뛴다는 마음으로&lt;/del> Github Actions 를 이용해, Pull Request 가 특정 조건을 만족하면 매일 아침 팀 Slack 채널에 &amp;lsquo;리뷰 요청&amp;rsquo; 메시지를 보내는 Workflow 를 만들어 보기로 했다. 여기서는 Github Action 이나 Workflow 소개 없이, 문제 해결 과정만 적어 두었다.&lt;/p>
&lt;h1 id="대상-pull-request-조건">대상 Pull Request 조건&lt;/h1>
&lt;ul>
&lt;li>Open&lt;/li>
&lt;li>Approval 을 받지 않음&lt;/li>
&lt;li>마지막 커밋에서 CI/CD 파이프라인을 통과함&lt;/li>
&lt;li>&lt;code>Ready for review&lt;/code> 레이블이 존재함&lt;/li>
&lt;/ul>
&lt;h1 id="workflow-기본-구조">Workflow 기본 구조&lt;/h1>
&lt;p>우선 &lt;del>ChatGPT의 도움을 조금 받아&lt;/del> 다음 2개의 Step 이 포함된 Job 을 지정하는 것부터 출발했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Notify PR Review Request&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">schedule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">cron&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;0 0 * * *&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 매일 00:00&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">notify&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Get Pull Requests&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pulls&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/github-script@v6&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">github-token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{secrets.GITHUB_TOKEN}}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> // ...
&lt;/span>&lt;span class="sd"> // return ...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Send Slack message&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">if&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">steps.pulls.outputs.result != &amp;#39;&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">8398a7/action-slack@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">custom&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">custom_payload&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ fromJSON(steps.pulls.outputs.result) }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">SLACK_WEBHOOK_URL&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.SLACK_WEBHOOK_URL }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>actions/github-script&lt;/code> 와 &lt;code>8398a7/action-slack&lt;/code> 을 사용했고, 각각 &lt;code>$GITHUB_TOKEN&lt;/code> 과 &lt;code>$SLACK_WEBHOOK_URL&lt;/code> Variable 을 필요로 한다.&lt;/p>
&lt;p>Github Token 은 &lt;a class="link" href="https://docs.github.com/en/actions/security-guides/automatic-token-authentication#about-the-github_token-secret" target="_blank" rel="noopener"
>이미 내장되어 있지만&lt;/a>, Slack Webhook URL 은 직접 생성해서 등록해야 한다.&lt;/p>
&lt;h1 id="slack-app-생성">Slack App 생성&lt;/h1>
&lt;p>Slack Workspace 에 App 생성이 가능한 계정에 로그인 되어 있다면, 다음을 따르면 된다.&lt;/p>
&lt;ol>
&lt;li>&lt;a class="link" href="https://api.slack.com/apps?new_app=1" target="_blank" rel="noopener"
>다음 링크&lt;/a> 로 이동&lt;/li>
&lt;li>&amp;lsquo;From scratch&amp;rsquo; 를 선택&lt;/li>
&lt;li>App 이름을 지정하고, 대상 워크스페이스를 선택&lt;/li>
&lt;li>App 화면이 뜨면, &amp;lsquo;Features &amp;gt; Incoming Webhooks&amp;rsquo; 을 선택&lt;/li>
&lt;li>페이지 하단에 &amp;lsquo;Add New Webhook to Workspace&amp;rsquo; 를 클릭&lt;/li>
&lt;li>채널을 추가하면 채널의 Webhook URL 을 확인할 수 있다.&lt;/li>
&lt;/ol>
&lt;div style="background-color: var(--pre-background-color); width: 95%; margin:2rem; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
🪴
&lt;/div>
&lt;div>
&amp;lsquo;Display Information&amp;rsquo;에서 App 아이콘과 이름을 자유롭게 선택할 수도 있으니 참고하자.
&lt;/div>
&lt;/div>
&lt;p>이제 이 Webhook URL 을 Github Secret 으로 등록하면 된다. &lt;em>Settings &amp;gt; Secrets and variables&lt;/em> 에서 등록이 가능하며, 위에서 지정한 것 처럼 &lt;code>SLACK_WEBHOOK_URL&lt;/code> 이라는 이름으로 등록하면 된다.&lt;/p>
&lt;h1 id="rest-api-graphql-api">REST API? GraphQL API!&lt;/h1>
&lt;p>첫 번째 step 인 &lt;code>actions/github-script&lt;/code> 을 채워보자.&lt;/p>
&lt;p>REST API 를 활용한 함수를 사용하는 방법과, GraphQL 을 짜서 한 번에 쿼리하는 방법이 있다. 코드가 좀 더 간결해질 것 같아 두 번째 방법을 사용했는데, 첫 번째 방법을 통해 순차적으로 쿼리하는 것도 물론 가능하다.&lt;/p>
&lt;p>GraphQL 에 대해 잘 모르겠다면, &lt;a class="link" href="https://graphql-kr.github.io/learn/" target="_blank" rel="noopener"
>이 문서&lt;/a> 를 참고하자. Github GraphQL API 에 대한 자세한 내용은 &lt;a class="link" href="https://docs.github.com/ko/graphql" target="_blank" rel="noopener"
>이 문서&lt;/a> 도 참고하자.&lt;/p>
&lt;p>우선, 대상이 되는 정보(&lt;em>제목, URL, 리뷰 상태, 레이블, 최근 커밋의 상태&lt;/em>) 를 모두 뽑아와야 하므로, 아래와 같은 쿼리가 필요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-graphql" data-lang="graphql">&lt;span class="kd">query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nc">repository&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="py">owner&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;${context.repo.owner}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nc">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;${context.repo.repo}&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nc">pullRequests&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="py">states&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nc">OPEN&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">first&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nc">100&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">nodes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">title&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">url&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">reviewDecision&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">labels&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="py">first&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nc">10&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">nodes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">name&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">commits&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="py">last&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nc">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">nodes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">statusCheckRollup&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="py">state&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 쿼리는 현재 담당하는 프로젝트 크기에 맞춰 몇 가지 제약을 뒀다. Open 된 Pull Request 가 100개를 넘지 않고, Label 이 10개 미만으로 추가되는 프로젝트 환경이어야 유효하다. 커다란 프로젝트에서는 참고해야 한다.&lt;/p>
&lt;p>여기 &lt;code>repository&lt;/code> 를 지정할 때 &lt;code>${context.repo}&lt;/code> 의 값을 썼는데, 이는 &lt;code>github-scripts&lt;/code> 에서 제공하는 변수이다. 자세한 내용은 &lt;a class="link" href="https://github.com/actions/toolkit/blob/main/packages/github/src/context.ts" target="_blank" rel="noopener"
>이 소스코드&lt;/a> 를 참고해도 되지만, 지금은 &amp;lsquo;&lt;em>현재 project 의 owner/repo 이름&lt;/em>&amp;rsquo; 을 의미한다고만 알아두자.&lt;/p>
&lt;h1 id="github-scripts-완성">Github Scripts 완성&lt;/h1>
&lt;p>이제 GraphQL 을 사용해서 쿼리를 실행하고, 결과를 필터링해 Map 형태로 반환해보자. 참고로 &lt;code>github-scripts&lt;/code> 는 Javascript 를 사용한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Get Pull Requests&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pulls&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/github-script@v6&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">github-token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{secrets.GITHUB_TOKEN}}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> const query = `...` // 위의 GraphQL 쿼리
&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> const result = await github.graphql(query);
&lt;/span>&lt;span class="sd"> const prs = result.repository.pullRequests.nodes;
&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> const filteredPRs = prs.filter(pr =&amp;gt;
&lt;/span>&lt;span class="sd"> pr.reviewDecision !== &amp;#39;APPROVED&amp;#39; &amp;amp;&amp;amp;
&lt;/span>&lt;span class="sd"> pr.labels.nodes.find(label =&amp;gt; label.name === &amp;#39;Ready for review&amp;#39;) &amp;amp;&amp;amp;
&lt;/span>&lt;span class="sd"> pr.commits.nodes[0].commit.statusCheckRollup.state === &amp;#34;SUCCESS&amp;#34;
&lt;/span>&lt;span class="sd"> );
&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> if (filteredPRs.length &amp;gt; 0) {
&lt;/span>&lt;span class="sd"> // Slack message block 생성
&lt;/span>&lt;span class="sd"> }&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>filteredPRs&lt;/code> 에는 위에서 정의한 조건을 만족하는 Pull Request 들이 담긴다. 이제 이 정보를 Slack message block 으로 만들어서 보내면 된다.&lt;/p>
&lt;h1 id="통합-문제">통합 문제&lt;/h1>
&lt;p>여기서 두 가지 난관이 있었는데,&lt;/p>
&lt;ul>
&lt;li>Step 간에 JSON 으로 정보 교환이 가능한가&lt;/li>
&lt;li>Slack message 를 일반 텍스트가 아니라, 멋지게 만드려면 어떻게 해야 하는가&lt;/li>
&lt;/ul>
&lt;p>첫 번째는 쉽게 해결했다. &lt;code>fromJSON()&lt;/code> 을 활용하면 &lt;code>github-scripts&lt;/code> 에서 반환되는 (따옴표가 전부 escape 된) JSON String 을 그대로 받아다 쓸 수 있었다. 더욱 자세한 내용은 &lt;a class="link" href="https://github.blog/changelog/2020-04-15-github-actions-new-workflow-features/#expressions-in-jobcontinue-on-error" target="_blank" rel="noopener"
>블로그 문서&lt;/a> 를 참고하자.&lt;/p>
&lt;p>두 번째가 조금 어려웠는데, 결국 찾았다. 다음 매뉴얼과 Playground 페이지를 통해 Slack 의 (Block-kit 이라고 하는) custom message 구조를 이해하고 만들어 볼 수 있었다.&lt;/p>
&lt;ul>
&lt;li>매뉴얼: &lt;a class="link" href="https://api.slack.com/reference/block-kit" target="_blank" rel="noopener"
>https://api.slack.com/reference/block-kit&lt;/a>&lt;/li>
&lt;li>Playground: &lt;a class="link" href="https://api.slack.com/tools/block-kit-builder" target="_blank" rel="noopener"
>https://api.slack.com/tools/block-kit-builder&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>그러면 문제는 좀 더 간단해진다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>github-scripts&lt;/code> 에서는 Slack Message 구조를 전부 만들어서 JSON 으로 내보내고&lt;/li>
&lt;li>&lt;code>action-slack&lt;/code> 에서는 JSON 자체를 받아서 출력하면 된다.&lt;/li>
&lt;/ol>
&lt;h2 id="slack-message-구조-생성">Slack message 구조 생성&lt;/h2>
&lt;p>다시 &lt;code>github-scripts&lt;/code> step 으로 돌아가 보자. 제일 처음에 헤더가 되는 block 을 미리 지정한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">blocks&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;header&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;text&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;plain_text&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;text&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;👀 PR 목록&amp;#34;&lt;/span>&lt;span class="p">}},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;divider&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="p">];&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>그 다음, &lt;code>filteredPRs&lt;/code> 결과가 존재하는 경우에 &lt;code>blocks&lt;/code> 안에 메시지를 채워넣는다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">filteredPRs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Slack message block 생성
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">blocks&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>
&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;section&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;text&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;mrkdwn&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;text&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">filteredPRs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pr&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="sb">`• &amp;lt;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">pr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">url&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">|*&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">pr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">title&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">*&amp;gt; `&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;\n&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">});&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>마지막으로, &lt;code>blocks&lt;/code> 를 반환하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript"> &lt;span class="c1">// 디버깅
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">JSON&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stringify&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">blocks&lt;/span> &lt;span class="p">}));&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">JSON&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stringify&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">blocks&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="slack-step-완성">Slack Step 완성&lt;/h2>
&lt;p>&lt;code>pulls&lt;/code> step 에서 반환된 값을 JSON 으로 변환해 그대로 넣는다. 맨 처음 Step 과 크게 달라진 것은 없다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Send Slack message&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">if&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">steps.pulls.outputs.result != &amp;#39;&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">8398a7/action-slack@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">custom&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">custom_payload&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ fromJSON(steps.pulls.outputs.result) }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">SLACK_WEBHOOK_URL&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.SLACK_WEBHOOK_URL }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="마무리-작업">마무리 작업&lt;/h1>
&lt;p>이제 작업은 끝났고 테스트만 남았다.&lt;/p>
&lt;h2 id="main-이-아닌-특정-브랜치에서-workflow-실행하기">main 이 아닌, 특정 브랜치에서 Workflow 실행하기&lt;/h2>
&lt;p>우선, 위 workflow 에서 &lt;code>on:&lt;/code> 절에 다음이 추가되어야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">workflow_dispatch&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 뭘 더 넣을 필요없이 이게 전부다.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>나는 &lt;code>gh&lt;/code> CLI 를 사용해서 로그인한 다음, 아래 명령어로 실행했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">gh workflow run &lt;span class="s1">&amp;#39;Notify PR Review Request&amp;#39;&lt;/span> --ref &lt;span class="o">{&lt;/span>branch&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="github-scripts-디버깅">Github Scripts 디버깅&lt;/h2>
&lt;p>문법 오류를 잡기 위해서는, Javascript Linter 가 작동하는 IDE 에서 먼저 작성한 다음, 옮겨오는 것을 추천한다.&lt;/p>
&lt;h2 id="graphql-디버깅">GraphQL 디버깅&lt;/h2>
&lt;p>API 문서를 뒤져보면 Personal access token 을 사용해서 쿼리를 할 수 있는 방법이 존재한다. 원하는 값이 나오는지 확인한 뒤에 Github Scripts 에 적용해 주자.&lt;/p>
&lt;hr>
&lt;p>이 Workflow 는 특정 이벤트 기반이 아니라, 주기적으로 실행되면서 상태를 직접 체크해야 하기 때문에 Workflow 가 복잡해 진 것 같다. 그래도 Github Actions 를 이용하면, 일일히 리뷰 요청을 하지 않아도 된다. Github Scripts 에서 반환되는 값을 어떻게 받아 처리할지도 사실 막막했는데, &lt;code>fromJSON()&lt;/code> 을 사용하니 간단했다.&lt;/p>
&lt;p>전혀 다른 문제를 Github Actions 로 자동화하려는 경우에도, 이 글이 여러모로 도움이 되었으면 좋겠다.&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="image.png#center" width="70%"/>
&lt;/figure></description></item><item><title>Argo workflow 3가지 기본 개념</title><link>https://interp.blog/argo-workflow-intro/</link><pubDate>Mon, 06 Nov 2023 13:41:01 +0900</pubDate><guid>https://interp.blog/argo-workflow-intro/</guid><description>&lt;img src="https://interp.blog/argo-workflow-intro/feature.png" alt="Featured image of post Argo workflow 3가지 기본 개념" />&lt;p>&lt;a class="link" href="https://argoproj.github.io/argo-workflows/" target="_blank" rel="noopener"
>Argo workflow&lt;/a> 는, 쿠버네티스 환경에서 Job 을 효율적으로 실행하기 위한 컨테이너 기반의 워크플로우 엔진이다. 그리고 오픈소스이다.&lt;/p>
&lt;p>K8s 에서 이미 Job 이나 Cronjob 을 지원하지만, 각각의 Job (여기서는 template) 에 대한 상관관계 (dependency) 를 List 나 DAG 로 지정할 수 있고, 관련이 없는 Job들을 병렬로 실행할 수 있는 것은 물론, 실행 결과를 쉽게 추적할 수 있는 등의 다양한 기능을 추가로 지원한다.&lt;/p>
&lt;p>여기서는 Argo 의 클러스터 설치는 건너뛰고, Argo 를 클러스터에서 사용할 때 갖춰야 할 기본 개념만 간단히 정리해 보았다.&lt;/p>
&lt;h1 id="workflow">Workflow&lt;/h1>
&lt;p>&lt;a class="link" href="https://argoproj.github.io/argo-workflows/workflow-concepts/" target="_blank" rel="noopener"
>Core concepts&lt;/a> 에서 소개된 대로, &lt;strong>Workflow&lt;/strong> CR (custom-resource) 는 정적인 정의 리소스 (a static definition resource) 처럼 보이지만, 일종의 워크플로우 실행 &amp;lsquo;인스턴스&amp;rsquo; 로 취급된다. 무엇을 실행할지 정의해 둔 객체이면서도, 동시에 (Job 이나 Cronjob 처럼) Succeeded 와 같은 &lt;em>상태&lt;/em>를 남기는 것과 같다고 보면 된다.&lt;/p>
&lt;p>Workflow CR 에서 정의되는 &amp;lsquo;할 일 (work)&amp;rsquo; 의 개념은 &lt;code>spec.templates&lt;/code> 에서 정의된다. 할 일이 여러 개일 때, 작업 순서가 Step 형태인지, DAG 형태인지에 따라 steps 또는 tasks 라는 이름으로 세분화되기는 하지만, 기본적으로 Workflow 는 하나 또는 여러 개의 template 을 가진다고 생각하면 된다. (template = work)&lt;/p>
&lt;p>&lt;a class="link" href="https://argoproj.github.io/argo-workflows/walk-through/hello-world/" target="_blank" rel="noopener"
>Getting Started&lt;/a> 에서 Hello World Workflow 를 심어보도록 하자. &lt;code>kubectl&lt;/code> 을 이용해 Workflow CR 자체를 클러스터에 바로 적용해도 되고, &lt;code>argo&lt;/code> CLI 명령을 이용해서 입력해도 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 둘 모두 결과는 같다.&lt;/span>
kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-workflows/master/examples/hello-world.yaml
argo submit https://raw.githubusercontent.com/argoproj/argo-workflows/master/examples/hello-world.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Workflow 확인은 argo CLI 를 쓰는게 편하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">argo get @latest
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="template">template&lt;/h1>
&lt;p>&lt;strong>template&lt;/strong> 은 여섯가지의 타입으로 나뉘어 지는데, 여기 정리하는 것보다는 각각 매뉴얼을 보는게 훨씬 나을 것이므로 종류만 간단히 소개한다.&lt;/p>
&lt;h2 id="template-정의httpsargoprojgithubioargo-workflowsworkflow-conceptstemplate-definitions">&lt;a class="link" href="https://argoproj.github.io/argo-workflows/workflow-concepts/#template-definitions" target="_blank" rel="noopener"
>template 정의&lt;/a>&lt;/h2>
&lt;p>Definition 이라고도 하고, work 라고도 한다. 즉, 실제로 무엇을 할지 정의하는 부분이다. 아래 4가지는 모두 이름 (name) 이 반드시 포함되어야 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Container&lt;/strong>: docker image 를 내려받아, 클러스터 안에서 컨테이너를 확보해 &lt;code>args&lt;/code> 를 실행한다.&lt;/li>
&lt;li>&lt;strong>Script&lt;/strong>: &lt;em>Container&lt;/em> 와 유사하지만 &lt;code>source&lt;/code> 에 정의된 스크립트 내용을 실행한다. Shell Script 나 Python 코드 블럭이 주로 사용된다.&lt;/li>
&lt;li>&lt;strong>Resource&lt;/strong>: 클러스터 안에 있는 리소스를 직접 생성하거나 삭제한다. &lt;code>manifest&lt;/code> 에 정의된 리소스를 생성하거나 삭제한다. 당연하게도 이 부분엔 제약이 있는데, 연결된 ServiceAccount 에 리소스를 제어할 수 있는 적절한 RoleBinding 이 걸려있어야 한다.&lt;/li>
&lt;li>&lt;strong>Suspend&lt;/strong>: 단순히 Workflow 를 잠시금 멈추게 한다. 여기서 걸려서 쉬고있을 때 &lt;code>argo resume&lt;/code> 을 통해 다음으로 진행이 가능하다.&lt;/li>
&lt;/ul>
&lt;h2 id="template-실행httpsargoprojgithubioargo-workflowsworkflow-conceptstemplate-invocators">&lt;a class="link" href="https://argoproj.github.io/argo-workflows/workflow-concepts/#template-invocators" target="_blank" rel="noopener"
>template 실행&lt;/a>&lt;/h2>
&lt;p>Invocator 라고도 하고, orchestration 이라고도 한다. 즉, 앞서 정의해 둔 template 을 어떻게 실행할지 정의하는 부분이다. 따라서 &lt;code>template:&lt;/code> 부분에는, 이미 정의된 template 이름을 참조하게 된다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Steps&lt;/strong>: 여러 개의 step 을 정의하고, 순차적으로 (혹은 병렬로) 실행한다.&lt;/li>
&lt;li>&lt;strong>DAG&lt;/strong>: 여러 개의 task 를 DAG 로 정의할 수 있다. 이 때 edge 는 template 의 이름이 아닌 task 의 이름이어야 한다.&lt;/li>
&lt;/ul>
&lt;h1 id="workflowtemplate">WorkflowTemplate&lt;/h1>
&lt;p>Argo 를 접하면서 가장 헷갈렸던 부분이 바로 &lt;strong>WorkflowTemplate&lt;/strong> CR 이었다. 아까 들은 &lt;em>template&lt;/em> 이랑 무슨 관계인가?&lt;/p>
&lt;p>&lt;a class="link" href="https://argoproj.github.io/argo-workflows/workflow-templates/" target="_blank" rel="noopener"
>소개 페이지&lt;/a> 에서 짚어준 내용을 들여다 보면, 이 CR 은 Workflow 를 템플릿한다는 뜻이고 앞선 template 과는 관련이 적다는 점을 알 수 있다.&lt;/p>
&lt;ol>
&lt;li>&lt;em>WorkflowTemplate&lt;/em> CR 은 Workflow 를 재사용하기 위해 만든 CR 이다. 즉, Workflow 에서 &amp;lsquo;정적인 정의&amp;rsquo; 부분을 저장해두려고 만든 것이다.&lt;/li>
&lt;li>&lt;em>template&lt;/em> 은 Workflow 의 &amp;lsquo;할 일&amp;rsquo; 을 정의한 것이다. &lt;strong>Workflow CR 도, WorkflowTemplate CR 도 한 개의 (또는 여러 개의) template 을 가지고 있어야 한다.&lt;/strong>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>Argo workflow 에서 주로 사용되는 &lt;del>그러면서 엄청나게 헷갈리는&lt;/del> 세 가지 개념을 먼저 짚어봤다. 다음에는 어떻게 workflow 를 관리하고 모니터링 할 수 있는지 CLI 와 UI 도구를 잘 써 봐야겠다.&lt;/p></description></item><item><title>Git merge vs. rebase</title><link>https://interp.blog/git-merge-rebase/</link><pubDate>Tue, 17 Oct 2023 21:23:43 +0900</pubDate><guid>https://interp.blog/git-merge-rebase/</guid><description>&lt;img src="https://interp.blog/git-merge-rebase/feature.jpg" alt="Featured image of post Git merge vs. rebase" />&lt;p>Git 에서 브랜치 (Branch) 를 합치는 방법은 &lt;em>merge&lt;/em> 와 &lt;em>rebase&lt;/em> 가 있다. 보통은 작업 브랜치를 Pull Request 로 등록할 때, 메인이 되는 &lt;code>main&lt;/code> 브랜치 (혹은 &lt;code>master&lt;/code>) 와 작업 브랜치 사이에 충돌 (conflict) 이 발생하는 경우에 사용하게 된다.&lt;/p>
&lt;p>그런데, 주변 개발자들은 &lt;em>merge&lt;/em> 만 해도 충분하다고 생각하는 것 같다. 나는 &lt;em>rebase&lt;/em> 를 해서 깔끔하게 만든 다음에 Pull Request 를 만드는 것을 선호한다. 물론 내 고집만 피울 필요는 전혀 없는 것이, 사실 &lt;em>merge&lt;/em> 로 충돌을 제거하면 상관없기 때문이다.&lt;/p>
&lt;p>그러니 우선은 내가 먼저 알아봐야 하겠다. 어느 것이 더 나은지, 언제 &lt;em>merge&lt;/em> 를 쓰고 언제 &lt;em>rebase&lt;/em> 를 써야 할지 먼저 알아보도록 하자.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h1 id="git-merge">git merge&lt;/h1>
&lt;p>좀 더 쉬운 방법이다. 작업 브랜치 &lt;code>feature&lt;/code> 에서 &lt;code>main&lt;/code> 브랜치 내용을 합치려면 다음과 같이 하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">git checkout feature
git merge main
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이러면 커밋 트리 (commit tree) 가 어떻게 생기는지 혹시 본 적이 있는가? &lt;code>git log&lt;/code> 만 하게 되면 commit 들이 나열되어 있지만, &lt;code>git log --graph&lt;/code> 로 보게 되면 &lt;strong>커밋 트리가 한 줄이 아니라 두 줄&lt;/strong>이 생긴 것을 확인할 수 있다. (Github Desktop 이나 다른 도구를 사용해서도 확인할 수 있다.)&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="merge.svg#center"
alt="출처: Atlassian Git Tutorial" width="80%"/> &lt;figcaption>
&lt;p>출처: Atlassian Git Tutorial&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>이 그림을 잘 보자. 현재 브랜치인 &lt;code>feature&lt;/code> 의 헤드 커밋 (HEAD commit) 이 별표로 표시되어 있는데, 사실 merge 작업을 한다고 새로운 수정내역이 있는 것이 아닌데도 &lt;strong>새로운&lt;/strong> 커밋이 하나 더 생긴 것을 확인할 수 있다. 바로 &lt;code>main&lt;/code> 브랜치의 새로운 커밋을 연결하는 &amp;lsquo;&lt;em>머지 커밋 (merge commit)&lt;/em>&amp;rsquo; 이다.&lt;/p>
&lt;p>나는 이 의미없는 (?) 커밋이 마음에 들지 않았다. 왜냐하면 그래프로 보지 않는 이상, 머지 커밋이 어떤 브랜치의 커밋들을 물고 왔는지 파악하기가 힘들다.&lt;/p>
&lt;p>작업 브랜치와 메인 브랜치만 있다면 괜찮은데, 작업 브랜치가 낳은 또 다른 작업 브랜치가 있는 경우에는 여러 개의 머지 커밋이 중첩될 수 있다. 이럴 땐 커밋 트리가 두 줄이 아니라 세줄 이상도 우습게 생겨난다. 어떤 커밋이 이 아래에서 머지되었는지 파악하기가 점점 어려워진다.&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="complex_graph.png#center"
alt="어.. 음.. 그냥 지저분해요" width="70%"/> &lt;figcaption>
&lt;p>어.. 음.. 그냥 지저분해요&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="6929871144"
data-ad-format="auto"
data-full-width-responsive="true">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h1 id="git-rebase">git rebase&lt;/h1>
&lt;p>반면, &lt;em>rebase&lt;/em> 는 작업 브랜치의 내용을 메인 브랜치 &amp;lsquo;위에 (onto)&amp;rsquo; 올려두는 작업을 진행하는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">git rebase main
&lt;/code>&lt;/pre>&lt;/div>&lt;p>작업한 커밋들을 고스란히 메인 브랜치 위에 올려두기 때문에, 다음과 같은 커밋 트리가 생긴다.&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="rebase.svg#center"
alt="출처: Atlassian Git Tutorial" width="80%"/> &lt;figcaption>
&lt;p>출처: Atlassian Git Tutorial&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>아까 그림과 다른 것이, 메인 브랜치 커밋이 따로 놀지 않고 작업 브랜치의 커밋들이 메인 브랜치 위에서 &lt;em>다시 커밋된 모습&lt;/em>을 볼 수 있다. 그래서 모든 작업 커밋들이 (별표 표시로) 수정된 것 처럼 보인다.&lt;/p>
&lt;p>&lt;strong>머지 커밋? 없다!&lt;/strong> Pull Request 오픈할 때 충돌이 발생할까? 그럴리가! 메인 브랜치에 고스란히 얹기만 하면 되는데 충돌 해결이 필요없다. 물론 이렇게만 이야기하면 당연히 rebase 를 해야겠지만, 현실은 엄청나게 귀찮고 복잡해서 외면받는 경우가 많다.&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-Rebase-%ED%95%98%EA%B8%B0" target="_blank" rel="noopener"
>git rebase&lt;/a> 매뉴얼이 생각보다 복잡하다. 그냥 merge 하고싶은 생각이 들 정도다.&lt;/li>
&lt;li>(나처럼) SVN 을 버전 관리 시스템으로 쓴 구세대 개발자들에겐, rebase 라는 개념이 생소해서 잘 안쓰게 된다. 동감한다.&lt;/li>
&lt;li>충돌 해결만 하면 되는데, 굳이 rebase 를 해야 하냐는 개발자도 물론 존재한다. 이 또한 공감한다.&lt;/li>
&lt;/ul>
&lt;p>세 번째 이야기를 좀 더 해보자. rebase 에는 한 가지 귀찮은 점이 있는데, 바로 작업한 커밋 마다 충돌이 일어나면 그걸 하나씩 해결해주고 &amp;lsquo;rebase 진행&amp;rsquo; 을 시켜야 하기 때문이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">git rebase main
&lt;span class="c1"># conflict on commit A !! resolving..&lt;/span>
git rebase --continue
&lt;span class="c1"># conflict on commit B again !! resolving..&lt;/span>
git rebase --continue
&lt;span class="c1"># ...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A 와 B 에서의 충돌내용이 같을 경우, (운이 좋으면) 한 번만 해결해도 되지만 현실은 그렇지 않다. 그래서 rebase 를 하다보면 충돌 해결에 시간을 조금 더 많이 쓰게 된다는 점은 분명하다.&lt;/p>
&lt;h1 id="어떤-걸-써야-할까">어떤 걸 써야 할까&lt;/h1>
&lt;p>메인 브랜치에서는 rebase 를 하거나, squash 된 commit 만 merge 되도록 해서 커밋 트리를 깔끔하게 유지하자. 작업 브랜치에서 메인 브랜치 내용을 merge 할 때는 사실 어느 것을 써도 무방하지만, 나는 다음 기준으로 사용한다.&lt;/p>
&lt;ul>
&lt;li>커밋이 너무 많아서, rebase 하면서 충돌 해결에 시간을 너무 많이 잡아먹을 경우엔 merge 를 사용한다.&lt;br>
(개인적으로는 merge &amp;ndash;no-commit 으로 작업 내용만 반영받고 충돌을 해결한 뒤 커밋을 따로 하기도 한다)&lt;/li>
&lt;li>&lt;code>git bisect&lt;/code> 로 디버깅을 해야 하는 경우엔 rebase 를 사용한다. 머지 커밋이 끼게 되면 bisect 하기가 쉽지 않았었다.&lt;/li>
&lt;/ul>
&lt;h1 id="참고">참고&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener"
>https://www.atlassian.com/git/tutorials/merging-vs-rebasing&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>자주 쓰는 3가지 파일 검색 터미널 도구</title><link>https://interp.blog/useful-3-terminal-tools/</link><pubDate>Tue, 09 May 2023 13:18:40 +0900</pubDate><guid>https://interp.blog/useful-3-terminal-tools/</guid><description>&lt;p>업무의 절반은 문서 작업, 나머지 절반은 코딩 작업이라고 생각한다. 코딩 작업 중에서도 가장 많이 하는 일은, 바로 &amp;lsquo;찾기&amp;rsquo; 이다. 내용을 찾을 때도 있고, 특정 파일을 찾을 때도 있다. 대부분의 경우엔 경로를 외워두거나 하긴 하는데, 정확히 외우지 않아도 되게끔 도와주는 효율 좋은 도구를 소개한다.&lt;/p>
&lt;p>물론 아래 도구는 모두 터미널 기준이고, VSCode 나 PyCharm, Atom 같은 IDE 는 개별 가이드를 참고해서 써야 하겠다. 아래 도구들은 모두 homebrew 에서 설치가 가능하므로, &lt;code>brew&lt;/code> 를 이용한 설치 명령을 마지막에 추가해 두었다.&lt;/p>
&lt;h1 id="ag-the-silver-searcher">ag, the silver searcher&lt;/h1>
&lt;p>📌 &lt;a class="link" href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="noopener"
>Github&lt;/a>&lt;/p>
&lt;p>&lt;code>grep&lt;/code> 을 대신할 친구다. 나느 &lt;code>grep . -rn&lt;/code> 을 밥먹듯이 하는데, ag 를 사용하면 더욱 빠르게 찾을 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">brew install the_silver_searcher
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">ag &amp;lt;pattern&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="fzf-command-line-fuzzy-finder">fzf, command-line fuzzy finder&lt;/h1>
&lt;p>📌 &lt;a class="link" href="https://github.com/junegunn/fzf" target="_blank" rel="noopener"
>Github&lt;/a>&lt;/p>
&lt;p>단독으로 입력하면 File 을 검색한다. 파이프라인에 태우면 앞선 출력에서 검색한다. 이게 마치 &amp;lsquo;검색어 입력&amp;rsquo; 처럼 키워드를 공백으로 띄워가며 입력해도 알아서 잘 찾아주고, 정규 표현식도 잘 먹는다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">brew install fzf
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># solo&lt;/span>
fzf
&lt;span class="c1"># or after a pipeline&lt;/span>
cat file_list.dat &lt;span class="p">|&lt;/span> fzf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>oh-my-zsh 에 fzf plugin 을 활성화하면, 단축키로 파일 검색 (&lt;code>Ctrl+T&lt;/code>) 이나 히스토리 검색 (&lt;code>Ctrl+R&lt;/code>) 이 가능하다.&lt;/p>
&lt;h2 id="plugin-문제해결">plugin 문제해결&lt;/h2>
&lt;p>참고로 homebrew 로 설치한 뒤 oh-my-zsh plugin 활성화를 한 다음, zsh 를 다시 실행시키면 다음 에러가 뜰 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">[&lt;/span>oh-my-zsh&lt;span class="o">]&lt;/span> fzf plugin: Cannot find fzf installation directory.
Please add &lt;span class="sb">`&lt;/span>&lt;span class="nb">export&lt;/span> &lt;span class="nv">FZF_BASE&lt;/span>&lt;span class="o">=&lt;/span>/path/to/fzf/install/dir&lt;span class="sb">`&lt;/span> to your .zshrc
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 때는 homebrew 의 PATH 설정이 plugin 활성화 시점 이후일 가능성이 높다. 내 경우엔 &lt;code>$HOME/.zshrc&lt;/code> 에서 아래 라인을 &lt;code>plugin=(..)&lt;/code> 위에 두면 해결이 되었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># in your $HOME/.zshrc&lt;/span>
&lt;span class="nb">export&lt;/span> &lt;span class="nv">PATH&lt;/span>&lt;span class="o">=&lt;/span>/opt/homebrew/bin:&lt;span class="nv">$PATH&lt;/span>
&lt;span class="nb">eval&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>/opt/homebrew/bin/brew shellenv&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="c1"># ...&lt;/span>
plugin&lt;span class="o">(&lt;/span>fzf ...&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="fd-simple-and-fast-alternative-to-find">fd, simple and fast alternative to find&lt;/h1>
&lt;p>📌 &lt;a class="link" href="https://github.com/sharkdp/fd" target="_blank" rel="noopener"
>Github&lt;/a>&lt;/p>
&lt;p>&lt;code>find&lt;/code> 을 대신할 친구다. 파일 찾기가 더 빠르다고 한다. 참고로 &lt;a class="link" href="https://github.com/spearkkk/fd-kor" target="_blank" rel="noopener"
>README&lt;/a> 에 한국어가 지원되는데, 아니나 다를까 Main Contributor 가 한국 분이신 &lt;a class="link" href="https://spearkkk.dev/" target="_blank" rel="noopener"
>정창권&lt;/a> 님이시다. (감사합니다!)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">brew install fd
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>fzf&lt;/code> 역시 파일 검색을 할 수 있지만, 내부에서는 &lt;code>find&lt;/code> 결과를 얻어 처리하는 수준이다. 따라서, &lt;code>fzf&lt;/code> 가 &lt;code>fd&lt;/code> 를 사용하게 만드려면 다음의 환경변수가 추가로 필요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">export&lt;/span> &lt;span class="nv">FZF_DEFAULT_COMMAND&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;fd — type f&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Jupyter Notebook on VSCode</title><link>https://interp.blog/jupyter-notebook-vscode/</link><pubDate>Mon, 08 May 2023 09:40:22 +0900</pubDate><guid>https://interp.blog/jupyter-notebook-vscode/</guid><description>&lt;h1 id="jupyter-notebook-이란">Jupyter Notebook 이란&lt;/h1>
&lt;p>웹 브라우저에서 Python 코드를 작성/실행하는 REPL (Read-Eval-Print Loop) 개발 도구이다. 주로 머신러닝이나 데이터분석 용도로 Python을 사용할 때 쓰이는 도구이다. 코드를 작성하고 곧바로 실행한 결과를 볼 수 있어 간편하며, Notebook 파일로 공유가 가능하다는 특징이 있다.&lt;/p>
&lt;p>원래는 &lt;a class="link" href="https://www.anaconda.com/download" target="_blank" rel="noopener"
>&lt;strong>Anaconda&lt;/strong>&lt;/a> 를 활용하면서 Notebook 웹 서비스를 컴퓨터에 띄우는 게 일반적인 사용 방법이다. 하지만, Anaconda 설치나 웹 서비스를 띄우지 않고도 VSCode 에서 곧바로 사용해 볼 수 있는 가장 빠른 방법 역시 정리해 봤다. (물론 &lt;code>conda&lt;/code> 를 쓰지 않는다 뿐이지, 나 또한 가상환경을 따로 설정해서 썼으니 사실상 원리는 똑같다.)&lt;/p>
&lt;h1 id="visual-studio-code-에서">Visual Studio Code 에서&lt;/h1>
&lt;h2 id="확장-프로그램-설치">확장 프로그램 설치&lt;/h2>
&lt;p>&lt;em>View &amp;gt; Extensions&lt;/em> 으로 이동해서 &lt;code>jupyter&lt;/code> 라고 검색하자. Microsoft 에서 공인된 확장 프로그램이 여럿 나오는데, 맨 위에 있는 &lt;a class="link" href="https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter" target="_blank" rel="noopener"
>&lt;strong>Jupyter&lt;/strong>&lt;/a> 만 설치해도 알아서 설치될 것이다.&lt;/p>
&lt;p>아래 노란색으로 칠해 둔 것은 실험적인 기능을 위한 확장 프로그램이니, 필요한 경우에만 설치하도록 하자.&lt;/p>
&lt;p>한 가지 더, &lt;code>Python&lt;/code> 확장 프로그램도 설치되었는지 확인하자.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="extension.png" width="50%"/>
&lt;/figure>
&lt;h2 id="환경-설정-1-python">환경 설정 (1) Python&lt;/h2>
&lt;p>Anaconda 없이 쓸 경우, Python 이나 Virtualenv 와 이미 친숙한 경우라면 이 방법이 좀 더 수월할 수 있다. Python 설치가 안 되어 있다면 &lt;a class="link" href="https://www.python.org/downloads/" target="_blank" rel="noopener"
>설치하면 되는데&lt;/a>, Python 버전은 3.8 이상이면 된다. (ipykernel 때문)&lt;/p>
&lt;p>여기에 프로젝트 디렉터리를 만들고, 거기에만 사용할 가상 환경을 꾸리려면 virtualenv 를 사용하자.&lt;/p>
&lt;p>현재 디렉터리가 프로젝트 디렉터리라고 가정하고, 다음을 실행하자. (Windows 의 경우엔 cmd, powershell 에 따라 활성화 방법이 조금 다르다.)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">python -m pip install virtualenv
python -m virtualenv venv
&lt;span class="nb">source&lt;/span> venv/bin/activate
pip install jupyter ipykernel
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="환경-설정-2-anaconda">환경 설정 (2) Anaconda&lt;/h2>
&lt;p>파이썬 설치나 가상환경 만드는 것 자체가 귀찮거나, 파이썬과 친숙하지 않은 경우, 윈도우에서 한 방에 Jupyter Notebook 을 실행하고자 하는 경우라면 Anaconda 가 더 좋을 수 있다. 사용자가 필요없는 패키지도 설치하기 때문에 용량이 크고 시간이 오래 걸린다는 점은 단점이겠지만 말이다.&lt;/p>
&lt;p>&lt;a class="link" href="https://www.anaconda.com/download" target="_blank" rel="noopener"
>다운로드 사이트&lt;/a>에서 운영체제에 맞는 설치 파일을 내려받아 실행한 뒤, 설치가 끝나면 준비가 완료된 것이다.&lt;/p>
&lt;p>여기서 가상환경을 만들고 싶다면 다음과 같이 한다. 이렇게 하면, 프로젝트 디렉터리 내부에 &lt;code>venv&lt;/code> 따위를 만들지 않아도 되는 편리함은 있다. 대신, 이 때 나오는 &lt;code>environment location&lt;/code> 을 잘 기억해 두자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">conda create -n jupyter_env
conda activate jupyter_env
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="실제-사용">실제 사용&lt;/h2>
&lt;p>다른 예제에서는 ipykernel 을 설치하거나 웹 서비스를 띄워서 브라우저에서 접속한 뒤에 개발을 시작하는데 그럴 필요가 없다.&lt;/p>
&lt;ol>
&lt;li>프로젝트 디렉터리를 만든다. (virtualenv 를 사용한 경우라면 작업해 둔 디렉터리가 이미 있어야 한다)&lt;/li>
&lt;li>VSCode 로 해당 디렉터리를 오픈한다. (File -&amp;gt; Open Folder..) 여기서 작업할 것이다.&lt;/li>
&lt;li>Command Palette (&lt;code>Ctrl+Shift+P&lt;/code> 또는 &lt;code>Cmd+Shift+P&lt;/code>) 를 열어 &lt;strong>Create: New Jupyter Notebook&lt;/strong> 을 선택한다.&lt;/li>
&lt;li>Notebook 파일이 하나 생성되었다. (아직 저장은 안 됨) 이 노트북이 사용할 커널 환경을 지정해야 하는데, 우리가 만든 가상환경 또는 파이썬 실행파일을 지정하기만 하면 알아서 다 해주니까 너무 걱정말자.&lt;/li>
&lt;li>다시 Command Palette 를 열어, 이번엔 &lt;strong>Notebook: Select Notebook Kernel&lt;/strong> 을 선택한다. 반드시 Notebook 파일이 열린 상태에서 선택해야 하며, 다른 파일에서는 아무런 반응이 없으니 주의.&lt;/li>
&lt;li>&lt;strong>Select Another Kernel..&lt;/strong> 을 선택.&lt;/li>
&lt;li>&lt;strong>Python Environments..&lt;/strong> 를 선택.&lt;/li>
&lt;li>이제 Anaconda 를 했건, Virtualenv 를 사용했건 간에 VSCode 가 인식할 수 있는 모든 Python binary 경로가 나온다. 원하는 경로에 있는 Python 을 선택하고, 만약 없으면 Python binary 의 경로를 직접 입력해 주자.&lt;/li>
&lt;/ol>
&lt;p>그러면 VSCode 가 알아서 jupyter 와 ipykernel 을 설치해 준다!&lt;/p>
&lt;p>Virtualenv 의 경우에는 직접 설치하라고 귀띔해 주긴 했는데, 내 기억엔 저게 필요 없었던 것 같지만 보험 차원에서 설명한 것이니 &lt;del>이해해달라&lt;/del>.&lt;/p>
&lt;h1 id="결과">결과&lt;/h1>
&lt;p>나는 Anaconda 로 설치해 둔 게 있어서 환경만 새로 만들어 다음과 같이 바로 돌려봤다. 심지어 Notebook 파일을 저장하지 않았는데도 잘 도는 것을 확인할 수 있다!&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="result.png" width="100%"/>
&lt;/figure>
&lt;h1 id="응용">응용&lt;/h1>
&lt;p>만약 다른 튜토리얼처럼 웹 서버를 실행한 경우엔 어떡할까? 아까 눈치챘겠지만 `&lt;strong>Select Another Kernel..&lt;/strong>' 화면에서 &lt;em>Existing Jupyter Server&lt;/em> 를 선택할 수 있다. 거기서 오픈된 웹 서버 URL 을 입력하면 똑같이 VSCode 인터페이스에서 개발이 가능하다!&lt;/p></description></item><item><title>Pyenv 로 Python 설치 할 때 Openssl 문제</title><link>https://interp.blog/pyenv-openssl-problem/</link><pubDate>Wed, 19 Apr 2023 11:39:11 +0900</pubDate><guid>https://interp.blog/pyenv-openssl-problem/</guid><description>&lt;h1 id="문제">문제&lt;/h1>
&lt;p>&lt;a class="link" href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener"
>pyenv&lt;/a> 를 이용해 Python 3.7 버전 이상 (내 경우는 3.9 버전 이상) 설치할 때 다음의 에러를 만났다. (하다 보니 둘 다 만났다)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">ERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib?
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">*** WARNING: renaming &amp;#34;_hashlib&amp;#34; since importing it failed: /usr/lib64/libcrypto.so.1.1: version `OPENSSL_1_1_1&amp;#39; not found (required by /tmp/python-build.20230418192124.103279/Python-3.10.11/build/lib.linux-x86_64-3.10/_hashlib.cpython-310-x86_64-linux-gnu.so)
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="추적">추적&lt;/h1>
&lt;p>결론은 OpenSSL 1.1.1 을 설치해야 한다는데, 내 경우엔 이 방법이 전부 힘들었다.&lt;/p>
&lt;ul>
&lt;li>1.1.1 을 패키지 매니저로 설치할 수 없는 Linux OS 였고&lt;/li>
&lt;li>Homebrew 로 설치하면 무슨 이유에선지 엄청나게 꼬였다 (&lt;code>ld&lt;/code> 링크할 때 엉뚱한 곳을 본다던가..)&lt;/li>
&lt;/ul>
&lt;p>화면에 바로 안내되는 &lt;a class="link" href="https://github.com/pyenv/pyenv/wiki/Common-build-problems#error-the-python-ssl-extension-was-not-compiled-missing-the-openssl-lib" target="_blank" rel="noopener"
>URL&lt;/a> 를 살펴보면, openssl 을 수동으로 설치하는 방법이 아래에 안내되어 있다. 가장 확실한 방법이다.&lt;/p>
&lt;h1 id="해결">해결&lt;/h1>
&lt;ol>
&lt;li>&lt;a class="link" href="https://help.dreamhost.com/hc/en-us/articles/360001435926-Installing-OpenSSL-locally-under-your-username" target="_blank" rel="noopener"
>Installing OpenSSL locally under your username&lt;/a> 으로 접속&lt;/li>
&lt;li>&lt;strong>Installing OpenSSL&lt;/strong> 을 하나씩 따라하기 (매우 친절하다!)
&lt;ul>
&lt;li>&lt;code>username&lt;/code> 부분을 바꾸는 걸 잊지 말자.&lt;/li>
&lt;li>이 때, &lt;code>make test&lt;/code> 가 실패할 수 있다. 그럴 땐 아쉽더라도 &lt;code>make install&lt;/code> 이후 과정을 진행한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다음을 입력한다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nv">CPPFLAGS&lt;/span>&lt;span class="o">=&lt;/span>-I&lt;span class="nv">$HOME&lt;/span>/openssl/include &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="nv">LDFLAGS&lt;/span>&lt;span class="o">=&lt;/span>-L&lt;span class="nv">$HOME&lt;/span>/openssl/lib &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>&lt;span class="nv">SSH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">$HOME&lt;/span>/openssl
pyenv install -v 3.7.2 &lt;span class="c1"># 원하는 버전을 입력&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ssl-에러">SSL 에러?&lt;/h2>
&lt;p>간혹, 다음 에러를 마주하게 될 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">pyenv install -v 3.9.15
/tmp/python-build.20230419102453.2507312 ~
Downloading Python-3.9.15.tar.xz...
-&amp;gt; https://www.python.org/ftp/python/3.9.15/Python-3.9.15.tar.xz
curl: (60) SSL certificate problem: unable to get local issuer certificate
More details here: https://curl.haxx.se/docs/sslcerts.html
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이럴 땐, 아까 OpenSSL 설치하면서 진행했던 환경변수 설정 부분에서 다음을 주석처리한다. 다시 설치를 시도하면 성공!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"># export PATH=$HOME/openssl/bin:$PATH
# export LD_LIBRARY_PATH=$HOME/openssl/lib
# export LC_ALL=&amp;#34;en_US.UTF-8&amp;#34;
export LDFLAGS=&amp;#34;-L /home/username/openssl/lib -Wl,-rpath,/home/username/openssl/lib&amp;#34;
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Mac 디스플레이 해상도 조절 팁</title><link>https://interp.blog/mac-display-resolution-adjustment/</link><pubDate>Tue, 18 Apr 2023 14:04:01 +0900</pubDate><guid>https://interp.blog/mac-display-resolution-adjustment/</guid><description>&lt;img src="https://interp.blog/mac-display-resolution-adjustment/feature.png" alt="Featured image of post Mac 디스플레이 해상도 조절 팁" />&lt;p>내 Macbook M1 Pro 에는 두 개의 디스플레이가 있다.&lt;/p>
&lt;ul>
&lt;li>DELL U3818DW&lt;/li>
&lt;li>BenQ EX2780Q&lt;/li>
&lt;/ul>
&lt;figure>
&lt;img loading="lazy" src="monitor.png" width="50%"/>
&lt;/figure>
&lt;p>델 38인치 와이드 모니터는 주사율이 60Hz 밖에 지원되지 않지만, 벤큐의 27인치 모니터는 게이밍 답게 144Hz 까지 지원한다. &lt;del>나름 들어줄 만한 스피커도 있어서 서브로 잘 쓰는 중이다&lt;/del>&lt;/p>
&lt;h1 id="증상">증상&lt;/h1>
&lt;p>그런데 이 &amp;lsquo;디스플레이&amp;rsquo; 옵션에서는 HiDPI 설정만 하면 주사율이 50Hz 까지만 올릴 수 있다. HiDPI 를 끄면 144Hz 까지 선택할 수 있는데 말이다.&lt;/p>
&lt;p>내가 원하는 것은, 자글거리는 폰트를 두고 고주사율로 쓰는 게 아니라, HiDPI 이면서 144Hz 로 쓰고 싶었다. 좋은 방법이 없을까?&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="problem.png" width="50%"/>
&lt;/figure>
&lt;h1 id="해결-1-better-display-설치">해결 (1) Better Display 설치&lt;/h1>
&lt;p>&lt;a class="link" href="https://github.com/waydabber/BetterDisplay" target="_blank" rel="noopener"
>Better Display&lt;/a> 를 설치할 수 있다. 기본적으로 무료이고, 특정 기능을 사용하려면 구입해야 하지만 여기서는 무료 기능만 있어도 충분하다.&lt;/p>
&lt;p>설치하고 실행하면, 아래와 같이 해상도, 주사율 설정이 가능하다. HiDPI 설정하고도 주사율을 144Hz 까지 올릴 수 있다!&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="betterdisplay-option.png" width="70%"/>
&lt;/figure>
&lt;p>참고할 점은, 아까 디스플레이 설정에서 HiDPI 를 선택하면 자동으로 주사율 50Hz 가 선택될텐데, 이 상태에서 Better Display 를 실행시키면 해상도가 모두 보이지 않는다. 이 때는 &lt;strong>주사율을 먼저 50Hz 보다 높은 값으로 변경&lt;/strong>하면 된다. 그러면 해상도 옵션이 늘어난다.&lt;/p>
&lt;h1 id="해결-2-더욱-세밀한-hidpi-해상도-설정">해결 (2) 더욱 세밀한 HiDPI 해상도 설정&lt;/h1>
&lt;p>여기서 문제는, Better Display 를 해도 HiDPI 해상도 옵션이 몇개 없다는 사실이다. 나는 조금 더 큰 폰트 크기를 원했기 때문에, 두 개의 옵션 사이에 있는 중간 정도의 HiDPI 해상도를 원했다. 그렇다면 어떻게 해야 할까.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="all-resolution.png" width="50%"/>
&lt;/figure>
&lt;ol>
&lt;li>먼저 &amp;lsquo;디스플레이&amp;rsquo; 옵션에서 모니터를 선택한 뒤, &amp;lsquo;&lt;em>모든 해상도 보기&lt;/em>&amp;rsquo; 를 클릭한다.&lt;/li>
&lt;li>원하는 HiDPI 해상도를 선택한다. (나는 두 가지 옵션의 사이에 있는 1920x1080 을 선택했다)&lt;/li>
&lt;li>Better Display 에 가서, &lt;em>아무것도 건드리지 말고&lt;/em> &lt;strong>주사율 (Refresh rate)&lt;/strong> 만 144Hz 로 올린다.&lt;/li>
&lt;/ol>
&lt;p>그러면 원하는 해상도로 고주사율의 디스플레이를 사용할 수 있다!&lt;/p></description></item><item><title>VSCode Vim 에서 키를 눌러 계속 입력하게 만들기</title><link>https://interp.blog/vscode-vim-mac-key-pressing-input/</link><pubDate>Mon, 03 Apr 2023 16:17:59 +0900</pubDate><guid>https://interp.blog/vscode-vim-mac-key-pressing-input/</guid><description>&lt;img src="https://interp.blog/vscode-vim-mac-key-pressing-input/feature.png" alt="Featured image of post VSCode Vim 에서 키를 눌러 계속 입력하게 만들기" />&lt;h1 id="문제">문제&lt;/h1>
&lt;p>Visual Studio Code 에서 Vim Plugin 을 쓰던 중, 입력한 것을 되돌리기 위해 &lt;code>u&lt;/code> 를 꾹 눌렀다.&lt;/p>
&lt;p>그러면 아래와 같이 &lt;strong>u&lt;/strong> 라는 알파벳에 어떤 변형을 가할 것인지 묻는다. 한/영만 필요한 나에게는 필요없는 기능인데..&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="symptom.png"/>
&lt;/figure>
&lt;p>(참고로, &lt;code>u&lt;/code> 를 꾹 누르는게 아니라 반복해서 입력해도 한 번만 입력되는 경우엔 &lt;a class="link" href="https://interp.blog/vscode-vim-undo-redo-key-repeat" >블로그의 다른 포스팅&lt;/a>을 참고하자.)&lt;/p>
&lt;h1 id="해결">해결&lt;/h1>
&lt;p>터미널에서 다음을 입력하고, VSCode 를 &lt;strong>재시작&lt;/strong>한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="참고">참고&lt;/h1>
&lt;p>출처는 여기 &lt;a class="link" href="https://stackoverflow.com/questions/39972335/how-do-i-press-and-hold-a-key-and-have-it-repeat-in-vscode" target="_blank" rel="noopener"
>Stack overflow&lt;/a> 페이지에서 찾을 수 있다.&lt;/p>
&lt;p>참고로 모든 프로그램에서 저 변형 대화창을 끄고 싶다면 다음과 같이 입력한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">defaults write -g ApplePressAndHoldEnabled -bool false
&lt;/code>&lt;/pre>&lt;/div>&lt;p>윗 부분의 출처는 &lt;a class="link" href="https://junho85.pe.kr/1462" target="_blank" rel="noopener"
>준호씨의 블로그&lt;/a> 포스팅이다. (감사합니다!)&lt;/p></description></item><item><title>Apple Silicon Mac 에 Tensorflow 설치</title><link>https://interp.blog/apple-silicon-mac-tensorflow-install/</link><pubDate>Mon, 27 Feb 2023 00:00:00 +0900</pubDate><guid>https://interp.blog/apple-silicon-mac-tensorflow-install/</guid><description>&lt;img src="https://interp.blog/apple-silicon-mac-tensorflow-install/feature.png" alt="Featured image of post Apple Silicon Mac 에 Tensorflow 설치" />&lt;p>책 &lt;a class="link" href="http://www.yes24.com/Product/Goods/112028850" target="_blank" rel="noopener"
>개발자를 위한 머신러닝&amp;amp;딥러닝&lt;/a> 을 구매해서 읽어보고 있는데, 실습을 해 보기 위해 M1 Pro 칩의 Macbook Pro 에 환경을 설정하려고 했다.&lt;/p>
&lt;p>처음에는 virtualenv 로 가상 환경을 구성하고 tensorflow 를 pip 로 설치하면 되지 않을까? 하는 순진한 생각이었다. 그런데 예제 코드를 돌려보니 뿜어져 나오는 에러에 당황하고 말았다.&lt;/p>
&lt;p>다른 가이드들도 많지만 한번 이해하는 차원에서 여기 다시 정리해 둔다.&lt;/p>
&lt;h1 id="miniconda-설치">Miniconda 설치&lt;/h1>
&lt;p>&lt;a class="link" href="https://www.anaconda.com/products/distribution" target="_blank" rel="noopener"
>Anaconda&lt;/a> 에서 제공하는 tensorflow 관련 dependency 를 설치하기 위해, Anaconda 를 설치해야 한다. 하지만 여기서는 전체 설치를 할 필요는 없고 &lt;strong>Miniconda&lt;/strong> 만 설치해도 된다.&lt;/p>
&lt;p>다음 경로 중 하나를 선택해 Shell script 파일을 다운로드 받는다. 두 번째가 직접 다운로드 가능한 경로이다.&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://docs.conda.io/en/latest/miniconda.html" target="_blank" rel="noopener"
>Miniconda Download page&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh" target="_blank" rel="noopener"
>Shell script 다운로드 링크&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>파일이 위치한 곳에서, 다음 명령을 차례대로 입력한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">bash ./Miniconda3-latest-MacOSX-arm64.sh -b -p &lt;span class="nv">$HOME&lt;/span>/miniconda
&lt;span class="nb">source&lt;/span> &lt;span class="nv">$HOME&lt;/span>/miniconda/bin/activate
conda
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>conda&lt;/code> 명령에 에러가 없으면 설치가 완료되었다. 추가로 다음을 입력해 주자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">conda init &lt;span class="o">{&lt;/span>shell&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>{shell}&lt;/code> 에는 현재 사용중인 쉘을 입력한다. bash, zsh 같은 것 말이다. 잘 모르겠다면 &lt;code>echo $SHELL&lt;/code> 을 입력해서 알아내자.&lt;/p>
&lt;h1 id="conda-환경에서-tensorflow-설치">Conda 환경에서 Tensorflow 설치&lt;/h1>
&lt;p>&lt;a class="link" href="https://developer.apple.com/metal/tensorflow-plugin/" target="_blank" rel="noopener"
>Apple Developer Page&lt;/a> 에 안내된 대로 설치하면 완료된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">conda create -n tf-env &lt;span class="nv">python&lt;/span>&lt;span class="o">=&lt;/span>3.8
conda install -c apple tensorflow-deps
&lt;/code>&lt;/pre>&lt;/div>&lt;p>위와 같이 conda environment 를 설정한다.&lt;/p>
&lt;p>Python 버전은 &lt;em>3.8&lt;/em> 이 테스트되었고 다른 버전에 대해서는 자잘한 문제를 일으킬 수 있으니, 버전 업그레이드는 추천하지 않는다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">conda activate tf-cert3.8
pip install tensorflow-macos&lt;span class="o">==&lt;/span>2.9.0
pip install tensorflow-metal&lt;span class="o">==&lt;/span>0.5.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>tensorflow-macos&lt;/code> 나 &lt;code>tensorflow-metal&lt;/code> 의 버전도 가급적이면 그대로 놔 두길 추천한다. 참고로 최신 버전은 현재 &lt;em>2.11.0&lt;/em> 까지 확인되었다.&lt;/p>
&lt;h1 id="설치-확인">설치 확인&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">import&lt;/span> &lt;span class="nn">tensorflow&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">tf&lt;/span>
&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">__version__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>버전이 잘 출력되면 성공이다.&lt;/p>
&lt;h1 id="테스트-코드-확인">테스트 코드 확인&lt;/h1>
&lt;p>여려 예제가 있겠지만, 책의 첫 번째 예제 코드를 실행해 보자.&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/rickiepark/aiml4coders/blob/main/ch01/01-first-model.ipynb" target="_blank" rel="noopener"
>여기에서&lt;/a> Jupyter Notebook 파일로 제공되고 있으니 코드만 긁어다가 파이썬으로 실행해서 문제가 없어야 한다. (혹시 코드가 궁금하다면, 책을 한 번 읽어보길 권한다!)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">import&lt;/span> &lt;span class="nn">tensorflow&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">tf&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">tensorflow.keras&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">Sequential&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">tensorflow.keras.layers&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">Dense&lt;/span>
&lt;span class="n">dense&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Dense&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">units&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">input_shape&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="n">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Sequential&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">dense&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="n">model&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">compile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">optimizer&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;sgd&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">loss&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;mean_squared_error&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">xs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mf">1.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">2.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">3.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">4.0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">dtype&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">ys&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mf">3.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mf">1.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">3.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">5.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">7.0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">dtype&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">model&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">xs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ys&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">epochs&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">500&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>VSCode Vim Undo/Redo 키 반복 입력이 안 될 때</title><link>https://interp.blog/vscode-vim-undo-redo-key-repeat/</link><pubDate>Tue, 21 Feb 2023 00:00:00 +0900</pubDate><guid>https://interp.blog/vscode-vim-undo-redo-key-repeat/</guid><description>&lt;img src="https://interp.blog/vscode-vim-undo-redo-key-repeat/feature.png" alt="Featured image of post VSCode Vim Undo/Redo 키 반복 입력이 안 될 때" />&lt;h1 id="문제">문제&lt;/h1>
&lt;p>최근에 Undo 키인 &lt;code>u&lt;/code> 와 Reo 키인 &lt;code>Ctrl+r&lt;/code> 을 반복해서 입력해도, 딱 &lt;strong>한 번씩만&lt;/strong> 작동하는 현상을 겪었다.&lt;/p>
&lt;h1 id="조치">조치&lt;/h1>
&lt;p>우선 VSCodeVim 의 이슈에는 &lt;a class="link" href="https://github.com/VSCodeVim/Vim/issues/1490" target="_blank" rel="noopener"
>몇년 전에 올라온 것&lt;/a> 이 있는데, 최근 코멘트를 뒤지다 보니 workaround 는 찾을 수 있었다. (&lt;a class="link" href="https://github.com/VSCodeVim/Vim/issues/2007#issuecomment-529924611" target="_blank" rel="noopener"
>링크&lt;/a>)&lt;/p>
&lt;ol>
&lt;li>Command Palette 를 열어서 &lt;strong>Preferences: Open User Settings (JSON)&lt;/strong> 을 검색해 선택한다.&lt;/li>
&lt;li>열린 JSON 파일에, 다음을 붙여넣는다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;vim.normalModeKeyBindingsNonRecursive&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;u&amp;#34;&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[],&lt;/span>
&lt;span class="nt">&amp;#34;commands&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;command&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;undo&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;&amp;lt;C-r&amp;gt;&amp;#34;&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[],&lt;/span>
&lt;span class="nt">&amp;#34;commands&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;command&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;redo&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>물론 특정 Workspace 에만 설정하고 싶다면, &lt;strong>Preferences: Open Workspace Settings (JSON)&lt;/strong> 을 선택해 편집하면 된다.&lt;/p></description></item><item><title>Docker Container 출력이 Disk 를 채운다</title><link>https://interp.blog/docker-container-print-uses-disk/</link><pubDate>Thu, 09 Feb 2023 02:00:00 +0900</pubDate><guid>https://interp.blog/docker-container-print-uses-disk/</guid><description>&lt;img src="https://interp.blog/docker-container-print-uses-disk/feature.png" alt="Featured image of post Docker Container 출력이 Disk 를 채운다" />&lt;p>어느 날, GCP 에서 알람이 날아왔다. 테스트로 docker container를 하나 올려 둔 VM (Compute Engine) 에서 &lt;em>Disk 가 꽉 차서 아무것도 할 수 없다&lt;/em>는 것이었다.&lt;/p>
&lt;p>디스크를 쓴다고? 이 container 는 mount 된 volume 도 없었고, container 가 하는 일은 소스에서 데이터를 받아 계산한 뒤 GCP Cloud Storage 에 저장하는 것 밖에 하지 않는데?&lt;/p>
&lt;h1 id="문제">문제&lt;/h1>
&lt;p>Docker container 만 떠 있고 아무런 작업을 하지 않는 Host 의 &lt;strong>디스크 사용량이 계속해서 줄어든다.&lt;/strong> 결국, 디스크를 100% 가까이 쓰게 되어 시스템을 마비시킨다.&lt;/p>
&lt;h1 id="진단">진단&lt;/h1>
&lt;p>우선 해당 Host (VM 또는 on-premise) 에 접속해서 &lt;code>df -h&lt;/code> 를 실행하자. &lt;code>/&lt;/code> 경로에서 디스크 사용량이 압도적으로 많다면, 해당 문제에 접근한 것이다.&lt;/p>
&lt;p>이제 이 부분을 실행해 보자. (root 가 아니라면, sudoer 권한이 필요하다)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">sudo du -h -d &lt;span class="m">1&lt;/span> /var/lib/docker/containers
&lt;/code>&lt;/pre>&lt;/div>&lt;p>해당 경로에서 특정 container 의 디스크 사용량이 &lt;code>df -h&lt;/code> 를 입력했을 때의 사용량과 비슷하다면, 이 친구가 문제다.&lt;/p>
&lt;h1 id="분석">분석&lt;/h1>
&lt;p>그렇다면 왜 디스크를 쓰는 container 가 아닌데, 이렇게 디스크를 먹었던 것일까?&lt;/p>
&lt;p>&lt;code>docker logs&lt;/code> 를 입력하면 container 의 stdout/stderr 출력 내용을 볼 수 있다. &lt;strong>문제는, Docker daemon 은 별다른 지시가 없다면 container 가 출력하는 내용을 전부 디스크에 쓴다는 것이다.&lt;/strong>&lt;/p>
&lt;p>바로 &lt;code>/var/lib/docker/containers&lt;/code> 경로에 말이다!&lt;/p>
&lt;br/>
&lt;p>&lt;a class="link" href="https://docs.docker.com/config/containers/logging/configure/" target="_blank" rel="noopener"
>Docker docs 페이지&lt;/a>에도 같은 내용을 경고하고 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>By default, no log-rotation is performed.&lt;/strong> As a result, log-files stored by the default json-file logging driver logging driver can cause a significant amount of disk space to be used for containers that generate much output, which can lead to disk space exhaustion.&lt;/p>
&lt;/blockquote>
&lt;h1 id="해결">해결&lt;/h1>
&lt;p>container directory 를 지우는 것은, 문제를 완화하고 서비스를 잠시 정상으로 되돌려 놓을 순 있지만 진짜 해결책은 아니다.&lt;/p>
&lt;p>분석에서 말한 대로, container 가 출력하는 내용을 rotation 으로 기록하도록 만들어야 한다. 즉, &lt;em>최근 출력만 기억하게 하고 오래된 것은 삭제하도록&lt;/em> 말이다.&lt;/p>
&lt;p>먼저, &lt;code>/etc/docker/daemon.json&lt;/code> 에 아래 내용을 넣는다. (없으면 만든다)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;log-driver&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;json-file&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;log-opts&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;max-size&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;10m&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;max-file&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;3&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>container 가 출력하는 최신 내용을 JSON 포맷으로 10MB 씩 3개의 파일로 저장하고, 오래된 내용은 없애도록 하는 것이다. 원하는 값으로 수정하거나, &lt;a class="link" href="https://docs.docker.com/config/containers/logging/configure/" target="_blank" rel="noopener"
>Docker docs 페이지&lt;/a> 를 참고해 다양한 설정으로 바꿔줘도 무방하다.&lt;/p>
&lt;p>설정이 끝났다면, Docker daemon 을 재시작한다. 나의 경우엔 &lt;code>sudo service docker restart&lt;/code> 로 재시작했다.&lt;/p>
&lt;p>이후 container 를 다시 실행시킨 뒤, 출력이 쌓일 때 까지 기다렸다가 &lt;code>/var/lib/docker/containers/&lt;/code> 에서 &lt;code>{container_id}&lt;/code> directory 에 있는 &lt;code>.log&lt;/code> 파일이 3개&lt;strong>만&lt;/strong> 생성되어 있는지 확인하면 된다.&lt;/p></description></item><item><title>Secure Communication 에 대한 모든 것</title><link>https://interp.blog/ssl-tls-pki-x509-certificate/</link><pubDate>Thu, 02 Feb 2023 17:00:00 +0900</pubDate><guid>https://interp.blog/ssl-tls-pki-x509-certificate/</guid><description>&lt;img src="https://interp.blog/ssl-tls-pki-x509-certificate/feature.jpeg" alt="Featured image of post Secure Communication 에 대한 모든 것" />&lt;h1 id="시작하면서">시작하면서&lt;/h1>
&lt;p>SSL/TLS/HTTPS 부터 알아보자.&lt;/p>
&lt;ul>
&lt;li>SSL (Secure Socket Layer): 클라이언트와 서버 간 보안 통신을 위한 프로토콜이다.&lt;/li>
&lt;li>TLS (Transport Layer Security): SSL 에서 발전된 프로토콜. SSL/TLS 로 묶어서 부르고 있음.&lt;/li>
&lt;li>HTTPS (HTTP Secure): SSL/TLS 위에서 통신하는 HTTP&lt;/li>
&lt;/ul>
&lt;p>결국은 셋 모두 &amp;lsquo;클라이언트와 서버가 주고받는 정보가 안전하게 만드는 프로토콜&amp;rsquo; 이라는 것인데, 그럼 TLS 에서는 어떻게 정보를 안전하게 만드는 걸까? 이해한 대로 최대한 쉽게 풀어내 보려고 한다.&lt;/p>
&lt;p>대부분의 내용은 &lt;a class="link" href="https://www.udemy.com/course/certified-kubernetes-administrator-with-practice-tests/" target="_blank" rel="noopener"
>Udemy CKA 강의&lt;/a>를 바탕으로 정리했다.&lt;/p>
&lt;h1 id="시나리오-1-암호화-비대칭-키">시나리오 (1) 암호화, 비대칭 키&lt;/h1>
&lt;p>태초에 (?) 클라이언트와 서버는 다음과 같이 통신을 시작한다.&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>클라이언트가 서버에 접속한다.&lt;/li>
&lt;li>서버는 클라이언트에게 사용자 정보 (ID, Password) 를 요청한다.&lt;/li>
&lt;li>클라이언트는 사용자 정보를 서버에게 보낸다.&lt;/li>
&lt;li>이제 서버는 클라이언트의 사용자를 확인할 수 있다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>이 과정에 아무런 보안이 적용되지 않는다면, &lt;strong>해커가 패킷을 수집해서 ID 와 패스워드를 들여다 볼 수 있다.&lt;/strong> 평문 (plain text) 으로 전달되기 때문이다. 그렇다면 이 평문을 알아볼 수 없게 해야 한다. 암호화/복호화 (encryption/decryption) 를 해야 한다.&lt;/p>
&lt;p>서버는 암호화와 복호화가 가능한 키 (key) 를 만들어 뒀다고 가정하자.&lt;/p>
&lt;blockquote>
&lt;ol start="2">
&lt;li>서버는 클라이언트에게 &lt;strong>키&lt;/strong>를 준다. &amp;lsquo;이걸로 암호화해서 줘&amp;rsquo;&lt;/li>
&lt;li>클라이언트는 &lt;strong>서버가 준 키를 가지고 사용자 정보를 암호화&lt;/strong>해서 보낸다.&lt;/li>
&lt;li>서버는 암호화한 정보를 &lt;strong>복호화&lt;/strong>해서 안전하게 (?) 사용자를 확인한다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>이 시나리오의 문제는? (2) 에서 &lt;strong>키를 보내는 패킷은 암호화되지 않는다는 점&lt;/strong>이다. 이 키를 읽게 되면, (3) 에서 보낸 정보를 해커 역시 복호화 할 수 있게 된다. 그래서 나온 것이 비대칭 키 (asymmetric key) 이다. 오래전부터 사용된 &lt;a class="link" href="https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29" target="_blank" rel="noopener"
>RSA&lt;/a> 같은 것들 말이다.&lt;/p>
&lt;p>이번엔 서버가 공개 키와 비공개 키를 한 쌍 (public/private key pair) 만들어 뒀다고 가정하자.&lt;/p>
&lt;blockquote>
&lt;ol start="2">
&lt;li>서버는 클라이언트에게 &lt;strong>공개 키&lt;/strong>를 준다. &amp;lsquo;이걸로 암호화해서 줘&amp;rsquo;&lt;/li>
&lt;li>클라이언트는 서버가 준 &lt;strong>공개 키&lt;/strong>를 가지고 사용자 정보를 암호화해서 보낸다.&lt;/li>
&lt;li>서버는 암호화한 정보를 &lt;strong>비공개 키로&lt;/strong> 복호화해서 안전하게 (?) 사용자를 확인한다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>여기서 주목할 점은, &lt;strong>공개 키는 &lt;u>암호화&lt;/u>할 때 쓰고 비공개 키는 &lt;u>복호화&lt;/u> 할 때만 쓴다는 점&lt;/strong>이다. 그러면 복호화에 필요한 비공개 키는 해커가 알 수 없으니 안전해 보인다.&lt;/p>
&lt;h1 id="시나리오-2-피싱-그리고-인증서">시나리오 (2) 피싱, 그리고 인증서&lt;/h1>
&lt;p>이번엔 해커가 패킷을 수집하는 것을 포기하고, &lt;strong>클라이언트나 사용자를 속여서 피싱을 했다&lt;/strong>고 가정하자.&lt;/p>
&lt;p>피싱 방법은 여러 가지인데, 사회공학적 기법으로 구별하기 어려운 URL 을 사용자에게 제공하거나, 클라이언트나 DNS를 해킹하는 방법이 필요하겠다. 아무튼 해커가 준비한 가짜 사이트로 들어가게 되면, 해커가 마련한 비대칭 키를 가지고 사용자 정보가 고스란히 넘어가게 된다.&lt;/p>
&lt;p>이런 시나리오를 방지하기 위해서, 서버가 보내는 공개 키를 누군가가 보증해야 하며, &amp;lsquo;이 공개 키는 안전합니다! &lt;del>안심하고 정보를 넘겨 주십시오&lt;/del>&amp;rsquo; 라는 뜻의 &lt;strong>인증서&lt;/strong>가 필요하다.&lt;/p>
&lt;blockquote>
&lt;ol start="2">
&lt;li>서버는 클라이언트에게 &lt;strong>공개 키가 담긴 인증서&lt;/strong>를 준다. &lt;br/>&amp;lsquo;이거 &lt;u>인증 받은&lt;/u> 공개키야, 이걸로 암호화해서 줘&amp;rsquo;&lt;/li>
&lt;li>클라이언트는 서버가 준 인증서가 진짜인지 확인한다. (사인해 준 곳에 가서 물어보거나..)&lt;/li>
&lt;li>클라이언트는 서버가 준 공개 키를 가지고 사용자 정보를 암호화해서 보낸다.&lt;/li>
&lt;li>서버는 암호화한 정보를 비공개 키로 복호화해서 안전하게 (?) 사용자를 확인한다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>이렇게 공개 키를 인증받고 교환하는 모든 과정을 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C_%ED%82%A4_%EA%B8%B0%EB%B0%98_%EA%B5%AC%EC%A1%B0" target="_blank" rel="noopener"
>공개 키 기반 구조 (Public Key Infrastructure, PKI)&lt;/a> 이라고 부른다. 그리고 PKI 의 ITU 표준이 &lt;a class="link" href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener"
>X.509&lt;/a> 인 것이다.&lt;/p>
&lt;p>간략히 말하자면, 이 인증서에는 (1) 공개 키 (2) 서버의 신원 (호스트네임, 기관이나 개인 이름 등) (3) 인증서에 사인을 해 준 기관 (Certificate Authority, &lt;em>CA&lt;/em>) 이 포함되어 있다. (CA 로부터 사인받지 않았다면 self-signed 로 표시된다)&lt;/p>
&lt;div style="background-color: var(--pre-background-color); width: 95%; margin:2rem; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
💡
&lt;/div>
&lt;div>
&amp;lsquo;CA 의 비대칭 키 한 쌍&amp;rsquo; 은 &lt;strong>Root/Intermediate Certificate&lt;/strong> 라고 한다. &lt;br/>&lt;br/>
Root 와 Intermediate 의 차이는 CA 의 공개 키를 어디서 인증 받았는지 여부에 달렸다. Root Certificate 의 공개 키는 Self-signed 이고, &lt;strong>Intermediate Certificate 의 공개 키는 는 다른 CA 가 사인해 준 것&lt;/strong>이다. CA 에서 발급받은 일반 인증서는 Leaf Certificate 라고 부른다. (&lt;a href="https://cert-manager.io/docs/reference/tls-terminology/#whats-the-difference-between-root-intermediate-and-leaf-certificates">링크&lt;/a>) &lt;br/>&lt;br/>
일반적인 인터넷 환경이라면 이 차이를 굳이 알 필요가 없지만, Kubernetes Cluster 를 구축하거나 운영할 때는 master node 에 위치한 Root Certificate 부터 다룰 수 있어야 한다. (K8s Cluster 의 다른 서비스와 보안 통신을 하기 위해서!)
&lt;/div>
&lt;/div>
&lt;p>자, 이제 여기서 해커가 생각할 수 있는 건 무엇일까?&lt;/p>
&lt;h2 id="self-signed-인증서를-보낸다면">Self-signed 인증서를 보낸다면?&lt;/h2>
&lt;p>위의 피싱 시나리오에서, 해커가 혼자 사인한 (self-signed) 인증서로 감싸서 던지면 되지 않을까?&lt;/p>
&lt;p>&lt;strong>이제부터는 클라이언트 (좀 더 친숙한 표현으론, 웹 브라우저) 에서 경고를 뿜는다.&lt;/strong> &amp;ldquo;이 인증서를 받았는데, 발급 기관이 없는데요? (아니면 이상한데요?)&amp;rdquo; 라고 말이다. 쉽게 말하면, 주소창에 &lt;code>https://&lt;/code> 로 시작하는 주소를 입력했는데, 자물쇠 모양이 &lt;span style="color:red">빨갛게&lt;/span> 보이는 경우다.&lt;/p>
&lt;h2 id="해커가-ca-를-만들어-사인을-받는다면">해커가 CA 를 만들어 사인을 받는다면?&lt;/h2>
&lt;p>아예 악의적인 CA 를 만들어서, 거기서 인증서를 사인해 주면 어떨까?&lt;/p>
&lt;p>대부분의 웹 브라우저는 공인된 CA 의 공개 키를 이미 내장하고 있다. 이외의 CA 와 통신하고자 한다면 브라우저가 경고를 보낸다. &amp;ldquo;이 인증서가 진짜인지 확인하기 위해, 인증서가 가리키는 CA 와 통신하려고 하는데요.. 제가 모르는 곳인데 괜찮나요?&amp;rdquo; 라고 말이다.&lt;/p>
&lt;h1 id="정리-결국-암호화">정리: 결국 암호화&lt;/h1>
&lt;p>정리를 해 보니 결국 통신 암호화를 확실히 하기 위한 일련의 역사를 되짚은 느낌이다. 용어에 통일성이 없으니 들을 때마다 어색해지기 마련이었는데, 이렇게나마 나열해 보니 두려움이 조금 사라지긴 했다.&lt;/p>
&lt;p>CKA 시험에는 CSR (Certificate Signing Request) 보내는 방법까지 배우긴 하는데 거기까진 여기서 다루지 않아도 될 듯하다.&lt;/p></description></item><item><title>SSH 비대칭 키로 접속할 때 문제 해결</title><link>https://interp.blog/ssh-authorized-keys-problem/</link><pubDate>Fri, 23 Dec 2022 13:57:59 +0900</pubDate><guid>https://interp.blog/ssh-authorized-keys-problem/</guid><description>&lt;img src="https://interp.blog/ssh-authorized-keys-problem/feature.jpg" alt="Featured image of post SSH 비대칭 키로 접속할 때 문제 해결" />&lt;p>클라이언트에서 서버로 SSH 접속을 패스워드 없이 하기 위해&lt;/p>
&lt;ul>
&lt;li>클라이언트 컴퓨터에서, RSA 알고리즘으로 비대칭 키를 생성했다.&lt;/li>
&lt;li>비대칭 키의 Public Key 를 서버의 &lt;code>~/.ssh/authorized_keys&lt;/code> 파일에 붙여넣었다.&lt;/li>
&lt;/ul>
&lt;p>그런데도 아직 패스워드를 입력하라고 하면?? 혹시나 해서 &lt;code>ssh -vvv ..&lt;/code> 로 디버그 메시지를 출력해 보니&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">debug1: Offering public key: debug3: send packet: type 50
debug2: we sent a publickey packet, wait for reply
debug3: receive packet: type 51
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이런 메시지를 혹시 만났다면, 다음을 체크해 보자.&lt;/p>
&lt;h1 id="ssh-의-소유자권한-점검">&lt;code>.ssh/&lt;/code> 의 소유자/권한 점검&lt;/h1>
&lt;p>아래 사항이 모두 맞는지 점검한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>~/.ssh&lt;/code> 권한이 700 이어야 한다.
&lt;ul>
&lt;li>&lt;code>ls -al ~ | grep .ssh&lt;/code> 결과가 &lt;code>d r w x - - - - - -&lt;/code> 로 시작되어야 한다.&lt;/li>
&lt;li>수정하는 방법은 &lt;code>chmod 700 ~/.ssh&lt;/code> 이다. (&lt;code>-R&lt;/code> 옵션을 붙이지 말자!)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>~/.ssh&lt;/code> 소유자가 달라서는 안 된다.&lt;/li>
&lt;li>&lt;code>~/.ssh/authorized_keys&lt;/code> 권한이 600 이어야 한다.
&lt;ul>
&lt;li>&lt;code>ls -al ~/.ssh/authorized_keys&lt;/code> 결과가 &lt;code>- r w - - - - - - -&lt;/code> 로 시작되어야 한다.&lt;/li>
&lt;li>수정하는 방법은 &lt;code>chmod 600 ~/.ssh/authorized_keys&lt;/code> 이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>~/.ssh/authorized_keys&lt;/code> 소유자가 달라서는 안 된다.&lt;/li>
&lt;/ul>
&lt;p>한 가지 더 중요한 것은, &lt;strong>만약 &lt;code>$HOME&lt;/code> 경로가 &amp;lsquo;심볼릭 링크&amp;rsquo; 를 포함하는 경우&lt;/strong>라면, 반드시 실제 경로에서 적용해야 한다는 점이다.&lt;/p>
&lt;h1 id="rsa-는-이제-그만">RSA 는 이제 그만..&lt;/h1>
&lt;p>서버가 OpenSSH 를 쓰는 경우라면, RSA 를 곧 지원하지 않는다는 release note 가 있다. 따라서 RSA 대신 다른 알고리즘으로 된 비대칭 키를 생성해서 쓰는 것도 방법이 될 수 있다. 나는 &lt;strong>ECDSA&lt;/strong> 를 사용해 봤다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">ssh-keygen -t ECDSA
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="참고자료">참고자료&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="https://chemicloud.com/kb/article/ssh-authentication-refused-bad-ownership-or-modes-for-directory/" target="_blank" rel="noopener"
>https://chemicloud.com/kb/article/ssh-authentication-refused-bad-ownership-or-modes-for-directory/&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-authentication-issues/" target="_blank" rel="noopener"
>https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-authentication-issues/&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.openssh.com/txt/release-8.7" target="_blank" rel="noopener"
>https://www.openssh.com/txt/release-8.7&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>K8s Headless Service, 왜 필요한가</title><link>https://interp.blog/k8s-headless-service-why/</link><pubDate>Thu, 22 Dec 2022 11:13:12 +0900</pubDate><guid>https://interp.blog/k8s-headless-service-why/</guid><description>&lt;p>K8s Resource 를 보거나 Helm Chart 를 보거나 헷갈리는 개념 중 하나가 바로 &lt;strong>&amp;lsquo;Headless Service&amp;rsquo;&lt;/strong> 이다.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="20221220_63a1afceb4826.jpg"
alt="흐라챠!" width="40%"/> &lt;figcaption>
&lt;p>흐라챠!&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>머리가 없는 서비스를 &lt;del>위 짤방처럼&lt;/del> 왜 만드는 건지부터 이해하려면, 먼저 서비스가 왜 필요한지 알아야 한다.&lt;/p>
&lt;h1 id="설명-먼저">설명 먼저&lt;/h1>
&lt;p>공식 문서 설명을 먼저 보자. &lt;a class="link" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="noopener"
>영어 원문&lt;/a>과 &lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4" target="_blank" rel="noopener"
>한국어 번역본&lt;/a>을 적절히 믹스했다.&lt;/p>
&lt;blockquote>
&lt;p>로드 밸런싱 (Load-balancing) 이나 단일 서비스 IP 가 필요하지 않은 경우엔, &amp;lsquo;헤드리스&amp;rsquo; 서비스라는 것을 만들 수 있다. &lt;code>.spec.clusterIP: None&lt;/code> 을 명시적으로 지정하면 된다.&lt;/p>
&lt;p>이 헤드리스 서비스를 통해, 쿠버네티스의 구현에 의존하지 않고도 다른 서비스 디스커버리 메커니즘과 인터페이스할 수 있다.&lt;/p>
&lt;p>헤드리스 서비스의 경우 (각 node 에 상주하는) kube-proxy 가 해당 서비스를 처리하지 않는데, 즉 로드 밸런싱 또는 프록시를 하지 않는다. DNS가 자동으로 구성되는 방법은 서비스에 &lt;code>selector&lt;/code> 가 정의되어 있는지에 달려있다.&lt;/p>
&lt;/blockquote>
&lt;p>나름 의역을 섞어가며 최대한 쉽게 풀려고 노력했지만&amp;hellip; &lt;em>죄송합니다.&lt;/em> 지금 읽어봐도 무슨 소리를 하는지 잘 모르겠다.&lt;/p>
&lt;p>아마도, 영어 설명에서 함의된 내용이 너무나 많기 때문인 것 같다.&lt;/p>
&lt;hr>
&lt;p>내가 가장 마음에 들어하는 다른 설명을 가져와 봤다. 이번엔 &lt;a class="link" href="https://stackoverflow.com/questions/52707840/what-is-a-headless-service-what-does-it-do-accomplish-and-what-are-some-legiti" target="_blank" rel="noopener"
>스택 오버플로우 답변&lt;/a>이다.&lt;/p>
&lt;blockquote>
&lt;p>Service 로 향하는 네트워크 연결은 결국 서비스 아래에 존재하는 여러 Pod 중 하나로 가게 될 겁니다. 그런데, &lt;strong>클라이언트가 Pod 1개가 아니라 모든 Pod 들과 통신해야 한다면요&lt;/strong>? 만약 &lt;strong>같은 서비스 아래에 있는 Pod A 와 Pod B 가 서로 통신해야 한다면요&lt;/strong>?&lt;/p>
&lt;p>Service 를 통하는 건 확실한 방법은 아닙니다. 그럼 뭘까요?&lt;/p>
&lt;p>모든 Pod 들과 통신해야 하는 클라이언트를 위해, 개별 Pod 의 IP 주소를 알아내는 게 필요하겠죠. 그러면 클라이언트가 K8s API Server 에 직접 요청해서 해당 Pod 들의 IP 리스트를 얻어내는 방법이 있습니다. 이상적인 방법은 아닙니다. &lt;strong>개발 중인 어플리케이션을 K8s Cluster 가 있는지조차 모르게 (K8s-agnostic) 만들고 싶어 하잖아요.&lt;/strong>&lt;/p>
&lt;p>다행히도, Kubernetes 는 클라이언트에게 Pod IP 리스트를 알려주는 방법을 DNS Lookup 을 통해 제공합니다. 대개는, 어떤 Service 를 위한 DNS Lookup 를 수행하면 DNS 서버는 IP 주소 1개를 반환합니다. 바로 Service 의 &lt;em>Cluster IP&lt;/em> 죠.&lt;/p>
&lt;p>그런데 여러분이 Service 를 만들 때 Cluster IP 가 필요 없다고 알려주면, 해당 Service 에 대한 DNS Lookup 요청이 DNS 서버에 오게 될 때, Service 에 소속된 Pod IP 주소 목록을 전부 반환합니다. &lt;strong>즉, DNS A 레코드 1개가 아니라, 각각의 Pod 과 통신할 수 있는 A 레코드 여러 개가 반환되는 것이죠.&lt;/strong> 그러면 클라이언트는 간단하게 이 A 레코드를 순회하면서 다시 DNS Lookup 을 할 수 있고 실제 Pod 들의 IP 를 얻을 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>보통 Service 의 역할은, Service 로 들어온 요청을 &lt;em>여러 개의 Pod 중 하나&lt;/em> 에만 전달하는 것이다. 하지만 이 요청이 &lt;strong>모든 Pod 에&lt;/strong> 전달되어야 하는 경우에는 적합하지 않다.&lt;/p>
&lt;p>이를 위해서 k8s-api-server 에 요청해서, Service 에 속한 Pod 의 IP 리스트를 얻어오도록 애플리케이션을 구성할 수는 있겠지만, 그 때부터 애플리케이션은 해당 API 서버 위치에 의존해야 하기 때문에 적절한 방법이 아닌 것이다.&lt;/p>
&lt;p>위의 설명대로라면, Cluster IP 를 없앤 Service 의 경우 DNS Server 가 모든 Pod 들의 A 레코드를 직접 알려주는 (resolving) 것이다. &lt;strong>요청을 수신받을 Cluster IP 가 없으니, 머리가 없는 Service 라고 부를 수 있겠다.&lt;/strong>&lt;/p>
&lt;h1 id="데모">데모&lt;/h1>
&lt;p>사실 데모는 다른 블로그에서 많이 찾아볼 수 있어서, 최소한으로 재현 할 수 있는 방법을 알아보도록 하자.&lt;/p>
&lt;h2 id="deployment-생성">Deployment 생성&lt;/h2>
&lt;p>우리는 &lt;code>nginx&lt;/code> 로 포트 오픈도 해 두고 &lt;code>curl&lt;/code> 이나 &lt;code>nslookup&lt;/code> 으로 Pod 간 통신을 체크해야 하니, &lt;code>praqma/network-multitool&lt;/code> 이미지로 replica 3개의 deployment 를 하나 만들도록 하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl create deployment test-deploy --image&lt;span class="o">=&lt;/span>praqma/network-multitool --replicas&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span> --port&lt;span class="o">=&lt;/span>&lt;span class="m">80&lt;/span>
kubectl get pods -lapp&lt;span class="o">=&lt;/span>test-deploy -o wide
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">NAME READY STATUS ...
test-deploy-7bff8c5f84-hxcfw 1/1 Running ...
test-deploy-7bff8c5f84-rjdm9 1/1 Running ...
test-deploy-7bff8c5f84-w5l8j 1/1 Running ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>첫 번째 Pod 의 IP 가 &lt;code>200.96.1.50&lt;/code> 이다. 두 번째 Pod 에서 첫 번째 Pod 으로 접속을 시도해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># connect to test-deploy-7bff8c5f84-hxcfw &lt;/span>
kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- curl 200.96.1.50:80
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Praqma Network MultiTool (with NGINX) - test-deploy-7bff8c5f84-hxcfw - ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>접속이 잘 된다. 하지만 여기 보이는 Pod IP 는 &lt;strong>언제든지 바뀔 수 있기 때문에&lt;/strong> 이런 식으로 쓰면 안 된다.&lt;/p>
&lt;h2 id="headless-service-생성">Headless Service 생성&lt;/h2>
&lt;p>이제 Headless Service 를 만들어보자. 이번에는 바로 만들지 말고 manifest 를 YAML 파일로 저장해 둔 다음에 수정이 좀 필요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl create service clusterip test-cs-svc --clusterip&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;None&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --tcp&lt;span class="o">=&lt;/span>80:80 --dry-run&lt;span class="o">=&lt;/span>client -oyaml &amp;gt; test-cs-svc.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Headless 로 만드는 핵심 옵션이 바로 &lt;code>--clusterip=&amp;quot;None&amp;quot;&lt;/code> 라는 걸 알 수 있다. 여기서 출력되는 파일을 열어서, &lt;code>spec.selector&lt;/code> 를 deployment 의 것으로 바꿔줘야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-cs-svc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-cs-svc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">clusterIP&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">None&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80-80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-deploy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># test-deploy deployment 가 가지고 있던 app label&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterIP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">loadBalancer&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>저장해 주고, 해당 YAML 파일을 적용하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl apply -f test-cs-svc.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="dns-lookup-하기">DNS Lookup 하기&lt;/h2>
&lt;p>이제 남은 일은 Service 의 domain name 을 가지고 DNS Lookup 을 한 결과를 받아오는 일이다.&lt;/p>
&lt;p>그런데, domain name 을 어떻게 아냐고? 마지막 참고 자료에 있는 &lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener"
>K8s DNS&lt;/a> 를 읽어봐도 좋지만, 직접 알아보기 위해서는 아까 생성한 Pod 에서 &lt;code>/etc/resolv.conf&lt;/code> 가 어떻게 설정되어 있는지 확인하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- cat /etc/resolv.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">search default.svc.cluster.local svc.cluster.local ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기 잘 보면, 해당 Pod 위치에서 요청하는 domain name 에 &lt;code>default.svc.cluster.local&lt;/code> 을 자동으로 붙여서 resolving 하려는 걸 볼 수 있다. (default namespace 에 있는 모든 Pod 들이 똑같을 것이다)&lt;/p>
&lt;p>즉, 우리는 전체 domain name 을 알 필요가 없이 Service Name 만 가지고도 DNS Lookup 을 할 수 있다.&lt;/p>
&lt;p>바로 Lookup 을 하러 가보자. 똑같이 &lt;code>kubectl exec&lt;/code> 를 할 텐데, 이번에는 &lt;code>nslookup&lt;/code> 을 해보도록 한다. domain name 은 그냥 Service Name 을 입력한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- nslookup test-cs-svc
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Server: 200.64.0.10
Address: 200.64.0.10#53
Name: test-cs-svc.default.svc.cluster.local
Address: 200.96.1.50
Name: test-cs-svc.default.svc.cluster.local
Address: 200.96.0.59
Name: test-cs-svc.default.svc.cluster.local
Address: 200.96.2.24
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여러 개의 A 레코드로 이뤄진 Pod IP 목록을 얻을 수 있다. 그리고 &lt;code>test-cs-svc&lt;/code> 처럼 Service Name 만 입력했을 뿐인데 &lt;code>test-cs-svc.default.svc.cluster.local&lt;/code> 로 바뀐 것도 볼 수 있다.&lt;/p>
&lt;h2 id="head-를-달아주면요">Head 를 달아주면요?&lt;/h2>
&lt;p>이번에는 &lt;code>test-cs-svc-head&lt;/code> 라는 이름의 Service 를 하나 더 만들자.&lt;/p>
&lt;p>단순히, &lt;code>spec.clusterIP: None&lt;/code> 부분만 없는 &lt;code>test-cs-svc&lt;/code> 나 다름없다. 아까 만들어 둔 파일에서 &lt;code>metadata.name&lt;/code> 부분과 &lt;code>spec.clusterIP&lt;/code> 부분만 바꿔서 &lt;code>kubectl apply -f&lt;/code> 로 적용해 보자.&lt;/p>
&lt;p>수정한 다음, 아까와 같이 &lt;code>nslookup&lt;/code> 을 해보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- nslookup test-cs-svc-head
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Server: 200.64.0.10
Address: 200.64.0.10#53
Name: test-cs-svc-head.default.svc.cluster.local
Address: 200.68.238.114
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 IP 는 어디서 왔을까? 바로 Service 의 Cluster IP 되시겠다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl get svc test-cs-svc-head
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
test-cs-svc-head ClusterIP 200.68.238.114 &amp;lt;none&amp;gt; 80/TCP 2m32s
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="주의할-점">주의할 점&lt;/h2>
&lt;p>&lt;code>test-cs-svc&lt;/code> 나 &lt;code>test-cs-svc-head&lt;/code> 는 DNS Lookup 에서는 차이를 보이지만, &lt;code>curl&lt;/code> 결과는 차이가 없다. 더 자세히 말하면, &lt;strong>두 요청 모두 3개의 Pod 중 1개에만 랜덤하게 전달된다는 것이다.&lt;/strong>&lt;/p>
&lt;p>다음 명령들을 반복적으로 실행해 보자. 목적지 Pod 주소가 매번 다를 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- curl test-cs-svc:80 &lt;span class="p">|&lt;/span> head -2
kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- curl test-cs-svc-head:80 &lt;span class="p">|&lt;/span> head -2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>왜 이렇게 되는 것일까? Headless Service 의 경우, DNS Lookup 하는 A 레코드 순서가 랜덤으로 전달되고 &lt;code>curl&lt;/code> 은 그저 맨 위의 것을 쓰기 때문이다. &lt;code>nslookup&lt;/code> 을 반복적으로 해 보면 보다 더 확실해 질 것이다.&lt;/p>
&lt;h1 id="이해를-돕기-위한-기초자료">이해를 돕기 위한 기초자료&lt;/h1>
&lt;p>혹시 아직도 이해가 잘 안된다면, 기초자료로 다음을 참고해보자. &lt;del>혹은 &lt;a class="link" href="https://interp.blog/cka-exam-review/" >CKA 시험 준비&lt;/a>를 하는 것도 좋은 방법이다!&lt;/del>&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/service/" target="_blank" rel="noopener"
>K8s Service&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener"
>K8s DNS&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>VSCode 문자열 자동완성 설정</title><link>https://interp.blog/vscode-string-suggestion-config/</link><pubDate>Wed, 21 Dec 2022 14:33:07 +0900</pubDate><guid>https://interp.blog/vscode-string-suggestion-config/</guid><description>&lt;p>프로그래밍 언어 키워드나 객체 이름만 추천받을 때 유용하게 쓸 수 있는 IntelliSense. VSCode 에도 물론 내장되어 있어 유용하게 쓸 순 있지만 다음 경우에는 잘 되지 않았다.&lt;/p>
&lt;ul>
&lt;li>반복되는 문자열을 복사/붙여넣기 하지 않고 물 흐르듯 쓰고 싶을 때&lt;br>
(복사할 대상이 여러개이고, 번갈아 반복되는 경우라면 더더욱.. A/B/A/B 이런 식으로)&lt;/li>
&lt;li>다른 형식의 확장자로 된 파일 내용에서 반복되는 문자열을 추천받고 싶을 때&lt;/li>
&lt;/ul>
&lt;p>나의 경우는, 한 쪽에는 &lt;code>.env&lt;/code> 파일을 열어두고 다른 쪽에는 &lt;code>docker-compose.yaml&lt;/code> 을 열어둔 경우가 여기에 해당한다. 설정 가능한 변수는 &lt;code>.env&lt;/code> 에 변수로 등록하고, &lt;code>docker-compose.yaml&lt;/code> 파일 작업할 때 참조해서 쓰고 싶은데 자동완성이 안 돼서 힘들었다. 결국 검색해서 찾아내긴 했는데, 이게 기본 설정인지 아닌지는 잘 모르겠다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">{
&amp;#34;editor.quickSuggestions&amp;#34;: {
&amp;#34;strings&amp;#34;: &amp;#34;on&amp;#34;
},
&amp;#34;editor.wordBasedSuggestions&amp;#34;: true,
&amp;#34;editor.wordBasedSuggestionsMode&amp;#34;: &amp;#34;allDocuments&amp;#34;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 두면, 필요한 파일을 열어두기만 하면 모든 문자열을 추천받을 수 있다.&lt;/p>
&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/2-98NrJ9rG4"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>조금 이상한 부분은, 참조해야 할 파일을 한 번 수정하거나 저장해야 적용이 되는 것 처럼 보이기는 했는데&amp;hellip; 조금 더 써보고 업데이트 해야겠다.&lt;/p></description></item><item><title>Mac 에서 Eclipse Home/End 키 바인딩 하기</title><link>https://interp.blog/mac-eclipse-key-binding-home-end/</link><pubDate>Tue, 20 Dec 2022 10:57:42 +0900</pubDate><guid>https://interp.blog/mac-eclipse-key-binding-home-end/</guid><description>&lt;p>아이폰, 아이패드, 애플워치까지 갖고 있지만 macbook 을 본격적으로 써 본지 만 1년도 안 된다. 그래서 윈도우에서 즐겨 쓰던 Home/End 가 Mac 에서는 Cmd 키와 화살표로만 이뤄지는 걸 극복하는데 너무 힘들었다. 물론 적응하면 되겠지만, 습관이란 게 무서운 거라고.&lt;/p>
&lt;p>결국 어떻게 하면 고칠까 알아보면서 하나씩 적용하고 있다. 일단 KeyBindings 에서 Home/End 키로 줄 시작과 줄 끝으로 이동하도록 해 두는 걸 적용했다. (&lt;a class="link" href="https://apple.stackexchange.com/questions/16135/remap-home-and-end-to-beginning-and-end-of-line" target="_blank" rel="noopener"
>링크&lt;/a>)&lt;/p>
&lt;p>그런데 어째선지, Eclipse 기반의 에디터에서는 이것과 무관하게 Home/End 가 &amp;lsquo;페이지 시작/끝&amp;rsquo; 으로 작동하는게 아닌가! Page Up/Down 키가 옆에 버젓이 있는데도 말이다! 최근에 PostgreSQL (정확히는 &lt;a class="link" href="https://docs.timescale.com/" target="_blank" rel="noopener"
>TimescaleDB&lt;/a>) 를 조사할 기회가 생겨서 &lt;a class="link" href="https://dbeaver.io/" target="_blank" rel="noopener"
>DBeaver&lt;/a> 를 설치했는데, 이 친구도 Eclipse 기반의 에디터라서 KeyBindings 설정 내용과 딴판으로 놀았었다.&lt;/p>
&lt;p>그렇다, 이 글을 쓰는 이유 되시겠다.&lt;/p>
&lt;h2 id="키-설정을-바꿔야-한다">키 설정을 바꿔야 한다&lt;/h2>
&lt;ol>
&lt;li>Eclipse 의 Preference (설정) 을 열어보자. 어딘지 모르겠다면 &lt;code>Cmd + ,&lt;/code> 를 누르면 된다.&lt;/li>
&lt;li>여기서 &lt;code>Key&lt;/code> 라고 검색해 보면 &lt;strong>User Interface -&amp;gt; Key (키)&lt;/strong> 부분에 하이라이트가 되어 있다.&lt;/li>
&lt;li>카테고리를 눌러 Text Editor (텍스트 편집기) 로 이동한다.&lt;/li>
&lt;/ol>
&lt;p>여기서 다음 항목을 입맛대로 바꾸면 된다.&lt;/p>
&lt;ul>
&lt;li>Line Start (행 시작) : Home &lt;code>↖&lt;/code>&lt;/li>
&lt;li>Select Line Start (행 시작 선택) : Shift+Home &lt;code>⇧↖&lt;/code>&lt;/li>
&lt;li>Line End (행 끝) : End &lt;code>↘&lt;/code>&lt;/li>
&lt;li>Select Line End (행 끝 선택) : Shift+End &lt;code>⇧↘&lt;/code>&lt;/li>
&lt;li>Page Up (텍스트 시작) : Page Up &lt;code>⇞&lt;/code>&lt;/li>
&lt;li>Page Down (텍스트 끝) : Page Down &lt;code>⇟&lt;/code>&lt;/li>
&lt;/ul>
&lt;figure>
&lt;img loading="lazy" src="setting.png"/>
&lt;/figure>
&lt;h2 id="그래도-안-되면">그래도 안 되면?&lt;/h2>
&lt;p>내 경우엔 이렇게 두고 &lt;code>Apply and Close&lt;/code> 를 눌러도 적용이 안 되더라. 심플하게 Eclipse (여기선 DBeaver) 를 껐다 다시 실행시키면 되었다.&lt;/p></description></item><item><title>screen, tmux, 그리고 byobu</title><link>https://interp.blog/terminal-multiplexer-screen-tmux-byobu/</link><pubDate>Wed, 12 Oct 2022 08:57:42 +0900</pubDate><guid>https://interp.blog/terminal-multiplexer-screen-tmux-byobu/</guid><description>&lt;img src="https://interp.blog/terminal-multiplexer-screen-tmux-byobu/feature.jpg" alt="Featured image of post screen, tmux, 그리고 byobu" />&lt;p>개발자들은 전통적으로 워크스테이션이나 서버에 단말기를 접속해서 개발을 진행해 왔다. 이 때 사용되는 기기를 단말, 터미널 (terminal) 이라고 했다. 과거에는 컴퓨팅 파워를 구성하는 단가가 비쌌기 때문에, 저사양의 단말 컴퓨터를 가지고 상대적으로 고사양의 서버에 접속해 일을 하는 것이다.&lt;/p>
&lt;p>물론 지금은 PC 나 노트북 역시 충분히 고사양이긴 하다. 그래도 여전히 훨씬 더 효율적이고 강력한 서버 컴퓨터가 조직마다 존재하고, 클라우드 컴퓨팅으로 인해 자원을 필요할 때 마다 (on-demand) 빌려 쓸 수 있는 시대이다. 그렇기에 터미널은 여전히 유효하고, SSH 프로토콜로 통신하는 터미널 프로그램으로 남아있게 된다.&lt;/p>
&lt;p>어디서든, 어떤 단말로도 서버에 (또는 클라우드 VM 에) 접속할 수 있다는 것은 장점이지만, 네트워크 연결이 끊기거나 다른 단말로 다시 접속하게 되면 새로운 SSH 세션이 시작되고, 텅 빈 화면에서 다시 시작하게 되는 문제가 동시에 존재한다.&lt;/p>
&lt;p>또 한 가지 문제는, 한 화면에 하나의 세션만 열 수 있다는 것이다. 아니, 지금은 다양한 터미널 프로그램에서 &amp;lsquo;다중 윈도우, 다중 탭&amp;rsquo; 을 지원하는데, 그래서 여러 세션으로 넘나드는 게 가능한데 이게 무슨 문제일까? 그런 GUI 도 없는 유닉스/리눅스 시절엔 문제였다&amp;hellip;&lt;/p>
&lt;p>이 두 문제를 해결해 줄 Terminal Multiplexer 에 대해 알아보자.&lt;/p>
&lt;h2 id="terminal-multiplexer--tmux-screen">Terminal Multiplexer : tmux, screen&lt;/h2>
&lt;p>우선 흔히들 쓰는 tmux 의 매뉴얼 첫 설명을 보자.&lt;/p>
&lt;blockquote>
&lt;p>tmux is a terminal multiplexer: it enables a number of terminals to be created, accessed, and controlled from a single screen. &lt;strong>tmux may be detached from a screen and continue running in the background, then later reattached&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>터미널을 다중화해서, 한 화면에 여러 개의 터미널을 다룰 수 있다고 한다. 그리고 이 터미널 조합은 프로세스로 떠 있어서, (프로세스가 죽지 않는 한) 서버에 재접속 해서 해당 터미널 조합을 그대로 쓸 수 있다는 것이다.&lt;/p>
&lt;p>screen 의 설명은 조금 더 길고 복잡하다. (그래서 tmux 설명을 먼저 소개했다) 그 중에서 소개글을 발췌해 보면 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>Screen is a full-screen window manager that multiplexes a physical terminal between several processes (typically interactive shells). When &lt;code>screen&lt;/code> is called, it creates a single window with a shell in it (or the specified command) and then gets out of your way so that you can use the program as you normally would.&lt;/p>
&lt;p>Then, at any time, you can create new (full-screen) windows with other programs in them (including more shells), kill existing windows, view a list of windows, turn output logging on and off, copy-and-paste text between windows, view the scrollback history, switch between windows in whatever manner you wish, etc.&lt;/p>
&lt;p>&lt;strong>All windows run their programs completely independent of each other&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>screen 에서는 여러 터미널이 윈도우라는 개념으로 나뉘어지며, 여기서 실행하는 프로그램은 완전히 독립된다는 것을 강조한다.&lt;/p>
&lt;p>각자 다른 특징을 지닌 것 같지만, 결국 둘 모두 terminal multiplexer 라는 것은 변함이 없고, 앞서 언급한 특성들을 모두 공유한다. 즉, 서론에서 이야기한 문제를 전부 해결해 줄 수 있는 특징이 있다.&lt;/p>
&lt;ol>
&lt;li>여러 터미널을 한 화면에 띄우고, 관리할 수 있다.&lt;/li>
&lt;li>이 터미널 조합은, 서버에 재 접속해서 그대로 쓸 수 있다.&lt;/li>
&lt;li>각 터미널 안에서 수행하는 작업들은 철저히 독립적이다.&lt;/li>
&lt;/ol>
&lt;p>개인적으로 두 개 중 어느 것을 써도 문제는 없을 것 같다. 몇몇은 screen 에서 최신 기능이나 자잘한 것들이 지원되지 않는다는 사람도 있었고, 몇몇은 screen 을 계속 써와서 굳이 바꿔야 할 이유를 찾지 못했다는 이야기도 들었으니까.&lt;/p>
&lt;h2 id="byobu">byobu&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.byobu.org" target="_blank" rel="noopener"
>https://www.byobu.org&lt;/a>&lt;/p>
&lt;p>byobu 는 병풍(屏風)이라는 뜻의 일본어 독음이다. Canonical 에서 우분투 서버와 클라우드 팀에 있는 Dustin Kirkland 의 개인 프로젝트 라고 한다. (와우&amp;hellip;)&lt;/p>
&lt;p>이 프로그램은 &lt;strong>tmux 와 screen 의 wrapper&lt;/strong> 라고 보면 된다. 즉, 두 multiplexer 중 하나를 좀 더 쉽고 간단하게 쓸 수 있도록 만든 것이다. 처음에 실행하면, 둘 중 어느 것을 쓸 것인지 선택할 수 있다.&lt;/p>
&lt;h3 id="설치-방법">설치 방법&lt;/h3>
&lt;p>나는 brew 를 설치한 다음에 byobu 를 설치했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">/bin/bash -c &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="c1"># install brew into ~/.linuxbre&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;eval &amp;#34;$($HOME/.linuxbrew/bin/brew shellenv)&amp;#34;&amp;#39;&lt;/span> &amp;gt;&amp;gt; ~/.zshrc
brew install byobu
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="사용-방법">사용 방법&lt;/h3>
&lt;p>유튜브 튜토리얼 영상을 보면, 모짜르트 교향곡과 함께 윈도우를 화려하게 넘나드는 것을 볼 수 있다.&lt;/p>
&lt;p>&lt;code>man byobu&lt;/code> 를 입력해서 매뉴얼을 열어보자. 여기서 단축키 리스트를 알려주긴 하, 당장 내가 자주 쓰는 단축키는 이 정도다.&lt;/p>
&lt;ul>
&lt;li>F2 : 새로운 윈도우를 만든다. 이 때 새로운 세션을 시작한다.&lt;/li>
&lt;li>F3/F4 : 이전/다음 윈도우로 포커스를 이동한다.&lt;/li>
&lt;li>Shift+F2 : 스크린을 상/하로 분할해, 아래쪽에 새로운 세션을 시작한다.&lt;/li>
&lt;li>Ctrl+F2 : 스크린을 좌/우로 분할해, 오른쪽에 새로운 세션을 시작한다.&lt;/li>
&lt;li>Shift+F3/F4 : 이전/다음 스크린으로 포커스를 이동한다.&lt;/li>
&lt;li>F7 : 스크롤백 모드로 전환한다. 방향키 또는 PageUp/Dn 를 이동해 화면을 스크롤할 수 있고, Enter 를 치면 종료된다.
&lt;ul>
&lt;li>복사 : Spacebar 를 누르면 커서부터 블록을 잡을 수 있다. 블록을 다 잡고 나서 Enter 를 누르면 복사가 된다&lt;/li>
&lt;li>붙여넣기 : Alt+Insert (나는 안 됐음 ㅜㅜ) &lt;strong>Ctrl+a 누른 후 ]&lt;/strong> (이게 잘 됨!)&lt;br>
(iterm2 의 경우, applications in terminal may access clipboard 옵션을 켜줘야 함)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="접속하면-자동으로-byobu-실행하기">접속하면, 자동으로 byobu 실행하기&lt;/h3>
&lt;p>접속하자 마자 byobu 를 실행하려면 아래를 입력하면 되는데,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">byobu-enable
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>man byobu-launcher-install&lt;/code> 을 보면 알겠지만, 이게 &lt;code>~/.profile&lt;/code> 에 내용이 추가되는 거라서, shell 설정에 따라서는 적용 자체가 안 될 수도 있다. &lt;code>~/.profile&lt;/code> 의 마지막 줄 내용을 &lt;code>~/.bashrc&lt;/code> 또는 &lt;code>~/.zshrc&lt;/code> 에 옮겨줘야 한다.&lt;/p>
&lt;h3 id="macos-에서-ctrl-키가-먹지-않을-때">macOS 에서 Ctrl 키가 먹지 않을 때&lt;/h3>
&lt;p>매뉴얼에서 나오는 Ctrl+F2 단축키가 맥북에서는 먹질 않는다. Ctrl 이 인식되지 않는다기 보단 Function Key 인식에 문제가 있는 것 같다. (그렇다고 Ctrl+Fn+F2 를 누르면 F2 효과가 난다..)&lt;/p>
&lt;p>그래서 아예 byobu 단축키를 수정했다. tmux 를 쓴다고 가정했을 때, 아래 파일을 열어보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># assume that you&amp;#39;re using with tmux&lt;/span>
vi &lt;span class="nv">$BYOBU_PREFIX&lt;/span>/share/byobu/keybindings/f-keys.tmux
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 &lt;code>C-F2&lt;/code> 따위의 키워드를 검색할 수 있는데, 이걸 Function Key 가 들어가지 않는 조합으로 바꿔주자.&lt;/p>
&lt;p>참고 : &lt;a class="link" href="https://askubuntu.com/questions/969846/ubuntu-server-using-byobu-ctrlf2-does-not-split-screen-in-vertical" target="_blank" rel="noopener"
>https://askubuntu.com/questions/969846/ubuntu-server-using-byobu-ctrlf2-does-not-split-screen-in-vertical&lt;/a>&lt;/p></description></item><item><title>Golang: errors.new() vs. fmt.Errorf()</title><link>https://interp.blog/golang-errorsnew-fmterrorf/</link><pubDate>Tue, 04 Oct 2022 09:01:55 +0900</pubDate><guid>https://interp.blog/golang-errorsnew-fmterrorf/</guid><description>&lt;p>두 함수 호출 모두 error 를 리턴하지만, 어디서는 &lt;code>errors.new()&lt;/code> 를 쓰고 다른 데서는 &lt;code>fmt.Errorf()&lt;/code> 를 써서 헷갈렸다. &lt;a class="link" href="https://www.digitalocean.com/community/tutorials/how-to-add-extra-information-to-errors-in-go" target="_blank" rel="noopener"
>링크&lt;/a>에서 확인한 결과, 아래와 같은 설명이 되어 있었다.&lt;/p>
&lt;blockquote>
&lt;p>Generally, when creating a sentinel error value, the &lt;a class="link" href="https://pkg.go.dev/errors#New" target="_blank" rel="noopener"
>errors.New&lt;/a> function from the &lt;a class="link" href="https://pkg.go.dev/errors" target="_blank" rel="noopener"
>errors&lt;/a> package is used instead of the &lt;code>fmt.Errorf&lt;/code> function you’ve been using thus far.&lt;/p>
&lt;p>&lt;strong>Using &lt;code>errors.New&lt;/code> instead of &lt;code>fmt.Errorf&lt;/code> does not make any foundational changes to how the error works&lt;/strong>, though, and both functions could be used interchangeably most of the time.&lt;/p>
&lt;p>The biggest difference between the two is the &lt;code>errors.New&lt;/code> function will only create an error with a static message, and &lt;strong>the &lt;code>fmt.Errorf&lt;/code> function allows formatting the string with values&lt;/strong>, similar to &lt;code>fmt.Printf&lt;/code> or &lt;code>fmt.Sprintf&lt;/code>. Since sentinel errors are fundamental errors with values that don’t change, it’s common to use errors.New to create them.&lt;/p>
&lt;/blockquote>
&lt;p>두 함수 호출로 리턴되는 error 에 특별한 차이는 없지만, &lt;strong>포맷이 필요하면 fmt.Errorf, 포맷이 필요없는 static error message 라면 errors.New&lt;/strong> 를 쓰는 것이다.&lt;/p></description></item><item><title>클로저 (Closure)</title><link>https://interp.blog/program-language-closure/</link><pubDate>Sun, 18 Sep 2022 08:33:23 +0900</pubDate><guid>https://interp.blog/program-language-closure/</guid><description>&lt;img src="https://interp.blog/program-language-closure/feature.jpg" alt="Featured image of post 클로저 (Closure)" />&lt;p>나와 같은 개발자 친구와 이런저런 이야기를 하던 중, 내 리뷰가 반려된 경험담을 꺼냈던 적이 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>나:&lt;/strong> 내가 클로저를 사용해서 구현했거든. 그런데 리뷰어가 그게 뭐냐고, 아예 함수로 빼달라고 하는거 있지?&lt;br>
&lt;strong>친구:&lt;/strong> 아~ 그런데, 클로저가 도대체 뭐야?&lt;br>
&lt;strong>나:&lt;/strong> 어..? 그거, 있잖아! 함수 안에 함수 만드는 거! 그런데 그 함수 외부 변수 참조할 수 있는 거!&lt;/p>
&lt;/blockquote>
&lt;p>그러고 나자 (친구는 가만히 있는데) 나 혼자 부끄러운 생각이 들었다. 제대로 알지도 못하고 쓰고 있었구나 😂 일단 나부터 잘 모르고 쓰고 있다는 생각이 들어, 이참에 정리를 해 두려고 한다.&lt;/p>
&lt;h1 id="정의">정의&lt;/h1>
&lt;p>프로그래밍 언어에서 Closure 는, &lt;em>함수 바깥에 있는 변수를 참조하는 함수 &amp;lsquo;값&amp;rsquo;&lt;/em> 을 말한다..고 한다.&lt;/p>
&lt;p>한국어판 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%ED%81%B4%EB%A1%9C%EC%A0%80_%28%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%29" target="_blank" rel="noopener"
>위키백과 설명&lt;/a>을 보도록 하자.&lt;/p>
&lt;blockquote>
&lt;p>컴퓨터 언어에서 클로저(Closure)는 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4" target="_blank" rel="noopener"
>일급 객체 함수&lt;/a>(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다.&lt;/p>
&lt;p>기능상으로, 클로저는 함수를 저장한 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EB%A0%88%EC%BD%94%EB%93%9C" target="_blank" rel="noopener"
>레코드&lt;/a>(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener"
>MDN&lt;/a> 에 있는 정의도 찾아봤다.&lt;/p>
&lt;blockquote>
&lt;p>A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the &lt;strong>lexical environment&lt;/strong>). In other words, a closure gives you access to an &lt;strong>outer function&amp;rsquo;s scope&lt;/strong> from an inner function.&lt;/p>
&lt;/blockquote>
&lt;figure>
&lt;img loading="lazy" src="giphy.webp"
alt="시방 저것이.. 뭔 소리여?"/> &lt;figcaption>
&lt;p>&lt;del>시방 저것이.. 뭔 소리여?&lt;/del>&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h1 id="golang-에서의-closure">Golang 에서의 Closure&lt;/h1>
&lt;p>백문이 불여일견, 일단 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">outer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">x&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">x&lt;/span>&lt;span class="o">++&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Output:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">x&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">inner_f&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">outer&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nf">inner_f&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nf">inner_f&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>main()&lt;/code> 에서 호출하는 두 번의 &lt;code>inner_f()&lt;/code> 가 일반 함수 호출이었다고 생각해보자. 일반적인 함수에는 &lt;em>상태가 저장되는 곳이 없다&lt;/em>. 즉, 입력 값에 변화가 없기 때문에 두 번의 호출이 동일한 결과를 낼 것 같다.&lt;/p>
&lt;p>하지만 현실은 그렇지 않다. &lt;code>inner_f&lt;/code> 에서 받은 것은 &lt;code>outer()&lt;/code> 라는 함수가 아니라 &lt;strong>클로저&lt;/strong>이기 때문이다. 따라서 출력이 다음과 같을 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Output: 1
Output: 2
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="python-에서의-closure">Python 에서의 Closure&lt;/h1>
&lt;p>이번에는 똑같은 결과를 내는 Python 코드를 짜 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">outer&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">inner&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="k">nonlocal&lt;/span> &lt;span class="n">x&lt;/span>
&lt;span class="n">x&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Output:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">x&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">inner&lt;/span>
&lt;span class="n">inner_f&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">outer&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">inner_f&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">inner_f&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>거의 똑같지만, Python 에서는 &lt;code>nonlocal&lt;/code> 키워드를 사용해서 외부 변수를 참조하겠다고 명시해야 한다.&lt;/p>
&lt;p>&lt;code>def inner()&lt;/code> 말고 Golang 처럼 unnamed function 을 정의해서 넘겨주려면 lambda function 을 참고하면 된다.&lt;/p>
&lt;h1 id="일급-객체-일급-함수">일급 객체, 일급 함수&lt;/h1>
&lt;p>잠시 일급 객체라는 개념을 먼저 짚고 넘어가자. 일급 객체가 되려면, 세 가지 조건이 있다.&lt;/p>
&lt;ul>
&lt;li>변수에 담을 수 있는 것&lt;/li>
&lt;li>인자로 전달이 가능한 것&lt;/li>
&lt;li>반환값으로도 전달이 가능한 것&lt;/li>
&lt;/ul>
&lt;p>일급 함수는 &lt;em>함수형으로 된 일급 변수&lt;/em>를 뜻하니까, 짧게 설명하면 &lt;strong>변수처럼 다룰 수 있는 함수&lt;/strong> 일급 함수라 할 수 있다. (&lt;a class="link" href="https://velog.io/@mgm-dev/%EC%9D%BC%EA%B8%89%ED%95%A8%EC%88%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80" target="_blank" rel="noopener"
>참조&lt;/a>)&lt;/p>
&lt;p>대부분의 스크립트 프로그래밍 언어가 일급 함수를 취급한다. 하지만 오래된 언어들 (기본 C, Algol&amp;hellip;) 의 경우엔 세 가지 조건 중 일부만 지원하기 때문에, 일급 함수를 취급할 수 없다.&lt;/p>
&lt;h1 id="스코프">스코프&lt;/h1>
&lt;p>어떤 변수의 스코프는, 다른 말로 하면 변수가 어디까지 접근 가능한지를 나타낸 개념이다. 특정 변수의 &lt;em>수명 (lifetime)&lt;/em> 으로도 나타내지만, 나는 두 개념이 모두 포함된 것이라고 본다.&lt;/p>
&lt;p>앞서 본 것 처럼, 클로저는 함수가 선언된 스코프 (scope) 안에 선언된 어느 변수라도 접근이 가능하다. 즉, 함수 스코프의 상위 스코프 까지다. &lt;/p>
&lt;p>예제를 다시 보자. 변수 &lt;code>x&lt;/code> 가 이에 해당 한다. outer() 안에 선언된 클로저 안에는 x 가 없지만, 클로저가 선언된 스코프 (그러니까 outer() 전체) 에는 x 가 사용 가능하다. 물론 이건 클로저 역시 마찬가지다.&lt;/p>
&lt;p>수명 이야기를 했는데, outer() 가 호출되기 시작할 때 변수 x 는 스택에 쌓이고, 호출이 종료되면 x 는 스택에서 빠질 것이다. 하지만 클로저가 선언되어 있다면 이 변수 x 의 수명은 늘어나게 된다. 그럼 이렇게 수명이 늘어난 변수 x 는 어디에 저장될까?&lt;/p>
&lt;h1 id="자유-변수">자유 변수&lt;/h1>
&lt;p>클로저에서 숨어있는 개념이 바로 &amp;lsquo;&lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%9E%90%EC%9C%A0_%EB%B3%80%EC%88%98%EC%99%80_%EC%A2%85%EC%86%8D_%EB%B3%80%EC%88%98" target="_blank" rel="noopener"
>자유 변수 (free variable)&lt;/a>&amp;rsquo; 이다. 자유변수란 수학에서 나온 개념인데, 수식 속에서 상수로 치환이 가능한 변수를 말한다. 그 외의 변수는 전부 종속 변수 (bound variable) 이라고 말한다.&lt;/p>
&lt;p>위키 예제를 잠깐 빌려 이해해보자. $\textstyle\sum_{n=1}^1 m/n$ 에서 자유 변수는 무엇일까? 수식에서 자유로운 &lt;code>m&lt;/code> 이 바로 자유 변수고, &lt;code>n&lt;/code> 은 $\Sigma$ 에 종속된 종속 변수다.&lt;/p>
&lt;p>클로저에서 이 개념을 적용해 보자. 클로저를 선언한 스코프 바깥에 있는 변수지만, 참조를 하고 있는 변수가 자유 변수인 것이다.&lt;/p>
&lt;p>클로저가 그냥 함수였다면, 자유 변수가 어떤 값을 가지고 있건 상관 없이 작동해야 한다. 반대로 말하면 &lt;strong>이런 자유 변수로 인해, 함수로써 닫힐 수 있게 만든 것&lt;/strong>을, 우리는 클로저 (closure) 라고 부르는 것이다. (써놓고도 무슨 말인지..)&lt;/p>
&lt;h1 id="다시-정의를-읽어보자">다시 정의를 읽어보자&lt;/h1>
&lt;blockquote>
&lt;p>컴퓨터 언어에서 클로저(Closure)는 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4" target="_blank" rel="noopener"
>일급 객체 함수&lt;/a>(first-class functions)의 개념을 이용하여, 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>참고로 일급 객체 함수와 클로저는 같은 말이 아니라, &lt;strong>일급 객체 함수 ∋ 클로저&lt;/strong>이다.&lt;/li>
&lt;li>&lt;em>스코프에 묶인 변수를 바인딩한다&lt;/em>는 뜻은, 클로저가 사용할 수 있게 계속 유지한다는 말과 같을 것이다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>기능상으로, 클로저는 함수를 저장한 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EB%A0%88%EC%BD%94%EB%93%9C" target="_blank" rel="noopener"
>레코드&lt;/a>(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>클로저 = &lt;strong>함수를 저장한 레코드&lt;/strong>!&lt;/li>
&lt;li>스코프의 인수는, 달리 말하면 클로저가 선언된 스코프에 선언된 모든 변수/객체를 말한다. 이 것들이 &lt;strong>클로저가 만들어질 때 (=선언될 때) 정의&lt;/strong>된다는 것이다. 어디에? 바로 레코드 안에.&lt;/li>
&lt;li>스코프 내의 영역이 실제로 소멸되는 시점은, 스코프가 호출이 끝난 시점 (=함수 호출이 끝난 시점) 일 것이다.&lt;br>
하지만 클로저 안에서는 해당 영역으로 영원히 접근 가능한 상태로 남아있게 된다.&lt;/li>
&lt;/ul>
&lt;p>여기까지 해석해 보면, 간접적으로 메모리를 좀 더 쓸 것이라는 추측이 가능하다. 단순히 생각해도 지역 변수들의 수명이 클로저 때문에 계속 되도록 만들어야 하기 때문이다.&lt;/p>
&lt;p>MDN 정의도 다시 읽어보자. 이번엔 해석을 해 봤다.&lt;/p>
&lt;blockquote>
&lt;p>A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function&amp;rsquo;s scope from an inner function.&lt;/p>
&lt;p>클로저란, 클로저를 둘러싼 상태 (사전적 환경) 와의 참조를 함께 넣어 묶은, 함수의 조합입니다. 다른 표현으로, 클로저를 통해 함수 내부에서 함수 외부로 접근을 가능하게 만들 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>클로저를 둘러싼 상태, lexical environment 라는 말들 전부 &lt;strong>클로저 바깥&lt;/strong>을 말한다. 사실 뒷 문장이 다 설명을 해 주고 있다.&lt;/p></description></item><item><title>VSCode Python 디버그 반응이 없을 때</title><link>https://interp.blog/vscode-python-debugging-no-response/</link><pubDate>Tue, 23 Aug 2022 22:26:07 +0900</pubDate><guid>https://interp.blog/vscode-python-debugging-no-response/</guid><description>&lt;img src="https://interp.blog/vscode-python-debugging-no-response/feature.png" alt="Featured image of post VSCode Python 디버그 반응이 없을 때" />&lt;h1 id="증상">증상&lt;/h1>
&lt;p>Visual Studio Code 에서 Python 파일을 디버깅 (debugging) 하려 하면, &lt;strong>아무런 반응이 없고 곧바로 종료된다.&lt;/strong> 그냥 실행 자체를 하지 않은 것 처럼 말이다..!&lt;/p>
&lt;p>&lt;div style="background-color: var(--pre-background-color); width: 95%; margin:2rem; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
😂
&lt;/div>
&lt;div>
2023년 2월 현재, 파이썬 버전이 낮으면 아래 경고 문구가 잘 나오는 것을 확인했다.&lt;br/>그래도 Python 3.6 이하 버전을 사용해야겠다면 아래 내용을 참고하자.
&lt;/div>
&lt;/div>
&lt;br/>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="warning.png#center" width="30%"/>
&lt;/figure>
&lt;/p>
&lt;h1 id="분석">분석&lt;/h1>
&lt;p>관련해서 메시지가 나타나지 않기 때문에, 단서를 찾기가 쉽진 않았다. 그나마 &amp;lsquo;&lt;em>Output&lt;/em>&amp;rsquo; 패널에 있는 &amp;lsquo;&lt;em>Python&lt;/em>&amp;rsquo; 에서 아래와 같은 로그가 한 줄 떠 있었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">DAP Server launched with command: /home/interp/work/project/venv/bin/python \
/home/interp/.vscode-server/extensions/ms-python.python-2022.12.1/pythonFiles/lib/python/debugpy/adapter
&lt;/code>&lt;/pre>&lt;/div>&lt;p>저기서 &lt;code>.. with command:&lt;/code> 이후의 명령어를 그대로 &lt;strong>터미널에서&lt;/strong> 입력해 보았다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">Traceback &lt;span class="o">(&lt;/span>most recent call last&lt;span class="o">)&lt;/span>:
File &lt;span class="s2">&amp;#34;/home/interp/.pyenv/versions/3.6.12/lib/python3.6/runpy.py&amp;#34;&lt;/span>, line 193, in _run_module_as_main
&lt;span class="s2">&amp;#34;__main__&amp;#34;&lt;/span>, mod_spec&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;/home/interp/.pyenv/versions/3.6.12/lib/python3.6/runpy.py&amp;#34;&lt;/span>, line 85, in _run_code
exec&lt;span class="o">(&lt;/span>code, run_globals&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;/home/interp/.vscode-server/extensions/ms-python.python-2022.12.1/pythonFiles/lib/python/debugpy/adapter/__main__.py&amp;#34;&lt;/span>, line 212, in &amp;lt;module&amp;gt;
__import__&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;debugpy&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;/home/interp/.vscode-server/extensions/ms-python.python-2022.12.1/pythonFiles/lib/python/debugpy/adapter/../../debugpy/__init__.py&amp;#34;&lt;/span>, line 28, in &amp;lt;module&amp;gt;
&lt;span class="s2">&amp;#34;Python 3.6 and below is not supported by this version of debugpy; &amp;#34;&lt;/span>
AssertionError: Python 3.6 and below is not supported by this version of debugpy&lt;span class="p">;&lt;/span> use debugpy 1.5.1 or earlier.
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="원인과-해결">원인과 해결&lt;/h1>
&lt;p>저기서 마지막 문장이 중요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">AssertionError: Python 3.6 and below is not supported by this version of debugpy; \
use debugpy 1.5.1 or earlier.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>찾아보니 Python Extension 에서 debugpy 버전을 업그레이드 했고, 더 이상 Python 3.6 에서 호환되지 않는 것이 문제였다. &lt;a class="link" href="https://marketplace.visualstudio.com/items/ms-python.python/changelog" target="_blank" rel="noopener"
>Changelog&lt;/a>를 보니, 2022.10.0 버전부터 debugpy 를 1.6.2 로 올린 것을 확인할 수 있었다.&lt;/p>
&lt;p>그러면 해결책은 간단하다. 원하는 대로 해주거나, 되돌아가거나.&lt;/p>
&lt;h2 id="1-python36-에서-버전-업그레이드">(1) Python3.6 에서 버전 업그레이드&lt;/h2>
&lt;p>가장 간단한 방법은 더 높은 버전의 Python을 설치하고, 해당 버전을 기본 환경으로 설정하면 된다.&lt;/p>
&lt;p>&lt;code>virtualenv&lt;/code> 없이 Python 버전만 바꾼다면, VSCode 에서 Command Palette (&lt;code>Ctrl/Cmd+Shift+P&lt;/code>) 를 열어서 &lt;strong>Python: Select Interpreter&lt;/strong> 를 선택하는 것으로 버전 선택이 가능하다.&lt;/p>
&lt;p>나는 &lt;code>virtualenv&lt;/code> 를 통해 개발 환경을 구성하기 때문에 아래와 같은 순서대로 업그레이드를 진행했다. 혹시 참고가 되길 바라며 정리해 둔다.&lt;/p>
&lt;ol>
&lt;li>(requirements.txt 따위로 관리하고 있지 않는다면) &lt;code>pip freeze &amp;gt; requirements.txt&lt;/code> 로 설치된 라이브러리 백업&lt;/li>
&lt;li>기존 virtualenv directory 삭제 (예: &lt;code>venv&lt;/code> 라고 가정하자)&lt;/li>
&lt;li>(python3.9 를 설치했다면) &lt;code>python3.9 -m virtualenv venv&lt;/code> 으로 virtualenv directory 생성&lt;/li>
&lt;li>&lt;code>source venv/bin/activate &amp;amp;&amp;amp; pip install -r requirements.txt&lt;/code> 로 라이브러리 재설치&lt;/li>
&lt;/ol>
&lt;h2 id="2-extension-다운그레이드-하기">(2) Extension 다운그레이드 하기&lt;/h2>
&lt;p>다른 해결책으로는, VSCode Python 의 Extension 버전을 다운그레이드 하는 방법이다.&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="downgrade.png#center"/>
&lt;/figure>
&lt;p>Extension 탭에서 Python 을 찾은 다음, &lt;strong>Install Another Version&lt;/strong> 을 선택한다. 잠시 기다리면, 버전 목록이 나타나며, 초록색 부분 (그 아래도 상관없음) 을 클릭하면 된다.&lt;/p>
&lt;p>하지만 별로 추천하고 싶진 않다. Python 3.10 까지 나온 마당에 특별한 이유가 없다면 (1) 번처럼 Python 버전을 올리는게 좋을 것 같다.&lt;/p>
&lt;h2 id="3-symbolic-link-경로-문제">(3) Symbolic link 경로 문제&lt;/h2>
&lt;p>혹시 (1) 이나 (2) 번을 전부 적용해도 (아니면 이미 Python 3.6 이상의 버전을 쓰고 있는데도) 디버깅이 안 된다면 이 해결책이 도움이 될 것이다.&lt;/p>
&lt;p>한 번은, symbolic link 경로로 workspace directory 를 열었을 때 디버깅 문제가 생겼었다. 반대로 말하면, symbolic link 경로가 아닌 &lt;strong>실제 directory 경로로 workspace 를 열어야&lt;/strong> 한다.&lt;/p>
&lt;p>예를 들어, &lt;code>/home/interp/&lt;/code> 는 사실 symbolic link 이고, 실제 경로는 &lt;code>/SSD/homes/interp&lt;/code> 이라고 가정하자. 그렇다면, &lt;em>File - Open Folder..&lt;/em> 메뉴로 directory 를 열 때, 다음 중 하나만 디버깅이 가능하다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>/home/interp/workspace_python&lt;/code> ❌&lt;/li>
&lt;li>&lt;code>/SSD/homes/interp/workspace_python&lt;/code> ✅&lt;/li>
&lt;/ul></description></item><item><title>BDD in Python: Behave</title><link>https://interp.blog/bdd-in-python-behave/</link><pubDate>Fri, 19 Aug 2022 09:00:36 +0900</pubDate><guid>https://interp.blog/bdd-in-python-behave/</guid><description>&lt;p>&lt;a class="link" href="https://interp.blog/bdd-behavior-driven-development/" >지난 포스팅&lt;/a>으로 BDD 는 어떤 개발방법론이고, 어떤 면에서 이 방법이 필요한지를 정리해 봤다. &lt;/p>
&lt;p>이번 포스팅을 시작으로, 직접 다양한 언어에서 BDD 를 적용하는 방법을 정리해 볼 예정이다. 첫 시간으로는 &lt;strong>파이썬&lt;/strong> (Python) 언어를 가지고 할 것이다. Python 라이브러리 중 하나인 &lt;a class="link" href="https://behave.readthedocs.io/en/stable/" target="_blank" rel="noopener"
>behave&lt;/a> 를 통해, BDD 테스트 프레임워크를 구성하고, 예제 시나리오를 만들어서 테스트 자동화가 어떻게 이뤄질 수 있을지 알아보자.&lt;/p>
&lt;h1 id="예제-프로젝트-생성">예제 프로젝트 생성&lt;/h1>
&lt;div style="background-color: var(--pre-background-color); width: 95%; margin:2rem; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
💡
&lt;/div>
&lt;div>
모든 명령어는 리눅스 OS 또는 WSL 환경에서 실행한다고 가정한다.
&lt;/div>
&lt;/div>
&lt;p>파이썬이 설치된 환경에서 다음과 같이 디렉터리만 만들면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir behave-test &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">cd&lt;/span> behave-test
&lt;/code>&lt;/pre>&lt;/div>&lt;p>나는 virtualenv 를 이용해 환경을 분리해 두도록 하겠다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">virtualenv venv
&lt;span class="nb">source&lt;/span> venv/bin/activate
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="behave-설치">behave 설치&lt;/h1>
&lt;p>&lt;code>pip install behave&lt;/code> 만 하면 된다.&lt;/p>
&lt;h1 id="featuressteps-디렉터리-생성">&lt;code>features/steps&lt;/code> 디렉터리 생성&lt;/h1>
&lt;p>behave 는 &lt;code>features/steps&lt;/code> 를 필요로 한다. 만들어 주자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir -p features/steps
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>디렉터리만 만들고 곧장 &lt;code>behave&lt;/code> 를 실행하면, &lt;code>ConfigError: No feature files in $(pwd)/features&lt;/code> 라는 메시지가 뜰 것이다.&lt;/p>
&lt;h1 id="feature-파일-만들기">&lt;code>.feature&lt;/code> 파일 만들기&lt;/h1>
&lt;p>&lt;code>features/hotdog.feature&lt;/code> 라는 파일을 하나 만들어보자. 핫도그 12개에서 5개를 먹으면 반드시 7개가 남아야 한다는 내용이다. 단순 영어로 되어 있지만, 문법에 대해 더 자세히 알고 싶다면 &lt;a class="link" href="https://interp.tistory.com/entry/BDD-%EC%9D%98%EB%AF%B8%EC%99%80-%ED%95%84%EC%9A%94%EC%84%B1" target="_blank" rel="noopener"
>이전 포스팅&lt;/a>을 꼭 참고하고 오자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gherkin" data-lang="gherkin">&lt;span class="k">Feature:&lt;/span>&lt;span class="nf"> eat hotdogs
&lt;/span>&lt;span class="nf">
&lt;/span>&lt;span class="nf"> &lt;/span>&lt;span class="k">Scenario:&lt;/span>&lt;span class="nf"> Eat 5 out of 12
&lt;/span>&lt;span class="nf">&lt;/span>&lt;span class="k"> Given &lt;/span>&lt;span class="nf">there are &lt;/span>&lt;span class="s">12&lt;/span>&lt;span class="nf"> hotdogs
&lt;/span>&lt;span class="nf"> &lt;/span>&lt;span class="k">When &lt;/span>&lt;span class="nf">I eat &lt;/span>&lt;span class="s">5&lt;/span>&lt;span class="nf">
&lt;/span>&lt;span class="nf"> &lt;/span>&lt;span class="k">Then &lt;/span>&lt;span class="nf">there should be &lt;/span>&lt;span class="s">7&lt;/span>&lt;span class="nf"> remaining
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>이제 다시 &lt;code>behave&lt;/code> 를 실행하면, 아래 구조로 되어 있는 테스트 파일이 존재하지 않다고 하면서, 스니펫 (snippet) 을 출력해 주고 내부를 구현해 달라고 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># None&lt;/span>
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># None&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># None&lt;/span>
Failing scenarios:
features/hotdog.feature:3 Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span>
&lt;span class="m">0&lt;/span> features passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> scenarios passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> steps passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped, &lt;span class="m">3&lt;/span> undefined
Took 0m0.000s
You can implement step definitions &lt;span class="k">for&lt;/span> undefined steps with these snippets:
@given&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
def step_impl&lt;span class="o">(&lt;/span>context&lt;span class="o">)&lt;/span>:
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: Given there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
@when&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;I eat 5&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
def step_impl&lt;span class="o">(&lt;/span>context&lt;span class="o">)&lt;/span>:
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: When I eat 5&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
@then&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
def step_impl&lt;span class="o">(&lt;/span>context&lt;span class="o">)&lt;/span>:
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: Then there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="테스트-python-파일-만들기">테스트 Python 파일 만들기&lt;/h1>
&lt;p>방금 출력된 내용을 단순히 복사해서 &lt;code>features/steps/hotdog.py&lt;/code> 라는 파일을 만들었다. 참고로 파일 이름은 상관없지만 반드시 &lt;code>features/steps&lt;/code> 디렉터리에 위치해야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">behave&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="o">*&lt;/span>
&lt;span class="nd">@given&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">NotImplementedError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;STEP: Given there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@when&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;I eat 5&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">NotImplementedError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;STEP: When I eat 5&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">NotImplementedError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;STEP: Then there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>시나리오의 각 구절 (&lt;em>GIVEN, WHEN, THEN&lt;/em>) 에 연결되는 기준은, 각 method 에 위치한 decorator 인 &lt;code>@given&lt;/code>, &lt;code>@when&lt;/code>, &lt;code>@then&lt;/code> 에 따라 달려있기 때문에, 파일 이름은 상관없고 해당 decorator 만 수정하지 않으면 된다. &lt;/p>
&lt;p>그리고 주의할 것은, 반드시 맨 위에 &lt;code>from behave import *&lt;/code> 와 같이 &lt;code>behave&lt;/code> 라이브러리를 import 해야 한다는 것이다.&lt;/p>
&lt;hr>
&lt;p>이렇게 하고 다시 &lt;code>behave&lt;/code> 를 실행하면, 예상대로 &lt;code>NotImplementedError&lt;/code> exception 이 발생하면서 traceback 이 출력되고, 테스트는 실패한 것으로 간주한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
Traceback &lt;span class="o">(&lt;/span>most recent call last&lt;span class="o">)&lt;/span>:
File &lt;span class="s2">&amp;#34;/home/behave-test/venv/lib/python3.6/site-packages/behave/model.py&amp;#34;&lt;/span>, line 1329, in run
match.run&lt;span class="o">(&lt;/span>runner.context&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;/home/behave-test/venv/lib/python3.6/site-packages/behave/matchers.py&amp;#34;&lt;/span>, line 98, in run
self.func&lt;span class="o">(&lt;/span>context, *args, **kwargs&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;features/steps/hotdog.py&amp;#34;&lt;/span>, line 5, in step_impl
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: Given there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
NotImplementedError: STEP: Given there are &lt;span class="m">12&lt;/span> hotdogs
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># None&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># None&lt;/span>
Failing scenarios:
features/hotdog.feature:3 Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span>
&lt;span class="m">0&lt;/span> features passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> scenarios passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> steps passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">2&lt;/span> skipped, &lt;span class="m">0&lt;/span> undefined
Took 0m0.000s
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="테스트-파일-구현하기">테스트 파일 구현하기&lt;/h1>
&lt;p>이제 테스트 파일 안의 method 를 구현해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">behave&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="o">*&lt;/span>
&lt;span class="nd">@given&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there are &lt;/span>&lt;span class="si">{num_hotdog}&lt;/span>&lt;span class="s1"> hotdogs&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_hotdog&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hotdogs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_hotdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@when&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;I eat &lt;/span>&lt;span class="si">{eaten_hotdog}&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">eaten_hotdog&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hotdogs&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">eaten_hotdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there should be &lt;/span>&lt;span class="si">{remaining_hotdog}&lt;/span>&lt;span class="s1"> remaining&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">remaining_hotdog&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">assert&lt;/span> &lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hotdogs&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">remaining_hotdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>decorator 에서 숫자를 나타내는 부분을 &lt;code>num_hotdog&lt;/code> 같은 식으로 파라메터로 치환한 것을 주목해 달라. 이렇게 해 두면, 나중에 숫자만 바꾼 시나리오를 추가해도, 위의 세 개 method 를 재사용할 수 있는 장점이 있다.&lt;/p>
&lt;p>그리고 behave 는 &lt;a class="link" href="https://behave.readthedocs.io/en/stable/tutorial.html?highlight=eq_#context" target="_blank" rel="noopener"
>&lt;code>context&lt;/code> 라는 파라메터를 입력으로 받을 수 있도록&lt;/a> 지원한다. 해당 시나리오가 진행되는 동안 유효한 객체이며, 따라서 여기에 원하는 attribute 를 만들어 값을 저장하고 열람할 수 있다. 예제 시나리오에서는, 남은 핫도그 개수를 &lt;code>context.hotdogs&lt;/code> 로 보관한다.&lt;/p>
&lt;blockquote>
&lt;p>엄밀히 말하면, when 에 해당하는 method 에서 핫도그 개수를 차감하는 부분은 &lt;strong>여기서 구현하면 안 된다&lt;/strong>. 실제 업무에 사용하려면, 여기서 &lt;strong>&amp;lsquo;실제로 구현한 로직&amp;rsquo; 을&lt;/strong> &lt;strong>호출해야&lt;/strong> 한다. 그래야 검증을 할 수 있으니 말이다!&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>다시 &lt;code>behave&lt;/code> 를 실행하면, 이제야 모든 테스트가 통과되었음을 알 수 있다!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># features/steps/hotdog.py:8 0.000s&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># features/steps/hotdog.py:12 0.000s&lt;/span>
&lt;span class="m">1&lt;/span> feature passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">1&lt;/span> scenario passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">3&lt;/span> steps passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped, &lt;span class="m">0&lt;/span> undefined
Took 0m0.000s
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="숫자만-바꾼-시나리오를-추가하면">숫자만 바꾼 시나리오를 추가하면?&lt;/h1>
&lt;p>시나리오&lt;strong>만&lt;/strong> 추가하더라도 이미 재사용이 가능한 형태로 테스트 method 를 구현했기 때문에, 아래처럼 성공적으로 작동한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># features/steps/hotdog.py:8 0.000s&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># features/steps/hotdog.py:12 0.000s&lt;/span>
Scenario: Eat &lt;span class="m">10&lt;/span> out of &lt;span class="m">20&lt;/span> &lt;span class="c1"># features/hotdog.feature:8&lt;/span>
Given there are &lt;span class="m">20&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
When I eat &lt;span class="m">10&lt;/span> &lt;span class="c1"># features/steps/hotdog.py:8 0.000s&lt;/span>
Then there should be &lt;span class="m">10&lt;/span> remaining &lt;span class="c1"># features/steps/hotdog.py:12 0.000s&lt;/span>
&lt;span class="m">1&lt;/span> feature passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">2&lt;/span> scenarios passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">6&lt;/span> steps passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped, &lt;span class="m">0&lt;/span> undefined
Took 0m0.001s
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>이제 이 테스트 케이스를 구현할 때 mock 라이브러리를 통해 mocking 을 하면, 기능 검증을 충분히 할 수 있을 것이다. 시나리오를 추가하는 것은 개발자 뿐만이 아닌 비 개발자나 QA 도 할 수 있어야 하고, 개발자는 그렇게 푸시된 새로운 시나리오를 보고 커버리지를 달성하기 위해 테스트에 좀 더 집중할 수 있을 것이다.&lt;/p>
&lt;p>한 가지 맹점은, 기존 시나리오가 바뀌면 테스트 케이스 개발 과정에서 엄청난 고통이 뒤따를 수 있단 것이다. 따라서 (전에도 말했지만) 항상 시나리오는 합의 하에 신중히 추가되어야 한다.&lt;/p>
&lt;p>다음 시간에는 golang 으로 똑같은 시나리오를 테스트 해 볼 예정이다.&lt;/p></description></item><item><title>Oh my zsh! 에서 kubectl 자동 완성 하기</title><link>https://interp.blog/oh-my-zsh-kubectl-autocomplete/</link><pubDate>Tue, 16 Aug 2022 12:31:36 +0900</pubDate><guid>https://interp.blog/oh-my-zsh-kubectl-autocomplete/</guid><description>&lt;p>&amp;lsquo;&lt;a class="link" href="https://kubernetes.io/ko/docs/tasks/tools/included/optional-kubectl-configs-zsh/" target="_blank" rel="noopener"
>zsh 자동 완성&lt;/a>&amp;rsquo; 이라는 Kubernetes 공식 문서에 따르면, 다음 명령으로 자동 완성이 가능하다고 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">source&lt;/span> &amp;lt;&lt;span class="o">(&lt;/span>kubectl completion zsh&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>그런데 Oh my zsh! 에서는 몇가지 더 설정을 해야 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>$HOME/.zshrc&lt;/code> 를 열어서, plugins 에 다음을 추가한다.
&lt;ul>
&lt;li>kubectl&lt;/li>
&lt;li>kube-ps1&lt;/li>
&lt;li>zsh-syntax-highlighting&lt;/li>
&lt;li>zsh-autosuggestions&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nv">plugins&lt;/span>&lt;span class="o">=(&lt;/span>git kubectl kube-ps1 zsh-syntax-highlighting zsh-autosuggestions&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>kubectl, kube-ps1 은 이미 설치되어 있을텐데, 아래 2개는 별도 설치가 필요할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># zsh-syntax-highlighting&lt;/span>
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">ZSH_CUSTOM&lt;/span>&lt;span class="k">:-&lt;/span>&lt;span class="p">~/.oh-my-zsh/custom&lt;/span>&lt;span class="si">}&lt;/span>/plugins/zsh-syntax-highlighting
&lt;span class="c1"># zsh-autosuggestions&lt;/span>
git clone https://github.com/zsh-users/zsh-autosuggestions &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> &lt;span class="si">${&lt;/span>&lt;span class="nv">ZSH_CUSTOM&lt;/span>&lt;span class="k">:-&lt;/span>&lt;span class="p">~/.oh-my-zsh/custom&lt;/span>&lt;span class="si">}&lt;/span>/plugins/zsh-autosuggestions
&lt;/code>&lt;/pre>&lt;/div>&lt;p>참고로 Auto-suggestion 되는 내용이 하얀색으로 나와서 타이핑하거나 알아보기가 힘들다면, 해당 내용만 다른 색으로 바꿔줄 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>export ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=(number)'&lt;/code> 라고 쓰면 된다.&lt;/li>
&lt;li>나는 &lt;code>(number)&lt;/code> 자리에 &lt;code>243&lt;/code> 을 사용했다. 연한 회색이다.&lt;/li>
&lt;li>자세한 color 값은 &lt;a class="link" href="https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자. 물론 사용하려면 &lt;code>$TERM&lt;/code> 값이 &lt;strong>xterm-256color&lt;/strong> 여야 한다.&lt;/li>
&lt;/ul>
&lt;p>그리고 다시 로그인하면, 탭키(&lt;code>&amp;lt;tab&amp;gt;&lt;/code>) 를 통해 자동 완성이 잘 되는 것을 확인할 수 있다.&lt;/p></description></item><item><title>BDD (Behavior-driven Development) 소개</title><link>https://interp.blog/bdd-behavior-driven-development/</link><pubDate>Thu, 11 Aug 2022 16:31:36 +0000</pubDate><guid>https://interp.blog/bdd-behavior-driven-development/</guid><description>&lt;img src="https://interp.blog/bdd-behavior-driven-development/feature.jpg" alt="Featured image of post BDD (Behavior-driven Development) 소개" />&lt;p>작년 즈음에, 팀에 테스트 주도 개발 (Test-driven Development,TDD) 에 대해 어떤 강력한 합의 (?) 가 필요하지 않을까라고 팀장님께 주장했던 기억이 났다. &lt;del>일단 나부터 좀 잘 해야 할텐데&lt;/del> 그런데 그걸 언제 또 기억하셔서는, 올 초에 ‘TDD 말고 BDD 에 대해 조사해서 차기 프로젝트에 녹여보면 어떻겠냐’ 는 제안을 하셨다. 두 눈을 동그랗게 뜬 채 음성 채팅으로 ‘그것이… 무엇이죠?!’ 라고 되물었던 슬픈 기억이 난다.&lt;/p>
&lt;p>지금은 프로젝트를 진행 중인데 거의 설계 단계를 지났고, 프로토타이핑이 끝나간다. 바쁜 시간이 지나고서야 팀장님의 부름이 닿아, 뒤늦게나마 우리가 쥐고 있는 요구사항이 무엇인지, 어떻게 적용할 수 있는지 찾아보고 있다. 그런데 이 결과물을 팀원들에게 공유하려면 내가 먼저 ‘BDD 를 왜 써야 하는지’ 를 이해하고 설명할 수 있어야 하기에, 블로그에 정리해 보려고 한다.&lt;/p>
&lt;h2 id="bdd-란">BDD 란?&lt;/h2>
&lt;p>BDD 는 &lt;strong>Behavior-driven Development&lt;/strong>, 즉, 제품이나 서비스의 행동에 초점을 맞춘 개발 방법론이다. 소프트웨어가 어떤 일을 해내야하는지가 가장 중요하며, 개발과 테스팅이 거기에 맞춰 진행되어야 한다는 것이다. &lt;del>뭐, 당연한 소리 아닌가? 다들 이렇게 다 하잖아요, 그쵸?&lt;/del>&lt;/p>
&lt;p>&lt;a class="link" href="https://cucumber.io/docs/bdd/" target="_blank" rel="noopener"
>Cucumber 에서의 BDD 정의&lt;/a>는 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>BDD is a way for software teams to work that closes the gap between business people and technical people by:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Encouraging collaboration&lt;/strong> across roles to build shared understanding of the problem to be solved&lt;/li>
&lt;li>Working in rapid, small iterations to increase feedback and the flow of value&lt;/li>
&lt;li>&lt;strong>Producing system documentation&lt;/strong> that is automatically checked against the system’s behavior&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://inviqa.com/blog/bdd-guide#what-is-it" target="_blank" rel="noopener"
>Inviqa 의 BDD 블로그 포스트&lt;/a>에서는 이렇게 정의했다.&lt;/p>
&lt;blockquote>
&lt;p>BDD is a process designed to aid the management and the delivery of software development projects by improving communication between engineers and business professionals. In so doing, BDD ensures all development projects remain focused on delivering what the business actually needs while meeting all requirements of the user.&lt;/p>
&lt;/blockquote>
&lt;p>잘 보면 collaboration, communication 이 겹쳐 보인다.&lt;/p>
&lt;h2 id="bdd-적용-방식">BDD 적용 방식&lt;/h2>
&lt;p>여기서 나는 BDD 의 Best Practice 나 심지어 Gherkin 문법에 대해서 자세히 조사해 정리하지 않을 것이다. 왜냐하면 나도 배우는 입장이고, 이 포스팅의 목적은 ‘BDD 가 정말 필요할까요?’ 를 밝히는 것이기 때문이다.&lt;/p>
&lt;p>정말 필요하다고 생각하면, 그때서야 더 깊이 찾아보면 될 일이다.&lt;/p>
&lt;h3 id="discovery">Discovery&lt;/h3>
&lt;p>User Story 에서 실제 예제를 만든다. 이 예제는 합의되어야 한다.&lt;/p>
&lt;p>이 과정은 협업 단계이다. 워크샵을 통해 아이디어를 모으고, 구체적인 예시를 들어야 한다. 이 과정을 통해 어떤 기능이 정말 필요한지 우선순위를 정할 수도 있다. User Story 의 범위를 조정하는 작업이기도 하다.&lt;/p>
&lt;p>이런 과정을 통해, 우리가 뭘 해야 할지 결정하기 위해 빠진 정보를 알아낼 수도 있다. 처음부터 모든 정보를 들고 요구사항을 구체화할 수 없기 때문이다. 다시 채워서, 다시 이야기해야 한다.&lt;/p>
&lt;p>다시 말하지만, 여기서 산출된 예제들은 합의된 것이어야만 한다. 그렇지 않으면 다음 사이클에 영향을 끼친다.&lt;/p>
&lt;h3 id="formulation">Formulation&lt;/h3>
&lt;p>예제를 자동화 가능한 형태로 문서화한다. 이 문서는 합의되어야 한다.&lt;/p>
&lt;p>문서는 Gherkin 문법 (GIVEN - WHEN - THEN) 으로 정형화한다. 이 문서 내용을 다시 모든 조직원들에게 공유해, 이렇게 테스트할 것이라고 검증받아야 한다. (다시 말하지만, 이 문서도 합의되어야 한다.)&lt;/p>
&lt;h3 id="automation">Automation&lt;/h3>
&lt;p>문서에 맞춰 구현하고 테스트한다.&lt;/p>
&lt;p>언어 별로 다양한 라이브러리/패키지가 지원되며, BDD 또는 Cucumber, Gherkin 으로 검색하면 관련 자료가 늘 나왔었다. 내가 확인한 건 일단 Java (&lt;a class="link" href="https://site.mockito.org/" target="_blank" rel="noopener"
>Mockito&lt;/a>), Python (&lt;a class="link" href="https://behave.readthedocs.io/en/stable/" target="_blank" rel="noopener"
>behave&lt;/a>), Go (&lt;a class="link" href="https://github.com/cucumber/godog" target="_blank" rel="noopener"
>godog&lt;/a>) 정도가 있다.&lt;/p>
&lt;p>Gherkin 문법으로 정형화된 문서를 입력으로, 코드 템플릿을 출력하거나 코드 템플릿과 일치하는 테스트 케이스가 존재하면 바로 테스트 결과를 출력한다. (behave, godog 만 테스트해 봤다) 각 언어 별 실제 사용 예제는 블로그에 따로 정리할 예정이다.&lt;/p>
&lt;h3 id="gherkin-format">Gherkin Format&lt;/h3>
&lt;p>그럼 도대체 Gherkin &lt;del>오이피클&lt;/del> 은 어떻게 쓰는가? 가장 간단한 방법은 세 문장으로 나타내는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Given there are 12 cucumbers
When I eat 5 cucumbers
Then I should have 7 cucumbers
&lt;/code>&lt;/pre>&lt;/div>&lt;p>GIVEN 은 전제 조건이고, WHEN 은 액션, THEN 은 그 결과이다. 이 부분을 테스트 케이스로 만드려면,&lt;/p>
&lt;ul>
&lt;li>GIVEN : 전제조건이 되도록 환경을 구성하거나 mocking 한다.&lt;/li>
&lt;li>WHEN : 액션을 가한다. (함수를 호출하거나)&lt;/li>
&lt;li>THEN : 실제 결과가 명세에서 예상한 대로 나왔는지 검증하는 코드가 필요하다.&lt;/li>
&lt;/ul>
&lt;p>물론 세 가지 키워드 말고도 다양한 방법으로 ‘예제’ 를 표현할 수 있다. 자세한 문법 내용은 &lt;a class="link" href="https://cucumber.io/docs/gherkin/reference/" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/p>
&lt;h2 id="내가-생각하는-bdd">내가 생각하는 BDD&lt;/h2>
&lt;p>BDD 가 어떤 것인지 맛을 봤으니, 이제는 왜 이 방법론이 필요한지 내 생각과 경험을 얹어 설명해 보겠다.&lt;/p>
&lt;blockquote>
&lt;p>보통 프로젝트를 시작하거나 하면 TDD 를 기본으로 깔고 시작한다.&lt;/p>
&lt;p>우선 개발자는 요구사항에 맞는 테스트 케이스를 만든다. 그 요구사항은 프로젝트 안에서 개인에게 할당된 작업 내용에 관한 것일 수도 있고, 정말 고객이나 비즈니스에서 원하는 기능에 대한 요구사항 명세일 수도 있다.&lt;/p>
&lt;p>테스트 케이스를 먼저 만들고, 테스트 케이스는 물론 실패한다. 실패하지 않게 구현하고, 박수를 짝짝 치고 PR 을 연다. 리뷰를 받고 파이프라인을 통과해 프로덕션 브랜치로 기능 (또는 수정 내역) 이 반영된다.&lt;/p>
&lt;/blockquote>
&lt;p>문장 자체로만 보면 아주 당연하고 아름다운 순서이겠지만, 여기서 뭔가 꺼림칙한 부분이 생기게 된다. 나는 크게 두 가지가 걸리는데,&lt;/p>
&lt;ol>
&lt;li>&lt;strong>테스트 케이스가 요구사항을 온전히 반영했는지 검증이 가능한가?&lt;/strong> 사람은 오류와 상상의 동물이라서, 요구사항을 아무렇게나 해석해서 테스트 케이스를 만들어 둘 수 있다. 물론 코드 리뷰하면 다 나오는거, 맞다. 그런데 우리가 리뷰해야 할 것은 리펙터링과 모킹 (mocking) 이 복잡하게 뒤섞인 ‘코드’ 란 말이다. 정말 그 오류를 잘 찾아낼 수 있나?&lt;/li>
&lt;li>&lt;strong>요구사항은 대체 어떻게 만드는가?&lt;/strong> 이건 좀 더 근원적인 질문인데, 요구사항이라는 것은 언제나 ‘고객/비즈니스-개발 조직’ 또는 ‘프로젝트 리더-프로젝트 개발자’ 사이에 정량적으로 합의된 내용이어야 한다. 티켓에 적힌 내용, 회의록이 합의된 결과 아니냐고? 글쎄… 그걸 다 모아다가 볼 수 있나? UML 은 어떨까? UML 다이어그램에 대한 지식이 없는 사람은 그럼 요구사항 리뷰를 못 하는 걸까?
&lt;ul>
&lt;li>우리는 늘 이런 걸 겪지 않았던가? “&lt;em>그건 제가 하고 싶은 말이 아니었어요!&lt;/em>” “&lt;em>그건 제가 원하던 것이 아니었어요!&lt;/em>” 라는 말… 어정쩡하고 단방향의 요구사항은 늘 화를 불러오게 되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이런 방식대로라면 (1) 사용자가 정말 원하는 &lt;strong>요구사항을 ‘요구사항 명세’ 가 100% 커버하는지&lt;/strong> (결과물이 너무 다양하거나 복잡하기 때문에) 쉽게 알 수도 없고 (2) &lt;strong>요구사항 명세가 테스트 케이스로 변환되어 100% 기능하고 있는지&lt;/strong>도 쉽게 알 수 없다는 것이다. 내가 ‘쉽게’ 라는 말을 붙이긴 했지만, 현실에서는 거의 불가능하다고 본다.&lt;/p>
&lt;p>내가 봤을 때 BDD 는 두 가지 문제를 짚어 나가는데 효과적이다. 개발 외 조직으로부터 사용자 요구사항을 받는 것 말고도, 개발조직 내부에서 요구사항을 합의하고 기능을 검증할 때도 효과적이라는 점 역시 덧붙이고 싶다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>이렇게 설명해놓고 보니, 일선 개발자에겐 TDD 의 확장 개념이라고 여기게 될까 조심스럽다. 어차피 자연어로 된 문서를 소스로 한다는 점만 틀리지, 거기서 생성된 테스트 케이스의 코드를 구현하고 Regression 을 돌리는 작업이 기존에 하던 TDD 와 무엇이 다르냐고 할 수도 있겠다.&lt;/p>
&lt;p>하지만 TDD 를 시작하기 이전에 ‘어떻게 테스트 케이스를 만들죠’ 라는 부분에 대한 하나의 대안으로 생각해주면 좋겠다. 이 방법이 부상하기 전부터, 소프트웨어 공학에서 제시한 UML 명세나 수 많은 다이어그램에 기초해서 테스트 케이스를 만들지 않았던가. 조직에서 이런 방식으로 이미 명세-테스트 케이스 자동화가 되어 있다면 정말로 BDD 가 필요없을 순 있겠다. 하지만, UML 부터 무척 복잡하다고 느끼는 것은 비단 나 뿐일까?&lt;/p>
&lt;p>&lt;strong>BDD 는 확실히 사용자가 정말 원하는 예제를 찾고, 보완하는데 불편함이 적다.&lt;/strong> 누구나 읽을 수 있는 언어로 되어 있으니, 비즈니스를 다루는 직원은 뭔가를 더 배울 필요가 없다. 개발자는 나름 규격화된 문서를 가지고 테스트 케이스를 만들 수 있다. 즉, 이 방법론은 조직 전체에 걸쳐 광범위한 개발 방법론이라고 볼 수 있겠다.&lt;/p>
&lt;p>다음 포스팅은, 내가 실제로 구동해 본 behave 나 godog 예제가 될지, 아니면 현업에서 적용해보고 난 뒤 받은 피드백에 대해서 이야기할지 고민 중이다. 아직 이렇다 할 피드백이 없어서, 아마도 실제로 따라 써 볼 수 있는 글을 쓰는게 현실적이리라 본다.&lt;/p></description></item><item><title>키보드 키 바운싱 문제 해결</title><link>https://interp.blog/keyboard-key-bouncing-problem/</link><pubDate>Thu, 11 Aug 2022 02:25:04 +0000</pubDate><guid>https://interp.blog/keyboard-key-bouncing-problem/</guid><description>&lt;img src="https://interp.blog/images/featured/keyboard-key-bounce.jpg" alt="Featured image of post 키보드 키 바운싱 문제 해결" />&lt;p>회사에서 기계식 키보드를 아무거나 사라고 해서 &lt;a class="link" href="http://prod.danawa.com/info/?pcode=1458635" target="_blank" rel="noopener"
>i-rocks의 KR-6251&lt;/a> 을 사서 5년 째 쓰고 있다. 2년 전부터 &lt;strong>몇몇 키들은 한 번 누를 때마다 두 번 입력&lt;/strong>되는 느낌을 받았고, 쓰면서 이 현상이 더욱 가중되어 성가신 느낌을 지우기 힘들었다.&lt;/p>
&lt;p>그런데 이 문제를 어떻게 인터넷에서 검색하지? 감을 통 잡을 수 없으니 &amp;lsquo;그냥 새로운 키보드 하나 사야 하나?&amp;rsquo; 라고 고민하고 있었다. &lt;del>이럴 때만 지름신이 오셔서는, &amp;lsquo;비싼 걸 사서 쓰라&amp;rsquo; 고 말씀하시지&lt;/del> 그러다가 우연찮게 이런 유형의 문제를 &amp;lsquo;키 바운스&amp;rsquo; 라고 부르는 몇몇 문서를 발견할 수 있었다.&lt;/p>
&lt;h2 id="키-바운스">키 바운스?&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.youtube.com/watch?v=Du3rcfI9hDY" target="_blank" rel="noopener"
>&lt;del>그대가 돌아서면~♪&lt;/del>&lt;/a> 말 그대로, 키가 제멋대로 춤을 춰서 한번 더 스위치와 부비는(!) 현상을 말한다.&lt;/p>
&lt;p>무접점 키보드가 아닌 이상, 일반 키보드인 멤브레인을 포함, 스위치를 사용하는 기계식 키보드들은 발생할 수도 있는 증상이다. &lt;strong>분명히 나는 한 번 키를 눌렀다 뗐는데, 내부에서 진동으로 인해 스위치가 한번 더 (혹은 여러 번) 눌리는 현상&lt;/strong>이라고 이해하면 되겠다. 다른 말로 채터링(Chattering) 이라고도 부르더라.&lt;/p>
&lt;h2 id="해결시도-1-청소">해결시도 (1) 청소&lt;/h2>
&lt;p>원인은 여러 가지가 있을 수 있지만, 원칙적으로는 스위치 고장이라고 생각해야 하지 않을까. 이럴 땔, 스위치 교체를 해야 한다. 혹시 키캡-스위치 접촉 불량으로 미세하게 덜렁거릴 수도 있으니 청소를 한번 해봤는데… 청소를 다 하고도 똑같은 문제가 자주 발생하는 걸 보면 그렇게 효과가 크진 않은 것 같다.&lt;/p>
&lt;h2 id="해결시도-2-바이오스-업데이트">해결시도 (2) 바이오스 업데이트&lt;/h2>
&lt;p>바이오스 업데이트로 키 입력에 대한 패치를 하는 방법도 있다는데, 잘 모르겠으니 제조사에서 추가 정보가 업데이트 되었는지 확인해 보는 방법도 있겠다. (당연히 내 키보드는 이미 단종이라 그런 사후지원을 기대할 수 없었다.)&lt;/p>
&lt;h2 id="해결시도-3-os-설정으로-문제-억제시키기">해결시도 (3) OS 설정으로 문제 억제시키기&lt;/h2>
&lt;p>그럼 스위치를 교체하거나 키보드를 버려야 할까? 잠깐 그 잔인한 생각을 집어넣고 타협할 방법을 알려드리도록 하겠다.&lt;/p>
&lt;p>나 역시 소프트웨어적으로 이런 반복적인 키 입력을 막을 방법이 분명히 있을거라고 생각했는데, 다양한 해결책이 있었다. 모든 OS는 &amp;lsquo;사용자 접근성&amp;rsquo;이란 메뉴가 존재한다. 화면 글씨를 일부러 키우거나 소리를 읽어주거나 하는 그런 기능들이다. 여기서 제공하는 것들 중 &amp;lsquo;탄력 키&amp;rsquo; 기능을 사용한다.&lt;/p>
&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>윈도우 7 이후의 버전이라면, &amp;lsquo;제어판&amp;rsquo; 의 &amp;lsquo;접근성 센터&amp;rsquo; 에서 &amp;lsquo;키보드를 사용하기 쉽게 설정&amp;rsquo; 항목으로 들어간다. 여기에서 &amp;lsquo;필터 키 켜기&amp;rsquo; 를 적용하면 된다. 그러나 애석하게도 필터 키의 바운스 타임을 뜻하는 &amp;lsquo;탄력 키 입력 인식 시간&amp;rsquo; 간격을 0.5초 이하로 조정할 수 없다. 이 말은, 키를 반복해서 탁탁 칠 때 0.5초보다 빠른 간격으로 치면 모두 무시된다는 소리고, 생각보다 빠른 입력을 할 때 (특히 백스페이스를 반복해서 누를 때) 복장이 터질 가능성이 높다. 결국 이걸 낮추려면 레지스트리를 건드려야 하는데, [이 포스팅][2]을 참고해서 조정이 가능하다.&lt;/p>
&lt;h3 id="linux-ubuntu">Linux (Ubuntu)&lt;/h3>
&lt;p>나 같은 리눅스 사용자는 그럼 어떡해야 할까. Ubuntu 기준으로 설명하면, &amp;lsquo;설정&amp;rsquo; – &amp;lsquo;접근성&amp;rsquo; – &amp;lsquo;자판 입력&amp;rsquo; 에 있는 &amp;lsquo;탄력 키&amp;rsquo; 를 켜서 허용 지연 시간 바(Bar)를 거의 왼쪽으로 갖다 두면 윈도우의 최소 단위인 0.5초보다 간격이 낮아져서, 반복 입력을 해도 무시되는 경우가 거의 없는데다가 키 바운싱이 완화되는 것을 확인할 수 있다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>&lt;a class="link" href="http://m.blog.naver.com/dondek77/140178945548" target="_blank" rel="noopener"
>위 네이버 포스팅&lt;/a>에도 언급되지만, 100% 해결책은 아니다. &amp;lsquo;다&amp;rsquo; 를 치는데 &amp;lsquo;ㄷ&amp;rsquo; 키가 바운싱이 되는 사이에 &amp;lsquo;ㅏ&amp;rsquo;가 입력되면 OS 입장에서는 &amp;lsquo;ㄷㄷ&amp;rsquo; 같은 중복 키로 인식하지 않으므로 &amp;lsquo;닫&amp;rsquo; 같은 문자가 입력되기 때문이다. 이런 문제는 지금 포스팅을 쓰는데도 발생하고 있다 (이런!)&lt;/p>
&lt;p>결국 지름신을 모셔야 할 것 같지만… 어느 정도 완화할 수는 있겠다 싶어서 작성한다.&lt;/p></description></item><item><title>저작권 걱정 없는 무료 이미지 사이트 3개</title><link>https://interp.blog/license-free-image-3-sites/</link><pubDate>Thu, 28 Jul 2022 01:39:19 +0000</pubDate><guid>https://interp.blog/license-free-image-3-sites/</guid><description>&lt;img src="https://interp.blog/images/2022-07-28-glenn-carstens-peters-loatw2afdyu-unsplash.jpg" alt="Featured image of post 저작권 걱정 없는 무료 이미지 사이트 3개" />&lt;div style="background-color: var(--pre-background-color); width: 95%; margin:2rem; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
😉
&lt;/div>
&lt;div>
이 포스팅의 대표 이미지는 Unsplash 에서 찾은 &lt;a href="https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText">Glenn Carstens-Peters&lt;/a> 의 사진이다. Thanks, Glenn!
&lt;/div>
&lt;/div>
&lt;h2 id="unsplash">Unsplash&lt;/h2>
&lt;p>&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-07-28-unsplash.jpg"/>
&lt;/figure>
&lt;a class="link" href="https://unsplash.com/" title="https://unsplash.com/"
target="_blank" rel="noopener"
>https://unsplash.com/&lt;/a>&lt;/p>
&lt;p>Unsplash 는 노트 서비스인 &lt;a class="link" href="https://www.notion.so/" target="_blank" rel="noopener"
>Notion&lt;/a> 사용자들에게 친숙할 수 있는데, 페이지의 커버 이미지를 선택할 때 Unsplash 에서 손쉽게 검색하고 등록할 수 있는 기능을 제공하기 때문이다. 블로깅 도구인 &lt;a class="link" href="https://ghost.org/integrations/unsplash/" target="_blank" rel="noopener"
>Ghost&lt;/a> 에서는 본문에 이미지를 추가할 때 동일한 기능을 제공하고 있어, 다른 두 곳보다 상대적으로 유명하다 할 수 있겠다.&lt;/p>
&lt;h3 id="저작권">저작권&lt;/h3>
&lt;ul>
&lt;li>✅ 자유롭게 다운로드하고 사용할 수 있음.&lt;/li>
&lt;li>✅ 상업적 사용이 가능함.&lt;/li>
&lt;li>✅ 사용에 어떠한 조건도 없지만, 출처 언급을 해 주면 더욱 좋을 것.&lt;/li>
&lt;li>❌ 수정 없이 재판매 금지&lt;/li>
&lt;li>❌ 다른 스톡/배경화면 모음 서비스에 게재 금지&lt;/li>
&lt;/ul>
&lt;p>자세한 내용은 &lt;a class="link" href="https://unsplash.com/license" title="https://unsplash.com/license"
target="_blank" rel="noopener"
>https://unsplash.com/license&lt;/a> 를 참고한다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="pexels">Pexels&lt;/h2>
&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-07-28-pexels.jpg"/>
&lt;/figure>
&lt;p>&lt;a class="link" href="https://www.pexels.com/" title="https://www.pexels.com/"
target="_blank" rel="noopener"
>https://www.pexels.com/&lt;/a>&lt;/p>
&lt;p>최근에 찾은 또 다른 스톡 서비스인 Pexels 는 한국어 인터페이스를 지원하면서, Unsplash 에서 보던 사진 느낌을 볼 수 있다. 게다가 비디오까지 내려받을 수 있다.&lt;/p>
&lt;h3 id="저작권-1">저작권&lt;/h3>
&lt;ul>
&lt;li>✅ 자유롭게 다운로드하고 사용할 수 있음.&lt;/li>
&lt;li>✅ 상업적 사용이 가능함.&lt;/li>
&lt;li>✅ 수정 가능함.&lt;/li>
&lt;li>✅ 사용에 어떠한 조건도 없지만, 출처 언급을 해 주면 더욱 좋을 것.&lt;/li>
&lt;li>❌ 식별할 수 있는 인물이 부정적 이미지로 소비되는 것 금지&lt;/li>
&lt;li>❌ 식별할 수 있는 인물/브랜드를 통해 홍보 금지&lt;/li>
&lt;li>❌ 수정 없이 재판매 금지&lt;/li>
&lt;li>❌ 다른 스톡/배경화면 모음 서비스에 게재 금지&lt;/li>
&lt;/ul>
&lt;p>자세한 내용은 &lt;a class="link" href="https://www.pexels.com/ko-kr/license/" title="https://www.pexels.com/ko-kr/license/"
target="_blank" rel="noopener"
>https://www.pexels.com/ko-kr/license&lt;/a> 를 참고한다.&lt;/p>
&lt;h2 id="pixabay">Pixabay&lt;/h2>
&lt;figure>
&lt;img loading="lazy" src="https://interp.blog/images/2022-07-28-pixabay.jpg"/>
&lt;/figure>
&lt;p>&lt;a class="link" href="https://pixabay.com/" title="https://pixabay.com/"
target="_blank" rel="noopener"
>https://pixabay.com/&lt;/a>&lt;/p>
&lt;p>Pexels 에서 사진과 비디오를 제공하는 것에 더해, 여기 Pixabay 에서는 벡터, 일러스트레이터, 음악과 사운드 이펙트까지 내려받을 수 있다. 물론 한국어 인터페이스를 지원한다.&lt;/p>
&lt;h3 id="저작권-2">저작권&lt;/h3>
&lt;p>별도로 저작권 설명 페이지는 없고 FAQ 를 통해 간접 추측이 가능하다.&lt;/p>
&lt;ul>
&lt;li>✅ 자유롭게 다운로드하고 사용할 수 있음.&lt;/li>
&lt;li>✅ 수정을 거친 뒤, 상업적 사용이 가능함. (FAQ 문서를 참고)&lt;/li>
&lt;li>✅ 사용에 어떠한 조건도 없지만, 출처 언급을 해 주면 더욱 좋을 것.&lt;/li>
&lt;li>❌ 식별할 수 있는 인물이 부정적 이미지로 소비되는 것 금지&lt;/li>
&lt;li>❌ 식별할 수 있는 인물/브랜드를 통해 홍보 금지&lt;/li>
&lt;li>❌ 수정 없이 상업적 사용/재판매 금지&lt;/li>
&lt;li>❌ 수정을 하더라도 상표 등록을 할 수 없음.&lt;/li>
&lt;li>❌ 다른 스톡/배경화면 모음 서비스에 게재 금지&lt;/li>
&lt;/ul>
&lt;p>자세한 내용은 &lt;a class="link" href="https://pixabay.com/ko/service/faq/" title="https://pixabay.com/ko/service/faq/"
target="_blank" rel="noopener"
>https://pixabay.com/ko/service/faq/&lt;/a> 를 참고한다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>미디어를 프린팅해서 판매한다거나, 특정 제품을 위한 로고나 브랜딩을 위한 이미지 작업을 위해 사용하는 것이 아니라면야 어떤 식으로 사용해도 상관없을 것 같다. 재판매 역시도 원본 그대로는 불가능하지만, 나름의 창의력을 더한 수정본의 경우엔 판매가 가능하다는 것이 세 사이트의 공통적인 지침이다.&lt;/p>
&lt;p>세 사이트 모두 다량의 사진을 보유하고 있고, 실력있는 작가들의 멋진 작품 투고가 현재까지 누적되고 있으니 유용하다고 생각한다. 블로그를 꾸미거나 프레젠테이션을 꾸밀 때, 단순히 디자인이나 사진 영감을 얻기 위해 둘러보면 좋을 것 같다. 개인적으로는 이미지 자체를 내려받을 때는 Unsplash 를 자주 사용했는데, 다른 두 서비스에는 비디오를 제공하니 같이 써봐야겠다.&lt;/p></description></item><item><title>A tour of Go: Pointer, Struct, Array, Slice</title><link>https://interp.blog/tour-of-go-pointer-struct-array-slice/</link><pubDate>Sun, 03 Jul 2022 17:06:37 +0000</pubDate><guid>https://interp.blog/tour-of-go-pointer-struct-array-slice/</guid><description>&lt;p>Go 여행 세 번째 시간이다. &lt;a class="link" href="https://interp.blog/tour-of-go-flow-control-stmts/" target="_blank" rel="noopener"
>지난 시간&lt;/a>에는 flow control statement 에 대해서 알아봤다. 이번에는 Go 언어의 다양한 자료형에 대해 정리해 봤다.&lt;/p>
&lt;h2 id="a-tour-of-go">A tour of Go&lt;/h2>
&lt;ul>
&lt;li>English: &lt;a class="link" href="https://go.dev/tour/" title="https://go.dev/tour/"
target="_blank" rel="noopener"
>https://go.dev/tour/&lt;/a>&lt;/li>
&lt;li>한국어판: &lt;a class="link" href="https://go-tour-ko.appspot.com/" title="https://go-tour-ko.appspot.com/"
target="_blank" rel="noopener"
>https://go-tour-ko.appspot.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="pointer">Pointer&lt;/h2>
&lt;ul>
&lt;li>C/C++ 처럼, golang 에도 포인터가 있다.&lt;/li>
&lt;li>NULL 표현은 &lt;code>nil&lt;/code> 이다.&lt;/li>
&lt;li>그 외엔.. 뭐 C pointer 쓰는 거랑 별로 다를게 없다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">42&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2701&lt;/span>
&lt;span class="nx">p&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">i&lt;/span> &lt;span class="c1">// point to i
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// read i through the pointer = 42
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">21&lt;/span> &lt;span class="c1">// set i through the pointer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// see the new value of i = 21
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">j&lt;/span> &lt;span class="c1">// point to j
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">37&lt;/span> &lt;span class="c1">// divide j through the pointer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// see the new value of j = 73
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="struct">Struct&lt;/h2>
&lt;p>C 의 struct 와 동일한, field 들의 모음이다.&lt;/p>
&lt;p>C 였다면 &lt;code>typedef type struct Vertex { ... } Vertex;&lt;/code> 이라고 typedef 를 곁들여야 하지만, 여기서는 &lt;code>type&lt;/code> 만 써도 된다. 사실상 &lt;code>type&lt;/code> 하나가 위의 &lt;code>typedef ...&lt;/code> 전체를 모두 커버한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>var [변수명] [타입]&lt;/code> 처럼 &lt;code>type [타입명] struct&lt;/code> 인 것을 잘 기억해 두자.&lt;/li>
&lt;li>struct 형 변수를 초기화할 때는 &lt;code>{ }&lt;/code> 로 써야 한다.&lt;/li>
&lt;li>각 field 는 &lt;code>.&lt;/code> 을 사용해서 참조할 수 있다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">type&lt;/span> &lt;span class="nx">Vertex&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">X&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="nx">Y&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Vertex&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">})&lt;/span> &lt;span class="c1">// {1, 2} 라고 표시된다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="struct-pointer">Struct Pointer&lt;/h3>
&lt;p>원래 C 같았으면 struct pointer 변수에서 특정 필드를 참조하려면 &lt;code>(*p).X&lt;/code> 이런 식으로, 포인터의 struct 값을 dereference 한 다음에 참조하거나, &lt;code>p-&amp;gt;X&lt;/code> 같은 식으로 &amp;lsquo;포인터 변수&amp;rsquo; 라는 걸 나타내서 참조하는데.. 여기서는 둘 다 귀찮으니까 &lt;code>p&lt;/code> 가 struct pointer 라도 &lt;code>p.X&lt;/code> 로 참조가 가능하게 했다.&lt;/p>
&lt;pre>&lt;code>func main() {
v := Vertex{1, 2}
p := &amp;amp;v
p.X = 1e9 // 이렇게만 참조하고 값까지 할당하는데, 아무런 문제가 없다.
fmt.Println(v) // {1000000000 2}
}
&lt;/code>&lt;/pre>
&lt;h3 id="struct-literals">Struct Literals&lt;/h3>
&lt;p>Struct 형 변수 초기화할 때 취할 수 있는 방법을 소개한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>보통 unnamed list 를 할 것이다. &lt;code>Vertex{1,2}&lt;/code> 처럼&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>named list 도 가능한데, &lt;code>[field name]:&lt;/code> 으로 쓴다. function 의 default parameter 와는 달리, 여기선 순서는 상관없다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>값을 넣지 않으면, 각 필드의 기본값이 들어간다. (여기서는 int 니까 0)&lt;/p>
&lt;p>var (
v1 = Vertex{1, 2} // has type Vertex
v2 = Vertex{X: 1} // Y:0 is implicit
v3 = Vertex{} // X:0 and Y:0
p = &amp;amp;Vertex{1, 2} // has type *Vertex
)&lt;/p>
&lt;p>func main() {
fmt.Println(v1, v2, v3, p) // {12} {1 0} {0 0} &amp;amp;{1 2}
}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="array">Array&lt;/h2>
&lt;p>Slice 와는 달리, 사이즈가 고정된다.&lt;/p>
&lt;ul>
&lt;li>C 처럼 length 가 뒤에 오지 않고, 앞에 온다.&lt;/li>
&lt;li>출력하면 struct 와는 달리 꺽쇠 &lt;code>[ ]&lt;/code> 로 출력된다.&lt;/li>
&lt;li>&lt;strong>하지만 literal 선언은 (slice 와 마찬가지로) &lt;code>{ }&lt;/code> 안에서 원소를 나열해야 한다.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="slice">Slice&lt;/h2>
&lt;p>Array 에서 length number 만 지우면, slice 가 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>array 또는 slice 에서 index range 를 지정할 수 있는데, C array index 를 생각해도 헷갈릴 수 있는 부분이다.
&lt;ul>
&lt;li>수학적으로 정확한 range 표현은 &lt;code>[n:m)&lt;/code> 이다. 마지막 인덱스에 해당하는 원소는 &lt;strong>포함이 안 된다&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">primes&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">13&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">primes&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 3, 5, 7, 11 인가?
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [3 5 7] 만 출력된다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Slice 는 단독으로 쓰이기도 하지만, 보통은 array 의 특정 구간을 나타내기 위해서도 쓰인다. 주의할 점은, Slice 가 바뀌면 연결된 array 도 같이 바뀐다는 것이다 (&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">names&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span> &lt;span class="c1">// 어.. 비틀즈 성님덜?
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="s">&amp;#34;John&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;Paul&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;George&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;Ringo&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">names&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">names&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// [John Paul]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">b&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">names&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// [Paul George]
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">b&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;XXX&amp;#34;&lt;/span> &lt;span class="c1">// 아니 왜 폴 메카트니 성님을 지워여;;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 폴의 이름이 다 바뀌어 있음.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">names&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 그리고 원래 array 에도 영향이..
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>[n:m]&lt;/code> 으로 구간을 나눌 때 양쪽 end 를 생략할 수도 있고, 둘 다 생략할 수도 있다.
&lt;ul>
&lt;li>왼쪽 생략 = 0&lt;/li>
&lt;li>오른쪽 생략 = 끝까지&lt;/li>
&lt;li>양쪽 생략 = 그냥 그 array/slice 전체 (&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>slice 안에 당연히 struct 를 쓸 수 있다. 그래서 이런 괴상망측한 하지만 자주 보게 될 선언도 있다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="c1">// 이런게 가능합니다...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 이렇게 typed value 를 바로 선언하는 걸 literal 이라고 하는데,
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// slice 건 struct 건 간에 literal 은 [] 가 아니라 {} 로 해야 한다.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="nx">b&lt;/span> &lt;span class="kt">bool&lt;/span>
&lt;span class="p">}{&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>slice 는 length &lt;code>len()&lt;/code> 과 와 capacity &lt;code>cap()&lt;/code> 을 지원한다.
&lt;ul>
&lt;li>&lt;code>len()&lt;/code> : 실제 원소들의 개수&lt;/li>
&lt;li>&lt;code>cap()&lt;/code> : 하위 array 의 개수 (array 는 fixed-width 라고 했다)
&lt;ul>
&lt;li>이게 언제 필요하냐면, slicing 할 수 있는 길이를 가늠할 때 (만약 cap 이 6인데 &lt;code>[:7]&lt;/code> 이렇게 쓰면 에러가 나버린다.&lt;/li>
&lt;li>중요한 건, underlying array 에서, slice 의 first element 가 가리키는 위치 부터 끝까지의 길이이다 (끝 인덱스는 상관없는게 또 헷갈린다..)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">13&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Slice the slice to give it zero length.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 끝이 지정되어 있지 않으니 cap 은 6임. length 는 당연히 0이고.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Extend its length.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 0~4 까지니까 length 는 5이고, 역시 끝이 지정되어 있지 않아서 cap 은 6임.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Drop its first two values.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">:]&lt;/span> &lt;span class="c1">// 마지막 slice 를 또 slicing 하지만, &amp;#39;처음 array&amp;#39; 에서 2번째 element 부터의 array 길이가 cap 이므로
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 5,7,11,13 -&amp;gt; 4임. ㄱ-
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 그런데 또 length 는 &amp;#39;마지막 slice&amp;#39; 에서의 2번째부터니까 5,7,11 만 있어서 3임 (...)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>slice 에 아무 값도 없으면, 그 값은 &lt;code>nil&lt;/code> 과 같다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">cap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;nil!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>make()&lt;/code> 로 slice 를 만들 수 있다. 직접 값을 입력하는게 아니라, 변수를 통해 slice 를 선언할 수 있다는 차이가 있다.
&lt;ul>
&lt;li>length, capacity 를 별도로 입력할 수 있는 정도?&lt;/li>
&lt;li>length 가 0이면 비어 있는데, 그걸 잘라내면 0이 채워진다?? ㄱ-&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">b&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;b&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">d&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">d&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> b len=0 cap=5 []
&lt;/span>&lt;span class="cm"> c len=2 cap=5 [0 0]
&lt;/span>&lt;span class="cm"> d len=3 cap=3 [0 0 0]
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>slice 안에 slice 를 담을 수 있음. 이러면 2차원 배열이 됨. 이 때는 &lt;code>[][]string&lt;/code> 처럼 slice type 앞에 slice 를 쓰겠다고 선언하면 됨. (&lt;strong>2차원 배열이 된다&lt;/strong>)
&lt;ul>
&lt;li>그리고 각 원소도 slice literal 임을 명시해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아래는 2차원 배열 예제 프로그램인데, 주목할 건 for 문이 1개만 쓰였단 거다.
&lt;ul>
&lt;li>대신 &lt;code>strings.Join()&lt;/code> 을 써서 내부 원소 (&lt;code>board[i]&lt;/code>) 를 String 으로 만들어 출력했다는 점..&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Create a tic-tac-toe board.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">board&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[][]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// The players take turns.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;X&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;O&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;X&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;O&amp;#34;&lt;/span>
&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;X&amp;#34;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">board&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s\\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">strings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>익히 알겠지만, slice 는 &lt;code>append()&lt;/code> 가 가능하다. 첫 번째 파라메터는 소스 slice, 나머지는 쭉 원소(들) 을/를 입력하면 된다.
&lt;ul>
&lt;li>그럼 cap 은 어떻게 되나요? 직접 실험해보자 (&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// append works on nil slices.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// The slice grows as needed.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// We can add more than one element at a time.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 여기서 재밌는 건 cap 이 5가 아니라 6이 된다는 거다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">printSlice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> len=0 cap=0 []
&lt;/span>&lt;span class="cm"> len=1 cap=1 [0]
&lt;/span>&lt;span class="cm"> len=2 cap=2 [0 1]
&lt;/span>&lt;span class="cm"> len=5 cap=6 [0 1 2 3 4]
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>마지막 줄이 왜 cap 이 6이 되는지는, go blog 에 있는 &lt;a class="link" href="https://go.dev/blog/slices-intro" target="_blank" rel="noopener"
>Slices-intro&lt;/a> 를 살펴보자. 특히 ‘&lt;strong>Growing slices (the copy and append functions)&lt;/strong>’ 처음에 make 하는 부분을 보면 된다.&lt;/p>
&lt;ul>
&lt;li>Slice 에서의 for 는 &lt;code>for each&lt;/code> 같은 구문을 사용할 수 있다.
&lt;ul>
&lt;li>&lt;code>range [slice]&lt;/code> 로 initialize 를 하게 되는데, 리턴되는 게 2개다. 인덱스와 실제 값.&lt;/li>
&lt;li>※ 인덱스를 안 쓰게 되면 (어차피 compile 에서 에러를 내겠지만) &lt;code>_&lt;/code> 처리해야 한다.&lt;/li>
&lt;li>value 를 안 쓰려면, value 자리를 &lt;code>_&lt;/code> 로 감싸도 되지만, 단순히 인덱스’만’ 받아도 된다.
&lt;ul>
&lt;li>인덱스만 받아서 슬라이스를 인덱스+1 로 참조할 용도로 쓰는.. 뭐 그런?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="k">for&lt;/span> &lt;span class="nx">idx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">value&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">slice_var&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// 인덱스만 쓰고 싶으면
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">idx&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">slice_var&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Rough Notation</title><link>https://interp.blog/rough-highlight-js/</link><pubDate>Fri, 24 Jun 2022 03:01:26 +0000</pubDate><guid>https://interp.blog/rough-highlight-js/</guid><description>&lt;img src="https://interp.blog/images/2022-06-24-68747470733a2f2f726f7567686e6f746174696f6e2e636f6d2f696d616765732f736f6369616c2e706e67.png" alt="Featured image of post Rough Notation" />&lt;p>GeekNews 를 보다보니 Atlassian JIRA 와 Bitbucket 서비스가 &lt;span class="rn-underline">너무 구려서 못 써먹겠다&lt;/span>는 코멘트를 모아 둔 사이트를 발견했다. (사이트 주소도 비범하게 &lt;a class="link" href="https://ifuckinghatejira.com/" target="_blank" rel="noopener"
>https://ifuckinghatejira.com/&lt;/a> 이다..!)&lt;/p>
&lt;blockquote>
&lt;p>개인적으로 Confluence 사용에 익숙해져서 큰 불만은 없지만, Issue Tracker 로는 Github/Gitlab 을 쓰는게 백번 낫다는 입장이기는 하다 ㅎㅎ&lt;/p>
&lt;/blockquote>
&lt;p>아무튼, 이 사이트 페이지에 나와있는 강조 표현이 애니메이션으로 차례차례 이뤄지고 있는 게 눈에 띄었다. 그것도 반듯한 모양이 아니라, 마치 사람이 수작업으로 글을 읽어내려가면서 표시하는 것 처럼 친숙해 보였다. 당장 F12 키를 눌러서 어떤 스크립트가 쓰여졌는지 확인해 봤다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/images/2022-06-24-2022-06-24-131516.png"
loading="lazy"
alt="Rough Notation main page"
>&lt;/p>
&lt;p>공식 사이트는 &lt;a class="link" href="https://roughnotation.com/" title="https://roughnotation.com/"
target="_blank" rel="noopener"
>https://roughnotation.com/&lt;/a> 이고, 다양한 효과를 &amp;lsquo;ANNOTATE&amp;rsquo; 버튼을 눌러 라이브로 볼 수 있다. 밑줄, 네모, 동그라미, 하이라이트, 취소선, X선 등의 효과가 가능하며, 애니메이션을 수행하지 않도록 지정할 수도 있다고 한다.&lt;/p>
&lt;p>그리고 &lt;span class="rn-circle">&lt;strong>여기서도&lt;/strong>&lt;/span> 동일한 효과를 적용해 보았다!&lt;/p>
&lt;script type="module">import { annotate } from 'https://unpkg.com/rough-notation?module'; const n2 = document.querySelector('span.rn-circle'); const n4 = document.querySelector('span.rn-underline'); const a2 = annotate(n2, { type: 'circle', color: 'red', padding: 10 }); const a4 = annotate(n4, { type: 'highlight', color: '#ff0066', iterations: 1, multiline: true }); a2.show(); a4.show();&lt;/script></description></item><item><title>Golang struct tag: omitempty</title><link>https://interp.blog/golang-struct-tag/</link><pubDate>Tue, 21 Jun 2022 16:19:07 +0000</pubDate><guid>https://interp.blog/golang-struct-tag/</guid><description>&lt;h2 id="태그">태그?&lt;/h2>
&lt;p>Go 언어의 &lt;code>struct&lt;/code> 타입에는 각 필드마다 태그를 붙일 수 있다. (struct tag 라고도 불린다) 이렇게 아무렇게나 태그를 붙여둘 수 있다. 물론 다른 함수나 패키지에서 이런 태그를 파싱해서 다룰 수 있어야 하겠지만.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`mandatory`&lt;/span>
&lt;span class="nx">ID&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="s">`mandatory`&lt;/span>
&lt;span class="nx">Phone&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`optional`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>encoding/json&lt;/code> 은 &lt;code>json&lt;/code> 으로 시작하는 태그를 지원하는데, 아래와 같이 흔히들 볼 수 있는 것들이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;span class="nx">ID&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="s">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;span class="nx">Phone&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;phone_number&amp;#34;`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 태그를 가지고 있으면, &lt;code>json.Marshal()&lt;/code> 을 할 때 구조체 필드 값을 자동으로 JSON 문서로 변환해준다. 또는 &lt;code>json.Unmarshal()&lt;/code> 을 통해, 입력된 JSON 문서 바이트 배열을 해당 구조체의 각 필드에 맞춰 알아서 변환해 준다.&lt;/p>
&lt;h2 id="omitempty-옵션">omitempty 옵션&lt;/h2>
&lt;p>오늘 알아볼 것은, 이런 태그 뒤에 붙는 옵션들 중에서 &lt;code>omitempty&lt;/code> 에 대한 내용이다. 이 옵션은 말 그대로 &amp;lsquo;비어있는 필드 값은 생략하겠다&amp;rsquo; 라는 뜻이다.&lt;/p>
&lt;p>&lt;strong>결론만 말하면, 이 옵션은 Marshalling 할 때만 효과가 있다.&lt;/strong> &lt;a class="link" href="https://go.dev/play/p/EhzLmox7CYN" target="_blank" rel="noopener"
>Go Playground Link&lt;/a> 에 아래 예제 코드를 넣어뒀으니, 직접 실행해보고 확인해보는 것을 추천한다.&lt;/p>
&lt;h3 id="값이-비어있다">값이 비어있다?&lt;/h3>
&lt;p>Go 언어의 자료형 기본값이 들어가 있으면 값이 비어 있다고 간주한다. 이 부분은 이전 포스팅인 &lt;a class="link" href="https://interp.blog/tour-of-go-package-function-variable/" >Go Tour 문서&lt;/a>에 더욱 자세한 내용이 들어있다.&lt;/p>
&lt;ul>
&lt;li>실수형 = 0&lt;/li>
&lt;li>문자형 = &amp;quot;&amp;quot;&lt;/li>
&lt;li>boolean 형 = false&lt;/li>
&lt;li>포인터형 = nil&lt;/li>
&lt;/ul>
&lt;h3 id="unmarshalling-json---struct">Unmarshalling (JSON -&amp;gt; struct)&lt;/h3>
&lt;p>안 해도 되는데, 일단 의심을 거두기 위해 Unmarshalling 부터 테스트 해보자. 위의 &lt;code>Employee&lt;/code> struct type 에다가, 다음 JSON String 을 Unmarshalling 해보려고 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;John Doe&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">e&lt;/span> &lt;span class="nx">Employee&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unmarshal&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">jsonString&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nb">panic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;[%s]\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Phone&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>그 결과는, 뻔하긴 하지만 대괄호만 나올 것이다. (&lt;code>[]&lt;/code>) 그럼 여기서 &lt;code>e.Phone&lt;/code> 에 값이 있었다면 어떻게 될까? 이 &amp;ldquo;010-&amp;rdquo; 값은 Unmarshalling 을 해도 그대로 남는다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">e&lt;/span> &lt;span class="nx">Employee&lt;/span>
&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Phone&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;010-&amp;#34;&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>그렇다면, 이번에는 &lt;code>omitempty&lt;/code> 를 &lt;code>Employee.Phone&lt;/code> 에 붙이고 위의 두 실험을 해보자. 결과는 같은가? &lt;strong>그렇다.&lt;/strong> 값이 없으면 없는대로, 있으면 있는대로 출력된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;span class="nx">ID&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="s">`json:&amp;#34;id&amp;#34;`&lt;/span>
&lt;span class="nx">Phone&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="s">`json:&amp;#34;phone_number,omitempty&amp;#34;`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="marshalling-struct---json">Marshalling (struct -&amp;gt; JSON)&lt;/h3>
&lt;p>이번에는 저장된 값을 JSON 으로 나눠보자. 우선, &lt;code>omitempty&lt;/code> 옵션을 다시 빼고, &lt;code>e.Phone&lt;/code> 에는 아무런 값을 넣어보지 않았다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">e&lt;/span> &lt;span class="nx">Employee&lt;/span>
&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;John Doe&amp;#34;&lt;/span>
&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ID&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">jsonReturned&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Marshal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nb">panic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">jsonReturned&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;id&amp;quot;:1,&amp;quot;phone_number&amp;quot;:&amp;quot;&amp;quot;}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>phone_number&lt;/code> 라는 필드가 생겼다. struct 필드 값이 비어 있어도 JSON 에는 필드가 보인다는 것이다.&lt;/p>
&lt;p>이걸 방지하기 위해 &lt;code>omitempty&lt;/code> 가 필요하다. 해당 옵션을 다시 &lt;code>Employee.Phone&lt;/code> 에 넣고 동일한 코드를 돌려보면 다음과 같이 출력된다.&lt;/p>
&lt;pre>&lt;code>{&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;id&amp;quot;:1}
&lt;/code>&lt;/pre>
&lt;h2 id="사소한-문제">사소한 문제?&lt;/h2>
&lt;p>아까 Go 언어 기본값이 들어있는 필드는 JSON encoding package 에서 비어있는 필드로 간주한다는 말을 했었다. 그런데, 이 값들이 유의미한 값이라면 어떻게 해야 할까? 이 때는 &lt;code>omitempty&lt;/code> 옵션 사용을 자제해야 한다.&lt;/p>
&lt;p>예를 들면, 통장 내역을 나타내는 struct type 에서, 잔고를 나타내는 &lt;code>balance&lt;/code> 필드가 있다고 가정하자. 만약, 이 필드가 정확히 0을 가진다면 이 0이란 숫자는 유효한 숫자다. 그런데 이 필드에 대고 &lt;code>omitempty&lt;/code> 를 붙이게 되면, 사용자가 반환받을 JSON 문서에 &lt;code>balance&lt;/code> 자체가 없게 되고 큰 혼란 (?) 이 올 수 있다. 잔고라는 필드는 프로그램에서 필수적으로 있을 것이라 가정하기 때문에 일종의 &lt;em>AssertionError&lt;/em> 에 빠질 수 있다는 뜻이다.&lt;/p>
&lt;p>Marshalling 할 때 JSON 문서의 다이어트 목적으로 이 옵션을 종종 쓸 텐데, 항상 주의해서 써야 한다는 것으로 끝맺는다.&lt;/p></description></item><item><title>A tour of Go: Flow control statements</title><link>https://interp.blog/tour-of-go-flow-control-stmts/</link><pubDate>Mon, 20 Jun 2022 02:36:25 +0000</pubDate><guid>https://interp.blog/tour-of-go-flow-control-stmts/</guid><description>&lt;p>&lt;a class="link" href="https://interp.blog/tour-of-go-package-function-variable" >지난 시간&lt;/a>에 이어서, 여기서는 Flow Control Statement 에 대해 정리해 보았다.&lt;/p>
&lt;h2 id="a-tour-of-go">A tour of Go&lt;/h2>
&lt;ul>
&lt;li>English: &lt;a class="link" href="https://go.dev/tour/" title="https://go.dev/tour/"
target="_blank" rel="noopener"
>https://go.dev/tour/&lt;/a>&lt;/li>
&lt;li>한국어판: &lt;a class="link" href="https://go-tour-ko.appspot.com/" title="https://go-tour-ko.appspot.com/"
target="_blank" rel="noopener"
>https://go-tour-ko.appspot.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="if-else">If, else&lt;/h2>
&lt;p>조건문은 다른 프로그래밍 언어와 마찬가지로 &lt;code>if&lt;/code>, &lt;code>else&lt;/code> 그리고 &lt;code>else if&lt;/code> 의 조합으로 구성된다. 조건 절 (condition clause) 에 있는 수식을 검증 (evaluation 이라고도 한다) 한 결과가 참이면 해당 블록이 수행된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nf">funcTrue&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여러 개의 수식들을 넣어도 되고, 마지막 수식이 boolean 으로 검증되거나 반환되어야 한다. 수식 간에는 세미콜론(&lt;code>;&lt;/code>)으로 구분한다. 이 부분에서 가장 널리 쓰이는 패턴이 바로 &lt;code>error&lt;/code> 객체가 반환되었는지 검증하는 구문이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">funcTest&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// error handling with `err` object
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>참고로 저기 &lt;code>err&lt;/code> 는 조건 블록 안에서만 사용할 수 있다. 바깥에서는 참조할 수 없고, 대신 다른 &lt;code>else if&lt;/code> 나 &lt;code>else&lt;/code> 블록에서는 참조가 가능하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">if&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">testStr&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ok
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ok
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ok
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// error
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>심지어는 &lt;code>else if&lt;/code> 에서 선언된 변수가 있는데 &lt;code>if&lt;/code> 에서 쓸 수 있을까? 된다! hoisting 해서 쓴다. 이 쯤 생각해보니, &lt;strong>if block 전체에 선언된 변수들에 대해 evaluation 을 먼저 하는 것으로 보인다&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">pow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">lim&lt;/span> &lt;span class="kt">float64&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">float64&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">lim&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">v&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%g &amp;gt;= %g\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">lim&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 여기선 가능
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">lim&lt;/span> &lt;span class="c1">// 여기서 v 를 참조할 수 없다.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>performance 를 중요시한다면 필요한 변수는 inner-block 에서 선언해 쓰는게 좋을 거 같긴 한데.. 아직 언어에 대해 잘 모르겠으니 참고만 하자.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="for">For&lt;/h2>
&lt;h3 id="basic-for">basic for&lt;/h3>
&lt;p>다른 프로그래밍 늘 그렇듯, &lt;code>init; condition; post&lt;/code> 로 이루어져 있다. init 에는 마치 지역 변수 선언과 같은 모양을 한다 (bash 를 떠올리면 된다) 그리고 여타 다른 언어와 달리 (C, Java, &amp;hellip;) 괄호가 없다는 점을 주목하자. 그러나 반드시 브라켓 &lt;code>{ }&lt;/code> 은 필요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="nx">sum&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="nx">i&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="continued-for">Continued for&lt;/h3>
&lt;p>init 과 post 은 optional 이다. 이게 비어 있으면 condition 만 남아 while 과 같은 기능을 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> sum := 0
for ; sum &amp;lt; 10; {
// for sum &amp;lt; 10 { // 둘 중 아무거나 써도 똑같다.
// 그리고 위 처럼 쓴 뒤 go fmt 를 돌리면 세미콜론이 알아서 빠진다.
sum += sum
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>리스트나 맵을 순회할 때도 continued for 의 일종이라고 보면 된다. 이 때는 &lt;code>range&lt;/code> 를 사용한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">myMap&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>
&lt;span class="nx">myMap&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="nx">myKey&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myValue&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">myMap&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="while">While&lt;/h2>
&lt;p>다른 말로, &lt;strong>golang 은 while 이 없다&lt;/strong>&amp;hellip; 대신 &lt;code>for&lt;/code> 만 적으면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="switch">Switch&lt;/h2>
&lt;p>C/C++, Java 의 switch 라고 생각하면 된다. 차이점은,&lt;/p>
&lt;ul>
&lt;li>C 처럼 단일 값 (e.g. int, character) 이 아니라 &lt;strong>string 도 사용이 가능&lt;/strong>하고&lt;/li>
&lt;li>&lt;code>case&lt;/code> 에 &lt;strong>variable 을 넣어도&lt;/strong> 된다.&lt;/li>
&lt;li>각 case 마다 break 를 다 집어넣지 않아도 된다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Go runs on &amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">darwin_os&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;darwin&amp;#34;&lt;/span> &lt;span class="c1">// 이걸 타겟으로 써도.. 된다고?
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="nx">os&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">GOOS&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">os&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">darwin_os&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1">// ㅇㅇ 되네
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;OS X.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;linux&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Linux.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s.\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>참고로 &lt;code>case:&lt;/code> 만 쓰면 &lt;code>case True:&lt;/code> 와 같은 의미가 된다.&lt;/p>
&lt;p>위의 차이점을 생각해보면, 마치 기다란 &lt;code>if-else&lt;/code> 를 &lt;code>switch&lt;/code> 로 치환할 수 있을 것 처럼 보이지만 사실 두 가지 제약을 고려해서 선택해야 한다.&lt;/p>
&lt;ol>
&lt;li>가독성 문제를 고려해야 한다.&lt;/li>
&lt;li>if 안에서 변수 선언/할당이 가능하지만, case 에서는 변수 선언이 안 된다.&lt;/li>
&lt;/ol>
&lt;h2 id="defer">defer&lt;/h2>
&lt;p>이 키워드로 시작하는 구문은 &lt;strong>해당 함수가 끝날 때 까지 실행이 유예된다&lt;/strong>. 이 키워드는 블록에 종속된 개념이 아니라 &lt;em>함수에 종속&lt;/em>된 개념이다. 따라서, 어느 inner block 에서 쓰이건 간에 이 구문을 지난다면, 함수가 끝날 때에야 구문이 수행된다.&lt;/p>
&lt;p>&lt;code>defer&lt;/code> 뒤에 오는 구문은 &lt;strong>반드시 함수 호출이어야 한다&lt;/strong>. 변수 선언이거나 변수 값 할당같은 식은 안 된다. (&lt;code>+=&lt;/code> 도 안 됨)&lt;/p>
&lt;p>재미있는 건, &lt;code>defer&lt;/code> 줄을 만나는 시점에 argument 값이 결정된다. 이후에 argument 로 들어간 variable 이 바뀌더라도, &lt;code>defer&lt;/code> 의 실제 수행 시점에서는 영향이 없는 것을 아래 코드로 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">abc&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>
&lt;span class="c1">// 아래 세 줄을 브라켓으로 감싸 블록으로 만든다 한 들, 결과는 동일함 (함수 레벨이기 때문)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">abc&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="s">&amp;#34; world&amp;#34;&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">abc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 뒤에 느낌표는 여기서 평가가 안 되지만, 출력은 마지막에 된다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">abc&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="s">&amp;#34; !!&amp;#34;&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">abc&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 여기서는 전부 출력된다.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm">hello world !!
&lt;/span>&lt;span class="cm">hello world
&lt;/span>&lt;span class="cm">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>defer&lt;/code> 를 하나의 함수 안에서 여러 개 선언할 수 있다. 실행 순서는 LIFO, 즉 먼저 들어간 수식이 나중에 실행된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 맞춰보자. 0이 먼저 나올까 9가 먼저 나올까?
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>A tour of Go: Package, Function, Variable</title><link>https://interp.blog/tour-of-go-package-function-variable/</link><pubDate>Thu, 16 Jun 2022 10:26:18 +0900</pubDate><guid>https://interp.blog/tour-of-go-package-function-variable/</guid><description>&lt;p>A tour of Go 시리즈를 두 번씩 돌아보고, 나름 배운 것들을 연이어 적어보려 한다. 첫 번째로 패키지, 변수, 함수 정의와 사용에 대한 내용이다. 이 문서는 번역이 아니라서, 개인적으로 중요했던 부분만 있을 수도 있고 투어 예제에서 다루지 않은 부분이 섞여있을 수 있으니 편하게 봐주셨으면 한다. &lt;del>화면 안 넘기고 스크롤만으로 볼 수 있다는 장점 정도?&lt;/del>&lt;/p>
&lt;h2 id="a-tour-of-go">A tour of Go&lt;/h2>
&lt;p>Go 언어의 튜토리얼 페이지라고 보면 된다. 다양한 언어로 번역되어 있으니 영어 원문으로 봐도 좋고 한국어판으로 봐도 좋다.&lt;/p>
&lt;ul>
&lt;li>English: &lt;a class="link" href="https://go.dev/tour/" title="https://go.dev/tour/"
target="_blank" rel="noopener"
>https://go.dev/tour/&lt;/a>&lt;/li>
&lt;li>한국어판: &lt;a class="link" href="https://go-tour-ko.appspot.com/" title="https://go-tour-ko.appspot.com/"
target="_blank" rel="noopener"
>https://go-tour-ko.appspot.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="package">Package&lt;/h2>
&lt;p>모든 &lt;code>*.go&lt;/code> 파일의 첫 줄에는, 이 파일이 속한 &amp;lsquo;패키지&amp;rsquo; 이름을 작성한다. &lt;code>main.go&lt;/code> 는 이렇게 패키지 이름이 지정될 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>다음 줄에는, 이 파일에서 사용할 다른 패키지들을 작성할 수 있다. 이렇게 각각 패키지 이름과 함께 &lt;code>import&lt;/code> 를 해도 되지만,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// separated
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;math&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 뭉쳐서 선언하는게 보통이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// factored (better)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;math&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="function-declaration">Function declaration&lt;/h2>
&lt;p>다양한 방식으로 함수 시그니처를 선언할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// 기본적인 형태. return type 까지 적어야 함.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// input 타입이 다 같으면 이렇게 typing 을 몰아서 할 수도 있음 (가독성은 좀 떨어짐)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// return 도 여러 개 가능함.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// return 에 변수명을 입력해도 됨. 이 때는 변수명이 함수 내부에서 사용되고, naked return 으로 리턴함 (&amp;#39;return&amp;#39; 만 씀)
&lt;/span>&lt;span class="c1">// &amp;lt;&amp;lt; 가독성이 심하게 떨어지므로 짧은 함수일 때만 쓰는걸 추천함.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sum&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">..&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="variable-declaration">Variable declaration&lt;/h2>
&lt;p>변수 또한 다양한 방식으로 선언이 가능한데, 크게 두 가지 방법으로 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>var&lt;/code> 키워드를 통한 선언&lt;/li>
&lt;li>&lt;code>:=&lt;/code> 를 사용해 선언+할당 동시에 하기&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="c1">// 여러 변수가 전부 같은 타입이면 이렇게 변수명 리스트와 마지막 타입 한 번만 적어서 정의해도 됨.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 이건 패키지 레벨, 즉, 다른 함수도 c, python, java 를 모두 접근할 수 있다.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 순서는 var [변수명] [타입] 이다. 이건 함수 레벨이다.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>변수 선언과 함께 값을 할당하는 initializer 방법도 다양하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="c1">// 지정된 타입에 맞춰 넣는다. 여러 개를 이렇게 동시에 넣어도 된다. (이 경우에 j = &amp;#34;str&amp;#34; 하면 에러 난다)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;no!&amp;#34;&lt;/span> &lt;span class="c1">// 타입 지정이 되어 있지 않아도, 값에 따라 개별로 설정된다. 앞부터 bool, bool, string 이 된다.
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 이렇게 factored 방식으로 지정할 수도 있고, 가독성 역시 좋아진다~
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="nx">ToBe&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="nx">MaxInt&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1">// bit-wise operator 조심
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>:=&lt;/code> 도 알아보자. 단, 이 방법은 전역 변수 (=패키지 레벨 변수) 에서는 사용이 불가능하다. 이 때는 &lt;code>var&lt;/code> 로만 선언이 가능하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">blahblah&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">k&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="c1">// var k = 3 과 같다. var == : 라는 뜻.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">python&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">java&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;no!&amp;#34;&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exported-variablefunction">Exported variable/function&lt;/h2>
&lt;p>첫 문자가 &lt;strong>대문자&lt;/strong>인 함수나 전역 변수 이름은, &lt;code>패키지 이름.이름&lt;/code> 형식으로 다른 패키지에서 참조가 가능하다. 아래와 같이 쓰고 &lt;code>custommath_pi.go&lt;/code> 라고 저장했다고 하면, &lt;code>custommath.hiddenPi&lt;/code> 로는 참조가 안 되고 &lt;code>custommath.Pi()&lt;/code> 는 참조가 가능하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">custommath&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">hiddenPi&lt;/span> &lt;span class="kt">float64&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">Pi&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">float64&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="o">...&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>주목할 부분은,&lt;/p>
&lt;ul>
&lt;li>파일 이름이 아니라 패키지 이름으로 참조한다는 것이다.&lt;/li>
&lt;li>다른 말로, 같은 패키지 안이기만 하면, 다른 파일에서도 모든 변수/함수 참조가 가능하다는 것이다. (같은 패키지에서 중복된 변수/함수 이름은 허용되지 않는 이유..)&lt;/li>
&lt;/ul>
&lt;h2 id="variable-types-default-values">Variable types, default values&lt;/h2>
&lt;pre>&lt;code>bool
string
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
byte // alias for uint8
rune // alias for int32
// represents a Unicode code point
float32 float64
complex64 complex128 // 복소수임.. e.g. 3+2i
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>C/C++ 개발자들에겐 &lt;code>uintptr&lt;/code>, &lt;code>rune&lt;/code>, &lt;code>complex&lt;/code> 타입이 좀 생소할 수 있다. 주석으로 설명해 뒀으니 이해해주면 좋겠다.&lt;/li>
&lt;li>&lt;code>int&lt;/code>, &lt;code>uint&lt;/code>, &lt;code>uintptr&lt;/code> 은 물론, 32-bit system 에서는 4바이트, 64-bit system 에서는 8바이트이다.&lt;/li>
&lt;/ul>
&lt;p>이제 각 타입의 기본값을 알아보자.&lt;/p>
&lt;ul>
&lt;li>정수/실수형은 전부 &lt;strong>0&lt;/strong> (float 역시 0.0 이 아니라 0)&lt;/li>
&lt;li>boolean 은 &lt;strong>false&lt;/strong>&lt;/li>
&lt;li>string 은 &lt;strong>“”&lt;/strong> (empty) (formatting 에서 주목할 부분은 &lt;code>%q&lt;/code> 로 하면 quota 가 붙는다는 거다 (&amp;hellip;))&lt;/li>
&lt;li>포인터형은 전부 &lt;strong>nil&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="variable-type-casting">Variable type-casting&lt;/h2>
&lt;p>Go 언어에서 type casting 은 &lt;em>type conversion&lt;/em> 이라고 불린다. 그냥 캐스팅 하듯 type 을 앞에 쓰고 괄호로 감싸면 형변환이 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">42&lt;/span>
&lt;span class="nx">f&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">float64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">u&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">uint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>다른 대부분의 언어에서는 암묵적 캐스팅이 가능한데, Go 언어는 이 부분에서 엄격하다. 따라서 이 구문은 안 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">f&lt;/span> &lt;span class="kt">float64&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="c1">// i 가 int 여서 안 됨. 1.0 으로 들어가지 않음
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="constant">Constant&lt;/h2>
&lt;p>&lt;code>const&lt;/code> 키워드를 쓰면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">const&lt;/span> &lt;span class="nx">Pi&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mf">3.14&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">const&lt;/span> &lt;span class="nx">world&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;세계&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>다음의 특징을 가진다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>패키지 레벨, 함수 레벨 둘 다 가능하다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>var&lt;/code> 이나 &lt;code>:=&lt;/code> 로 선언할 수 없다. 이 말은, &lt;strong>별도의 타입 선언을 하지 않고&lt;/strong> 상수 값과 함께 선언한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>별도 타입 선언이 안 되므로, 정수형 상수 (numeric constant) 를 넣을 때는 내부적으로 필요한 type 을 (마음대로) 결정한다. 예를 들어,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">const&lt;/span> &lt;span class="nx">Big&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">100&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 선언하면 Big 은 &lt;code>int&lt;/code> 형이 아니라 &lt;code>float64&lt;/code> 쯤 될 것이다. 이 말은 &lt;code>Big&lt;/code> 을 int 처럼 쓰려고 들면 type conversion error 를 만날 수 있다는 것이다.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>VSCodeVim: 분리된 줄 위/아래로 커서 이동하기</title><link>https://interp.blog/vim-wrapping-line-cursor-up-down/</link><pubDate>Fri, 15 Apr 2022 02:45:00 +0900</pubDate><guid>https://interp.blog/vim-wrapping-line-cursor-up-down/</guid><description>&lt;p>VSCode 에서도 Vim 환경을 쓰고 싶어서 &lt;a class="link" href="https://github.com/VSCodeVim/Vim" target="_blank" rel="noopener"
>VSCodeVim&lt;/a> 을 설치해서 쓰고 있다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/images/2022-04-15-vscodevim.png"
loading="lazy"
>&lt;/p>
&lt;p>그런데 위와 같이 markdown 편집을 할 때 처럼 줄 분리가 이뤄져서 (line wrapping) 사실 한 줄인데 여러 줄로 보여지는 경우에는, 커서를 아래로 내릴 경우에 &lt;em>실제&lt;/em> 다음 줄 로 이동한다. &lt;strong>화면에 보이는 줄이 아니라, 실제 줄로 이동하기 때문에&lt;/strong>, 커서를 옮길 때 여간 불편한 게 아니다.&lt;/p>
&lt;h2 id="해결-방법">해결 방법&lt;/h2>
&lt;p>Vim 도 사실 line wrapping 이 되었을 때 같은 문제가 있고, (문제라기 보다는 특성인데) 원하는 방법대로 우회할 수 있는 방법을 &lt;a class="link" href="https://vim.fandom.com/wiki/Move_cursor_by_display_lines_when_wrapping" target="_blank" rel="noopener"
>여기&lt;/a>서 찾았다. 이 방법을 그대로 VSCode 에도 적용한 것이다.&lt;/p>
&lt;p>먼저 Settings 를 열어서 &lt;strong>Vim: Normal Mode Key Bindings&lt;/strong> 로 이동하면, Edit in settings.json 링크가 있다. 이걸 눌러서 다음을 추가하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;vim.normalModeKeyBindings&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;Up&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;g&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;k&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;Down&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;g&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;j&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>적용하고 곧바로 편집 중인 파일로 돌아오면 적용이 되어 있는 걸 볼 수 있다. 이제 커서를 위/아래로 움직여도 화면에 보이는 윗줄/아랫줄로 이동한다!&lt;/p></description></item><item><title>K8s Operator vs. Controller</title><link>https://interp.blog/kubernetes-operator-vs-controller/</link><pubDate>Tue, 15 Mar 2022 02:44:57 +0000</pubDate><guid>https://interp.blog/kubernetes-operator-vs-controller/</guid><description>&lt;p>쿠버네티스에서 서비스를 개발하거나 운영하다 보면 자주 접하게 될 개념 중 하나가, 바로 이 Controller 와 Operator 일 것이다. 어떤 경우에는, 동일한 서비스를 두고 &amp;lsquo;이건 Controller 야&amp;rsquo; 라고 말 할 때도 있고 &amp;lsquo;이 Operator 는&amp;hellip;&amp;rsquo; 이라고 불릴 때도 있어서 헷갈릴 수 있다. 심지어 공식 문서에서도 두 개념에 대한 비교는 하지 않고 있어서 명확한 구분이 필요한 것 같다.&lt;/p>
&lt;p>와중에 &lt;a class="link" href="https://blog.marcnuri.com/kubernetes-operator-vs-controller" target="_blank" rel="noopener"
>이 문서&lt;/a>를 발견했는데, 요약하자면 이렇다.&lt;/p>
&lt;h1 id="controller">Controller&lt;/h1>
&lt;blockquote>
&lt;p>So in the Kubernetes world, a controller will basically &lt;strong>monitor and measure the cluster resources state to adjust those resources that diverge from the desired state&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>더 줄여보면, Controller 는 (1) K8s 리소스의 상태를 체크하고 (2) 이 리소스들의 상태를 &amp;lsquo;목표 상태 (desired state)&amp;rsquo; 로 조정하는 역할을 한다.&lt;/p>
&lt;p>&lt;code>ReplicaSet&lt;/code>, &lt;code>StatefulSet&lt;/code>, &lt;code>DaemonSet&lt;/code> 이 대표적인 Controller 들이다. 이 리소스에 속해 있는 Pod 들의 상태를 &amp;lsquo;목표 상태&amp;rsquo; 로 만들기 위해, Pod 을 추가하거나 삭제한다.&lt;/p>
&lt;h1 id="operator">Operator&lt;/h1>
&lt;p>CoreOS 에서 정의하는 Operator 는 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>An Operator is &lt;strong>a method of packaging, deploying and managing a Kubernetes application&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>그런데 이 개념을 구현하기 위해서는 필연적으로 Controller 가 들어가게 된다.&lt;/p>
&lt;p>그렇다면 Controller 와 비교했을 때 Operator 의 차이점은 무엇일까?&lt;/p>
&lt;h1 id="operator-vs-controller">Operator vs. Controller&lt;/h1>
&lt;p>여기에서 말하는 &amp;lsquo;&lt;em>Kubernetes application&lt;/em>&amp;rsquo; 란, 사용자가 직접 지정할 수 있는 CRD (Custom Resource Definition) 과 거기서 파생된 CR (Custom Resource) 까지 포함하고 있는 것이다.&lt;/p>
&lt;p>예를 들면, Orange 라는 CRD 를 하나 만들어 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apiextensions.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CustomResourceDefinition&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">oranges.example.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">group&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">example.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scope&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Namespaced&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">names&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">plural&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">oranges&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">singular&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">orange&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Orange&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">subresources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 정의 (definition)를 가지고, &lt;code>orange1&lt;/code> 이란 CR 을 하나 만들 수 있을 것이다.&lt;/p>
&lt;p>특정 Orange CR 이 만들어지거나 수정될 때, 삭제될 때엔 뭘 해야 하는지 정의하는 코드를 만들 수 있을 것이다. 예를 들면, Orange CR 에는 1개의 &lt;code>Service&lt;/code> 와 1개의 &lt;code>Pod&lt;/code> 이 만들어져야 한다고 해보자. 그걸 Golang 으로 아주 간단히 표현하면,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">h&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">orangeHandler&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Handle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span> &lt;span class="nx">reconcile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">reconcile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Get the Orange instance
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">orange&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">examplev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Orange&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sdk&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NamespacedName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">orange&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">IsNotFound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">reconcile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">reconcile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wrap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;failed to get Orange instance&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// Create the Pod for the Orange instance
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">orange&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;-pod&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">orange&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Labels&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="s">&amp;#34;app&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">orange&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">Spec&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSpec&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Containers&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sdk&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">reconcile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wrap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;failed to create Pod&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// Create the Service for the Orange instance
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">service&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Service&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">orange&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;-service&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">orange&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Labels&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="s">&amp;#34;app&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">orange&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">Spec&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ServiceSpec&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Selector&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="s">&amp;#34;app&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">orange&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">Ports&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ServicePort&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="nx">Type&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">corev1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ServiceTypeClusterIP&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sdk&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">service&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Error creating the Service
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">reconcile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wrap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;failed to create Service&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">reconcile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이처럼 내부에 구현된 Reconcile Loop Code (특정 CR이 수정되는 이벤트를 관찰하고, 이벤트에 맞춰 코드를 실행하는 루프) 는 일종의 Orange &lt;em>&lt;strong>Controller&lt;/strong>&lt;/em> 라고도 부를 수 있다. (또는 이 코드가 실행되는 pod 도 controller 라고 볼 수 있다)&lt;/p>
&lt;p>하지만 이렇게 Orange CR 을 &lt;em>관리&lt;/em>하는 application 자체를 가리킬 때, 또는 이렇게 관리하는 전체 패턴을 Orange CR 의 &lt;em>&lt;strong>Operator&lt;/strong>&lt;/em> 라고 부를 수 있다. 바꿔 말해서, 실재하는 K8s 리소스인 Service 와 Pod 을 만드는 역할은 Controller 에서 이뤄지지만, Orange CR 의 명세를 관리하는 전체 과정은 Operator 라고 부를 수 있다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h1 id="정리하면">정리하면&lt;/h1>
&lt;p>개인적으로 Controller 는 기술적인 개념이고, Operator 는 좀 더 포괄적이면서 논리적인 개념으로 받아들여진다. &lt;a class="link" href="https://blog.marcnuri.com/kubernetes-operator-vs-controller" target="_blank" rel="noopener"
>문서&lt;/a>에서도 &amp;lsquo;&lt;em>모든 Operator 는 CR 을 관리하기 위해 쓰이는 Controller 라고 부를 수 있다.&lt;/em>&amp;rsquo; 라고 하고 있으니까 말이다.&lt;/p>
&lt;p>그리고 Controller 나 Operator 모두 어떤 프레임워크일 뿐이지, 프로그래밍 언어에 국한된 것은 아니라고 언급한다. 나 역시 Go 언어와 Python 으로 모두 구현해 봤기 때문이다. 다만 용어를 사용할 때 좀 더 확실히 이해하고 쓴다면 헷갈릴 여지가 없기를 바란다.&lt;/p></description></item><item><title>카카오/네이버 메일 아이폰 연동</title><link>https://interp.blog/kakao-naver-email-iphone-connect/</link><pubDate>Fri, 04 Feb 2022 16:35:37 +0000</pubDate><guid>https://interp.blog/kakao-naver-email-iphone-connect/</guid><description>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/feature-image.jpg" alt="Featured image of post 카카오/네이버 메일 아이폰 연동" />&lt;div style="background-color: var(--pre-background-color); width: 95%; margin:2rem; padding: 20px; border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
🚧
&lt;/div>
&lt;div>
이미지 정렬이 필요합니다&amp;hellip;!
&lt;/div>
&lt;/div>
&lt;h2 id="요약">요약&lt;/h2>
&lt;ul>
&lt;li>원래는 홈페이지에서 하라는 대로 하면 된다.&lt;/li>
&lt;li>비밀번호를 잘 입력했는데 서버 접속이 안 된다면, 혹시 2단계 인증을 쓰고 있지는 않은지?&lt;/li>
&lt;li>2단계 인증을 쓰는 경우라면, &lt;strong>앱 비밀번호&lt;/strong>를 별도로 발급받는다.&lt;/li>
&lt;/ul>
&lt;h2 id="참고">참고&lt;/h2>
&lt;p>카카오 메일 뿐만 아니라 네이버 메일이나 네이버 캘린더 동기화도 비슷하다. 아래에 ‘부록’ 으로 달아뒀으니 참고하면 된다.&lt;/p>
&lt;h2 id="설정-방법">설정 방법&lt;/h2>
&lt;ol>
&lt;li>PC 에서 브라우저를 열고, 카카오 메일을 접속한다.
&lt;ul>
&lt;li>모바일 브라우저에서 카카오 메일을 접속하면 카카오톡으로 리다이렉트 되는데, 카카오톡에서는 해당 설정을 진행할 수 없다. 반드시 PC 로 접속한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>환경설정 &amp;gt; IMAP/POP3&lt;/strong> 을 클릭해서, IMAP 사용을 체크하고 저장한다.&lt;/li>
&lt;li>설정 앱으로 가서 ‘메일 &amp;gt; 계정’ 을 차례대로 누른다.&lt;/li>
&lt;/ol>
&lt;p>
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-1.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-2.jpeg" width="200px" style="display: inline;"/>
&lt;/p>
4. 그 다음 ‘계정 추가’ 를 누른 다음 ‘기타’ 를 선택한다. 이후에 'Mail 계정 추가' 를 선택한다.
&lt;p>
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-3.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-4.jpeg" width="200px" style="display: inline;" />
&lt;/p>
5. 기본 정보를 입력한다. 이메일과 암호는 쓰던 걸 쓰면 되고 이름이나 설명은 자유롭게 입력한다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/iphone-5.png" width="300px" />
6. IMAP 또는 POP 을 선택하는 탭이 있는데, 어느 것을 선택하던 상관없지만 IMAP 으로 진행한다.
&lt;br/> &lt;br/>
&lt;p>이제 안내된 대로 주소를 설정한다. &lt;a class="link" href="https://cs.kakao.com/helps?articleId=1073195244&amp;amp;service=156&amp;amp;category=519&amp;amp;device=&amp;amp;locale=ko" target="_blank" rel="noopener"
>공식 FAQ 문서&lt;/a>, 7번 항목)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">- 아이디 : 카카오메일 아이디 (ooooo@kakao.com 에서 앞 부분)
- 비밀번호 : 카카오 계정 비밀번호
- IMAP (받는서버) : imap.kakao.com:993 (SSL)
- SMTP (보내는서버) : smtp.kakao.com:465 (SSL)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>SSL 은 아마 처음 설정할 때 바로 시도할 것이다. 포트 번호는 당장 신경 쓰지 않아도 되는데, 나중에 계정 저장을 한 다음에 포트 세부설정이 가능한 곳이 있긴 하다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="비밀번호가-맞는데-되지-않아요">비밀번호가 맞는데 되지 않아요&lt;/h2>
&lt;p>혹시 2단계 인증을 쓰고 있지 않은지? 그렇다면 기존 비밀번호로는 인증을 할 수 없다. 사람이 로그인을 했다면 카카오톡에 들어가서 인증하기를 눌러줬겠지만, 이건 아이폰이니까.&lt;/p>
&lt;p>그래서 ‘앱 비밀번호’ 라는 걸 발급받아야 한다. PC 에서도 발급이 가능하지만, 어차피 아이폰에서 복사해서 바로 붙여넣을 예정이니, 모바일로 해 보자.&lt;/p>
&lt;ol>
&lt;li>이번에는 모바일 기기에서 ‘카카오톡’ 앱을 실행한다.&lt;/li>
&lt;li>‘&amp;hellip;’ 버튼을 누르고, 오른쪽 위에 있는 톱니바퀴를 누른다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-1.jpeg" width="300px" />&lt;/li>
&lt;li>개인/보안 → ‘카카오 계정’을 누르고, 나오는 화면에서 ‘2단계 인증’ 을 누른다.&lt;/li>
&lt;/ol>
&lt;p>
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-2.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-3.jpeg" width="200px" style="display: inline;"/>&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-4.jpeg" width="200px" style="display: inline;"/>
&lt;/p>
4. 비밀번호를 입력한 뒤, ‘앱 비밀번호’를 누른다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/kakao-5.jpeg" width="300px" />
5. 앱 이름을 원하는 대로 입력하고, ‘생성’ 을 누르면 앱 비밀번호가 뜬다. 앱 비밀번호는 다시 볼 수 없기 때문에, 복사해 두거나 메모해 둬야 한다. 비밀번호를 놓쳤다면, 삭제했다가 다시 만들면 되니까 걱정하지 말자.
&lt;br/> &lt;br/>
&lt;p>이 앱 비밀번호를, 원래 비밀번호 대신 입력하면 서버 접속이 가능하다.&lt;/p>
&lt;h2 id="네이버는-어디서">네이버는 어디서?&lt;/h2>
&lt;p>이번에도 모바일 환경에서 해 볼 것이다. 네이버 앱으로 해도 되고, 일반 브라우저 에서 해도 상관없다.&lt;/p>
&lt;ol>
&lt;li>네이버에 로그인 한다.&lt;/li>
&lt;li>오른쪽 위에 있는 프로필 아이콘을 누른 뒤, 다시 왼쪽 위에 있는 프로필 아이콘을 누른다.&lt;/li>
&lt;li>&amp;lsquo;내 정보 및 프로필 관리&amp;rsquo; 에 있는 본인 계정을 누른다.&lt;/li>
&lt;li>보안 설정 및 비밀번호 변경을 클릭한다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/naver-3.jpeg" width="300px" />&lt;/li>
&lt;li>2단계 인증 항목에서 관리하기를 클릭한다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/naver-4.jpeg" width="300px" />&lt;/li>
&lt;li>조금 스크롤을 내리면, 애플리케이션 비밀번호 관리 항목이 보인다.
&lt;img src="https://interp.blog/images/2022-02-04-kakao-email/naver-5.jpeg" width="300px" />
&lt;ul>
&lt;li>종류에서 아이폰을 선택해도 되지만, 카카오에서의 이름 설정에 지나지 않기 때문에, 아무거나 입력해도 된다.&lt;/li>
&lt;li>생성하기 버튼을 누르면 비밀번호가 보인다. 마찬가지로, 지금 복사하거나 메모해두지 않으면 나중에 다시 볼 수 있는 방법이 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>CKA 시험 후기</title><link>https://interp.blog/cka-exam-review/</link><pubDate>Tue, 18 Jan 2022 22:38:42 +0000</pubDate><guid>https://interp.blog/cka-exam-review/</guid><description>&lt;img src="https://interp.blog/images/featured/cka-exam.jpg" alt="Featured image of post CKA 시험 후기" />&lt;p>CKA (Certified K8s Administrator) 를 2021년 12월 말에 합격 통지를 받았다. 합격을 받고 나서 정리한 팁을 공유하고자 한다.&lt;/p>
&lt;h1 id="강의">강의&lt;/h1>
&lt;p>매우 유명한 Udemy 의 Mumshard 강의를 완강했다. 내가 너무 초보여서 그런지는 몰라도, 기초 강의도 기본을 다지고 한번 더 리마인드 하자는 차원에서 완강을 했고, 결론적으로는 시험 뿐만 아니라 업무에도 큰 도움이 되고 있다.&lt;/p>
&lt;ul>
&lt;li>이해가 쏙쏙 되는 강의&lt;/li>
&lt;li>지속적인 업데이트&lt;/li>
&lt;li>KodeCloud 를 통한 인터렉티브 연습 문제 (엄청 많다!)&lt;/li>
&lt;li>3개의 모의고사 (요점은 다 나온다)&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>유료 (이긴 한데 상시 할인이라 큰 부담은 없다. 등록하면 평생 수강이니, 할인율이 높을 때를 노려 구매해 두는 것을 추천.)&lt;/li>
&lt;li>영어 (수준이 높다기 보다는 그냥 귀찮다. 영어 자막은, 거의 자동 생성인 경우가 많기 때문에 별 도움이 안 된다.)&lt;/li>
&lt;/ul>
&lt;h2 id="시험-등록">시험 등록&lt;/h2>
&lt;p>보통 시험을 Linux Foundation 에서 볼 텐데, 그럼 아래와 같은 절차로 시험을 준비한다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Global Candidate Agreement&lt;/strong> 를 읽고 &amp;lsquo;동의&amp;rsquo; 를 누른다.&lt;/li>
&lt;li>&lt;strong>이름을 확인한다&lt;/strong>. 반드시 신분증에 있는 영어이름과 일치해야 한다. (여권이나 국제운전면허증 등등) 일치하지 않거나 하면 피곤해진다고 한다.&lt;/li>
&lt;li>&lt;strong>시험에 사용될 OS 를 지정한다&lt;/strong>. 보통 우분투를 사용한다.&lt;/li>
&lt;li>&lt;strong>시험 일정을 예약한다&lt;/strong>. 한번 시험 등록에 들어오면 시험 일정을 잡는데 유효기간이 있다. 그래서 가급적 스케줄을 확인하고 얼른 시험 일정을 예약해야 한다.&lt;/li>
&lt;li>시스템 환경을 체크할 수 있다.
&lt;ul>
&lt;li>&lt;strong>Chrome 확장 프로그램&lt;/strong> 을 반드시 설치하고 시험을 시작해야 한다.&lt;/li>
&lt;li>비인가된 프로그램을 사용하는지 감독관이 반드시 체크한다. 작업관리자를 &amp;lsquo;간단히&amp;rsquo; 버전으로 띄우도록 요청한다.&lt;/li>
&lt;li>책상은 컴퓨터/노트북 외엔 깨끗해야 하며 (외부 모니터는 된다고 하던데 나는 치웠다) 책상 아래도 깨끗해야 한다. 이걸 증명하기 위해 웹캠이 필요하다. 노트북 내장 웹캠도 가능하다 (내가 그랬으니까)&lt;/li>
&lt;li>방 안엔 누구도 있어선 안 되고, 밝고 조용한 환경이어야 한다. 단, 수험자 뒤에서 밝은 빛이 나오면 안 된다 (감독관 방해)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>다음 글을 읽어 본다&lt;/strong>. 만약 시간이 없으면 Important Instructions 만 읽어 보자.
&lt;ul>
&lt;li>&lt;a class="link" href="https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad" target="_blank" rel="noopener"
>Important Instructions: CKA, CKAD&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.linuxfoundation.org/tc-docs/certification/lf-candidate-handbook" target="_blank" rel="noopener"
>Handbook&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>시험 준비가 모두 끝났다고 생각되면, &lt;a class="link" href="http://killer.sh" target="_blank" rel="noopener"
>killer.sh&lt;/a> 에 들어가서 모의고사 세션을 시작해보자.&lt;/li>
&lt;/ol>
&lt;h2 id="killersh">killer.sh&lt;/h2>
&lt;p>Linux Foundation 에서 제공하는 마지막 모의고사 성격의 mock-up exam 환경이다.&lt;/p>
&lt;ul>
&lt;li>저기서도 경고하지만, 실제 시험보다 훨씬 까다롭고 광범위한 질문이 나온다. 좌절할 필요 없다.&lt;/li>
&lt;li>2개의 세션이 제공되는데, 한 개당 36시간의 유효기간이 있다. 2시간 타이머가 돌긴 하지만, 타이머가 끝난다고 시험이 닫히진 않는다. 심리적인 압박 용이니, 2시간 시간관리 한다 생각하고 신경 써가며 풀어보자.&lt;/li>
&lt;li>2개 세션 모두 같은 문제 세트를 가지고 있다. 하나는 시험 치듯 풀고, 끝나면 정답과 함께 채점을 해 주기 때문에 두 번째 세션은 오답노트 풀듯이 훓는 걸 추천한다.&lt;/li>
&lt;/ul>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h1 id="팁">팁&lt;/h1>
&lt;h2 id="시험-환경-준비">시험 환경 준비&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>감독관은 말 하지 않는다&lt;/strong>. 대신 채팅으로 말한다.
&lt;ul>
&lt;li>시험 전 20분부터 입장이 가능한데, 감독관이 준비되어야 사실 입장이 가능하다 (&amp;hellip;)&lt;/li>
&lt;li>감독관을 만나면 하는 일은, 신분증으로 신원 확인, 방 주위를 둘러보기, 책상 보기, 책상 아래보기.. 정도만 했다.&lt;/li>
&lt;li>시험 중간에는 웬만하면 어떤 채팅도 올라오지 않는다. 내가 본 건 딱 ‘15분 남았습니다’ 였다.&lt;/li>
&lt;li>(내가 겪어 본 건 아니지만) 만약 허용되지 않은 웹 사이트를 실수로라도 방문하면, 경고성 채팅창이 올라올 것이다. 그런데 같은 짓을 4번 (3번?) 더 하면 시험이 그냥 종료되니 주의.
(자세한 내용은 위 문서에서 인스트럭션을 읽어보면 된다)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>북마크 사용은 가능하다&lt;/strong>, 물론 허용된 사이트 안의 웹 페이지만이다.&lt;/li>
&lt;li>&lt;strong>크롬이나 엣지 브라우저로 문제가 생길 수 있다는 이야기가 있다.&lt;/strong> 그러면 감독관이 &lt;a class="link" href="https://vivaldi.com/" target="_blank" rel="noopener"
>&lt;strong>비발디 (Vivaldi)&lt;/strong>&lt;/a> 브라우저를 권한다고 한다.
&lt;ul>
&lt;li>문제는, 환경설정에 시간을 다 뺏기고 (준비에 시간을 주긴 할테지만 2 시간 스케쥴이 틀어진다) 준비해 간 북마크 호환하기 어려울 수 있으므로 당황할 여지가 생긴다.&lt;/li>
&lt;li>추천: &lt;strong>그냥 ‘Vivaldi’ 브라우저를 설치하고, 거기다 환경을 구성해 두자.&lt;/strong> (물론 크롬 확장 프로그램 미리 깔아두는 것 잊지 말고)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>영어 해석에 애를 먹는다면, Google 번역 크롬 확장 프로그램을 설치해서 써도 된다.
&lt;ul>
&lt;li>K8s Docs 의 한글 번역본을 읽어도 아무런 제지가 없다.&lt;/li>
&lt;li>문제 몇 개는 해석이 조금만 틀려도 산으로 가는 것들이 있다. (NetworkPolicy 를 생성할 때 라던지)&lt;/li>
&lt;li>하지만 번역기는 만능이 아니다. 참고용으로만 쓰는 걸 추천한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="시험칠-때">시험칠 때&lt;/h2>
&lt;ul>
&lt;li>클러스터 몇 개가 주어지고, 매 문제마다 처음에 context 를 바꾸라고 한다. &lt;strong>안 바꿔도 된다는 확신이 있어도 반드시 바꾸자&lt;/strong>. 안 바꾸면 정답이 엉뚱한 클러스터에 반영되고 채점도 안 된다.&lt;/li>
&lt;li>15-20 개의 문제가 주어진다고 하고, 각 문제마다 배점이 있다. 컷 라인은 66점이니 &lt;strong>쉬운 것을 먼저 푸는게 좋다&lt;/strong>.&lt;/li>
&lt;li>다른 합격 후기에서는, &lt;code>kubectl&lt;/code> 자동 완성을 위해 cheat sheet 를 적용하라고 하는데, 나는 이게 시험 환경에 이미 적용이 되어 있었다.
&lt;ul>
&lt;li>&lt;code>kubectl&lt;/code> = &lt;code>k&lt;/code>&lt;/li>
&lt;li>명령어 자동 완성 가능 (예) &lt;code>k des&amp;lt;tab&amp;gt;&lt;/code> → &lt;code>k describe&lt;/code>&lt;/li>
&lt;li>리소스 이름 자동 완성 가능 (예) &lt;code>interp&lt;/code> 라는 ns 가 있다고 하면, then &lt;code>k get pod -n int&amp;lt;tab&amp;gt;&lt;/code> → &lt;code>k get pod -n interp&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>리소스를 지우거나 업데이트 하기 전에, &lt;strong>반드시 그 리소스를 백업해 두자.&lt;/strong> 혹시 그 리소스를 원상복구 시킬 때가 있을 수 있는데, 백업 없이는 다른 방법이 없다.&lt;/li>
&lt;/ul>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="6929871144"
data-ad-format="auto"
data-full-width-responsive="true">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h2 id="공부할-때">공부할 때&lt;/h2>
&lt;ul>
&lt;li>오픈북 시험에서 가장 중요한 건, 어떤 문제를 마주쳤을 때 어디를 봐야 하는지 기억해 두는 것이다.
&lt;ul>
&lt;li>좀 더 구체적으로, 어떤 키워드로 K8s docs 를 검색해야 하는지를 기억하는 것이 중요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하지만 아래 키워드는 찾아보기도 전에 타이핑할 수 있도록 기억해두는 게 좋다.
&lt;ul>
&lt;li>Pod 을 생성할 때: &lt;code>k run {name} --image= ... --dry-run=client -o yaml&lt;/code> 로 YAML 파일을 얻어서 수정한 뒤 &lt;code>k apply -f {yaml_file}&lt;/code> 로 입력&lt;/li>
&lt;li>리소스를 생성할 때 (가능하다면):
&lt;ul>
&lt;li>&lt;code>k create&lt;/code> 명령어로 어떤 리소스를 만들 수 있는지 보고,&lt;/li>
&lt;li>&lt;code>k create {resource} --help&lt;/code> 로 해당 리소스를 만들 수 있는 다양한 예제를 확인한 뒤,&lt;/li>
&lt;li>역시 &lt;code>--dry-run=client -oyaml&lt;/code> 을 붙여 YAML 파일을 얻을 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Hugo SCSS Rebuild</title><link>https://interp.blog/hugo-scss-rebuild/</link><pubDate>Fri, 31 Jan 2020 00:35:23 +0900</pubDate><guid>https://interp.blog/hugo-scss-rebuild/</guid><description>&lt;p>Tale 테마로 블로그를 처음 시작하려고 보고 있는데, 여기서 SCSS 내용을 변경해도 &lt;code>hugo server -D&lt;/code> 를 하니까 변경 내용이 적용이 되지 않았다. &lt;a class="link" href="https://gohugo.io/hugo-pipes/scss-sass/" target="_blank" rel="noopener"
>여기선&lt;/a> 잘 된다고 나와 있는데, 어떻게 해결했는지 자세히 적어본다.&lt;/p>
&lt;ul>
&lt;li>자세히 보니 이미 컴파일이 완료된 CSS 파일이 &lt;code>resources/_gen/assets/scss/scss/&lt;/code> 에 존재하고 있었다.&lt;/li>
&lt;li>설마 이것 때문인가? 삭제를 하고 다시 &lt;code>hugo server -D&lt;/code> 를 해보면 다음 문구가 반겨준다.
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">Building sites … ERROR 2020/01/31 00:27:39 Transformation failed: TOCSS: failed to transform &amp;#34;scss/tale.scss&amp;#34; (text/x-scss): this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information
Built in 16 ms
Error: Error building site: logged 1 error(s)
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>그렇다, &lt;strong>extension version 이 아닌 일반 hugo 를 설치한 것이었다!&lt;/strong> &lt;a class="link" href="https://gohugo.io/getting-started/installing" target="_blank" rel="noopener"
>Install Hugo&lt;/a> 페이지에 다시 들어가 재설치하니 잘 되었다.&lt;/p></description></item><item><title>프로세서의 우선순위 값 : nice</title><link>https://interp.blog/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EA%B0%92-nice/</link><pubDate>Thu, 28 Nov 2019 01:53:59 +0000</pubDate><guid>https://interp.blog/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EA%B0%92-nice/</guid><description>&lt;p>&lt;a class="link" href="https://docs.datafabric.hpe.com/70/ReferenceGuide/node-metrics.html?hl=cpunice" target="_blank" rel="noopener"
>MapR (현재는 HPE Data Fabric) 의 Monitoring (Node) Metric&lt;/a> 문서를 보다가, &lt;code>CPUNICE&lt;/code> 라는 컬럼 이름에 다음과 같은 설명이 있다. &lt;em>Amount of CPU time used by processes with a positive nice value.&lt;/em> 오잉, 프로세스의 CPU 사용 시간인 것 까진 알겠는데, 양(positive) 의 좋은 값이라니?&lt;/p>
&lt;p>실은, nice value가 다음과 같은 뜻이라고 한다.&lt;/p>
&lt;blockquote>
&lt;p>Nice 값은 CPU의 스케줄링 우선순위를 의미합니다. 값의 범위는 +19 ~ -20으로, &lt;strong>숫자가 높을 수록 우선 순위는 낮습니다&lt;/strong>. &lt;code>man 2 getpriority&lt;/code> 를 참고하시면, 더 자세한 정보가 나와 있습니다. 프로세스를 실행할 때 &lt;code>nice&lt;/code> 명령어로 우선 순위를 부여할 수 있고, &lt;code>renice&lt;/code> 명령어로 우선 순위를 조정할 수 있습니다. 우선 순위를 높이기 위해선, 슈퍼 유저 권한이 (root) 필요합니다. (&lt;a class="link" href="http://serverfault.com/questions/116950/what-does-nice-mean-on-cpu-utilization-graphs" target="_blank" rel="noopener"
>출처&lt;/a>)&lt;/p>
&lt;/blockquote>
&lt;p>참고로, &lt;code>getpriority()&lt;/code> 는 프로세스의 현재 우선순위를 반환하는 인터페이스 이다. &lt;code>setpriority()&lt;/code> 역시 존재하는데, 이 함수를 실행할 때 값을 낮추려면 sudoer 권한이 있어야 한다고 한다.&lt;/p></description></item><item><title>Visual Studio Code Remote Deployment</title><link>https://interp.blog/visual-studio-code-remote-deployment/</link><pubDate>Wed, 26 Jun 2019 05:11:21 +0000</pubDate><guid>https://interp.blog/visual-studio-code-remote-deployment/</guid><description>&lt;p>Vim 과 SSH 에 찌들어 있었는데, 이번 Visual Studio Code 의 베타 기능인 Remote Deployment 를 연결해 보고 나서, 학생 때 쓰던 IDE 로 돌아간 것 같아 너무 좋았다. 언제까지고 구식 도구를 쓰며 부심을 부릴 수만은 없다. 설치 과정이 조금 험난했지만, 간단히 요약해서 써본다.&lt;/p>
&lt;p>클라이언트 OS 는 윈도우 10 (빌드 1809), 서버 OS 는 Cent OS 7 기준으로 작성한다.&lt;/p>
&lt;h2 id="클라이언트-윈도우-준비">클라이언트 (윈도우) 준비&lt;/h2>
&lt;p>처음에 준비할 때는 &lt;a class="link" href="https://code.visualstudio.com/insiders/" target="_blank" rel="noopener"
>Visual Studio Code Insider&lt;/a> 버전을 설치하라고 되어 있었는데, 이제는 꼭 그럴 필요 없는 것 같다. 일반 &lt;a class="link" href="https://code.visualstudio.com/Download" target="_blank" rel="noopener"
>Visual Studio Code&lt;/a> 를 설치해도 된다.&lt;/p>
&lt;p>다음으로, SSH 클라이언트를 설치한다. &lt;strong>윈도우 10 빌드 1807 이상 버전&lt;/strong>의 윈도우 OS 라면 &lt;a class="link" href="https://docs.microsoft.com/ko-kr/windows-server/administration/openssh/openssh_install_firstuse" target="_blank" rel="noopener"
>여기 링크&lt;/a> 안내를 따르거나, 아래 요약된 스크린샷을 보면 된다.&lt;/p>
&lt;p>시작 &amp;gt; 설정 앱에서, &amp;lsquo;앱&amp;rsquo; 을 클릭한 뒤 &amp;lsquo;앱 및 기능&amp;rsquo; 탭의 &amp;lsquo;선택적 기능 관리&amp;rsquo; 를 클릭한다. 그 다음 아래 &amp;lsquo;OpenSSH 클라이언트&amp;rsquo; 를 찾아 설치한다. OpenSSH 서버는 설치할 필요가 없다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/uploads/2019/06/img_5d11df55e7f29.png"
loading="lazy"
>
&lt;img src="https://interp.blog/uploads/2019/06/img_5d11df39e0722.png"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>만약에 여러분이 윈도우 10 빌드 1807 이하 버전의 윈도우 OS 라면… 조금 귀찮아진다. &lt;a class="link" href="%22https://code.visualstudio.com/docs/remote/troubleshooting#_installing-a-supported-ssh-client%22" >이 문서&lt;/a> 에 따르면, &lt;a class="link" href="%22https://git-scm.com/download/win%22" >Git for windows&lt;/a> 를 설치하면서 옵션에서 &lt;strong>Use Git and optional Unix tools from the Command Prompt &lt;/strong>를 선택하면 된다.&lt;br>
그러면, 같이 설치된 mingw 내부의 SSH 를 클라이언트로 사용한다고 한다. 물론 난 테스트해 보진 않았다! 권한 문제 등등으로 생각보다 꼬일 가능성이 있으므로, 조심해야 한다.&lt;/p>
&lt;/blockquote>
&lt;p>이제 ssh key 를 만들어야 한다. 비대칭 키에 대한 지식이 없다면 &lt;a class="link" href="https://arsviator.blogspot.com/2015/04/ssh-ssh-key.html" target="_blank" rel="noopener"
>암호 대신 SSH Key 로 인증하기&lt;/a> 포스팅을 참고하면 된다. 혹시 PuTTY 에서 생성한 비공개 키를 등록하고 쓰고 있으니 이걸로 충분하지 않을까? 그렇게 준비하면.. 실제 접속할 때 아마 잘 안 될 것이다.&lt;/p>
&lt;p>Visual Studio Code 는 OpenSSH (또는 Git 의 ssh) 클라이언트를 쓰기 때문에, Key 호환성 문제로 &amp;lsquo;invalid format&amp;rsquo; 에러를 발생시킬 수 있다. 그러니 순순히 (?) &lt;strong>실행 명령 창 (cmd) 을 열어서&lt;/strong> 다음을 입력하자. 기존에 쓰던 키 저장 경로가 존재한다면, 다른 경로로 설정하는 것을 추천한다. 이 방법은 &lt;a class="link" href="https://code.visualstudio.com/docs/remote/troubleshooting#_quick-start-ssh-key" target="_blank" rel="noopener"
>Visual Studio Code 페이지의 Troubleshooting&lt;/a> 에 등록된 내용이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">ssh-keygen -t rsa -b  &lt;span class="m">4096&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="서버-리눅스-준비">서버 (리눅스) 준비&lt;/h2>
&lt;p>원활한 서비스가 가능한 리눅스 OS 목록은 &lt;a class="link" href="https://code.visualstudio.com/docs/remote/linux" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하면 된다. Cent OS 7 은 잘 되므로 별 다른 설정 없이 가능하다. 지원이 안 되는 리눅스들은 workaround 가 있는데 (특시 Cent OS 6) 생각보다 까다롭고 원치 않는 상황이 발생할 수 있기 때문에 신중해야 한다.&lt;/p>
&lt;p>접속하고자 하는 계정의 &lt;code>~/.ssh/authorized_keys&lt;/code> 파일에다가, 아까 만들었던 Key Pair 중 &amp;lsquo;공개 키&amp;rsquo; 정보를 입력해야 한다. 해당 파일이 없으면 만들면 되고, 있으면 파일 끝에 추가 (append) 해주면 된다.&lt;/p>
&lt;p>&lt;code>~/.ssh/authorized_keys&lt;/code> 파일의 권한이 600 (계정에서만 읽기/쓰기가 가능) 인지 반드시 체크하고, 아니라면 &lt;code>chmod&lt;/code> 명령으로 바꿔주도록 한다. (이건 SSH 일반 접속 때문에 하는 작업이지, Visual Studio Code 라서 하는 것이 아니다.)&lt;/p>
&lt;h2 id="visual-studio-code-준비">Visual Studio Code 준비&lt;/h2>
&lt;p>우여곡절 끝에 준비를 다 했으면, Visual Studio Code 를 열어서 &lt;a class="link" href="https://aka.ms/vscode-remote/download/extension" target="_blank" rel="noopener"
>Remote Deployment&lt;/a> 를 설치하자. 그 다음, 명령 팔레트를 열어서 (Shift + Ctrl + P) &lt;strong>Remote-SSH: Open Configuration File…&lt;/strong> 을 선택한다. 설정 파일 경로는 수정하거나 기존에 잡아주는 경로를 쓰건 상관없다.&lt;/p>
&lt;p id="KhDFgvb">
&lt;img class="alignnone size-full wp-image-1524 " src="https://interp.blog/uploads/2019/06/img_5d12fc88e148b.png" alt="" srcset="https://interp.blog/uploads/2019/06/img_5d12fc88e148b.png 622w, https://interp.blog/uploads/2019/06/img_5d12fc88e148b-300x45.png 300w" sizes="(max-width: 622px) 100vw, 622px" />
&lt;/p>
&lt;p>예시는 이렇다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Host 192.168.0.10
HostName 192.168.0.10
User interp
IdentityFile &amp;#34;C:\Users\interp\ssh_key\id_rsa&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Host : 목록에 나올 이름이다. 보통은 HostName 과 같이 지정해주거나 Username@HostName 으로 지정한다.&lt;/li>
&lt;li>HostName : 실제 접속할 호스트 주소&lt;/li>
&lt;li>User : 접속할 사용자 계정 이름&lt;/li>
&lt;li>IdentifyFile : 생성한 Key Pair 중 &amp;lsquo;비공개 키&amp;rsquo; 경로&lt;/li>
&lt;/ul>
&lt;h2 id="remote-로-접속">Remote 로 접속!&lt;/h2>
&lt;p>이제 설정 파일을 저장하고, 명령 팔레트를 열어서 (Shift + Ctrl + P) &lt;strong>Remote-SSH: Connect to Host…&lt;/strong> 을 선택한다. 아까 저장한 Host 가 1개만 떠 있을텐데, 접속하면 아예 새로운 Visual Studio Code 창이 하나 더 뜨게 된다.&lt;/p>
&lt;p>이것저것 하는 것 같으니 잠시 기다리면, 접속이 되었다는 메시지와 함께 &amp;lsquo;절대로 저 작은 터미널을 닫지 말아주세요&amp;rsquo; 라는 경고문이 뜬다. 최소화시키고 작업을 하면 된다!&lt;/p></description></item><item><title>공측도와 무리수</title><link>https://interp.blog/%EA%B3%B5%EC%B8%A1%EB%8F%84%EC%99%80-%EB%AC%B4%EB%A6%AC%EC%88%98/</link><pubDate>Sat, 27 Apr 2019 11:32:38 +0000</pubDate><guid>https://interp.blog/%EA%B3%B5%EC%B8%A1%EB%8F%84%EC%99%80-%EB%AC%B4%EB%A6%AC%EC%88%98/</guid><description>&lt;p>&amp;lsquo;알고리즘 산책&amp;rsquo; 책 요약이다. 공측도라는 개념이나, 귀류법을 사용한 증명 등의 내용을 까먹지 않으려고 정리한다. 물론 이미 다 어릴 적 배웠겠지만, 다시 공부한다는 마음으로 정리하는 것이다.&lt;/p>
&lt;p>최대공측도는 최대공약수 같은 개념이다. 선분 A와 B가 특정한 길이로 측정이 가능할 때, 이 길이 중 가장 긴 길이를 최대공측도라고 하는 것이다. 이 값을 코딩으로 구하려면, 최대공약수를 계산하는 방법과 다르지 않을 것이다. (여기서 공측도 값이 되는 선분 길이는 자연수여야 한다.)&lt;/p>
&lt;p>그런데 19세기 조지 크리스털이 증명한 것은, 정사각형의 변과 대각선의 변을 동시에 측정할 수 있는 선분은 &lt;strong>없다&lt;/strong>는 것이다. 왜일까? (다시 말하지만 공측도는 자연수이다.)&lt;/p>
&lt;p>귀류법을 통해, 정사각형의 변과 대각선의 변을 동시에 측정할 수 있는 선분이 있다고 가정해보자. 요약하자면, 이 선분으로 정사각형을 그리고, 또 그 정사각형에서 한 변과 대각선을 측정할 수 있는 선분 (공측도) 이 있고, 계속 이런 식으로 정사각형을 그려나가다 보면, 어느 순간 &lt;span style="text-decoration: underline;">가장 작은 정사각형&lt;/span>이 나올 것이다. 하지만 가정에 따르면, 이 경우에도 대각선과 공측도가 되는 선분이 존재할 수 있게 된다. 그렇다면 더 작은 정사각형을 그릴 수 있게 되므로 모순이 생긴다.&lt;/p>
&lt;p>그래서 대각선은 자연수가 아니라는 단서가 되었고, 이로 인해 무리수 $\sqrt{2}$ 를 발견할 수 있게 되었다고 한다.&lt;/p></description></item><item><title>Windows SSH RSA Key 문제 해결</title><link>https://interp.blog/windows-ssh-rsa-key-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/</link><pubDate>Mon, 18 Mar 2019 04:50:30 +0000</pubDate><guid>https://interp.blog/windows-ssh-rsa-key-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/</guid><description>&lt;img src="https://interp.blog/images/featured/ssh-rsa.jpg" alt="Featured image of post Windows SSH RSA Key 문제 해결" />&lt;p>Windows Server 2016에서 OpenSSH 를 설치하고, cmd 에서 다음과 같이 RSA 키를 생성한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ ssh-keygen -t rsa
&lt;/code>&lt;/pre>&lt;/div>&lt;p>그러고 Public Key 를 SSH Server 에 위치한 authorized_keys 파일에 추가하고 접속을 시도하면?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: UNPROTECTED PRIVATE KEY FILE! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Permissions &lt;span class="k">for&lt;/span> &lt;span class="s1">&amp;#39;C:\\Users\\interp/.ssh/id_rsa&amp;#39;&lt;/span> are too open.
It is required that your private key files are NOT accessible by others.
This private key will be ignored.
Load key &lt;span class="s2">&amp;#34;C:\\Users\\interp/.ssh/id_rsa&amp;#34;&lt;/span>: bad permissions
interp@192.168.0.30&lt;span class="err">&amp;#39;&lt;/span>s password:
&lt;/code>&lt;/pre>&lt;/div>&lt;p>오잉? 내 파일이 맞는데 이게 뭘까. Private Key 파일에 마우스 우클릭을 하고 봤더니 여러 사용자가 읽기 권한으로 걸려 있는 것을 확인할 수 있었다. 이건 아니다… 등록된 사용자를 전부 지우고 현재 사용자에게 모든 권한을 준 다음에, 확인을 눌러 권한 변경을 해 준다.&lt;/p>
&lt;p id="euLmFtS">
&lt;img class="alignnone size-full wp-image-1518 " src="https://interp.blog/uploads/2019/06/img_5d11dcea1b41a.png" alt="" srcset="https://interp.blog/uploads/2019/06/img_5d11dcea1b41a.png 421w, https://interp.blog/uploads/2019/06/img_5d11dcea1b41a-218x300.png 218w" sizes="(max-width: 421px) 100vw, 421px" />
&lt;/p>
&lt;p>&amp;lsquo;편집&amp;rsquo; 에 가서 등록된 사용자를 지우려고 하면, 상속으로 인해 지울 수 없다는 괴상한 에러가 뜰 것이다. 그러니까 위 화면에서 &amp;lsquo;고급&amp;rsquo; 으로 간 다음, 아래 캡처에 있는 &amp;lsquo;상속 사용 안 함&amp;rsquo; 을 클릭하면 자동으로 지워진다. 그 다음 시도하면, 잘 된다!&lt;/p>
&lt;p id="bzFxOJb">
&lt;img class="alignnone size-full wp-image-1519 " src="https://interp.blog/uploads/2019/06/img_5d11dd707fe99.png" alt="" srcset="https://interp.blog/uploads/2019/06/img_5d11dd707fe99.png 293w, https://interp.blog/uploads/2019/06/img_5d11dd707fe99-216x300.png 216w" sizes="(max-width: 293px) 100vw, 293px" />
&lt;/p>
&lt;p>출처 : https://superuser.com/questions/1296024/windows-ssh-permissions-for-private-key-are-too-open&lt;/p></description></item><item><title>Gitlab merge request 옵션 기본으로 두기</title><link>https://interp.blog/set-gitlab-merge-request-checked/</link><pubDate>Tue, 13 Nov 2018 05:03:22 +0000</pubDate><guid>https://interp.blog/set-gitlab-merge-request-checked/</guid><description>&lt;p>Gitlab Community 에서 필요로 하는 기능인데, 이렇게 수동으로 할 수 있어서 간단히 남긴다. Gitlab 에 있는 merge request 에 보면 다음 옵션이 있는데, 전부 체크가 해제되어 있다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/uploads/2018/11/%ec%a0%9c%eb%aa%a9-%ec%97%86%ec%9d%8c.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>Merge Request 에 성공한 Source Branch 를 삭제&lt;/li>
&lt;li>Merge Request 할 때 Commit 을 하나로 뭉쳐서 Merge (=Squash Merge)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>이 체크박스를 개발자가 일일해 해 줘야 하는 문제&lt;/strong>가 있다. 그래서 어떤 개발자는 체크하는 것을 까먹었다가 master branch 의 commit tree 를 엉망으로 만들기도 한다. 이 문제를 그냥 없애기 위해, 체크박스 표시를 그대로 두도록 하면 어떨까 고민하던 차에, 해결방법을 알아냈다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>/opt/gitlab/embedded/service/gitlab-rails/app/views/shared/issuable/form/_merge_params.html.haml&lt;/code> 을 편집기로 연다.&lt;/li>
&lt;li>&lt;code>check_box_tag&lt;/code> 항목으로 시작하는 줄이 &lt;span style="text-decoration: underline;">두 군데&lt;/span> 있는데, 아래와 같이 다음 내용을 &amp;lsquo;추가&amp;rsquo; 한다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">= check_box_tag &amp;#39;merge_request[force_remove_source_branch]&amp;#39;, &amp;#39;1&amp;#39;, issuable.force_remove_source_branch?, class: &amp;#39;form-check-input&amp;#39;&amp;lt;span style=&amp;#34;color: #ff0000;&amp;#34;&amp;gt;, checked: &amp;#39;checked&amp;#39;&amp;lt;/span&amp;gt;
&amp;lt;span style=&amp;#34;color: #0000ff;&amp;#34;&amp;gt;# ... blahblah&amp;lt;/span&amp;gt;
= check_box_tag &amp;#39;merge_request[squash]&amp;#39;, &amp;#39;1&amp;#39;, issuable.squash, class: &amp;#39;form-check-input&amp;#39;&amp;lt;span style=&amp;#34;color: #ff0000;&amp;#34;&amp;gt;, checked: &amp;#39;checked&amp;#39;&amp;lt;/span&amp;gt;```
&lt;/code>&lt;/pre>&lt;/div>&lt;p>다 했다면 &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 로 Gitlab 서버를 재시작한다.&lt;/p></description></item><item><title>Powerpoint 에서 방향키 이동이 너무 느릴 때</title><link>https://interp.blog/powerpoint-shape-move-faster/</link><pubDate>Sun, 12 Aug 2018 06:53:39 +0000</pubDate><guid>https://interp.blog/powerpoint-shape-move-faster/</guid><description>&lt;p>객체를 움직일 때 방향키로 이동하면, 예전에는 한 칸씩 움직이는 것 처럼 느껴졌는데 최근에 들어서는 정말 1픽셀 만큼만 이동해서 귀찮음을 유발하곤 한다. 이렇게 답답하게 움직이는 걸 되돌리기 위한 해결 방법이다. 별 건 없지만&amp;hellip;&lt;/p>
&lt;figure class="align-center ">
&lt;img loading="lazy" src="https://interp.blog/images/2018-02-12-powerpoint-shape-move-faster/screen1.jpg#center"/>
&lt;/figure>
&lt;ol>
&lt;li>보기 탭으로&lt;/li>
&lt;li>표시 항목에서 &amp;lsquo;확장 아이콘&amp;rsquo;이 아주 작게 보인다.&lt;/li>
&lt;li>&amp;lsquo;눈금 및 안내선&amp;rsquo; 이란 제목의 창이 뜨며, 여기서 &amp;lsquo;개체를 눈금에 맞춰 이동&amp;rsquo; 을 클릭한다.&lt;/li>
&lt;/ol>
&lt;p>끝이다. 참고로 개체 이동 간격을 제어하려면 (3) 번에서 눈금 간격을 조정하면 된다!&lt;/p></description></item><item><title>Atomic Operation 으로 하는 동시성 제어</title><link>https://interp.blog/atomic-operation-%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/</link><pubDate>Tue, 24 Apr 2018 02:31:38 +0000</pubDate><guid>https://interp.blog/atomic-operation-%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/</guid><description>&lt;h2 id="test-and-set-tas">Test-And-Set (TAS)&lt;/h2>
&lt;p>TAS 를 이용해서 간단한 동시성 제어를 할 수 있다. testAndSet 이라는 function 을 가지고 아래의 &lt;code>do...while&lt;/code> 문을 쓰레드 A, B 에서 동시에 호출한다고 해 보자. 이 때 lock 은 같은 변수이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">function&lt;/span> &lt;span class="nf">TestAndSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">boolean_ref&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">boolean&lt;/span> &lt;span class="n">initial&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">lock&lt;/span>
&lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">initial&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TestAndSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">amp&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">;&lt;/span> &lt;span class="c1">// do nothing
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// critical section
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// remainder section
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>우선 TestAndSet() 은 다음과 같은 일을 한다. 말 그대로 &amp;lsquo;지금 값이 무엇인지 검사하고, 값을 바꾼다&amp;rsquo; 는 것이다.&lt;/p>
&lt;ol>
&lt;li>lock의 현재 값을 저장해 둔다.&lt;/li>
&lt;li>lock의 값을 true 로 설정한다.&lt;/li>
&lt;li>저장한 lock 의 값을 반환한다.&lt;/li>
&lt;/ol>
&lt;p>그럼 이걸로 어떻게 아래 block 의 critical section 에 대한 동시성 제어를 할 수 있을까? Thread A 가 먼저 실행했다고 가정하면, 이런 시나리오가 된다.&lt;/p>
&lt;ol>
&lt;li>A : TestAndSet() 의 반환값이 false 이다. while 문을 빠져나온다.&lt;/li>
&lt;li>B : TestAndSet() 의 반환값이 true 이다. (A가 true로 두고 나왔기 때문에) while 문에서 계속 돈다.&lt;/li>
&lt;li>A : Critical Section 수행 후, lock 을 false 로 바꾼다.&lt;/li>
&lt;li>B : 여러 번의 TestAndSet() 호출 후에, 드디어 반환값이 false 가 되었다&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>(A가 false 로 두고 나왔기 때문에) while 문을 빠져나온다.
&lt;/code>&lt;/pre>
&lt;p>자, 그런데 뭔가 이상하다. 이렇게 이상적으로 동작하지 않을 것 같다. TestAndSet() 함수를 라인별로 동시에 실행한다고 하면 이런 사단이 날 수 있다.&lt;/p>
&lt;ol>
&lt;li>A : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다.&lt;/li>
&lt;li>B : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다.&lt;/li>
&lt;li>A : TestAndSet() 에서 lock 값을 true 로 바꾼다.&lt;/li>
&lt;li>B : TestAndSet() 에서 lock 값을 true 로 바꾼다.&lt;/li>
&lt;li>A : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다.&lt;/li>
&lt;li>B : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다.&lt;/li>
&lt;li>A &amp;amp; B : 모두 동시에 critical section 을 수행한다.&lt;/li>
&lt;/ol>
&lt;p>그럼 어떡하나? TestAndSet() 은 그래서 저런 함수만으로는 안 되고 Test-And-Set 의 연산이 일관되도록 조정해야 한다. 함수 안에 spinlock 을 쓰면 되겠네요? 싶겠지만 lock 구현하자고 lock 을 또 만드는 건 아닌 것 같다. 그래서 Test-And-Set 은 CPU에서 지원하는 Atomic Instruction 을 사용한다.&lt;/p>
&lt;h2 id="fetch-and-add--ticket-lock">Fetch-And-Add : Ticket Lock&lt;/h2>
&lt;p>Atomic Operation 으로 구현할 수 있는 Lock 중에 Ticket Lock 이 있는데, Fetch-And-Add 로 구현할 수 있는 방법을 알아보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">ticketLock_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next_ticket&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next_ticket&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">ticketLock_acquire&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next_ticket&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">my_ticket&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fetch_and_inc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">next_ticket&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">my_ticket&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">ticketLock_release&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">now_serving&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">now_serving&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>TAS 의 케이스를 이해하고 본다면 별 다른 설명이 필요 없을 것 같다.&lt;/p>
&lt;ol>
&lt;li>Table Lock 초기화를 한다.&lt;/li>
&lt;li>A : Table Lock 을 얻으려 한다. 이미 얻었던 &lt;code>my_ticket (0)&lt;/code> 과 &lt;code>now_serving (0)&lt;/code> 이 같은 값이므로 곧바로 빠져나온다.&lt;/li>
&lt;li>B : Table Lock 을 얻으려 한다. 이미 얻었던 &lt;code>my_ticket (1)&lt;/code> 과 &lt;code>now_serving (0)&lt;/code> 이 다른 값이므로 while 문에서 대기한다.&lt;/li>
&lt;li>C : Table Lock 을 얻으려 한다. 이미 얻었던 &lt;code>my_ticket (2)&lt;/code> 과 &lt;code>now_serving (0)&lt;/code> 이 다른 값이므로 while 문에서 대기한다.&lt;/li>
&lt;li>A : Table Lock 을 해제한다. &lt;code>now_serving (0)&lt;/code> 을 증가시켜 &lt;code>now_serving (1)&lt;/code> 을 만든다.&lt;/li>
&lt;li>B : 비로소 Table Lock 을 얻었다. (C는 여전히 대기 중이다.)&lt;/li>
&lt;/ol>
&lt;p>여기서 핵심은 &lt;code>fetch_and_inc&lt;/code> 인데, 마찬가지로 얻어오는 루틴과 값을 증가시키는 루틴이 따로 떨어져 있으면 중복된 티켓을 들고 기다리는 쓰레드들이 발생할 수 있다. 따라서 이것도 atomic operation 이 되어야 한다.&lt;/p></description></item><item><title>Timsort</title><link>https://interp.blog/timsort/</link><pubDate>Mon, 23 Apr 2018 01:36:57 +0000</pubDate><guid>https://interp.blog/timsort/</guid><description>&lt;p>알고리즘 강의를 들었다면, &lt;strong>가장 빠른 정렬 알고리즘이 뭐냐&lt;/strong>는 질문에 곧장 &lt;a class="link" href="https://www.toptal.com/developers/sorting-algorithms/quick-sort" target="_blank" rel="noopener"
>Quicksort&lt;/a> 라고 답할 수 있을 것이다. 실제로 현업에서도 적용하기 가장 편하기 때문에 많이 차용되는 편이다. 그런데 모든 문제를 쉽게 풀 수 있는 은탄은 세상에 존재하지 않듯, Quicksort 역시 특정 케이스에서는 성능이 낮게 나오는 경우가 있다. 더 심각한(?) 것은, 이 특정 케이스가 현실에서는 꽤나 자주 발생한다는 것이다.&lt;/p>
&lt;p>그 케이스란 바로 &amp;lsquo;거의 정렬된 데이터&amp;rsquo; 이다. 거의 정렬된 데이터라면 pivoting – partitioning 을 반복할 필요도 없이 Bubble Sort 나, 심지어는 Insertion Sort 를 해도 된다. &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC" target="_blank" rel="noopener"
>Bubble Sort&lt;/a> 의 경우엔 알고리즘 복잡도가 n&lt;sup>2 &lt;/sup>이지만 compare 과정에서 조기에 끝날 가능성이 매우 높아 비용이 거의 발생하지 않을 것이고, Insertion Sort 도 비슷한 이유로 빠르게 끝날 것이다. 하지만 모든 정렬 케이스가 거의 정렬된 데이터만 있지 않기 때문에 쓰지 않는 것일 뿐이다.&lt;/p>
&lt;p>만약에 데이터 순열이 &amp;lsquo;**거의 정렬된 데이터의 N 벌&amp;rsquo;**이라고 하자. &lt;span style="color: #3366ff;">1, 2, 3, …, 10&lt;/span>, &lt;span style="color: #800000;">2, 3, 4, …, 20&lt;/span> 이런 식으로 말이다. (여기서는 2벌) 그림을 그리자면 산이 N 개 생긴 것 처럼 보일 것이다. 이런 경우에는 Bubble Sort 가 큰 힘을 쓰지 못한다. 특정 원소가 산의 제 위치에 찾아가야 하는데, 조기에 끝났던 아까의 경우와는 달리 재수가 없다면 거의 모든 원소 개수와 비교해 봐야 하기 때문이다. 이럴 경우 역시 특효약이 있는데, 산마다 Mergesort 를 하면 쉽다.&lt;/p>
&lt;p>오늘 이야기할 &lt;a class="link" href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener"
>Timsort&lt;/a> 는 Mergesort 의 변형이라고 보면 된다. 아까 &amp;lsquo;산마다 Mergesort&amp;rsquo; 를 한다고 했는데, 어느 지점부터 산으로 봐야할지를 판단하는 알고리즘이 선행된다. 그리고 Mergesort 도 단순히 1개씩 건너뛰는 방법에서 좀 더 나은 방법을 제시한다.&lt;/p>
&lt;p>결론부터 말하자면 Timsort 는 무작위 데이터에서 Quicksort 보다 뒤쳐진다. 프로젝트할 때 적용해 본 결과로는 30~50% 정도 느렸다. 하지만 말했다시피, 현실 데이터는 어느 정도 정렬된 데이터의 덩어리를 가지고 있는 경우가 매우 많기 때문에, 그 부분에서는 확실한 성능 차이를 보였다.&lt;/p>
&lt;p>자, 이제 한 번 알아보자.&lt;/p>
&lt;h2 id="1단계--run">1단계 : Run&lt;/h2>
&lt;p>데이터 순열에서 &lt;strong>&lt;span style="color: #0000ff;">이미 정렬이 끝난 부분 데이터들을 Run&lt;/span>&lt;/strong> 이라고 한다. 1, 2, 1, 2, 3, 1, … 같이 주어졌을 때, 1, 2 와 1, 2, 3 을 Run 으로 인식하는 것이다. Timsort 에서는, 데이터 순열을 이런 Run 들로 찾거나 만들어서 확보하는 과정을 거친다. 이게 1단계이다.&lt;/p>
&lt;p>Timsort 는 &lt;span style="text-decoration: underline;">Run 이 너무 짧으면 나중에 의미가 없으므로, 최소 길이를 정해서 Run 을 만들도록 한다&lt;/span>. 보통은 길이가 16인 Run 부터 의미있게 쓰길래, 나도 똑같이 16으로 조건을 설정했다.&lt;/p>
&lt;p>Run 은 데이터 처음부터 정렬되어 있는 위치까지를 찾는다. 이 길이가 16 미만이라면, 해당 범위는 기억해 두고 다음 Run 을 찾는다. 이렇게 길이가 16 이상의 Run 을 만들 수 있는데, 이 때 쓰는 알고리즘은 사실 아무거나 가져다 써도 된다. 길이가 짧을 때의 정렬 알고리즘은 어느 것을 쓰나 대동소이하기 때문에, 나는 &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC" target="_blank" rel="noopener"
>Insertion Sort&lt;/a>를 썼다.&lt;/p>
&lt;h2 id="2단계--merge">2단계 : Merge&lt;/h2>
&lt;p>1단계 이후로는, 이제 데이터 순열에 Run 여러개가 연속되어 있다. 만약 Run 이 1개뿐이라면? 축하한다. 아주 작은 원소 개수를 정렬하려 했거나, 이미 정렬된 데이터를 넣었단 것이니 이번 단계를 하지 않아도 된다.&lt;/p>
&lt;p>앞의 두 Run 을 불러서 Mergesort 하면 되는데, 여기서 Timsort 만의 트릭이 두 개 존재한다.&lt;/p>
&lt;p>하나는, Merge 에 참여할 두 Run 의 최소값/최대값을 서로 비교해서, &lt;span style="text-decoration: underline;">아예 이긴 구간이나 아예 진 구간을 미리 산정해 두는 것&lt;/span>이다. 이 부분은 사실상 Mergesort 과정에서 비교 대상이 될 필요가 없다. 괜한 compare 연산만 낭비하지 말고 처음에 (혹은 나중에) 순순히 들어와주기만 하면 된다. 이 전처리 과정이 끝나면, 남아있는 Run 끼리 Merge 과정을 거친다.&lt;/p>
&lt;p>두 번째는, Merge 과정에서 만약 한 쪽이 계속 이기는 상황 (오름차순 정렬이라고 가정했을 때, 한 쪽의 Run 이 계속 작은 원소를 가지고 있을 때) 라면 더 이상의 비교는 무의미하다. &lt;span style="text-decoration: underline;">이런 연속 위닝 회수를 정해서, 이후에는 &amp;lsquo;어디까지 이기는지 binary search 로 찾아서 한 번에 그냥 옮기자&amp;rsquo; 라는 건너뛰기 모드 (galloping mode) 로 전환된다.&lt;/span> 코드를 참조했을 땐, 이 위닝 회수는 3이었다. &lt;span style="color: #999999;">&lt;del>스윕승?&lt;/del>&lt;/span>&lt;/p>
&lt;p>건너뛰기 모드 (galloping mode) 에서는, 지고 있던 Run 의 첫 번째 원소가 이기고 있던 Run 의 어느 원소에서 비로소 이기는지를 찾는 것이다. 처음엔 한 칸, 다음엔 두 칸, 그 다음엔 네 칸씩 뛰며 이길 때 까지 찾는다. 그러다가 찾았다면, 직전 구간 사이를 Binary Search 를 통해 최초로 이긴 위치를 찾아내면 된다.&lt;/p>
&lt;p>그 다음은? 이기고 있던 Run 의 처음부터 발견된 위치 직전까지를 통째로 &lt;code>memcpy&lt;/code> 하면 된다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>이걸 구현할 때는 급한 나머지 그냥 구현했었는데, (물론 어딘가에선 하고 있겠지만) Mergesort 자체가 병렬 구현이 가능하므로 Timsort 역시 병렬 구현이 가능하리라 본다. Run 을 만드는 작업은 병렬로 할 수 있을까 고민이 되지만, Merge 과정은 작업 큐만으로도 쉽게 그려낼 수 있다.&lt;/p>
&lt;p>역시 이것도 만병통치약이 될 수 없다. 상황에 맞춰 적절히 섞어써야 한다. 이런 정렬 알고리즘도 있구나 하며 배웠던 소중한 기회로 여기고 있다.&lt;/p></description></item><item><title>gdb commands 이용하기</title><link>https://interp.blog/gdb-commands-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/</link><pubDate>Tue, 06 Feb 2018 08:46:05 +0000</pubDate><guid>https://interp.blog/gdb-commands-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/</guid><description>&lt;p>gdb/ddd 에서 commands 를 사용하면 간편하게 breakpoint 의 상태를 출력할 수 있다. 물론 다양하게 응용이 가능하겠지만, 매뉴얼에서 제시한 케이스가 굉장히 편해서 따로 정리한다.&lt;/p>
&lt;p>참고 : &lt;a class="link" href="http://sourceware.org/gdb/onlinedocs/gdb/Break-Commands.html" target="_blank" rel="noopener"
>http://sourceware.org/gdb/onlinedocs/gdb/Break-Commands.html&lt;/a>&lt;/p>
&lt;h2 id="breakpoint-상황을-출력하기">Breakpoint 상황을 출력하기&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="mi">10&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sAddr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">aSize&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="mi">11&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">sAddr&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">12&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드에서 if 문에 breakpoint 를 걸고, 할당받은 시작 주소와 그 크기를 보고자 한다. 한두번 발생하는 거라면 breakpoint 를 걸어 둔 다음 print 나 graph display (ddd 전용) 으로 띄워서 관찰하면 된다. 그런데 이게 100번 200번이면 하염없이 엔터를 치게 된다.&lt;/p>
&lt;p>이럴 때 다음과 같이 입력한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> b &lt;span class="m">10&lt;/span> &lt;span class="c1"># 10번째 라인에 breakpoint&lt;/span>
&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> commands &lt;span class="c1"># 아무 것도 입력하지 않으면 최근 breakpoint 에 대한 command 입력&lt;/span>
&amp;gt; silent &lt;span class="c1"># breakpoint 에 멈췄단 메시지를 출력하지 말아달라&lt;/span>
&amp;gt; &lt;span class="nb">printf&lt;/span> &lt;span class="s2">&amp;#34;alloc address is %p\n and its size is %ld&amp;#34;&lt;/span>, *sAddr, aSize
&amp;gt; cont &lt;span class="c1"># 흔히 입력하는 cont 와 동일하다.&lt;/span>
&amp;gt; end &lt;span class="c1"># command 입력 종료&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이러고 cont 를 날리면.. breakpoint 에서 멈추는 대신 해당 command 가 수행된다! 즉, 계속해서 주소와 할당 크기가 출력된다. 아주 편하다…&lt;/p>
&lt;h2 id="call-stack-보기">Call Stack 보기&lt;/h2>
&lt;p>일종의 응용인데, commands 내부에는 우리가 흔히 쓰는 명령어를 입력하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> commands
&amp;gt; silent
&amp;gt; bt &lt;span class="m">5&lt;/span> &lt;span class="c1"># backtrace (callstack) 을 출력하되, 안쪽에서 5개 까지만 출력&lt;/span>
&amp;gt; cont
&amp;gt; end
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="commands-의-초기화">Commands 의 초기화&lt;/h2>
&lt;p>commands 명령어를 입력한 다음, 바로 end 로 끝내면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>gdb&lt;span class="o">)&lt;/span> commands
&amp;gt; end
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Intel VTune Memory Bandwidth 분석하기</title><link>https://interp.blog/vtune-memory-bandwidth/</link><pubDate>Mon, 22 Jan 2018 05:19:48 +0000</pubDate><guid>https://interp.blog/vtune-memory-bandwidth/</guid><description>&lt;p>Intel VTune 으로 Memory Bandwidth 를 분석하려면, 분석할 수 있는 커널 드라이버를 로딩시켜야 한다. (참고로 메모리 분석은 리눅스에서만 가능하다.) 해당 작업을 하지 않고 &amp;lsquo;General Exploration &amp;gt; Analyze memory bandwidth&amp;rsquo; 를 체크하면 엄한 경고창이 반길 것이다.&lt;/p>
&lt;p>&lt;img src="https://interp.blog/uploads/2018/01/before.jpg"
loading="lazy"
>&lt;/p>
&lt;p>&lt;a class="link" href="https://software.intel.com/en-us/vtune-amplifier-help-building-and-installing-the-sampling-drivers-for-linux-targets" target="_blank" rel="noopener"
>이 문서&lt;/a>를 참고해도 좋지만, VTune 이 설치된 경로에서 &lt;code>sepdk/src/README.txt&lt;/code> 를 보는 게 더 쉽다. 이 내용을 요약하면,&lt;/p>
&lt;ol>
&lt;li>커널 환경변수를 체크한다. 프로파일링이 가능하고 모듈 로딩이 가능해야 한다.
&lt;ul>
&lt;li>&lt;code>CONFIG_MODULES=y&lt;/code>&lt;/li>
&lt;li>&lt;code>CONFIG_MODULE_UNLOAD=y&lt;/code>&lt;/li>
&lt;li>&lt;code>CONFIG_PROFILING=y&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>커널 드라이버를 컴파일시킬 헤더파일이 필요하다. Linux 배포판에 따라, 커널 개발용 패키지를 내려받아 설치한다.&lt;br>
(언급한 Linux 배포판이 없으면 소스를 직접 받아둔다.)
&lt;ul>
&lt;li>Redhat 5/Fedora/CentOS : &lt;code>yum install kernel-devel&lt;/code>&lt;/li>
&lt;li>Ubuntu/Debian : &lt;code>apt-get install build-essential linux-headers-`uname-r`&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>VTune이 필요로 하는 커널 드라이버를 컴파일하고 로드시킨다.
&lt;ul>
&lt;li>&lt;code>cd ${VTune Directory}/spedk/src&lt;/code>&lt;/li>
&lt;li>&lt;code>./build_driver&lt;/code> (이 때 2번에서 설치한 커널 헤더파일의 위치를 정확히 입력해야 한다.)&lt;/li>
&lt;li>&lt;code>./insmod-sep3&lt;/code>
&lt;ul>
&lt;li>로딩 확인을 위해서는 &lt;code>./insmod-sep3 -q&lt;/code> 라고 입력해 보자.&lt;/li>
&lt;li>언로딩 시키려면 &lt;code>./rmmod-sep3&lt;/code> 이라고 입력하자.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Office 2016 커서 애니메이션 끄기</title><link>https://interp.blog/office-2016-%EC%BB%A4%EC%84%9C-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%81%84%EA%B8%B0/</link><pubDate>Tue, 16 Jan 2018 12:14:29 +0000</pubDate><guid>https://interp.blog/office-2016-%EC%BB%A4%EC%84%9C-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%81%84%EA%B8%B0/</guid><description>&lt;img src="https://interp.blog/images/2018-01-16-office-animation-off/office-animation.jpg" alt="Featured image of post Office 2016 커서 애니메이션 끄기" />&lt;p>Office 2016 부터인지 모르겠지만, 커서가 부드럽게 움직이는 애니메이션이 추가되었다. 실제 입력 속도는 같을지 모르겠는데, 문서 작업을 하고 있자니 조금 답답한 느낌이 들었다. 조금 느리게 입력되는 느낌? 처음에는 엑셀에서 셀 이동 할 때만 그런 줄 알았더니, 파워포인트나 워드를 작업할 때도 신경이 쓰였다. 그래서 이걸 끌 수 있는 방법을 두 가지 찾았는데, 하나는 레지스트리를 수정하는 방법이라 엄청나게 귀찮았다. 다른 하나는 그 것보단 간단했다.&lt;/p>
&lt;p>아래 스크린샷 순서대로 따라가 체크를 해제하면 된다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;ol>
&lt;li>제어판 &amp;gt; 시스템으로 들어간 다음, 고급 시스템 설정으로 들어간다.&lt;/li>
&lt;li>고급 탭에서, 성능 항목에 &amp;lsquo;설정…&amp;rsquo; 을 클릭한다.&lt;/li>
&lt;li>&amp;lsquo;시각 효과&amp;rsquo; 탭에서, 창의 제어 및 요소에 애니메이션 효과 추가 항목의 체크를 해제한다. 그리고 확인.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://interp.blog/images/2018-01-16-office-animation-off/blog.png"
loading="lazy"
>&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="6929871144"
data-ad-format="auto"
data-full-width-responsive="true">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/></description></item><item><title>Gitlab 아바타/첨부파일 상대 경로 설정</title><link>https://interp.blog/gitlab-%EC%95%84%EB%B0%94%ED%83%80-%EC%83%81%EB%8C%80-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95/</link><pubDate>Mon, 08 Jan 2018 02:35:20 +0000</pubDate><guid>https://interp.blog/gitlab-%EC%95%84%EB%B0%94%ED%83%80-%EC%83%81%EB%8C%80-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95/</guid><description>&lt;p>사내 사정으로 인해 Gitlab의 &lt;code>External_Url&lt;/code> 을 실제 서버 주소와 다르게 설정해서 쓰고 있다.&lt;/p>
&lt;p>물론 실제 nginx 에도 해당 도메인으로 접근할 수 있도록 설정해야 하는 게 맞다. 그렇지 않으면, 첨부파일과 아바타 이미지가 모두 깨져나온다. 하지만 그러기 전에 Gitlab 차원에서 상대 경로로 아바타를 출력할 수 있도록 수정하는 방법 &amp;lsquo;도&amp;rsquo; 있으니 편법으로 수정했다. 아래는 그 편법 내용을 다룬다.&lt;/p>
&lt;h2 id="아바타-상대-경로-설정">아바타 상대 경로 설정&lt;/h2>
&lt;p>&lt;code>/opt/gitlab/embedded/service/gitlab-rails/app/models/concerns/avatarable.rb&lt;/code> 파일에서 절대 경로로 수정하는 코드가 있는데, url_base 에 덧붙이는 코드들을 전부 주석처리하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">module&lt;/span> &lt;span class="nn">Avatarable&lt;/span>
&lt;span class="kp">extend&lt;/span> &lt;span class="no">ActiveSupport&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Concern&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">avatar_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">only_path&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">unless&lt;/span> &lt;span class="nb">self&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="ss">:avatar&lt;/span>&lt;span class="o">].&lt;/span>&lt;span class="n">present?&lt;/span>
&lt;span class="n">asset_host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">ActionController&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Base&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">asset_host&lt;/span>
&lt;span class="n">use_asset_host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">asset_host&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">present?&lt;/span>
&lt;span class="c1"># Avatars for private and internal groups and projects require authentication to be viewed,&lt;/span>
&lt;span class="c1"># which means they can only be served by Rails, on the regular GitLab host.&lt;/span>
&lt;span class="c1"># If an asset host is configured, we need to return the fully qualified URL&lt;/span>
&lt;span class="c1"># instead of only the avatar path, so that Rails doesn&amp;#39;t prefix it with the asset host.&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">use_asset_host&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">respond_to?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:public?&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="kp">public&lt;/span>&lt;span class="p">?&lt;/span>
&lt;span class="n">use_asset_host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;span class="n">only_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="n">url_base&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
&lt;span class="c1"># if use_asset_host&lt;/span>
&lt;span class="c1"># url_base &amp;lt;&amp;lt; asset_host unless only_path&lt;/span>
&lt;span class="c1"># else&lt;/span>
&lt;span class="c1"># url_base &amp;lt;&amp;lt; gitlab_config.base_url unless only_path&lt;/span>
&lt;span class="c1"># url_base &amp;lt;&amp;lt; gitlab_config.relative_url_root&lt;/span>
&lt;span class="c1"># end&lt;/span>
&lt;span class="n">url_base&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">avatar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>당연히 &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 를 해 줘야 한다.&lt;/p>
&lt;p>참고 : &lt;a class="link" href="https://gitlab.com/gitlab-org/gitlab-ce/merge" target="_blank" rel="noopener"
>https://gitlab.com/gitlab-org/gitlab-ce/merge&lt;/a>_requests/11001/diffs#note_28659864&lt;/p>
&lt;h2 id="첨부파일-상대-경로-설정">첨부파일 상대 경로 설정&lt;/h2>
&lt;p>단서가 없어서 맨땅에 헤딩하듯이 뒤지고 다녔다. Markdown 언어에서 링크를 담당하는 라이브러리가 있는데, 이름이 &amp;lsquo;&lt;strong>banzai&lt;/strong>&amp;rsquo; 이다 (…) &lt;span style="color: #808080;">&lt;del>무슨 생각으로 이름을 지은건지 도저히 모르겠지만&lt;/del>&lt;/span> 여기를 수정해야 한다.&lt;/p>
&lt;p>&lt;code>filter/upload_link_filter.rb&lt;/code> 를 보면, &lt;code>build_url()&lt;/code> 이란 함수가 있다. 여기서 Geo node 여부에 따라 base_path 를 설정하는 코드가 있는데, 여기서 원하는 내부 주소로 변경하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">def&lt;/span> &lt;span class="nf">build_url&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uri&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">base_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="no">Gitlab&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Geo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">secondary?&lt;/span>
&lt;span class="no">Gitlab&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Geo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">primary_node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="c1"># Gitlab.config.gitlab.url&lt;/span>
&lt;span class="s2">&amp;#34;http://your.address.com/&amp;#34;&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">group&lt;/span>
&lt;span class="n">urls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">Gitlab&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Routing&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url_helpers&lt;/span>
&lt;span class="c1"># we need to get last 2 parts of the uri which are secret and filename&lt;/span>
&lt;span class="n">uri_parts&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">uri&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">File&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">SEPARATOR&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">file_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">urls&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">show_group_uploads_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">group&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uri_parts&lt;/span>&lt;span class="o">[-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uri_parts&lt;/span>&lt;span class="o">[-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="no">File&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">base_path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">file_path&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="no">File&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">base_path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">project&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">full_path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uri&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Gitlab 11 버전 으로 업그레이드 되면서부터 해당 파일은 삭제되고, &lt;code>absolute_link_filter.rb&lt;/code> 와 &lt;code>external_link_filter.rb&lt;/code> , &lt;code>relative_link_filter.rb&lt;/code> 가 남아있다. 여기 있는 &lt;code>Gitlab.config.gitlab.url&lt;/code> 을 원하는 주소로 바꿔주면 가능하다. (relative.rb 의 경우 &lt;code>Gitlab.config.gitlab.base_url&lt;/code>)&lt;/p></description></item><item><title>Gitlab Markdown Parser 고치기</title><link>https://interp.blog/gitlab-markdown-parser-configuration/</link><pubDate>Wed, 03 Jan 2018 02:29:21 +0000</pubDate><guid>https://interp.blog/gitlab-markdown-parser-configuration/</guid><description>&lt;p>Github 과 비슷한 서비스인 &lt;a class="link" href="https://about.gitlab.com/" target="_blank" rel="noopener"
>Gitlab&lt;/a> 은 오픈소스이기 때문에 Community Edition 을 쓰건, Enterprise Edition 을 쓰건 on-premise 환경에서 설치한 뒤 마음대로 수정해서 사용이 가능하다. 수정하는 범위를 한정하지 않는다면, 루비 (&lt;code>*.rb&lt;/code>) 파일까지 건드릴 수 있다.&lt;/p>
&lt;p>여기서는 Gitlab에서 문서 작성에 필요한 Markdown 의 Parser 부분을 미세하게 수정해서, 입맛에 맞게 바꾸기 위한 방법을 정리해 둔다. Ruby 개발자가 아니라서 전체 순서가 정공법처럼 보이진 않겠지만.&lt;/p>
&lt;h1 id="그런데-뭘-수정하나요">그런데 뭘 수정하나요?&lt;/h1>
&lt;p>내가 수정하고 싶었던 내용은, E&lt;strong>nter 키를 한 번만 쳐도 줄이 바뀌도록 보이게 하는 것&lt;/strong>이었다. 원래 Markdown 문법에선 Enter 키를 두 번 치면 문단 바꿈, 줄 끝에 스페이스를 두 번 넣으면 줄바꿈이 된다. 그런데 Enter 키를 한 번만 쳐도 줄바꿈이 되면 좋겠다는 개발자가 많았다. &lt;del>저기요, Markdown 안 써보셨어요? 라고 따질 순 없었다&lt;/del>&lt;/p>
&lt;h1 id="gitlab-10x--redcarpet">Gitlab 10.x : Redcarpet&lt;/h1>
&lt;p>Gitlab 10.x 에서는 Markdown Parser 를 &lt;a class="link" href="https://github.com/vmg/redcarpet" target="_blank" rel="noopener"
>Redcarpet&lt;/a> 으로 사용한다. 아마 &lt;a class="link" href="https://jekyllrb-ko.github.io/" target="_blank" rel="noopener"
>Jekyll&lt;/a> 도 기본적으로 Redcarpet 을 사용하는 것으로 알고 있다. 만약 Ruby의 Redcarpet 을 Markdown Parser 로 쓰는 경우라면 똑같이 적용이 가능하다.&lt;/p>
&lt;h2 id="parser-c-파일-수정하기">Parser C 파일 수정하기&lt;/h2>
&lt;p>&lt;code>/opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/redcarpet-3.4.0/&lt;/code> 으로 들어가면 Redcarpet의 소스코드가 존재한다. 여기서 &lt;code>ext/redcarpet&lt;/code> 디렉토리가 Parser C 파일들이 위치한 곳이다.&lt;/p>
&lt;p>여기 &lt;code>markdown.c&lt;/code> 파일을 보니 &lt;code>char_linebreak()&lt;/code>  라는 함수가 존재한다. 여기서 해당 부분을 주석처리했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="cm">/* char_linebreak • &amp;#39;\n&amp;#39; preceded by two spaces (assuming linebreak != 0) */&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="n">size_t&lt;/span>
&lt;span class="nf">char_linebreak&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">buf&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="nc">sd_markdown&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rndr&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">uint8_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">size_t&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">size_t&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//if (offset &amp;lt; 2 || data[-1] != &amp;#39; &amp;#39; || data[-2] != &amp;#39; &amp;#39;)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// return 0; /* removing the last space from ob and rendering */
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">ob&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">rndr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">cb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">linebreak&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ob&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rndr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">opaque&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="라이브러리-생성복사">라이브러리 생성/복사&lt;/h2>
&lt;p>수정이 끝나면 반드시 &lt;code>ext/redcarpet&lt;/code> 디렉토리에서 &lt;code>make&lt;/code> 를 수행해 주도록 하자. 그러면 Shared Library 파일인 &lt;code>redcarpet.so&lt;/code> 이 생성된다.&lt;/p>
&lt;p>이 파일을, 다음 경로에 모두 복사해주도록 하자.&lt;/p>
&lt;ul>
&lt;li>&lt;code>/opt/gitlab/embedded/lib/ruby/gems/2.3.0/extensions/x86_64-linux/2.3.0/redcarpet-3.4.0/&lt;/code>&lt;/li>
&lt;li>&lt;code>/opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/redcarpet-3.4.0/lib/&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="gitlab-재부팅">Gitlab 재부팅&lt;/h2>
&lt;p>마지막으로 &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 를 실행시켜 Gitlab 을 재부팅 하자.&lt;/p>
&lt;h1 id="gitlab-11x-이후--commonmark">Gitlab 11.x 이후 : Commonmark&lt;/h1>
&lt;p>11.x 부터는 Redcarpet 이 아니라 Commonmark 를 기본 파서로 사용한다. 구조가 달라져서 찾는게 귀찮아서 그렇지, 기본 원리는 비슷하다. 2칸 이상의 space 를 준 채로 줄바꿈하게 되면 &lt;code>CMARK_NODE_LINEBREAK&lt;/code>, 그렇지 않고 줄바꿈하면 &lt;code>CMARK_NODE_SOFTBREAK&lt;/code> 상태로 전이된다.&lt;/p>
&lt;p>옵션을 알아보고 정확히 적용했다면 더 없이 깔끔했겠지만, 나는 마음이 급했기 때문에 참고할 만한 소스코드만 붙이고 그만두기로 했다.&lt;/p>
&lt;p>&lt;code>html.c:283&lt;/code> 부터다. 여기서 직접 줄바꿈을 하도록 강제했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">case&lt;/span> &lt;span class="nl">CMARK_NODE_SOFTBREAK&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">options&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">amp&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">CMARK_OPT_HARDBREAKS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">cmark_strbuf_puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;br/&amp;gt;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">options&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">amp&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">CMARK_OPT_NOBREAKS&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// cmark_strbuf_putc(html, &amp;#39; &amp;#39;); // 수정 전
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cmark_strbuf_puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;&amp;lt;br/&amp;gt;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 수정 후
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">cmark_strbuf_putc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 하고 make 를 쳤더니, 어라? 빌드가 안 된다. 이 때는 banzai filter 가 위치한 곳의 ruby 파일을 수정하면 된다. &lt;code>/opt/gitlab/embedded/service/gitlab-rails/&lt;/code> 까지 들어간 다음 &lt;code>lib/banzai/filter/markdown_engines/common_mark.rb&lt;/code> 을 편집한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="no">RENDER_OPTIONS&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>
&lt;span class="ss">:DEFAULT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1"># default rendering system. Nothing special.&lt;/span>
&lt;span class="ss">:HARDBREAKS&lt;/span> &lt;span class="c1"># Treat `\n` as hardbreaks (by adding `&amp;lt;br/&amp;gt;`). # 이 옵션을 추가한다.&lt;/span>
&lt;span class="o">].&lt;/span>&lt;span class="n">freeze&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>반드시, Gitlab 재부팅을 잊지말자! &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 이다. Commonmark 는 라이브러리를 수정한 것이 아니라서 &lt;code>make&lt;/code> 같은 건 안 해도 된다.&lt;/p>
&lt;p>이 방법으로 했을 때 한 가지 아쉬운 점은(?) 일부러 soft break 를 시도하는 경우에, 내부에서 line break 까지 겹쳐서 인식하기 때문에 결론적으로 &lt;code>&amp;lt;br/&amp;gt;&lt;/code> 이 두번 붙는 사태가 일어난다. 깔끔하게 &lt;code>&amp;lt;p&amp;gt;&lt;/code> 로 감싼 문단을 얻고 싶을 때는 이 방법이 소용이 없어서, 어쩔 수 없이 commonmark 를 한번 빌드하는 수밖에 없나.. 하는 생각이 들었다.&lt;/p></description></item><item><title>oh-my-zsh 색깔 고르기</title><link>https://interp.blog/oh-zsh-%EC%83%89%EA%B9%94-%EA%B3%A0%EB%A5%B4%EA%B8%B0/</link><pubDate>Wed, 13 Dec 2017 05:43:01 +0000</pubDate><guid>https://interp.blog/oh-zsh-%EC%83%89%EA%B9%94-%EA%B3%A0%EB%A5%B4%EA%B8%B0/</guid><description>&lt;p>oh-my-zsh 테마 작업을 agnoster 를 기반으로 고쳐서 사용 중이다. 그런데 주석을 보면 다음 색깔만 지원하는 것 처럼 나온다.&lt;/p>
&lt;blockquote>
&lt;p>white, black, red, blue, green, yellow, cyan, magenta&lt;/p>
&lt;/blockquote>
&lt;p>위의 색깔 외에 다른 색상을 설정하려면, 다음 작업이 필요하다.&lt;/p>
&lt;ul>
&lt;li>터미널 종류가 xterm-256color 여야 한다. (xterm 으로 설정되어 있으면 제대로 출력이 안된다.)&lt;/li>
&lt;li>oh-my-zsh 에서, &lt;code>%{%K{---}%}&lt;/code> 또는 &lt;code>%{%F{---}%}&lt;/code> 를 가지고 색깔을 찾는다. 이 때 &lt;code>---&lt;/code> 대신 0~255 사이의 숫자를 입력한다.&lt;/li>
&lt;li>0~255 숫자와 대응되는 색상을 찾아야 하는데, &lt;a class="link" href="https://jonasjacek.github.io/colors/" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/li>
&lt;/ul></description></item><item><title>X11 on Windows Linux Subsystem</title><link>https://interp.blog/x11-windows-linux-subsystem/</link><pubDate>Wed, 29 Nov 2017 08:32:52 +0000</pubDate><guid>https://interp.blog/x11-windows-linux-subsystem/</guid><description>&lt;p>먼저, Windows 10 에서 지원하는 Linux Subsystem 기능에 대해 이야기한다. 잘 모르겠다면 &lt;a class="link" href="https://msdn.microsoft.com/en-us/commandline/wsl/install-win10" target="_blank" rel="noopener"
>이 글&lt;/a>을 읽고 설치에 도전해 보자. &lt;span style="color: #999999;">&lt;del>그런데 글 내용을 보면 이거랑 관련 없다. Babun, Mintty, Git on Bash, Putty 전부 포함이다&lt;/del>&lt;/span>&lt;/p>
&lt;ul>
&lt;li>SSH에 접속한 서버에서 X11 Forwarding 을 받고 싶은 경우를 이야기한다. 단적으로, 접속한 서버에서 파이어폭스 브라우저를 실행하면 내 윈도우 화면에 브라우저 창이 실행되는 거다. 이걸 따로 이야기하고 싶지 않으니 &lt;a class="link" href="https://www.google.co.kr/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=0ahUKEwj1yoOCrePXAhWCG5QKHeIRCkEQFggkMAA&amp;amp;url=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fxming%2F&amp;amp;usg=AOvVaw2r18vOyEGzisW0WiHH4ksg" target="_blank" rel="noopener"
>Xming&lt;/a> 이나 &lt;a class="link" href="https://www.google.co.kr/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=0ahUKEwj-y9aGrePXAhUJoZQKHXKpB2IQFggkMAA&amp;amp;url=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fvcxsrv%2F&amp;amp;usg=AOvVaw2UIxI0S4LFsqeqk9A47MSR" target="_blank" rel="noopener"
>VcXsrv&lt;/a> 을 참고해 설치해보자.&lt;/li>
&lt;/ul>
&lt;p>참고로, 이 방법은 Client측 PC의 X Server로 접근하는 무식한 방법이므로, 일반 데스크탑 PC에서 서버로 접속했을 때엔 사용할 수 없을 것 같다. 좀 더 알아보고 보충해야겠다.&lt;/p>
&lt;p>그리고, ssh_config 에서 &lt;code>X11ForwardTrusted&lt;/code> 를 확인하지 않았었다. 이걸 설정하니까 Server에서 DISPLAY를 따로 설정하지 않아도 잘 된다? &lt;code>xauth generate&lt;/code> 를 한번 더 해보긴 했는데.. 한번 더 실험이 필요하다.&lt;/p>
&lt;h2 id="windows에서-한-일">Windows에서 한 일&lt;/h2>
&lt;p>클라이언트 PC에서 작업한 일이다. 참고로 나는 Ubuntu 를 Linux Subsystem 으로 설치했는데, 어느 리눅스 버전이어도 상관 없을 것이다.&lt;/p>
&lt;ol>
&lt;li>Xming 또는 VcXsrv 를 설치해서 실행시켰다. 트레이 아이콘에 &amp;lsquo;X&amp;rsquo; 라고 떠 있으면 완료. (이걸 X Server 라고 부른다)&lt;/li>
&lt;li>Ubuntu Console을 하나 열어서,&lt;code>/etc/ssh/ssh_config&lt;/code> (sshd_config 가 아니다) 파일을 확인했다. 여기에서 ForwardX11 yes, ForwardX11Trusted yes 를 확인했다. (주석 처리되어 있다면 주석을 제거, sudo 권한 필요)&lt;/li>
&lt;li>SSH 접속을 하면, 다음 에러 메시지가 떠서 보기 싫었다.
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">No xauth data; using fake authentication data for X11 forwarding.
&lt;/code>&lt;/pre>&lt;/div>그래서 다음과 같이 처리했다.
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ xauth list &lt;span class="c1"># ~/.Xauthority 파일이 없었다!&lt;/span>
$ xauth generate :0 . trusted &lt;span class="c1"># ~/.Xauthority 파일을 만들어준다고 한다..&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>(Optional) Xming 또는 VcXsrv 의 설치 디렉토리에 가면 &lt;code>X0.hosts&lt;/code>라는 파일이 있다. 여기서 Server의 Hostname 또는 IP를 적어줘야 한다.&lt;/li>
&lt;/ol>
&lt;h2 id="server에서-한-일">Server에서 한 일&lt;/h2>
&lt;p>직접 SSH로 접속하고 나서 설정해야 할 것을 적었다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>/etc/ssh/sshd_config&lt;/code> 에서 &lt;code>X11UseLocalHost&lt;/code> 가 yes 로 되어 있거나, 활성화되어 있지 않아야 한다. 만약 no로 되어 있으면 yes 로 변경해야 한다.&lt;/li>
&lt;li>&lt;code>$DISPLAY&lt;/code> 환경 변수를 아예 Windows (클라이언트 PC) 의 Hostname 또는 IP 주소로 설정해버린다.
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">export&lt;/span> &lt;span class="nv">DISPLAY&lt;/span>&lt;span class="o">=&lt;/span>192.168.0.xxx:0
&lt;/code>&lt;/pre>&lt;/div>참고로, 뒤에 :0 또는 :10 같이 여러 예제가 인터넷에 나도는데, Windows 에서 X 아이콘에 마우스를 가져다 대면 &lt;code>Hostname:X.X&lt;/code> 라고 나올 것이다. X.X 를 저기에 쓰는 것이다. (나는 0.0 이라고 떠서 그냥 0만 적었다.)&lt;/li>
&lt;li>firefox 를 실행해 보자. 끝.&lt;/li>
&lt;/ol></description></item><item><title>C# xUnit 실습</title><link>https://interp.blog/csharp-xunit-practice/</link><pubDate>Wed, 29 Nov 2017 03:28:03 +0000</pubDate><guid>https://interp.blog/csharp-xunit-practice/</guid><description>&lt;p>대학생 때 팀 프로젝트로 윈도우 어플리케이션을 끄적이던 때가 있었다. 그 때 C# 기반으로 진행했었는데, 나는 뷰에 집중했던지라 디자인하고 프로퍼티 만지기 바빴고 뼈대는 다른 친구가 만들어 줬었던 기억이 난다. 그 때부터 C/C++ 와는 다르지만 비슷한 이름의 이 언어에 왠지 모를 끌림이 있었다. 하지만 배울 기회는 없었지..&lt;/p>
&lt;p>바로 그 언어, C#을 현업에서 당장 써먹어야 하는 상황이 발생했다. (이런 상황이 왜 발생했는지 한탄은 나중에 일단 하기로 하고) 어쩔 수 없이 배움의 기회로 삼는 수 밖에 없다.&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.microsoft.com/ko-kr/dotnet/core/testing/unit-testing-with-dotnet-test" target="_blank" rel="noopener"
>dotnet test 및 xUnit을 사용하여 .NET Core에서 C# 유닛 테스트&lt;/a>라는 MS 문서를 기반으로 실습을 했는데, 여기서 중요한 것은, 내가 만들어야 하는 라이브러리의 Target Framework가 .NET Core 가 아니라 .NET Framework 4.0 이다. xUnit은 최소 .NET Framework 4.5 이상에서만 돌아간다.&lt;/p>
&lt;p>그럼 나는 테스트를 못 하는 것인가? 실제론 그렇지는 않았다. xUnit 프로젝트만 .NET Framework 4.5 로 두고, 라이브러리 프로젝트는 .NET Framework 4.0 으로 설정해서 테스트를 진행해 봤다. 대부분의 내용은 위의 문서를 요약한 것에 지나지 않지만, 중간에 Target Framework를 설정하는 부분에 대해서도 설명하겠다.&lt;/p>
&lt;h2 id="사전-준비">사전 준비&lt;/h2>
&lt;p>혹시나 해서 적어둔다. 다 필요없고 .NET Core SDK 를 설치해주자.&lt;/p>
&lt;ul>
&lt;li>.NET Framework 4.0, .NET Framework 4.5 SDK 가 설치되어 있어야 한다. (Visual Studio 설치하면서 같이 설치하는게 속편하다)&lt;/li>
&lt;li>.NET Framework 4.5 이후의 TargetFramework를 가져가는 경우엔 .NET Core SDK 를 설치하는 것으로 끝날지도 모른다는 어렴풋한 추측을 해 본다. (Target Framework를 수정한 다음 dotnet restore 를 하면?)&lt;/li>
&lt;/ul>
&lt;p>그리고 아래 실습은 Visual Studio 가 아니라 Powershell 에서 진행한다. 사내 빌드할 때 Visual Studio를 안 쓰기 때문이다. 단지 그 뿐이다..&lt;/p>
&lt;h2 id="솔루션프로젝트-준비">솔루션/프로젝트 준비&lt;/h2>
&lt;ol>
&lt;li>디렉토리를 하나 만든다. 여기서는 &lt;code>testSolution&lt;/code> 라고 하자.&lt;/li>
&lt;li>&lt;code>dotnet new sln&lt;/code> 을 실행한다. 솔루션 파일이 생성된다.&lt;/li>
&lt;li>내부에 디렉토리를 하나 만든다. 여기서는 &lt;code>projLibrary&lt;/code> 라고 하자.&lt;/li>
&lt;li>&lt;code>projLibrary&lt;/code> 에 들어가서 &lt;code>dotnet new classlib&lt;/code> 명령으로 프로젝트를 만든다. &lt;br>
&lt;code>classlib&lt;/code> 라고 입력하면 해당 프로젝트는 라이브러리를 생성하는 것이 된다.&lt;/li>
&lt;li>다시 &lt;code>testSolution&lt;/code> 디렉토리로 돌아와서, &lt;code>dotnet sln add projLibrary/projLibrary.csproj&lt;/code> 를 입력한다.&lt;br>
이제 솔루션에 해당 프로젝트가 등록된다.&lt;/li>
&lt;li>&lt;code>testSolution&lt;/code>내부에 테스트용 디렉토리를 하나 만든다. 여기서는 &lt;code>projTest&lt;/code> 라고 하자.&lt;/li>
&lt;li>&lt;code>projTest&lt;/code> 에 들어가서 &lt;code>dotnet new xuint&lt;/code> 를 입력해 테스트용 프로젝트를 만든다.&lt;br>
&lt;code>xuint&lt;/code> 라고 입력하면, 해당 프로젝트는 테스트를 위한 것이 된다.&lt;/li>
&lt;li>다시 &lt;code>testSolution&lt;/code> 디렉토리로 돌아와서, &lt;code>dotnet sln add projTest/projTest.csproj&lt;/code> 를 입력한다. 이제 솔루션에 해당 프로젝트가 등록된다.&lt;/li>
&lt;li>마지막으로 테스트 프로젝트에 라이브러리 프로젝트를 참조할 수 있도록 연결해야 한다.&lt;br>
&lt;code>projTest&lt;/code> 에 들어가서 &lt;code>dotnet add reference ../projLibrary/projLibrary.csproj&lt;/code> 를 입력한다.&lt;/li>
&lt;/ol>
&lt;p>그러면 아래와 같이 디렉토리와 파일이 구성되어야 한다. (자동으로 생성되는 &lt;code>Class1.cs&lt;/code> 는 제외했다.)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">/testSolution
testSolution.sln
/projLibrary
projLibrary.csproj
/projTest
&lt;span class="c1"># other referenced files (xunit)&lt;/span>
projTest.csproj
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="test-framework-수정">Test Framework 수정&lt;/h2>
&lt;p>&lt;code>projLibrary&lt;/code> 에 있는 &lt;code>projLibrary.csproj&lt;/code>를 열어서 아래를 수정한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;TargetFramework&amp;gt;&lt;/span>net40&lt;span class="nt">&amp;lt;/TargetFramework&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>만들고자 하는 프레임워크 버전을 명시하면 되고, 버전은 [여기][2]를 참고한다. 여러 개의 버전을 명시할 경우에는 세미콜론(;) 으로 구분하면 된다.&lt;/p>
&lt;p>역으로, &lt;code>projTest&lt;/code> 에 있는 &lt;code>projTest.csproj&lt;/code> 는 이렇게 수정해야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;TargetFramework&amp;gt;&lt;/span>net45&lt;span class="nt">&amp;lt;/TargetFramework&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>기본적으로 netcore2.0 으로 설정되어 있을텐데, 이러면 net40 과 호환이 안되어서 참조조차 안되는 불상사가 발생한다. net45 또는 그 이상의 .NET Framework를 지정하되, netcore1.x 에 대응되는 버전으로만 지정하면 될 것으로 보인다.&lt;/p>
&lt;h3 id="테스트-작성">테스트 작성&lt;/h3>
&lt;p>&lt;code>projLibrary&lt;/code>에서 Class1.cs 에 다음을 추가하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="k">using&lt;/span> &lt;span class="nn">System&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">namespace&lt;/span> &lt;span class="nn">ProjLibrary&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Class1&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">IsPrime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">candidate&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">NotImplem&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">span&lt;/span> &lt;span class="n">style&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="s">&amp;#34;display: inline-block; width: 0px; overflow: hidden; line-height: 0;&amp;#34;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="n">mce&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="n">type&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="s">&amp;#34;bookmark&amp;#34;&lt;/span> &lt;span class="n">class&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="s">&amp;#34;mce_SELRES_start&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="n">span&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="n">entedException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Please create a test first&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>아직 구현을 안 한 거다. 이제 &lt;code>projTest&lt;/code>에서 Class1.cs에 다음을 추가한다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="k">using&lt;/span> &lt;span class="nn">Xunit&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">using&lt;/span> &lt;span class="nn">ProjLibrary&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">namespace&lt;/span> &lt;span class="nn">Prime.UnitTests.Services&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">TestClass1&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">Class1&lt;/span> &lt;span class="m">_&lt;/span>&lt;span class="n">service&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="n">Class1_IsPrimeShould&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="m">_&lt;/span>&lt;span class="n">service&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Class1&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="na">
&lt;/span>&lt;span class="na"> [Fact]&lt;/span>
&lt;span class="k">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">ReturnFalseGivenValueOf1&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">var&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">_&lt;/span>&lt;span class="n">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">IsPrime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">Assert&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">False&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;1 should not be prime&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="테스트">테스트&lt;/h3>
&lt;p>다 끝났다. 이제 솔루션 디렉토리에서 &lt;code>dotnet test&lt;/code> 를 힘차게 불러보자.&lt;/p>
&lt;p>에러가 날 것이다. 당연히 테스트 코드에서 result 값이 FALSE가 나오기를 기대하는데, 지금은 그냥 Exception 으로 떨어지기 때문이다.&lt;/p>
&lt;p>&lt;code>projLibrary&lt;/code>에서 &lt;code>IsPrime()&lt;/code> 함수의 리턴을 FALSE로 바꿔주면 테스트가 성공하는 것을 확인할 수 있다.&lt;/p>
&lt;p>[1]:
[2]: &lt;a class="link" href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard" target="_blank" rel="noopener"
>https://docs.microsoft.com/en-us/dotnet/standard/net-standard&lt;/a>&lt;/p></description></item><item><title>Gitlab 10.x 삽질기</title><link>https://interp.blog/gitlab-%EC%82%BD%EC%A7%88%EA%B8%B0/</link><pubDate>Wed, 15 Nov 2017 09:17:58 +0000</pubDate><guid>https://interp.blog/gitlab-%EC%82%BD%EC%A7%88%EA%B8%B0/</guid><description>&lt;h2 id="upgrade">Upgrade&lt;/h2>
&lt;p>8.x 로 쓰다가 10.x 로 업그레이드를 진행했다. 아니.. 그런데 Postgresql Database 버전이 다르다고? 알고보니 이렇게 대격변을 일으키면 안 되던 거였다. 그래서 겸사겸사 9.5.10 으로 다시 설치하니까 된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>gitlab-ctl reconfigure&lt;/code> 를 설치 직후에 반드시 해 줘야 한다.&lt;/li>
&lt;li>가끔 &lt;code>gitlab-ctl pg-upgrade&lt;/code> 를 꼭 하라는 말이 있던데, 내가 해보니까 &lt;code>gitlab-ctl reconfigure&lt;/code> 할 때 알아서 한다 (…) 했던 거 또 하는 느낌.&lt;/li>
&lt;li>&lt;code>gitlab-ctl restart&lt;/code> 를 할 때 postgresql 이나 다른 곳에서 &amp;lsquo;down, up, want up&amp;rsquo; 이런 게 뜨면 서비스가 온전히 수행될 수 없는 상황이다. &lt;code>gitlab-ctl tail&lt;/code> 을 실행시켜 로그를 뒤져봐야 한다. 에러가 났거나, 무한히 반복되는 메시지가 없는지 확인하자.&lt;/li>
&lt;/ul>
&lt;h2 id="runner">Runner&lt;/h2>
&lt;p>우리 회사 Gitlab 구조는 웹 서비스 주소와 내부 공유 주소가 다르다. (도메인을 거의 리다이렉트 비슷하게 해놨기 때문이기도 하지만) 비공개 저장소다 보니, 웹 접속은 외부에서 되었면서 Clone 은 똑같은 주소로 절대 받을 수 없게 해 놨다. 이게 Gitlab Runner 를 바보로 만들었다 (…)&lt;/p>
&lt;p>Gitlab Runner는 &lt;code>.gitlab-ci.yml&lt;/code> 의 구성에 상관없이, 선작업으로 해당 저장소를 Cloning 하거나 Fetching 하게 된다. (양자택일은 웹 페이지의 Runner 관리 페이지에서 설정이 가능하다.) 이건 Runner의 Executer를 Docker를 하던 Shell 을 하던 똑같다. 문제는 내가 언급했던 대로, 이 저장소 주소를 웹 주소에 기반해서 가져가기 때문에, 항상 실패했다는 것이다.&lt;/p>
&lt;p>짜증이 치밀 즈음, 아예 이 작업을 끌 수는 없을까 하고 봤더니… 역시나 답은 있었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">variables:
GIT_STRATEGY: none
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 두면, Runner의 옵션을 Cloning 으로 줬건 Fetching 으로 줬건 간에 &lt;strong>하지 않는다&lt;/strong>.&lt;/p>
&lt;p>즉, 모든 작업을 온전히 CI 명령에 맡기는 것이다. 위험하기도 하고, 캐싱도 안 되고 약점이 많지만, 나는 상관이 없었다. 직접 내부 주소의 저장소로 접근해서 받아오면 그만!&lt;/p>
&lt;h3 id="repository-에-ssh-key-등록">Repository 에 SSH Key 등록&lt;/h3>
&lt;p>그런데, 문제가 생겼다. 아래와 같이 &amp;lsquo;gitlab-runner&amp;rsquo; 사용자로 Runner Service를 등록하고, 실행시켰다고 가정하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">gitlab-runner install --user gitlab-runner
gitlab-runner start
ps aux &lt;span class="p">|&lt;/span> grep gitlab-runner &lt;span class="c1"># gitlab-runner run 이 잘 되고 있어야 한다.&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>나는 Executer를 Shell 로 쓰고 있는데, 이 친구가 내부 저장소로 (그것도 SSH 주소로) 접근하려면… SSH Public Key를 넣어줘야 된다. 넣지 않으면 인증에서 실패한다. 그런데 Gitlab Runner 의 Shell 사용자는 위에서 보이는 것 처럼 &amp;lsquo;gitlab-runner&amp;rsquo; 인데.. 얘는 Gitlab 계정도 없는 가상 사용자다. 어떻게 Public Key를 등록할까?&lt;/p>
&lt;p>Gitlab은, 각 사용자 계정의 SSH Public Key를 관리해 주기도 하지만 Project 별로 SSH Key를 등록할 수도 있다. &lt;em>Project 페이지의 Settings &amp;gt; Repository&lt;/em> 에서 Deploy Keys 부분을 펼쳐보자. 그러면 익숙한 SSH Key 등록 폼이 나온다. 여기에, 아까 언급한 &amp;lsquo;gitlab-runner&amp;rsquo; 의 SSH Key를 등록하면 된다. (당연히 gitlab-runner 계정에서 SSH Key 생성을 해야한다.)&lt;/p>
&lt;p>그러면&lt;code>.gitlab-ci.yml&lt;/code> 에 마구잡이로 &lt;code>'git clone git@~~~~:&amp;lt;user or group&amp;gt;/&amp;lt;project&amp;gt;.git'&lt;/code> 이런 식으로 스크립트를 적어도 아주 잘 clone 되는 걸 확인할 수 있다!&lt;/p>
&lt;h2 id="create-new-branch-의-기본-branch-바꾸기">&lt;em>Create New Branch&lt;/em> 의 기본 Branch 바꾸기&lt;/h2>
&lt;p>Issue 페이지에서 Create New Branch (9.x 에서는 New Branch) 를 하면, Branch의 이름이 &amp;lsquo;421 – invalid table error&amp;rsquo; 이런 식으로 뜬다. 이슈 번호와 이슈 제목.&lt;/p>
&lt;p>그런데 내부적으로는 이슈 제목에 한글을 많이 써서 Branch 이름을 출력하고 싶지 않았다. 그리고 규격화된 이름 (ISSUE#XXXX) 으로 Branch를 생성하고픈 욕구가 치밀었다. (참고로 Push Rule 에서 Branch Naming Rule에 저렇게 규칙을 쓰고, Create New Branch 를 누르면 절대로 Branch가 생기지 않는다.)&lt;/p>
&lt;p>Gitlab에 이미 &lt;a class="link" href="https://gitlab.com/gitlab-org/gitlab-ce/issues/21143" target="_blank" rel="noopener"
>#21143&lt;/a> 으로 이슈가 등록되었고, 10.3 에서 업데이트가 된다지만… 이렇게 되면 사용자가 매번 Push Rule을 피하려고 Branch 이름을 일일이 쳐넣는 어처구니없는 상황이 계속된다. 그래서 코드를 찾아내서 고치는 편이 낫다고 생각했다.&lt;/p>
&lt;p>Ruby는 쥐뿔도 모르지만 코드는 코드일 뿐.&lt;/p>
&lt;p>이슈에 대한 브랜치를 생성하는 작업은 &lt;a class="link" href="https://gitlab.com/gitlab-org/gitlab-ce/merge_requests/2808/diffs" target="_blank" rel="noopener"
>이 Merge Request&lt;/a> 에서 반영된 것이다. 여기 Diff를 쭉 봤더니 &lt;code>to_branch_name&lt;/code> 이 눈에 띈다. 오호라. 하지만 어디서 수정해야 할까?&lt;/p>
&lt;p>Gitlab을 Omnibus 로 정직하게 설치했다면 소스코드 경로는 &lt;code>/opt/gitlab/embedded/service/gitlab-rails/&lt;/code> 에 있다. 여기서 grep으로 &lt;code>to_branch_name&lt;/code> 을 검색해 보면?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">cd&lt;/span> /opt/gitlab/embedded/service/gitlab-rails/
grep to_branch_name . -rn
&lt;span class="c1"># ./embedded/service/gitlab-rails/app/models/issue.rb:XXX def to_branch_name&lt;/span>
&lt;span class="c1"># 이하 생략&lt;/span>
vi app/models/issue.rb
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 &lt;code>&amp;quot;#{iid}-#{title.parameterize}&amp;quot;&lt;/code> 라고 정의된 부분을 적절히 바꿔주자. 나는 &lt;code>&amp;quot;ISSUE##{iid}&amp;quot;&lt;/code> 로 심플하게 바꿨다.&lt;/p>
&lt;p>이것만 바꾸면 &amp;lsquo;Create New Branch&amp;rsquo; 를 누를 때 잘 될 것 같다. 하지만 Issue 페이지에서 &amp;lsquo;연관된 Issue Branch&amp;rsquo; 목록에 연결되지 않는다. 수정한 파일 &lt;code>/opt/gitlab/embedded/service/gitlab-rails/app/models/issue.rb&lt;/code> 에서, 더 수정할 것이 남아있다. 다음 함수를 수정해야 한다.&lt;/p>
&lt;ul>
&lt;li>has_related_branch&lt;/li>
&lt;li>related_branches&lt;/li>
&lt;/ul>
&lt;p>수정 방법은 간단한데, Branch와 비교하는 Regular Expression 의 문법을 찾아보자. &lt;code>/\A${iid}-(?!\d+-stable)/i&lt;/code> 라고 되어 있을 것이다. 이걸 실제로 &lt;code>irb&lt;/code> 에서 테스트해 보면, &lt;code>420-title&lt;/code> 같은 건 되는데 &lt;code>420-0-stable&lt;/code> 은 인식이 안 되는 것을 알 수 있다. (뭔가.. 이상하다) 아무튼 이걸 적절한 Regular Expression 으로 바꿔 주도록 하자. Ruby의 Regexp 에 익숙치 않다면 &lt;a class="link" href="http://rubular.com/" target="_blank" rel="noopener"
>Rubular 사이트&lt;/a>의 도움을 받아보도록 하자. (내 경우는 간단하게 &lt;code>/\AISSUE#{iid}/i&lt;/code> 라고 했다.)&lt;/p>
&lt;p>수정을 했다. 하지만 끝이 아니다. 마무리를 해 줘야 한다. 실제 Gitlab이 서비스되고 있는 경로는 &lt;code>/var/opt/gitlab&lt;/code> 이므로, 해당 경로로 적용을 시켜줘야 한다. 어떻게?&lt;/p>
&lt;p>간단하다. &lt;code>gitlab-ctl reconfigure &amp;amp;&amp;amp; gitlab-ctl restart&lt;/code> 를 입력하자.&lt;/p></description></item><item><title>Linux 에서 CPU/Memory/Disk 확인</title><link>https://interp.blog/linux-%EC%97%90%EC%84%9C-cpumemorydisk-%ED%99%95%EC%9D%B8/</link><pubDate>Mon, 30 Oct 2017 08:31:03 +0000</pubDate><guid>https://interp.blog/linux-%EC%97%90%EC%84%9C-cpumemorydisk-%ED%99%95%EC%9D%B8/</guid><description>&lt;p>자주 쓰긴 하지만, 곧바로 생각나지 않을 것을 대비해서&amp;hellip; 서버실 서버 사양을 전부 체크하려다 보니 어쩔 수 없이 정리했다.&lt;/p>
&lt;h2 id="cpu--memory-확인">CPU / Memory 확인&lt;/h2>
&lt;p>CPU / Memory 는 사실 쉽다. &lt;code>/proc/cpuinfo&lt;/code> 와 &lt;code>/proc/meminfo&lt;/code> 안에 들어있기 때문이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat /proc/cpuinfo &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;model name&amp;#34;&lt;/span>  &lt;span class="p">|&lt;/span> sort -u
model name : Intel&lt;span class="o">(&lt;/span>R&lt;span class="o">)&lt;/span> Core&lt;span class="o">(&lt;/span>TM&lt;span class="o">)&lt;/span> i3-4160 CPU @ 3.60GHz
$ cat /proc/meminfo &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;MemTotal&amp;#34;&lt;/span>
MemTotal: &lt;span class="m">8040588&lt;/span> kB
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="disk-확인">Disk 확인&lt;/h2>
&lt;p>&lt;code>df&lt;/code> 는 mount 된 것만 확인이 가능해서 별로고, &lt;code>lsblk&lt;/code> 를 하면 마운트되지 않은 것까지 나온다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda 8:0 &lt;span class="m">0&lt;/span> 477G &lt;span class="m">0&lt;/span> disk
├─sda1 8:1 &lt;span class="m">0&lt;/span> 468.8G &lt;span class="m">0&lt;/span> part /
└─sda2 8:2 &lt;span class="m">0&lt;/span> 8.2G &lt;span class="m">0&lt;/span> part &lt;span class="o">[&lt;/span>SWAP&lt;span class="o">]&lt;/span>
sdb 8:16 &lt;span class="m">0&lt;/span> 2.7T &lt;span class="m">0&lt;/span> disk
&lt;span class="c1">## df 는 sdb가 보이지 않는다.&lt;/span>
$ df -h
Filesystem Size Used Avail Use% Mounted on
/dev/sda1 462G 8.4G 430G 2% /
tmpfs 79G 224K 79G 1% /dev/shm
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>mmap : 메모리를 파일처럼</title><link>https://interp.blog/mmap-memory-block-like-file/</link><pubDate>Wed, 20 Sep 2017 13:29:57 +0000</pubDate><guid>https://interp.blog/mmap-memory-block-like-file/</guid><description>&lt;p>&lt;code>mmap&lt;/code> 은 memory map 의 줄임말이다. 메모리의 특정 영역을 파일 디스크립터로 인식하게 만드는 것이다.&lt;/p>
&lt;blockquote>
&lt;p>map or unmap files or devices into memory&lt;br>
(메모리 영역을 파일이나 디바이스로 인식하게 합니다)&lt;/p>
&lt;p>– manpage of mmap&lt;/p>
&lt;/blockquote>
&lt;h2 id="사용">사용&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">mmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">size_t&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">prot&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">off_t&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 의미가 있는 건 Length, Prot (Protection), Flag 뿐이다.&lt;/p>
&lt;ul>
&lt;li>Start 는, Kernel이 아무 곳이나 지정해도 좋다면 NULL을 입력한다.&lt;/li>
&lt;li>Offset 은, 보통 0으로 둔다. (MAP_ANONYMOUS 또는 MAP_ANON Flag가 있는 경우엔 무시된다)&lt;/li>
&lt;li>Fd 는, 연결할 파일 디스크립터를 지정한다. (MAP_ANONYMOUS 또는 MAP_ANON Flag를 통해서 &amp;lsquo;파일로 사용하지 않는다&amp;rsquo; 라고 한다면 -1을 넣어줘야 한다. (사실 안 넣어주고 무시해도 되지만 몇몇 구현에서는 넣어야 한다 카더라)&lt;/li>
&lt;/ul>
&lt;h2 id="protection">Protection&lt;/h2>
&lt;p>매핑된 메모리 영역의 사용 권한 같은 것을 정하는 것이라고 이해하자. 리눅스 파일 시스템의 권한과 비슷한 분류로 이해하면 더욱 쉽다. (물론 똑같지는 않지만)&lt;/p>
&lt;ul>
&lt;li>PROT_NONE : 메모리 영역은 아무것도 할 수 없다.&lt;/li>
&lt;li>PROT_READ : 메모리 영역을 읽을 수 있다.&lt;/li>
&lt;li>PROT_WRITE : 메모리 영역을 쓸 수 있다.&lt;/li>
&lt;li>PROT_EXEC : 메모리 영역이 실행될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이 때, 연결된 파일 디스크립터의 모드와 절대 충돌해서는 안 된다. 예를 들어 파일 디스크립터를 획득할 때는 &lt;code>w+&lt;/code> 라고 해놓고 여기서 PROT_READ 라고 하면, 예상치 못한 무언가가 일어나지 않을까?&lt;/p>
&lt;p>메모리 영역의 보호에 관련된 자세한 내용은 &lt;a class="link" href="http://man7.org/linux/man-pages/man2/mprotect.2.html" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/p>
&lt;h2 id="flag">Flag&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Flag&lt;/th>
&lt;th>사용 가능 커널&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MAP_SHARED&lt;/td>
&lt;td>–&lt;/td>
&lt;td>이 매핑을 다른 프로세스들이 공유할 수 있다. (실제 파일과 연결되어 반영된다. 하지만 자동으로 반영하지는 않고 &lt;code>msync&lt;/code> 나 &lt;code>munmap&lt;/code> 을 호출해야 반영된다.)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_PRIVATE&lt;/td>
&lt;td>–&lt;/td>
&lt;td>이 매핑을 다른 프로세스들과 공유하지 않는다. 실제 파일과도 연결되지 않으므로, &lt;code>mmap&lt;/code> 이후에 파일에 반영되는 변경 내역이 매핑된 영역에 반영되는지는 확신할 수 없다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_32BIT&lt;/td>
&lt;td>~2.4.20, 2.6&lt;/td>
&lt;td>첫 2GB 안에서 영역을 잡는다. x86-64 프로그램에서만 사용이 가능하다.&lt;br /> (초기 64-bit 프로세서에서는 context-switch 비용 절감을 위해 사용할 수 있는 옵션이겠지만, 지금은 그렇지 않으므로 굳이..)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_ANONYMOUS&lt;br /> MAP_ANON&lt;/td>
&lt;td>–&lt;/td>
&lt;td>파일 디스크립터로 인식하지 않는다. fd와 offset은 무시되지만, 몇몇 구현에서는 fd를 반드시 -1로 입력해야 한다. &lt;br/> ※ SHARED와 같이 사용하려면 Kernel Version 이 2.4 이하여야 한다.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>헉헉.. 아래에 더 있는데 여기까지만 해야겠다. 내가 사용하고자 하는건 사실 ANONYMOUS Flag 만 있으면 되는데 말이지.&lt;/p></description></item><item><title>pthread_yield vs. sleep</title><link>https://interp.blog/pthread_yield-vs-sleep/</link><pubDate>Thu, 24 Aug 2017 05:35:24 +0000</pubDate><guid>https://interp.blog/pthread_yield-vs-sleep/</guid><description>&lt;p>&lt;code>pthread_yield()&lt;/code> 와 &lt;code>sleep()&lt;/code> 의 차이를 묻는 &lt;a class="link" href="https://stackoverflow.com/questions/936993/pthread-what-is-the-difference-between-time-hsleep-and-pthread-hpthread" target="_blank" rel="noopener"
>Stack Overflow 글&lt;/a> 의 답을 발췌한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>pthread_yield()&lt;/code> 는, 호출한 쓰레드가 프로세서 사용을 그만두고, 스케쥴링이 될 때 까지 작업 큐(run queue)에서 기다립니다. 만약 호출되었을 때 작업 큐가 비어 있다면, 즉시 스케쥴링이 되겠죠.&lt;/p>
&lt;p>&lt;code>sleep()&lt;/code> 은 X초만큼 지나거나, 무시할 수 없는 시그널이 도착할 때 까지 (다른 쓰레드를 포함한) 호출 프로세스를 재웁니다.&lt;/p>
&lt;p>현재 쓰레드를 실제로 지연시키고 싶지 않지만 (호출 쓰레드 대신) 다른 쓰레드에게 실행권을 넘겨주고 싶은 경우라면, &lt;code>sleep()&lt;/code> 보단 &lt;code>pthread_yield()&lt;/code> 가 적합할 것 같습니다.&lt;/p>
&lt;/blockquote>
&lt;p>sleep 자체가 프로세스를 아예 멈추게 하니까 pthread_yield 를 통해서 나는 잠시 빠져주는 상태로 만드는 거였다. 코드를 보면서 감으로만 &amp;lsquo;아 저건 sleep() 같진 않지만 뭔가 이럴 때 쓰는거야&amp;rsquo; 라고만 어렴풋이 알고 있었는데, 무엇이든 확실히 알아야 한다.&lt;/p></description></item></channel></rss>
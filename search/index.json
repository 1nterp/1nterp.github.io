[{"content":"📙   도서 정보      모르는 번호로 전화가 오는 건 매우 드문 일이다.\n이제 내가 무언가 시도하거나 무언가를 세상에 던지지 않으면 아무도 나를 찾아주지 않는다.\n그것이 합격이든 당선이든 선정이든.\n 4개월의 작가프로그램에 신청했는데 덜컥 선정되어 떠난 나폴리 여행기를 다룬다. (조만간 꼭 블로그에 남기고픈) 소설 \u0026lsquo;급류\u0026rsquo; 를 쓴 정대건 작가의 2024년 여행 에세이. 밀리의 서재에 있어서 컬러풀한 사진도 그대로 볼 수 있었다.\n나폴리는 사진도 보고 여행기도 읽어보고 했지만, 막상 가보니 더욱 아름다웠고 더욱 지저분했다는 곳. 축구선수 김민재가 끌어올린 한국의 이미지를 한껏 누릴 수 있던 곳. 최고의 에스프레소와 마르게리타 피자, 파니니를 맛 볼 수 있는 곳. 버스 매표소가 따로 없는, 그래서 담배가게에서 버스 매표를 겸하는 곳. 전혀 팔 것 같지 않은 고깃집에 가서도 파니니를 살 수 있는 곳. 버스 시간표는 지켜지지 않고, 그래서 버스 티켓을 구매할 수 없을 정도로 늦은 밤에 막차를 탈 때는 인심좋게 그냥 타라고 하는 곳.\n마치 현지인들의 암호같아 보이지만, 그냥 다른 것이다. 형식이나 규칙에 구애받지 않는 자유로움이 느껴졌다고.\n작가는  피 말리는 시간이었다. 날씨가 영화의 운명을, 나의 운명을 좌지우지하던 시기에 비 소식을 보고 있을 때면 정말이지 하늘이 노랬다. 내 노력으로 커버할 수 없는 변수에 의해 휘둘리는 현장…… 다시는 돌아가고 싶지 않은 시간이다.\n 작가의 개인사를 에세이 사이사이에서 엿볼 수 있었다. 초반에 영화 연출을 시작했지만 잘 되지 않았고, 세상에 쓸모없는 사람으로 느껴졌었다고. 경험을 살려 소설 \u0026lsquo;GV 빌런 고태경\u0026rsquo; 을 집필하고 최근에는 \u0026lsquo;급류\u0026rsquo; 를 쓴 작가가 되었다. 작가가 의무소방으로 군 생활을 보냈단 대목을 읽으면서, \u0026lsquo;급류\u0026rsquo; 에 묘사된 소방관들의 모습이 허투루 느껴지지 않은 것이 맞아 떨어졌다.\n인연은  나폴리에는 ‘카페 소스페소’ 문화가 있다. 소스페소(sospeso)란 ‘매달린’, ‘걸려 있는’, ‘미루어진’이라는 뜻을 가진 이탈리아어다. 즉 카페 소스페소란 ‘맡겨둔 커피’라는 뜻으로, 커피를 마시고 싶지만 가난해서 마시지 못하는 누군가를 위해 나누는 행위다. 혼자 와서 두 잔을 시킨다거나, 두 사람이 와서 석 잔을 시킨다거나 하는 식으로, 누군가를 위해 ‘달아놓는’ 것이다.\n 나폴리의 \u0026lsquo;정\u0026rsquo; 은 책 곳곳에서 느낄 수 있다. 소득격차가 심한 이탈리아 북부에 비해 다 같이 잘 살자는 인정이 특히 이곳에서는 더 짙다고 묘사된다. 앞서 말한 대로 버스도 공짜로 타보기도 하고 말이다.\n작가가 나폴리에서 만난 소중한 인연이 있었다. 양장점에서 꿈을 안고 이탈리아에 와서 자신의 양복을 만들기 위해 견습하고 있는 20대 청년의 이야기다. 성공이 보장된 길도 아닌데, 코로나 때문에 한 번 귀국까지 했다는데, 그럼에도 청년은 꿈을 향해 묵묵히 한 걸음씩 나아갔다. 작가도, 나도 그의 꿈을 응원하게 되었다.\n 에필로그 전 마지막 사진이 화룡정점이다. 화려하지 않지만 이국적인, 한번쯤은 가 보고 싶은 사진들이 이어졌다. 여행 에세이로서 참 잘 읽었단 생각이 든다.\n나는 저렇게 내 이야기를 녹여서 쓸 수 있을까? 노력해 봐야겠다 우선 여행이라도 가야지\n 이 말은 분명히 할 수 있다.\n나는 ‘하면 된다’는 말보다 ‘하면 는다’는 말을 믿는 사람이다.\n재능은 의지가 만드는 것이다.\n ","date":"2025-01-31T15:29:03+09:00","image":"https://interp.blog/my-blue-napoli/book_hudc04a26808375681daca385834192291_769482_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/my-blue-napoli/","title":"나의 파란, 나폴리"},{"content":"Mac 을 업무에 사용하면서 가장 많이 쓰는 앱을 소개하면 좋겠다고 생각했다. 뭐가 있을까? 당연히 Visual Studio Code 겠지만 개발자가 아니더라도 범용적으로 쓸 수 있는 앱을 찾아보기로 했다.\n갑자기, 작업표시줄 위에 떠 있는 1월 25일 (토) 가 보였다. 오늘이 몇월 몇일인지 바로 확인할 수 있는, 이번 주가 몇 번째 주인지 확인할 수 있는, 다른 캘린더와 연결해서 일정을 간단히 확인할 수 있는 앱, itsycal 이다.\n  실제 사용화면\n  시간말고 날짜도 확인하고 싶어 내가 잘 모를 순 있겠지만, 작업표시줄에 시간만 나타낼 수 밖에 없어서 날짜도 바로 확인하고 싶었다.\n홈페이지에서는 영어 포맷으로 나타나나 있지만, 지금처럼 얼마든지 한글로 바꿀 수 있다.\n몇째 주인지 확인하고 싶어 회사 특성상, 일정을 이야기해야 할 때 주 번호 (Calendar Week) 를 자주 언급해야 할 때가 있다. 그래서 지금이 몇째 주인지 빠르게 파악할 수 있어야 하는데, 메일 프로그램인 아웃룩에서도 지원은 한다.\n  \u0026lsquo;설정 \u0026gt; 캘린더 \u0026gt; 주 번호 표시\u0026rsquo; 선택하면 이렇게 보인다 (스크린샷은 영문판)\n  아웃룩 열고 보고 하는게 번거로워 보이기도 했고, 무엇보다 현재 주가 아니라 4월 첫째주는 몇 번째 주야? 를 알려면 그때부터 더욱 복잡해졌기 때문이다. 휙휙 넘겨서 보는게 훨씬 더 쉬운 이 캘린더가 마음에 들었던 이유다.\n다른 앱들은 뭐예요? 아, 표시줄에 있는 다른 앱은 다음과 같다. 따로 소개해 드릴 시간이 있을 것 같다.\n Flow: 뽀모도로 앱이다. 무료로 쓰고, 업무 시간을 기록하기 위한 용도로 간단히 쓴다. Maccy: 남들 다 쓰는 클립보드 저장 앱이다.  가볍고 귀여운 캘린더, 바로 확인할 수 있는 간단한 캘린더를 원하십니까? 그렇다면 지금 바로 설치하세요! 라고 추천해 주고 싶다.\n","date":"2025-01-25T22:29:39+09:00","image":"https://interp.blog/itsycal-mac-calendar/feature_hud8f2c8a2587efb728b7a4f247aa68186_803385_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/itsycal-mac-calendar/","title":"Mac 용 달력 프로그램, itsycal"},{"content":"XBOX PC 게임 패스를 결재한지 2개월차가 되는 어느 날. 프로스트 펑크 2를 하던 중에 한 게임을 발견했다. 이건 뭐지? 음? 대만 게임사? 반교, 환원이라는 공포 게임을 만들었다고? 데드 스페이스 이후로 공포게임은 안 해봤는데. 바이오하자드4 리메이크는 액션 게임이고\n그런데 트레일러가 공포 게임이 아닌데? 횡스크롤.. 맵.. 보스전.. 죽으면 영혼을 떨궈? 이거 마치\u0026hellip;!!\n  익숙한 할로우 나이트의 향기 할로우 나이트는 귀여운 캐릭터와 아기자기한 (!) 그래픽, 밀도있는 맵 구조로 메트로배니아 유저들을 만족시킨 \u0026lsquo;옛날\u0026rsquo; 게임이다. 진 보스를 잡은 기억이 아직도 새록새록 떠오르는데, 2017년 출시니까 벌써 8년 전이다.\n팬들은 후속작인 할로우 나이트: 실크송의 출시를 목빠져라 기다리고 있는데, 2022년에 나온 트레일러가 최신 정보일 정도로 뭐가 없다. 올해는 나올런지 어쩔런지, 올해 출시를 발표한 닌텐도 스위치2 의 독점작이 되는게 아닌가 하는 루머까지 있다. 뭐, 아래 트레일러처럼 게임패스 데이원 출시라고 하니, 일단 믿어보자.\n  이 게임의 주인공 \u0026lsquo;예\u0026rsquo; 역시 뾰족한 귀를 가진 수인처럼 보이기 때문에, 할로우 나이트의 주인공 \u0026lsquo;기사\u0026rsquo; 와 비교될 수 밖에 없다. 기사는 종족이 뭘까 공격 모션도 비슷하고, 인트로에서 떨어지는 이벤트도 비슷해서 더욱 그런 것 같다. 실크송을 기다리다 지친 와중에 본 트레일러가 궁금해서 건드려봤는데, 확실히 더욱 몰입해서 했던 것 같다.\n전투는 소울라이크에 가까운 정확히는 소울라이크 중에서도 패링으로 밥먹고 사는 세키로에 가까운 전투 방식을 선택했다. 반대로 말하면, 패링을 못 하면 아~무것도 못한다. 그래서 제작진이 스토리를 즐기시라고 이지 모드 (=스토리모드) 를 만들 정도이니까. (대신 일반 모드 엔딩 도전과제는 존재한다)\n  이렇게 간단하면 좋겠는데\n  할로우 나이트의 전투가 회피와 딜타임 캐치로 이뤄진 것과는 대조된다. 다양한 패턴을 숙지하고 탄막을 솜씨좋게 피한 다음, 칼을 언제 휘두르고 언제 회복해야 하는지를 정확히 파악해야 했으니까. 하지만 여기서는 오히려 피하기만 할 수가 없고, 정말 세키로처럼 패턴에 맞춰 패링을 하는, 소위 \u0026lsquo;박자 맞추기\u0026rsquo; 가 강제된다.\n그렇다고 마냥 공격을 막는 것만 있느냐. 초반에는 가드 불가 공격이 나오고, 그 중 일부는 공중 밟기로 캔슬이 가능한 공격이 있고, 중반에는 이 가드 불가 공격도 튕겨내는 기술을 배우게 된다. 결국 나중에는 패링조차 삼지선다형 문제로 출제된다는 것이다. 그리고 패링을 할 수 없을 땐 대쉬 회피까지 해야 하니 실제로는 선택지가 더 늘어나게 된다. 정답은 하나 뿐.\n데미지를 넣는 것도 여러 가지가 있다. 피해는 기본적인 체력피해와 더불어 시간이 지나면 회복이 가능한 내상으로 구분되는데, 내상이 아무리 많아도 실제론 죽지 않는다. (그것은 주인공도 마찬가지다) 대신 내상을 모두 피해로 바꾸려면 부적을 붙여 터뜨려야 한다. 보스전에서는 부적 플레이가 강제되는데, 붙이고 나서 터뜨릴 떄 까지의 딜레이 관리를 하지 않으면 흠씬 두들겨 맞고 취소된다.\n  널 강시로 만들어 주겠다\n  그래서 회피일변도로 진행하는 할로우 나이트보다 훨씬 조작이 복잡하게 느껴진다. 복잡한 만큼 다양한 패턴을 경험할 수 있고 더욱 박진감이 넘칠 수도 있으니 이것이 특장점이라고 생각하지만\u0026hellip; 이런 류의 게임을 접해보지 않은 초심자들에게는 엄청난 진입장벽으로 느껴질 수 밖에 없다.\n더욱 풍부한 서사, 그리고 무위사상 할로우 나이트는 엔딩을 보고 나서도 뭔가 와닿는 메시지가 없었다. 그래서 기사는 왜 그런 선택을 하게 된 건지, 기사의 기원은 무엇인지 심연은 어떤 곳인지 등등..\n나인 솔즈도 초반부는 썩 친절하진 않다. 주인공은 인간들과 다르게 생겼는데, 이 인간들이 믿는 신은 주인공과 비슷해 보인다. 진행하다 보면 과학인지 도술인지 모를 세상이 소개된다. 황혼 파수꾼은 누구들이고, 이 곳들은 다 뭐지? 이 모든 파편들은, 마치 조각난 보스들의 기억이 맞춰지듯이, 최후반부에 가서야 모두 들어맞게 된다.\n그렇게 엔딩을 보고 나면, 조금 뻔해 보이기도 한다. 하지만 여기에는 동양에서 흔히 접할 수 있는 도교적 사상이 반영되어 있다고 한다.\n  도교의 핵심 사상은 \u0026lsquo;무위지치(無爲而治)\u0026rsquo;, 아무것도 하지 않음으로써 다스린다는 것이다. 헌데 주인공은 오히려 뭔가를 힘써서 바꿀 수 있다고 믿는다. 모든 여정과 전투가 그렇다. 세계관에서 무위사상을 설파한 옛 현인을 만나기도 하지만, 주인공의 의지는 꺾이지 않는다. 과연 그게 정답일까?\n게임은 주인공에게, 플레이어에게 질문한다.\n 거스를 수 없는 운명을 받아들이는 것은 의미가 없는가?\n운명에 맞서기 위해 노력하는 것은 과연 의미가 있는가?\n 종합해보면 개인적으로 할로우 나이트를 여러모로 뛰어넘은 게임이라고 생각한다. (어쩌면 내 생각과 비슷해서 좋다고 느낄만한) 스토리와 교훈도 있고, 액션도 훨씬 어렵지만 되려 성취감이 있었고, 그만큼 깊게 몰입할 수 있었던 것 같다. 마지막 크레딧 롤과 함께 하는 엔딩 OST 도 감상에 젖어 볼 수 있을 정도로 훌륭했다.\n다만, 액션의 진입장벽이 꽤나 높은 점, 게임 경고문구에도 나오는 잔인한 표현이 많다는 점 (그래서 일부러 수인으로 바꿔서 거부감을 낮췄다고 카더라), 일본 번역팀이 함꼐 번역해서인지 망쳐놓은 한국어 번역 퀄리티 문제는 걸림돌이 될 수 있겠다.\n 그런데, 지금 XBOX PC Game Pass 가 1,500 원에 2달을 즐길 수 있다! 2025년 2월 초까지라고 들었는데, 그 전에 가입만 한다면 나인 솔즈 엔딩은 충분히 볼 수 있을 것이다..!\n  지금이 기회다!\n  ","date":"2025-01-24T21:04:24+09:00","image":"https://interp.blog/nine-sols/feature_huccd4558ee10ed4196238180b68e2097d_1207626_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/nine-sols/","title":"나인 솔즈"},{"content":"📙   도서 정보     작년 일기를 들추다, 너무나 빨리 읽어버린 소설 한 권이 생각났다. 천만관중의 스포츠라 입이 아픈, 그렇다고 어린이 야구단을 했다거나 골수팬은 아니어서 어떤 부심을 부리기도 뭣한 야구 소설. 실상은 야구라는 탈만 썼지, 현실이라는 룰 속에서 낙오된 주인공들의 이야기. 불펜의 시간.\n정말 너무나 빨리 읽어버렸다. 내용이 적어서가 아니라, 그만큼 재밌어서였다. 괜히 문학상 수상작이 아니었나보다.\n유소년시절 그저 그런 야구선수였지만 지금은 회사원으로 일하는 준삼, 그와 같이 야구를 하던 리그 탑급 투수였지만 프로 데뷔 후 타이트한 상황에서는 경기를 망쳐버리는 이상한 투수 혁오, 여자 프로 야구 선수를 꿈꿨지만 스포츠지 기자로 살아가는 기현. 혁오의 이상한 게임 운영은 기현에게 호기심을 불러 일으켰고, 그 사연이 세간에 알려지면서 준삼은 자신의 인생을 돌아보게 된다.\n 야구는 자세로 하는 거야. 자세가 완벽하면 좋은 공이 나올 수밖에 없어. 저렇게 완벽한 자세로 볼넷을 던진다는 건 말이 안 돼. 일부러 던진 게 분명해.\n 보이는 규칙, 보이지 않는 규칙 스포츠는 경쟁이다. 사회는 경쟁이다. 경쟁에는 룰이 존재한다. 그 룰을 지키면서 사는 사람들에게, 룰 바깥에서 일어나는 오리의 물갈퀴질을 아는 척 모르는 척 할 뿐이다. 승부조작, 뇌물, 뒷담화. 남을 깎고 나를 세운다.\n세 명은 나름의 규칙을 지켜가며 살았다고 생각했지만, 숨겨진 규칙들을 깨닫고는 큰 박탈감에 빠지게 된다. 아니, 어쩌면 우리 모두가 아예 몰랐거나 쉬이 무시했던 것일지도 모른다. 조직에서의 경쟁, 나와 팀의 충돌, 성차별적 요소.\n지킬거 잘 지키면 안 건드린다 는 주말 행보관의 말이 모포자락 먼지만큼 가볍게 펄럭이듯.\n현실에서도, 선수가 못 하면 승부조작했냐고 비이냥 거리잖나. 마음 나쁘게 먹은 선수들에게는 그게 또 다른 룰이었을지도 모르겠다. 야구라는 승패와 전혀 상관없는 것 말이다. 하지만 작가는 따끔히 선을 긋는다. 팬을 내쫓는 가장 빠른 방법, 기만질이나 다름 없다면서 말이다.\n야구 팬이라면 더욱 재밌을 것들 탈을 썼다 한 들, 이 소설은 야구 선수였고 야구 선수인 인물들의 이야기다. 볼넷을 주는게 뭐가 나쁘냐, 무사 1,2 루라는 말조차 무슨 뜻인지 모르면 이해하기 힘들 수 있겠다. 반대로, 야구를 좋아하는 사람이라면 더욱 재미있게 읽을 수 있다는 것이다. 상황이 무엇을 이야기하는지 말하지 않아도 알 수 있으니까.\n지명이 나오지 않지만, 준삼과 혁오가 같이 다니던 지역은 대구일 가능성이 높다. 준삼의 아버지와 함께 들렀던 야구장이 대구시민구장의 모습과 흡사하기 때문이다.\n 그런 풍경 끝에 마주한 시민 야구장은 TV로 봤던 것보다 아담하고 소박했다. 외벽 군데군데 페인트칠이 벗겨져 있었고, 금이 가서 임시로 때운 흔적도 눈에 띄었다. 준삼은 약간 실망했지만, 시민 야구장이 전국에서 제일 낡았다는 친구의 말에 아는 체를 할 수 있게 되어 기쁘기도 했다.\n 홈런? 삼진? 그래서 세 명은 갖은 시련을 이겨내고 홈런을 쳤을까? 아니면 거대한 세상에 압도당해 삼진을 당할까? 이 소설의 결말을 이야기하는 것은 실례다. 하나 확실한 것은, 소설을 읽는 내내 이 세명과 함께 롤러코스터를 타게 될 것이다.\n이 이야기는 그래서 거대한 세상을 향해 날을 세운다. 보이지 않는 룰에서 밀려난 사람들, 그래서 똘똘 뭉쳐서 멀리 우리를 던진다. 지금 글을 쓰고 있는 시점에서도 우리는 그렇다. 원하는 바가 멀어 보여도, 우리가 작아 보여도, 사람들은 마음 단단히 던진다.\n 새롬이 천천히 말했다. “우린 쉽게 무너지지 않는 걸 만들고 싶어 해. 작아도 단단한 거, 어쩌면 작아서 단단한 거. 네가 한 말은 그래서 멀어.”\n ","date":"2025-01-06T21:28:51+09:00","image":"https://interp.blog/time-of-the-bullpen/feature_hu9c5762197529a6e79a71c15a82c1a3c9_84733_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/time-of-the-bullpen/","title":"불펜의 시간"},{"content":"📙   도서 정보     Github Copilot 을 사내에서 쓰면서, 단순 코딩 작업이나 반복작업을 떠넘기기 바빴었다. 물론 그것만으로도 효율이 올랐지만, 좀 더 스마트한 사용 케이스가 분명 있을 것이라는 기대가 있었다.\n종종 다른 팀원의 코드를 리뷰할 때 /explain 도 사용하는데, 이 내용을 기반으로 코드를 읽으면 훨씬 더 잘 보이는 것도 같아서 말이다. 최근에는 아예 Copilot 이 자체적으로 Code Review 해주는 기능도 추가되었으니, 다른 곳에서도 더 빠르면서도 준수한 결과를 내 줄 수 있지 않을까? 하는 궁금증이 생겼다. 말 그대로 \u0026lsquo;완벽한\u0026rsquo; 결과가 아닌 \u0026lsquo;일정한 수준의 결과를 빨리 처리할 수 있는\u0026rsquo; 그런 기대 말이다.\n이 책은 AI 페어 프로그래밍이라는 주제로, 사수가 없어도 Github Copilot 과 ChatGPT 를 이용하여 페어 프로그래밍을 할 수 있는 방법을 소개한다.. 고 한다. 아마 이런 분들이 도움이 될 것 같다.\n Github Copilot 자체를 잘 모르는 사람 프롬프트 자체를 어떻게 써야 할지 막막한 사람 (ChatGPT, Claude 사용 예제가 일부 나오기 때문) (나처럼) Copilot 으로 대체 뭘 할 수 있는데..? 를 알아보고 싶은 사람  프롬프트 엔지니어링 프롬프트 엔지니어링은 인공지능 모델에게 원하는 결과를 얻기 위해 입력 내용을 설계하는 과정이다. 쉽게 말해서, LLM 의 대답이 원하는 대로 나오도록, 질문이나 요청을 구체적이고 효과적으로 표현하는 기술이다.\n단순한 명령 대신 맥락과 의도를 명확히 하면 AI가 더 정확한 답을 내놓을 가능성이 높아진다. 예를 들어, \u0026ldquo;커피 만드는 법 알려줘\u0026rdquo; 라고 하면 일반적인 방법이 나올 수 있지만, \u0026ldquo;간단한 재료로 집에서 만드는 달고나 커피 레시피를 알려줘\u0026rdquo; 라고 하면 특정한 요구에 맞는 답을 얻을 수 있다. 프롬프트 엔지니어링은 이렇게 질문의 범위와 디테일을 조정해 원하는 결과를 끌어내는 데 초점을 맞춘다.\n책에서 소개하는 방법이 있지만, 소개된 방법이 전부 정리된 (그리고 더 많은 기법들이 포함된) 웹 페이지가 기재되어 있다.\n🔗 https://www.promptingguide.ai/kr\nGithub Copilot 기본적인 사용 케이스는 아래와 같다.\n 버그 픽스 코드 작성 코드 리팩토링 코드 검사 (Static Code Analysis 같은) 데이터 생성 README 문서 작성 Mermaid 다이어그램 생성  책에서 소개되는 예제는 너무나 단순해서, 현업에서 쓰기엔 아직 무리가 있어 보이지만 흥미가 돋는 부분은 마지막 두 부분이다. 바로 문서 작성과 다이어그램 그려주기이다.\n예~전에 내가 OOP 와 SE 강의를 들으면서 상상한 것이, 어떤 프로젝트의 Spec 과 Stub 을 꾸며주면 그에 맞는 내부 로직은 알아서 구현해주는 다소 비현실적인 꿈이었다. 그런데 만약에 어떤 프로젝트 결과를 보여주고 README 를 작성하게 하거나, 혹은 반대로 README 와 Mermaid 로 State/Flow/Class Diagram 을 그려주면 자기가 이해하고 코드를 드르륵 짜 주는 게 혹시 가능하지 않을까?\nmermaid 문법을 모르진 않았는데, Copilot 에게 이해한 대로 그려보라고 시키면 괜찮은 결과가 나오리라 믿었다. 음.. 현실은 기대만큼 따라주진 않았지만 적어도 얼개는 잡아주는 것 같아서 절반의 성공이라고 봐야겠다.\n건진 게 있다면, 나에겐 훌륭한 책 책이 두껍지 않아, 한번 훓기에 좋은 책이었다. 물론 내용이 어렵지 않아서 그런 것일 수도 있지만.\n대학교 때 HTML 관련 책을 동아리방에서 본 적이 있었다. 예전부터 해왔던 거라 다 알고 있다고 생각했는데, 웬걸. 잘 모르는 내용이 나왔고, 그 부분을 다질 수 있는 기회가 되었다. 책의 분량으로 치면 매우 적을지도 모르지만, 그래도 그 부분만큼 내가 얻어갈 수 있었기에 책을 고르는 데 주저함이 없었다.\n그래서 책을 읽는다는 건 많은 것을 얻기보다, 한 가지라도 건질 수 있다면 충분히 가치 있는 일이라 생각한다. 부족한 부분을 채워주거나 새로운 관점을 열어준다면 그걸로 훌륭한 길잡이가 된다. 지금 리뷰하는 이 책도 그런 작은 깨달음을 선사했기에, 기쁘게 리뷰를 남겨본다.\n","date":"2024-12-29T21:22:25+09:00","image":"https://interp.blog/ai-pair-programming/feature_hudcaf8fc02701773a6e828ed8900586f7_963286_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/ai-pair-programming/","title":"AI 페어 프로그래밍"},{"content":"📙   도서 정보     책 리뷰를 쓰기 전에, 거의 1년 넘게 리뷰를 쓰지 않았다는 사실이 충격적이다. 작년보다 책은 더 많이 읽었는데, 오히려 \u0026lsquo;이거 써서 뭐하나, 누가 읽어주는 것도 아니고\u0026rsquo; 같은 생각이 머리를 지배하고 있었던 것 같다. 문득 블로그를 하는 이유에 대해 진지하게 고민했는데, 늘 같은 결론에 도달하게 되었다. \u0026lsquo;쌓아가는 습관\u0026rsquo; 을 들이고 그것을 증명할 수 있는 수단으로써 블로그를 하는 것이다, 라고.\n그래서, 최근에 읽었던 것 중 가장 가볍게 읽었고 \u0026lsquo;각 잡고\u0026rsquo; 배우려 하거나 머리를 싸매지 않았던 매우 즐거운 책을 한 권 골라 쓰려고 한다. 스마트폰으로 사진을 찍는 방법에 관한 책, \u0026lsquo;오늘도 스마트폰으로 인생사진을 찍습니다\u0026rsquo; 이다.\n사진을 보면 알겠지만, 도서관에서 대출한 책이다. IT와 가까운 책들은 언제나 출판년도에 민감할 수 밖에 없고, 이 책은 2023년 8월에 출간되어 도서관 안에서 \u0026lsquo;스마트폰 사진 촬영\u0026rsquo; 분야에서는 가장 막내였다. \u0026lsquo;사진 촬영\u0026rsquo; 분야로 가면 다른 유망주가 있을 순 있겠으나, 보통은 에세이거나 이론에 빠삭하기만 한 친구들이었기에, \u0026lsquo;가볍게 읽을 수 있으면서 유익한\u0026rsquo; 이 책에 손이 가게 되었다.\n책의 구성은 크게 2가지로 나뉘는데, 사진을 어떻게 찍는가와 사진을 찍고 나서의 보정법에 대한 것이다.\n사진을 찍는 방법 들어서면 스마트폰 카메라 그립을 아주 친절히 설명해주고, 그 다음 아주 기초적인 팁 두 가지를 알려준다.\n 세로로 찍을 때는 카메라가 아래로 오도록 뒤집어서 찍는다. 렌즈를 항상 잘 닦아라!  카메라가 보는 각도와 사람이 보는 각도가 달라서, 그 구도를 맞추는 연습을 많이 해 둬야 한다고 한다. 안 그러면 보정으로는 도저히 잡을 수 없는 공간의 뒤틀림을 만들어낼 수 있다. 결국 연습인가 보다. 스마트폰은 크게 아이폰 또는 안드로이드일텐데, 두 OS 모두에 대한 카메라 설정 팁을 알려주는 게 매우 좋았다. 어떤 건 꺼 두는게 좋고, 어떤 건 화면에 나타내면 좋고 이런 것들 말이다. 2023년 기준이면 iPhone 14 Pro 와 Galaxy S23 Ultra 를 기준으로 설명하니까, 지금 시점에서도 나름 최신(?) 인 셈.\n  스마트폰 촬영 관련 다양한 웹페이지에서 알려주는 \u0026lsquo;격자 활용하기\u0026rsquo; 내용이 여기서도 나온다. 수평/수직을 맞출 때 필요한 격자선에서, 격자점 구도나 2:1 구도 등의 내용이 이어진다. 이것도 물론 연습이 필요하겠다! 태양을 피하지만 말고, 언제 찍어야 사진이 잘 나오는지도 짧게 설명하고 있다. 야경은 깜깜한 밤 말고 해 지고 난 직후!\n책 전반적으로, 피사체 하나가 아닌 피사체와 어울리는 것들을 곁들이는데 공을 들이라 는 암묵적인 조언이 퍼져있었다. 스마트폰으로 카페 사진을 많이들 찍을텐데, 커피만 찍지 말고 근처 소품을 곁들이거나 디자인이 담긴 명함이나 코스터를 옆에 두고 찍어보라고 조언한다. 제품을 그냥 맨바닥에 찍지 말고 침대 이불이나 식탁보를 써서 배경을 재밌게 만드는 방법도 소개하고, 보딩 패스를 찍고 싶다면 여행용 아이템을 곁들이는 방법 등등에서 이런 메시지가 들어가 있었다.\n사진을 보정하는 방법 여기서는 딱 하나의 앱만 소개한다. 바로 Snapseed! 구글에서 만든 사진 편집 앱으로, 무료임에도 불구하고 매우 강력한 편집 기능을 제공한다. 하지만 다른 앱에 비하면 직관적이진 않은 인터페이스 때문에 \u0026lsquo;이게 뭐시여\u0026rsquo; 하고 넘어갔을 수 있다. 이 책에서 말하는 대로만 따라해 보니, 꽤 자유도 높은 사진 보정을 할 수 있었다.\n이 책을 읽고 처음 알게 되었는데, 갤럭시의 AI 지우개 처럼 사진의 잡티 (또는 걸리적거리는 피사체) 를 없애는 \u0026lsquo;잡티 제거\u0026rsquo; 기능이 있다! 물론 피사체가 충분히 작아서 지워도 괜찮을 때만 효과적이고, 당연히 AI 보정을 해주는 갤럭시 지우개가 훨씬 더 좋기는 하지만 만만하게 쓰기에는 괜찮은 기능이었다.\n그 밖에도 \u0026lsquo;화사한 글로우\u0026rsquo; 로 소위 \u0026lsquo;뽀샤시\u0026rsquo; 한 사진을 만들거나 \u0026lsquo;거친 필름\u0026rsquo; 으로 옛날 사진 효과를 낸다거나, \u0026lsquo;빈티지\u0026rsquo; 로 비네트 효과를 줄 수 있는 방법을 소개한다. 그저 스타일 탭에서 몇개 골라서 누르는게 아니라, 내가 원하는 효과들을 쌓아서 다른 사진들엔 한번에 적용할 수 있는 스타일을 직접 만들 수도 있는 것이다!\n한 가지 아쉬운 점은, 책에서 제공하는 네 가지 스타일을 다운로드 할 수는 없었다. 스타일을 공유할 수 있는 snapseed.com 사이트가 더 이상 운영하지 않는 것 처럼 보였기 때문이다. 🥲\n스마트폰 카메라가 가지는 강력함 내 첫 카메라는 고등학교 때부터 썼던 코니카 KD-100. 삼성케녹스 X85, 소니 최초의 DSLT 로 광고하던 a55 를 차례대로 썼었고, 지금은 감성 카메라로 쳐주던 후지필름 X100F 를 남기게 되었다.\n하지만 X100F 가 밖으로 나가는 일이 점점 줄어들고 있다. 내 iPhone 15 와, 와이프의 갤럭시 S23 으로 그냥저냥 찍어대고 있다. 센서 크기에서 차이가 난다는 것, 그래서 X100F 로 찍은 결과물이 월등히 좋은 것, 물론 안다. 하지만 인화할 게 아니고 인스타로 소비될 거라면, 오히려 구도 잘 잡고 보정 잘 하는 것이 더 효율적이지 않을까? 게다가, (이건 X100 시리즈의 문제기도 한데) 스마트폰으로 촬영하면 GPS 동기화도 잘 되니 어디서 언제 찍었는지 지오태깅할 때 화딱지 날 일도 없다. 클라우드 동기화는 또 얼마나 잘 되는지! 점점 스마트폰 카메라가 대세가 되니, 이런 책의 도움을 받는 것도 나쁘지 않다고 생각한다. 😍\n","date":"2024-12-25T21:14:18+09:00","image":"https://interp.blog/photography-with-smartphone/feature2_huf22f6ecf165ffba98ff4167e54f05916_1121827_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/photography-with-smartphone/","title":"오늘도 스마트폰으로 인생사진을 찍습니다"},{"content":"OpenTelemetry는 소프트웨어의 성능과 동작을 분석하기 위한 텔레메트리 데이터(메트릭, 로그, 트레이스)를 생성하고 수집하며 내보내는 데 도움을 주는 API, SDK 및 도구 모음이다. 이는 개발자와 운영팀이 소프트웨어 시스템을 관찰하고 문제를 해결하는 데 필수적인 정보를 제공한다. OpenTelemetry는 여러 프로그래밍 언어에 걸쳐 일반적으로 사용할 수 있으며, 생산 환경에서도 안정적으로 사용할 수 있도록 설계되었다.\nOpenTelemetry의 핵심 요소 트레이스(Traces) 트레이스는 요청이 시스템을 통해 이동하는 경로를 기록한다. 트레이스를 통해 애플리케이션의 각 서비스가 어떻게 상호작용하는지, 성능 병목 현상은 어디에 있는지를 파악할 수 있다. 이는 문제 해결에 필수적인 정보를 제공한다.\n메트릭(Metrics) 메트릭은 시스템의 성능 지표를 수집하고 이를 분석하는 데 도움을 준다. 예를 들어, 요청 처리 시간, 시스템 리소스 사용량, 응답 속도 등을 모니터링할 수 있다. 이를 통해 시스템의 상태를 주기적으로 평가하고, 비정상적인 상태를 빠르게 감지할 수 있다.\n로그(Logs) 로그는 시스템에서 발생한 사건을 기록한 텍스트 데이터를 의미한다. 오류 메시지나 경고를 포함한 로그는 시스템의 문제를 추적하는 데 매우 유용하다. OpenTelemetry는 로그 데이터를 수집하여 관련된 트레이스나 메트릭과 결합하여 보다 명확한 관찰 정보를 제공한다.\nOpenTelemetry의 특징 통합성 및 호환성 OpenTelemetry는 여러 인기 있는 라이브러리와 프레임워크와 쉽게 통합된다. 코드 기반의 계측뿐만 아니라 제로 코드 계측도 지원하므로 개발자는 쉽게 OpenTelemetry를 기존 시스템에 적용할 수 있다.\n오픈 소스 및 공급업체 중립성 OpenTelemetry는 100% 무료이며 오픈 소스이다. OpenTelemetry의 가장 큰 특징 중 하나는 바로 제품 불가지론적(product agnostic) 이라는 점이다. 이는 특정 제품이나 플랫폼에 종속되지 않고, 다양한 시스템과 기술 스택에서 동일한 방식으로 사용할 수 있음을 의미한다.\n\u0026ldquo;불가지론(不可知論)\u0026rdquo; 이란 특정한 명제에 대해 의견을 강하게 주장하지 않는 태도를 의미한다. 이 말을 적용해 보면, OpenTelemetry는 특정 벤더나 도구에 의존하지 않고 다양한 환경에서 독립적으로 작동할 수 있는 특성을 가진다는 것을 의미한다. 이로 인해 OpenTelemetry는 여러 기업이나 팀들이 서로 다른 기술 스택을 사용하고 있더라도 손쉽게 통합할 수 있는 장점을 제공한다.\nCNCF 인큐베이팅 프로젝트 OpenTelemetry는 클라우드 네이티브 컴퓨팅 재단(CNCF)에서 인큐베이팅 중인 프로젝트로, 업계의 여러 주요 기업들이 채택하고 지원하고 있다.\n실제 예제 Instrumentation SDK 예제 OpenTelemetry를 사용하여 애플리케이션에 계측을 추가하는 첫 번째 단계는 Instrumentation SDK를 사용하는 것이다.\n아래는 Python을 예로 든 간단한 코드이다.\nfrom opentelemetry import trace from opentelemetry.ext import requests from opentelemetry.sdk.trace import TracerProvider from opentelemetry.sdk.trace.export import ConsoleSpanExporter, SimpleSpanProcessor # 트레이서 프로바이더 설정 trace.set_tracer_provider(TracerProvider()) tracer = trace.get_tracer(__name__) # Span을 추적하고 로그를 출력하는 예제 with tracer.start_as_current_span(\u0026#34;foo\u0026#34;): print(\u0026#34;Hello from OpenTelemetry!\u0026#34;) 이 코드는 OpenTelemetry SDK를 사용하여 \u0026ldquo;foo\u0026quot;라는 트레이스를 시작하고, 그 트레이스 내에서 print 명령을 실행한다. 이를 통해 애플리케이션에서 트레이스를 추적할 수 있다.\nOTel Collector 예제 OpenTelemetry Collector는 여러 출처에서 수집된 텔레메트리 데이터를 중앙화하여 내보내는 데 사용된다. 아래는 OTel Collector를 설정하는 간단한 예제이다.\nreceivers:otlp:protocols:grpc:exporters:logging:loglevel:debugservice:pipelines:traces:receivers:[otlp]exporters:[logging]이 설정 파일은 OTLP(OpenTelemetry Protocol) 수신기를 설정하여 데이터를 수집하고, 수집된 트레이스를 로깅으로 출력한다. OTel Collector를 통해 여러 데이터 출처에서 수집된 데이터를 중앙에서 관리할 수 있다.\n장점과 한계점 OTel 의 장점은 다음과 같다:\n 효율적인 관찰 가능성: OpenTelemetry를 통해 시스템의 모든 동작을 상세히 추적하고 모니터링할 수 있다. 이는 성능을 최적화하고 문제를 빠르게 해결하는 데 중요한 역할을 한다. 다양한 언어 지원: OpenTelemetry는 여러 프로그래밍 언어를 지원하며, 각 언어의 특징에 맞는 SDK와 도구들을 제공한다. 확장성: OpenTelemetry는 대규모 시스템에서도 문제없이 사용할 수 있도록 설계되어, 분산 환경에서의 관찰 가능성을 극대화한다.  그러나, OpenTelemetry에는 다음과 같은 한계점도 존재한다:\n 높은 학습 곡선: OpenTelemetry는 많은 기능을 제공하지만, 이를 제대로 활용하기 위한 학습 곡선이 존재한다. 다양한 구성 요소와 설정이 있기 때문에 처음 시작할 때 복잡할 수 있다. 특히, 분산 시스템에서 여러 서비스를 모니터링하려면 관련 개념과 툴에 대한 충분한 이해가 필요하다. 자원 소모: OpenTelemetry는 많은 데이터를 수집하고 처리하기 때문에 시스템 자원을 소모할 수 있다. 대규모 애플리케이션에서는 데이터 수집량이 많아지며, 그에 따라 네트워크 대역폭, CPU, 메모리 등을 많이 사용할 수 있다. 따라서 OpenTelemetry를 설정할 때 성능을 고려해야 한다. 데이터 정확도: OpenTelemetry는 다양한 소스에서 데이터를 수집하고 이를 통합하지만, 모든 환경에서 정확한 데이터를 보장하지는 않는다. 일부 환경에서는 계측이 제대로 작동하지 않거나, 데이터 누락이 발생할 수 있다. 이는 OpenTelemetry가 아직 발전 중인 기술이기 때문에 발생할 수 있는 문제다. 설정 복잡성: OpenTelemetry는 매우 유연하지만, 그만큼 설정이 복잡해질 수 있다. 특히 대규모 분산 시스템에서는 각 서비스마다 별도의 설정과 구성이 필요할 수 있으며, 여러 시스템과의 통합이 점점 더 어려워질 수 있다.  결론 OpenTelemetry는 소프트웨어 시스템의 성능을 관찰하고 문제를 해결하는 데 필수적인 도구이다. 트레이스, 메트릭, 로그 데이터를 종합적으로 분석할 수 있어 시스템의 상태를 명확하게 파악하고, 효율적으로 성능을 개선할 수 있다. 오픈 소스이며 다양한 언어와 통합이 가능하다는 점에서 개발자와 운영팀에게 매우 유용한 도구이다.\n","date":"2024-12-23T09:30:00+09:00","permalink":"https://interp.blog/opentelemetry-introduction/","title":"성능 관찰 및 시스템 분석을 위한 OpenTelemetry"},{"content":"yq는 jq 에서 쓸 수 있는 jsonpath 를 YAML 파일에 구사할 수 있는 CLI 도구이다. 여기서 소개하는 yq 는 mikefarah/yq 를 뜻한다.\n이 글에서는 yq의 설치 방법과 기본적인 사용법을 간단히 살펴본다.\nyq 설치 방법 Homebrew로 설치 (macOS/Linux) Homebrew를 사용하면 yq를 간단히 설치할 수 있다. 터미널에서 아래 명령어를 입력하면 된다.\nbrew install yq 설치가 끝난 뒤에는 yq --version 명령어로 설치 여부를 확인할 수 있다.\n기타 설치 방법 Homebrew 외에도 yq는 여러 가지 방법으로 설치할 수 있다. 운영 체제와 환경에 맞는 방법을 선택하면 된다.\n 공식 다운로드 링크: 바이너리를 직접 다운로드해서 설치 Snap 패키지 (Linux): snap install yq Windows: Chocolatey 또는 Scoop으로 설치  더 자세한 설치 방법은 공식 문서에서 확인할 수 있다.\nyq의 주요 기능 yq는 YAML 데이터를 쉽게 관리할 수 있는 다양한 기능을 제공한다.\nYAML 읽기 YAML 파일에서 특정 데이터를 읽는 것은 아주 간단하다.\nyq \u0026#39;.person.name\u0026#39; file.yaml 위 명령어는 file.yaml 파일에서 person 아래 name 값을 출력한다.\nYAML 수정 YAML 데이터를 업데이트할 수도 있다. -i 옵션을 사용하면 파일을 직접 수정할 수 있다.\nyq -i \u0026#39;.person.name = \u0026#34;인터피\u0026#34;\u0026#39; file.yaml JSON과 YAML 간 변환 yq는 JSON과 YAML을 손쉽게 변환할 수 있다.\nyq -Poy sample.json 이 명령어는 sample.json 파일을 YAML 형식으로 변환한다.\n4. 여러 파일 병합 여러 YAML 파일을 병합하는 것도 가능하다.\nyq -n \u0026#39;load(\u0026#34;file1.yaml\u0026#34;) * load(\u0026#34;file2.yaml\u0026#34;)\u0026#39; 5. 환경 변수 사용 환경 변수를 활용할 때는 strenv() 를 사용해야 한다. $... 는 먹지 않으므로 주의. 아래 예제는 환경변수 $NAME 을 가지고 YAML 데이터를 업데이트한다.\nbash NAME=\u0026#34;인터피\u0026#34; yq -i \u0026#39;.person.name = strenv(NAME)\u0026#39; file.yaml yq 의 장점  다양한 형식 지원: YAML뿐만 아니라 JSON, XML, CSV 등도 다룰 수 있다. 유연한 구문: jq 에서 쓸 수 있는 jsonpath syntax 로 간단히 작업할 수 있다. 데이터 보존: YAML 의 주석과 포맷을 유지하면서 데이터를 수정할 수 있다. 개발자 친화적: CI/CD 파이프라인에도 쉽게 통합할 수 있다.  공식 문서와 커뮤니티 yq에 대해 더 알고 싶다면 공식 문서를 확인해 보자. 명령어 사용법과 고급 기능에 대한 예제가 잘 정리되어 있다.\n 공식 문서 GitHub Repository: mikefarah/yq  ","date":"2024-12-13T14:07:39+09:00","permalink":"https://interp.blog/yq-yaml-parser/","title":"yq: YAML Parser"},{"content":"지난 포스팅 에 이어, 오늘은 Template 내부에 생성되는 공백을 유지하는 방법을 알아보자. 사실 이 부분 역시 Helm 문서에 나와있는 내용을 요약한 것이다.\n준비 helm create tempchart rm -rf tempchart/charts tempchart/templates/* tempchart/values.yaml cat \u0026lt;\u0026lt;EOF \u0026gt; tempchart/templates/test.yaml data: drink: {{ .Values.drink }} {{ if eq .Values.drink \u0026#34;coffee\u0026#34; }} mug: \u0026#34;true\u0026#34; {{ end }} EOF 이렇게 만든 test.yaml 파일을 보면, .Values.drink 값이 coffee 일 때에는 추가로 data.mug attribute 를 true 로 추가한다.\ndata:drink:{{.Values.drink }}{{if eq .Values.drink \u0026#34;coffee\u0026#34; }}mug:\u0026#34;true\u0026#34;{{end }}공백이 그대로 남아요! drink 가 coffee 가 아닌 경우라면, 아래와 같이 data.drink 만 가지는 yaml 파일이 생성된다.\nhelm template tempchart --set drink=\u0026#34;tea\u0026#34; ---# Source: tempchart/templates/test.yamldata:drink:teacoffee 로 설정하면 data.mug attribute 가 추가될텐데..\nhelm template tempchart --set drink=\u0026#34;coffee\u0026#34; 뭔가 이상하다. 저 공백은 무엇인가?\n---# Source: tempchart/templates/test.yamldata:drink:coffeemug:\u0026#34;true\u0026#34;해결방법 Helm 문서의 설명은 다음과 같다.\n First, the curly brace syntax of template declarations can be modified with special characters to tell the template engine to chomp whitespace. {{- (with the dash and space added) indicates that whitespace should be chomped left, while -}} means whitespace to the right should be consumed. Be careful! Newlines are whitespace!\n먼저, 템플릿 선언의 중괄호 ({ 와 }) 구문은 특수 문자를 사용하여 템플릿 엔진에 공백을 제거하도록 지시할 수 있습니다. {{- (대시와 공백이 추가된 경우) 는 왼쪽의 공백을 제거해 달라는 것이고, -}} 는 오른쪽의 공백을 제거해 달라는 것을 의미합니다. 주의하세요! 줄 바꿈도 공백입니다!\n 따라서 이 줄바꿈을 제거하기 위해 {{- 를 사용하면 된다.\ndata:drink:{{.Values.drink }}{{- if eq .Values.drink \u0026#34;coffee\u0026#34; }}mug:\u0026#34;true\u0026#34;{{- end }}양쪽에 다 사용하면 안 된다. 이렇게 에러가 발생한다.\nError: YAML parse error on tempchart/templates/test.yaml: error converting YAML to JSON: yaml: line 2:mapping values are not allowed in this contextUse --debug flag to render out invalid YAML","date":"2024-08-08T21:57:01+09:00","permalink":"https://interp.blog/helm-template-preserve-space/","title":"Helm Template 공백 유지하는 방법"},{"content":"Helm Templating 을 하다 보면, 값에 들어가 있는 따옴표를 그대로 보존해야 하는 상황이 발생한다. 다음과 같은 경우엔 어떻게 할 것인가?\nkind:Secretspec:data:password:{{.Values.password }}helm template mychart --set password=\u0026#34;my\u0026#39;password\u0026#34; # 성공 helm template mychart --set password=\u0026#34;my\\\u0026#34;\u0026#39;password\u0026#34; # YAML parse error helm template mychart --set password=\u0026#39;my\u0026#34;password\u0026#39; # YAML parse error \u0026gt;- 사용하기 처음으로 할 일은 spec.data.password 을 다음과 같이 \u0026gt; (angle bracket, greater-than-sign 이라고 부르더라) 와 - 의 조합으로 바꾸는 것이다.\npassword:\u0026gt;-{{.Values.password }}이게 뭔가요? 이건 Helm Template Engine 기술이 아니라 YAML 테크닉의 일종이고, 문자열 보존을 위한 목적도 아니다. Helm 문서1를 먼저 보면,\n Sometimes you want to represent a string in your YAML with multiple lines, but want it to be treated as one long line when it is interpreted. This is called \u0026ldquo;folding\u0026rdquo;. To declare a folded block, use \u0026gt;.\nYAML에서 문자열을 여러 줄로 표현하고 싶지만, 하나의 긴 줄로 나타내고 싶을 때가 있습니다. 이것을 \u0026ldquo;접기(folding)\u0026ldquo;라고 부르죠. 접혀야 할 블록을 선언하려면, \u0026gt; 를 사용하세요.\n 더 정확한 설명을 해 주는 YAML Multiline 문서2를 요약해 보면,\n Block 을 유지하려면 |, 한 줄로 접으려면 \u0026gt; Block 마지막에 줄바꿈을 넣는 것이 기본값, 넣지 않으려면 - 를 붙이고, 모든 줄바꿈을 유지하려면 (| 일 때만) + 를 붙인다.  그래서 \u0026gt; 만 사용하면 줄바꿈이 들어간 값을 얻기 때문에, 정확히 우리가 원하는 것은 아니다. \u0026gt;- 를 써야 한다.\n예제 적용하기 앞서 helm template 결과는 다음과 같이 나오는데,\n# helm template mychart --set password=\u0026#34;my\\\u0026#34;\u0026#39;password\u0026#34;---kind:Secretspec:data:password:\u0026gt;-my\u0026#34;\u0026#39;password# helm template mychart --set password=\u0026#39;my\u0026#34;password\u0026#39;kind:Secretspec:data:password:\u0026gt;-my\u0026#34;password# helm template mychart --set password=\u0026#34;my\u0026#39;password\u0026#34;kind:Secretspec:data:password:\u0026gt;-my\u0026#39;password어? spec.data.password 에 여전히 \u0026gt;- 가 남아있고, 값 앞에 줄바꿈도 되어 있는데 읽으면 이상한거 아니예요? 그렇지 않다.\nmikefarah/yq3을 사용해서 쿼리해 보면 정상적으로 나오는 것을 확인할 수 있다.\nhelm template mychart --set password=\u0026#34;my\\\u0026#34;password\u0026#34; | yq \u0026#39;.spec.data.password\u0026#39; -r my\u0026#34;password helm template mychart --set password=\u0026#34;my\\\u0026#34;\u0026#39;password\u0026#34; | yq \u0026#39;.spec.data.password\u0026#39; -r my\u0026#34;\u0026#39;password helm template mychart --set password=\u0026#39;my\u0026#34;password\u0026#39; | yq \u0026#39;.spec.data.password\u0026#39; -r my\u0026#34;password   https://helm.sh/docs/chart_template_guide/yaml_techniques/#folded-multi-line-strings\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://yaml-multiline.info/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/mikefarah/yq/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2024-08-07T09:59:24+09:00","permalink":"https://interp.blog/helm-template-value-preserve-string/","title":"Helm Template Value 의 문자열 값 보존하기"},{"content":"현재 하고 있는 작은 프로젝트는, 변경 내용을 main branch 에 반영하고 나서 추가 작업이 이루어지는 구조를 하고 있다. 문제는 이 \u0026lsquo;추가 작업\u0026rsquo; 을 Pull Request 에서 진행하더라도, main branch 와 working branch 사이에 어떤 결과물 차이가 있는지 눈으로 확인하기가 쉽지 않았다. 그래서, 아예 두 branch 에서 작업을 진행시키고, 진행한 결과를 diff 로 확인하면 어떨까 싶었다.\nPull Request (PR) 를 등록할 때, Github Workflow 를 이용해서 PR Comment 를 등록하는 방법을 찾아보았다. 이 글에서는, Github Workflow 에서 실행한 결과물을 그대로 PR Comment 로 등록하는 방법을 소개한다.\n언제 실행되어야 할까 name:Data Check on PRon:pull_request:paths:- \u0026#39;data/**\u0026#39;data/** 내용이 변경되는 PR 인 경우에만 해당 Workflow 가 작동하도록 했다.\n두 개의 checkout jobs:check-data:runs-on:self-hostedsteps:- name:Checkout main branchuses:actions/checkout@v4with:ref:mainpath:main-branch- name:Checkout PR branchuses:actions/checkout@v4with:path:pr-branch두 개 버전으로 checkout 을 받아, main-branch 와 pr-branch 경로에 각자 두기로 했다. 그리고 아래와 같이 working-directory 로 구분된 \u0026lsquo;추가작업\u0026rsquo; 을 실행했다.\n- name:Run \u0026#39;task\u0026#39; on main branchrun:... do something ...working-directory:./main-branch- name:Run \u0026#39;task\u0026#39; on PR branchrun:... do something ...working-directory:./pr-branchDiff 출력하기 두 결과가 각각 main-branch/result 와 pr-branch/result 에 저장되었다면, 이를 diff 로 출력해보자.\n- name:Diffid:diffrun:|diff -bur main-branch/result pr-branch/result \u0026gt; diff.txt || true if [ -s diff.txt ]; then echo \u0026#34;diff_exists=true\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV else echo \u0026#34;diff_exists=false\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV fi echo \u0026#39;DIFF_REPORT\u0026lt;\u0026lt;EOF\u0026#39; \u0026gt; $GITHUB_OUTPUT echo \u0026#34;\\`\\`\\`diff\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT cat diff.txt \u0026gt;\u0026gt; $GITHUB_OUTPUT echo \u0026#34;\\`\\`\\`\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT echo \u0026#39;EOF\u0026#39; \u0026gt;\u0026gt; $GITHUB_OUTPUT하나씩 설명하면,\n diff -bur 은 디렉토리 내부 파일들을 재귀적으로 비교해서 (-r) 공백은 무시하고 (-b) Unified diff 로 (-u) 출력한다. || true 는 diff 결과가 없어서 종료코드가 1 이 되는 경우를 무시한다. 이게 없다면, 해당 Step 은 실패한다! if [ -s diff.txt ] 는 diff 결과가 있으면, diff_exists=true 를 환경변수로 저장한다. 이 때 사용하는 $GITHUB_ENV 는 Workflow 내에서 사용할 수 있는 환경변수를 저장하는 공간이다. (예제) echo 'DIFF_REPORT\u0026lt;\u0026lt;EOF' 이하 내용들은, $GITHUB_OUTPUT 에 저장된 내용을 $DIFF_REPORT 라는 사용자 환경변수에 저장한다는 의미이다. 이는 Workflow 내에서 출력할 수 있는 변수로, 이를 이용해서 PR Comment 에 출력할 수 있다. (예제)  여기서 markdown syntax 를 한꺼번에 적용하기 위해서 ```diff 와 ``` 를 앞뒤로 미리 출력했다.    PR Comment 등록 이번에는 github-script 를 사용한다. 그렇기 때문에 GITHUB_TOKEN 등록이 필요하다. 자세한 내용은 이 블로그에 정리가 잘 되어 있다.\n- name:Upload diff to PR commentif:env.diff_exists == \u0026#39;true\u0026#39;uses:actions/github-script@v7env:DIFF_CONTENTS:${{steps.diff.outputs.DIFF_REPORT}}with:github-token:${{ GITHUB_TOKEN }}script:|github.rest.issues.createComment({ issue_number: context.issue.number, owner: context.repo.owner, repo: context.repo.repo, body: process.env.DIFF_CONTENTS })","date":"2024-07-09T09:56:16+09:00","permalink":"https://interp.blog/github-workflow-pr-comment/","title":"Github Workflow 로 PR Comment 등록하기"},{"content":"2023 독서 목록 에 이은 두 번째 씨리즈이다. 그런데 작성은 5월에 한다. 사실 적어 뒀다가 누가 볼까 싶어서 그만 뒀었는데, 그래도 마무리하기 위해 다시 적어본다.\n2년 전부터 게임하는 시간을 조금씩 줄여보려고 했는데, 들이는 시간이 짧다 보니 아무 게임이나 하기 보다는 고평가를 받은 게임을 선별해서 하게 되더라. 더불어서 게임 구입 비용도 줄여나가고 있는데, 이유는 PSN+ 구독으로 충분한 것 같고, 사내 동호회에서 게임 대여가 가능하기 때문이다. 더욱이 유명한 게임들 위주로 할 수 밖에 없었던 현실 (\u0026hellip;)\n엔딩을 못 봤던, 심지어 환불을 했건 간에 2023년 올 한해 했던 게임을 한번 정리해 봤다. 게임을 플레이한 순서대로 배치해 그림을 만들어 봤다.\n  추천작 여기서 6개의 게임을 (재밌었던 순서대로) 추천작으로 골라봤다.\n아머드코어 6 전작 아머드코어는 한 번도 해 본 적이 없고, 그 옛날 온게임넷에서 게임 대회하는 TV 프로그램을 주말에 챙겨 본 기억밖에 없다. 그 때 추억이 좋게 남아 있었는지, 신작 소식이 들려오니 왠지 모르게 들떠 있었다. 그 결과는?\n  소울류로 프롬 게임을 처음 접해본 나에게는, 오픈월드가 아닌 미션 진행 구성이 조금 어색했다. 그러나 1회차를 돌자마자 아, 분기를 전부 밟으려면 좋든 싫든 3회차는 해야 하는구나. 그리고 신나게 송버드와 짐머만으로 이지 모드로 돌파, 모든 엔딩을 볼 수 있었다!\n바이오하자드 RE:4 참고로 내돈내산한 유일한 AAA 게임이다 아머드코어는? 허허\u0026hellip;\n나는 PC 게임 위주로 하다 보니 이식이 활발했던 바이오하자드 456 를 처음 접할 수 밖에 없었다. 호러에 호-쾌한 액션! 을 쓰까넣은 시리즈를 사랑했기 때문에, 당연히 4편이 RE:Engine 으로 다시 만들어진다는 발표는 다른 전작들의 것보다 훨씬 기대가 컸었다. 기대를 배신하지 않았기 때문에 추천.\n드레지 아무리 남들 다 하는 대작 게임을 해본들, 인디 게임 중에서 속칭 \u0026lsquo;압긍 (압도적으로 긍정적)\u0026rsquo; 을 받은 게임을 외면할 수가 없었다.\n낚싯배를 몰고 크툴루 신화와 비슷해보이는 미스터리한 섬들을 떠돈다고? 물고기를 잡으면 딸칵 소리가 나지만, 요사스런 무언가 (?) 를 잡을 때는 이 소리가 의미심장하게 늘어진다. 게임을 한창 할 때는, 게임을 하지 않아도 이 소리가 환청으로 들릴 정도다\u0026hellip;\n컨트롤 에픽스토어에서 무료로 풀었을 때 초반부를 했다가, 각을 잡고 PSN+ 에서 다시 내려받아 새로 시작했다.\n이유는, 시간을 죽일 때 즐겨 읽던 SCP 재단 문서들과 이 게임이 비슷해 보여서다. 여기서도 문서들은 전부 검열 처리되어 있고, 그게 오히려 머릿속에서 알 수 없는 무언가를 채워넣기 시작한다. 슈퍼리미널 같은, 게임 속 규칙을 빨리 캐치해서 푸는 퍼즐도 재밌었다. 액션은 근데.. 던지기 원툴 아님?\n데이브 더 다이버 작년 초반을 책임진 게임. 드레지가 호러에 가깝다면, 이 게임은 낚시+초밥 타이쿤 이다. 간단해 보이지만 정말 재밌다!\n이제 \u0026lsquo;데더다\u0026rsquo; 와 \u0026lsquo;드레지\u0026rsquo; 의 콜라보도 성사되었고, 데더다가 데이원으로 PSN+ 으로 무료로 풀렸으니 플스로 올해 다시 해볼까 진지하게 고민 중이다. 하지만 엘든링 DLC 가 먼저겠지\n컵헤드 정확히는 DLC 를 할인할 때 사서 엔딩을 봤다. 이런 류의 횡스크롤 플랫포머 게임은 늘 가족들이 모여서 관전하는데 그 부담감이 상당하다 (\u0026hellip;) 훈수 좀 두지 마렴 얘들아\n안 맞았던 게임들 대중적인 평과는 달리 나에게 잘 안맞아서 쉽게 접은 게임들도 분명 있다.\n와룡 소울류라면서, 엄청나게 복잡했다. 엘든링 할 때도 조금 복잡했지만 나름 적응했는데, 이건 뭐\u0026hellip; 딱 십상시 나오는 초반부에서 접었던 것 같다. 우선 팀 닌자의 게임 자체가 나와 안 맞는 걸지도.\n파이널 판타지 16 스토리는 좋았을 수 있지만, 대화가 길고 액션은 짧은 분량이 답답했다. 액션도 처음엔 재밌다가, QTE 가 자꾸 나오고 호흡이 길어지니까 맥이 빠진다. 내 인생에서 파판은 7 오리지널 까지인 모양이다.\n마블 스파이더맨 2 도대체 왜? 나도 마일스 모랄레스는 재밌게 했기에 플레이 하기 전까진 기대가 컸다. 그런데\u0026hellip; 왠지 모르게 마일스 모랄레스를 또 하는 느낌이 들었다. 그게 전부였다. 손이 가지 않았다.\n 나머지 게임은 그냥저냥 재밌었지만, 기억에 남는 것은 별로 없었다. _고스트 오브 쓰시마_는 재밌긴 한데, 시간이 맞질 않아서 묵혀둔 채로 남아있다. 아직 평가하기 아직 이른 것 같다 (내년엔 올해는 할 수 있을까?)\n올해는 크게 \u0026lsquo;할로우 나이트:실크송\u0026rsquo; 과 \u0026lsquo;엘든링 DLC\u0026rsquo; 를 기다리고 있다. 실크송은 공식 발표가 나질 않았는데 대한민국과 호주 심의를 받은 걸 보면 연내 또는 내년초 출시를 기대할 수 있을 것 같다.\n올해도 즐겁고 알찬 게임 라이프를 보내보도록 하자. 똥겜 밟지 말기\n","date":"2024-05-01T17:25:32+09:00","image":"https://interp.blog/2023-game-history/feature_hu7cf1cd797ae607d8776629bdd1fbf283_4167927_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/2023-game-history/","title":"2023년 게임 목록"},{"content":"개발자들에게 위기인지 기회인지 모를 물결을 이해하기 위해 OpenAI 관련 내용을 보여줄 수 있는 Microsoft AI Tour 에 신청해 다녀왔다. 코로나 위기가 찾아오기 이전에 열렸던 MS Ignite 행사를 코엑스에 다녀온 이후로, 두 번째 MS 컨퍼런스 행사에 참석한 것이다. 이번에는 코엑스가 아닌, 양재 aT 센터이다.\n우선 초대장에 선착순이라는 문구가 몇 번이고 보였다. 늦으면 아침도 없다는 것 처럼 들렸기 때문에, 7시 30분 정도에 도착해서 등록하고 기다렸다. 아침은 다양한 빵과 우유/커피. 마들렌과 고구마 파이가 맛있었다. 아침이 컨퍼런스의 목적은 아니었지만, 맛있으면 기분 좋게 들을 수 있으니까!\n  브런치?\n  장소가 코엑스에 비해 넓지 않아서인지, 사람이 적었음에도 꽤나 북적였다. aT 센터 1, 3층만 사용하고 그마저도 에스컬레이터 만으로 이동이 가능했기 때문이다. 그래서 원하는 세션을 들으러 가려면 타임테이블을 잘 보고 이동해야 하는 건 기본에, 현재 듣고 있는 세션이 조금 늦을라치면 도중에 나와야 할 정도였다. 불만이라기 보다는, 어쩔 수 없다고 생각한다.\n정말로 불만이었던 점은 워크샵 세션 (핸즈온) 이나 브레이크아웃 (일반) 세션에서 알려주는 지식 수준이었다. 내가 RAG 워크샵을 못 들어서 이러는게 아니다 아무래도 청중의 수준을 가늠할 수 없다보니 가능한한 쉽게 했으리라 이해는 가지만, 그래도 개발자 세션이면 입문 코스보다는 심화 코스 위주로 알려줬으면 하는 바램은 솔직히 있었다.\n아무튼, 씨어터 세션 (부스 세션) 을 제외하고 오늘 들은 걸 간단히 정리하고 싶었다.\n키노트 그 넓고 넓은 키노트 강연장에 모든 사람이 들어갈 수 없어서, 1층 워크샵 세션장에서 스트리밍으로 보았다. 통역기도 자리마다 제공해 줬는데, 왜 통역사가 말하는 걸 스피커로도 틀었는지 의문이다. 스콧의 스피치를 듣는게 훨씬 더 나았는데 말이다.\n키노트 내용은 별다른게 없었고, 곧 MS 365 Copilot 이 한국어 지원을 한다는 내용과 LG전자, 엔비디아, SK이노베이션 순으로 Azure AI 사용 사례를 이야기한 게 전부였다. LG전자 상무님은 동굴 목소리에 언변이 좋으셔서 \u0026lsquo;저정도는 해야 저런 자리에 가는구나\u0026rsquo; 싶었다..\nGithub Copilot 스콧이 키노트 세션장에서 이어서 진행한 세션이었다. 이번에는 3층에 올라가서 들을 수 있어서 좋았고, Copilot 의 무궁무진함을 느껴볼 수 있어서 좋았다.\n주목할만한 구절이 두 개 있었는데, Github Copilot 의 목적은 \u0026lsquo;Focusing on your own code\u0026rsquo; 이라고 한다. 달리 말하면, 여러분만이 짤 수 있는 코드를 작성하는 일 외에 나머지 일들 (구글링을 하거나, 코드를 읽고 이해하거나, 코드 작업으로 다시 돌아오는 과정) 을 도와주기 위한 것이라는 말이다.\n그리고 이 서비스는 Autopilot 이 아니라 Copilot 이라는 점을 많이 강조했다. 알아서 다 해주는 것이 아니라, 여러분이 요청한 것에 맞춰 도움을 줄 수 있도록 제안하는 것이다. 자율주행 차에 올라타서도 핸들을 잡아야 하는 것에 비유하긴 했다.\nAzure AI Search 워크샵 세션에서 밀려서 듣긴 했는데, 나름 유익했다. Architect 분께서 현업에서 겪었던 일화는 슬라이드에 적혀있지 않았지만 슬쩍슬쩍 보따리에서 꺼내주셔서 재밌었던 것 같다. 고객님들은 데이터만 던져주시곤 \u0026lsquo;해줘\u0026rsquo; 하세요 ㅠㅠ\nRAG 개념을 모르는 사람은 초반부가 흥미가 있었을지 모르겠지만 나는 좀 지루했고, 되려 RAG 의 품질을 올리기 위해 어떤 방법을 쓰는지가 더 궁금했다. 몇 가지 인사이트는, vector search 뿐만 아니라 exact keyword search 를 섞은 hybrid search 가 더 좋은 결과를 낸다는 것이었다. Azure AI Search 는 여기에 더해 Semantic re-ranking 을 제공해서 그 정확도를 올렸다고 한다. 어쨌거나 중요한 건, 프롬프팅에 실어야 할 원천 데이터를 잘 선택하는 일일 것이다.\n 불만이 있다면 있고 없다면 없겠지만, 그래도 개발자들을 위해서 무료로 컨퍼런스를 열고 지식을 공유받은 입장에서는 훌륭한 시간이었다. 다음에도 기회가 된다면 다른 형태의 컨퍼런스라도 참석하고 싶다!\n오늘 점심 도시락 사진으로 마무리한다. 맛있었다!\n  ","date":"2024-04-30T21:23:23+09:00","image":"https://interp.blog/microsoft-ai-tour-review/feature_hucdcbca234df2a41c1ef9a8bfa59afbaf_226231_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/microsoft-ai-tour-review/","title":"Microsoft AI Tour 후기"},{"content":"Git 에서 Branch 이름을 바꾸는 방법에 대해 제대로 정리가 안 되어 있는 것 같아서, 짧지만 예제와 함께 확실히 정리해 보려고 한다.\n상황 Github, Gitlab 같은 원격 저장소에 있는 internal 이란 이름의 branch 가 있다고 가정하자. 이 branch 를 로컬 환경에서 (예: PC, 개발 서버) checkout 받아서 작업을 하고 있었다.\ngit checkout internal # do something 어? 갑자기 internal 에서 작업하던 내용이 Issue#10 으로 등록되었다. 이제 이 작업은 \u0026lsquo;내부적\u0026rsquo;인 작업이 아니게 된 것이다. 그래서 Issue 번호를 붙인 branch 이름, issue-10 으로 바꾸고 싶다.\n즉, 이런 상황이다.\nLocal branch = internal Remote branch = internal Local branch 이름 바꾸기 아직 원격 저장소에는 반영하기 싫고, 로컬에서만 이름을 바꾸고 싶다면.. 아주 간단하게 바꿀 수 있다.\n# (1) on `internal`` branch git branch -m issue-10 # (2) not on `internal` branch git branch -m internal issue-10 git checkout issue-10 git rev-parse --abbrev-ref HEAD # issue-10 Local branch = issue-10 Remote branch = internal 이 상태에서 그대로 push 하면 바뀌겠지? 라는 순진한 생각을 실험으로 옮겨보자.\ngit push origin issue-10 Enumerating objects: 1, done. Counting objects: 100% (1/1), done. Writing objects: 100% (1/1), 181 bytes | 181.00 KiB/s, done. Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 remote: remote: Create a pull request for \u0026#39;issue-10\u0026#39; on GitHub by visiting: remote: https://github.com/test/test-project/pull/new/issue-10 remote: To https://github.com/test/test-project.git * [new branch] issue-10 -\u0026gt; issue-10 와! 바뀐거 아니예요? 그럴리가요!\ngit fetch origin git branch -a * issue-10 main remotes/origin/internal remotes/origin/issue-10 remotes/origin/main Local branch = issue-10 Remote branch = issue-10, internal remotes/origin/internal 이 여전히 남아있다. 깔끔하지 못하다!\nRemote branch 이름 바꾸기 원격 저장소에 있는 branch 까지 이름을 바꾸려면 어떻게 해야 할까?\n이미 눈치챘겠지만 그냥 옛날 Remote branch 를 삭제하면 된다.\n# (1) git push origin :internal # (2) git push origin --delete internal 이러면 끝? Upstream 의 함정 지금 예제에서는 다행히 새로운 이름의 branch 가 그대로 Remote branch 로 업로드 된 경우이다. 위의 결과를 다시 가져와보면, issue-10 은 원격 저장소에 없었는데 이 Push 작업을 통해 새로 생긴 것이다.\nTo https://github.com/test/test-project.git * [new branch] issue-10 -\u0026gt; issue-10 다시 돌아가서, Local branch 이름만 바꾸고 Push 를 했는데 다음과 같은 상황이 발생했다면?\nTo https://github.com/test/test-project.git 38b2c6e..7489f75 issue-10 -\u0026gt; internal 음? 기존 Remote branch 인 internal 에 그대로 반영되었다.\n이러면 Remote branch internal 을 git push origin --delete 로 지워본들, issue-10 branch 를 계속 push 할 때 마다 internal 이란 이름으로 계속 Remote branch 가 생길 것이다.\n왜 이렇게 된 것일까? 답은 Upstream 때문이다. 다음 명령으로 branch 의 상태를 확인해 보자.\ngit branch -vv | grep issue-10 * issue-10 7489f75 [origin/internal] hello commit [] 안에 표시된 내용이 Upsteam 이며, 연결된 Remote branch 내용이 들어가 있다. 이 부분이 아예 없다면 Upstream 이 없으니, 새로운 branch 를 Push + 옛날 branch 는 Remote 에서 삭제하는 위 방법만으로 이름을 바꿀 수 있다. 반대로 말하면, Upstream 이 존재하면 추가 조치가 필요하다.\n마지막 조치 이름을 바꾼 Local branch 를 Push 하기 전에, Upstream 을 삭제하는 과정이 필요하다.\ngit branch --unset-upstream issue-10 💡   참고로, git branch --set-upstream-to= 명령으로 기존 Remote branch 에 Upstream 을 연결하는 방법도 있지만, Remote branch 가 존재하지 않으면 에러가 발생한다.   그리고 Upstream 을 연결하기 위해 다음과 같이 -u 옵션을 써서 git push 하면 된다!\ngit push -u origin issue-10 한 번에 하기 귀찮으신 분들을 위해 한 번에 하는 방법을 소개한다. 그냥 변수를 바꾸시면 되겠다.\nNEW_BRANCH=\u0026#34;internal\u0026#34; OLD_BRANCH=\u0026#34;issue-10\u0026#34; # Local branch git checkout ${OLD_BRANCH} git branch -m ${NEW_BRANCH} # Unset existing upstream and push with new upstream git branch --unset-upstream git push -u origin ${NEW_BRANCH} # Check whether new branch is okay on the remote # Delete old remote branch git push origin --delete ${OLD_BRANCH} 당부 어떻게 하든 예전 Remote branch 를 삭제하는 것은 동일하다. 하지만, Local branch 가 존재하는 로컬 환경이 어떻게 될지 아무도 모른다. 사람 일은 모르기 때문에 Remote branch 를 먼저 삭제해버렸더니, Local branch 를 못 쓰게 될 수도 있다. (disk 가 고장나거나 PC 가 먹통이 되거나!)\n따라서 반드시 Local branch 를 먼저 Push 한 다음에 Remote branch 를 삭제해야 한다.\n","date":"2024-01-05T17:41:29+09:00","image":"https://interp.blog/git-branch-rename/feature_hu3c492ca9688bd62431c1b7b3526581d9_1068144_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/git-branch-rename/","title":"Git Branch 이름 바꾸기"},{"content":"나는 개인 노트 작성에 옵시디언 (obsidian) 을 사용한다.\n작년까지는 노션 (Notion) 을 주로 사용했지만, 노션은 데이터베이스 형태로 기록할 만한 것들만 남겨두고, 실제 글들을 아이디어로 엮는 작업은 옵시디언에서 하고 있다. 주로 Macbook 앞에서 작성하지만, 컴퓨터를 쓰지 않을 때는 iPhone 에서 끄적이고 싶을 때 옵시디언 앱을 연다. 어느 쪽에서 쓰더라도, iCloud 를 통해 동기화가 이루어지므로 끊임없이 적을 수 있는 장점도 있다. (최근 워크스페이스가 늘어나면서 모바일 로딩 속도가 느려지는 문제가 있는 듯 하다. 이 때문에 임시 메모장 용도로만 다시 노션을 써야하나 고민 중이긴 하다.)\n아무튼, 옵시디언은 정제된 메모들과 아이디어가 있는 공간이기 때문에, 몇년이고 잘 보존되어야 한다는 욕심이 생겼다. 대학원 시절 잘 사용하던 스프링노트가 서비스 종료되면서, 백업을 받아두긴 했지만 재활용하기가 너무 힘든 부분이 있었다. 백업을 해 두면, iCloud 를 더 이상 사용하지 않는다거나, 불의의 사고가 생기더라도 저장장치에서 새출발 할 수 있지 않을까 해서 이리저리 알아봤다.\n  추억의 스프링노트..\n  옵시디언 저장소를 (옵시디언에서는 Vault 라고 부른다) 아예 OneDrive 나 다른 저장소에 두면 되겠지만, 모바일용 옵시디언에서는 외부 파일 클라우드 서비스를 지원하지 않는다. iPhone 에서만 쓰거나, iCloud 에 동기화하거나.\n  모바일 옵시디언에서 저장소 동기화는 iCloud 에서만 가능하다\n  문제 iCloud 로 동기화 중인 옵시디언 저장소를 다른 파일 동기화 서비스에도 백업해 둘 순 없을까?\n디자인 우선 내 작업 환경을 고려해서 다음 아이디어를 생각해 냈다.\n Macbook 이 꺼질 일은 없고, 매일 Macbook 을 사용하니까 Macbook 에서 iCloud 내용을 복사하는 반복 작업을 만들면? 대부분의 파일 동기화 서비스는 Mac OS 를 지원하니까, Macbook 내부 특정 위치를 동기화하게 만든 다음 그곳으로 iCloud 내용을 복사하면?  생각보다 간단하게 문제 해결 방법이 정리되었고, 단순 cp 명령어보다 훨씬 더 좋은 방법을 적용할 수 있었다. (이번에 새로 알게 된 것은 아니고 원래 알고 있었지만\u0026hellip;)\nrsync 를 써보자! rsync 는 파일 타임스탬프를 기반으로 (원격 시스템을 포함한) 두 경로 사이를 동기화하는데 사용된다. 당연히 로컬 환경에서도 사용이 가능하다! 하지만 MacOS 에 기본적으로 설치된 버전은 2.x 이기 때문에 인코딩 문제같은 자잘한 걸림돌이 많다. 그래서 먼저, 3.x 버전으로 업그레이드 해보자.\n무릇 MacOS 유저라면 Homebrew 를 설치했으리라 믿는다. 그럼 바로 설치해보자!\nbrew install rsync Homebrew 에서 설치한 바이너리 명령어들의 설치 경로가 Intel/Silicon Mac 마다 다르다. 해당 경로가 $PATH 최상단에 있는지 확인하자.\n Intel: /usr/local/bin Silicon (M1, M2..): /opt/homebrew/bin  export PATH=${HOMEBREW_BIN_PATH}:${PATH} which rsync # 확인 자, 이제 다음 명령어로 동기화를 해보자!\nrsync -uva --delete ${source}/ ${destination}/ man rsync 를 통해서도 얻을 수 있는 정보이지만, 정리해두면 다음과 같다.\n -u: 업데이트 된 파일만 destination 으로 복사 -v: 동기화되는 파일 목록과 결과 통계 출력 -a: archive mode (recursive + symbolic link + preserve metadata) --delete: 관계없는 파일은 destination 에서 삭제  반드시 --dry-run 을 추가해서, 저장 경로에 어떤 파일이 생성되고 삭제되는지 직접 테스트를 해 보자.\nCrontab 에 등록 이제는 매일 동기화하도록 해보자. 그런데 주의할 점은, 반드시 바이너리와 두 디렉토리를 모두 절대경로로 작성해야 한다는 것이다. crontab 은 PATH 를 인식하지 못하기 때문이며, 실행하는 위치를 특정할 수 없기 때문에 상대경로로 쓸 수 없다.\n말하자면 이런 식이다. (매일 오전 11시에 돌아간다)\n# 이러면 안 되고 0 11 * * * rsync -uva --delete src/ dest/ # 이래야 한다. 0 11 * * * /opt/homebrew/bin/rsync -uva --delete /Users/username/src/ /Users/username/dest/ 날짜와 함께 로그를 남기고 싶다면, 이렇게 log.log 에 내용을 쌓는 방법도 있다. 더 좋은 방법이 있겠지만, 간단하니 우선은 이렇게 확인 중이다.\n0 11 * * * date \u0026gt;\u0026gt; /Users/username/log.log \u0026amp;\u0026amp; /opt/homebrew/bin/rsync -uva --delete /Users/username/src/ /Users/username/dest/ \u0026gt;\u0026gt; /Users/username/log.log Operation not permitted 혹시 위 명령어를 보게 된다면 다음을 참고하자.\n \u0026lsquo;설정\u0026rsquo; 열기 검색에서 \u0026lsquo;디스크\u0026rsquo; 를 입력해서, \u0026lsquo;응용 프로그램이 모든 사용자 파일에 접근하는 것을 허용\u0026rsquo; 선택 목록 맨 아래에 더하기 (+) 기호 클릭 Command + Shift + G 를 눌러서, /usr/sbin/cron 입력 cron 이 활성화되어 있는지 확인 후, 설정 창 닫기  🔗 참고 : https://apple.stackexchange.com/questions/378553/crontab-operation-not-permitted\n /Users/username/dest 부분은 파일 동기화 클라이언트로 지정해 두면 클라우드/NAS 로 동기화가 자동으로 이뤄질 것이다!\n","date":"2023-12-17T13:27:40+09:00","image":"https://interp.blog/backup-from-icloud-obsidian/feature_hu4b4ed757e4b1c0b24b15644c97bf58e9_228493_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/backup-from-icloud-obsidian/","title":"iCloud Obsidian 주기적으로 백업하기"},{"content":"작년 (2022년) 연말부터 한 일이 있다. 적어도 한 해 읽은 책을 되돌아보는 시간을 갖자고. 독서의 습관화를 외친 지 3년차가 되어 가지만, 산발적인 독서노트 정리만 가지고는 한 눈에 성과 (?) 를 가늠하기가 어려웠다. 작년에는 독서노트를 쓰는 것과 별개로 노션 (Notion) 에 책에 대한 메타데이터와 커버를 정리해 보았다.\n그런데 다 읽은 것만 하려니까 몇 권 없는 것이다! 10권도 안 됐다! 물론 누군가는 10권보다 덜 읽고 살겠지만, 그리고 누군가는 완독에 목을 맬 필요가 없다고 하겠지만, 독서를 많이 하자는 다짐에 비하면 막상 보잘것이 없었다.\n그래서 올해는 기준을 대폭 완화해서 목록을 뽑았다. 아무리 적게 읽었어도, 의미를 찾을 수 있었다면 목록에 넣자고 말이다. 그리고 일단 읽었다면, 서평단을 했건 베타리딩을 했건 심지어 숙제를 했건 (\u0026hellip;) 무조건 넣기로.\n거기에 덧붙여서 나름의 추천 마크를 붙여보기로 했다. 기준은 다음과 같이 정했다.\n 다시 읽어도 좋을 책 남에게 추천해도 나쁜 소리 듣지 않을 책 엄청난 인사이트를 제공한 책  자, 그럼 내가 올해 뒤적거린 책을 한번 보도록 하자.\n   트렌드 당장 경제나 돈에 관한 자기계발 관련 도서가 눈에 띄게 많이 보인다. 세어보면, 주식이나 경제 관련 도서만 5권, 경영이나 자기계발서까지 하면 12권이나 된다. 욕심이 그득해 보인다. 굳이 이 많은 책들을 요약하자면,\n 작은 습관의 힘은 너무나도 중요하다 인생이나 행동 방향 설정에 대한 통찰을 얻어갈 수 있다 (제각기 다르지만, 요점은 비슷한 것 같다)  심리학, IT 도서가 그 뒤를 잇고, 철학 도서도 눈에 띈다. 작년에 즐겨 봤던 글쓰기 책이나 독서법 책도 눈에 띄는데, 완독하지 못한 책들이 많다. \u0026lsquo;네 번째 원고\u0026rsquo; 가 가장 완독하기 힘들었고, \u0026lsquo;거인의 노트\u0026rsquo; 는 얼른 읽고 싶다.\n뜬금없이 소설 두 권과 위스키 백과사전 한 권이 있다. 동물농장은 줄거리만 알지 읽은 건 처음이었는데, 신선한 충격이었다. 백과사전은 너무 좋았지만, 올해 내가 먹은 위스키 목록 같은걸 올릴 생각은 추호도 없다.\n추천 책 소개 이 분야에서 별을 달아둔 것만 소개해 본다. 아마 너무 유명해서 내가 코멘트를 굳이 할 필요 없는 것들도 있을 것이다.\n경제/자기계발 도서  부의 추월차선: 올해 딱 한권만 꼽으라면, 내 자세를 고쳐 준 이 책을 들고 싶다. 세이노의 가르침: 이미 리뷰를 올렸다. 나름 마일드한 버전을 보려면 위에 있는 \u0026lsquo;돈의 속성\u0026rsquo; 을 읽어도 좋다. 두 저자의 교훈 중 겹치는 부분이 좀 많다. 타이탄의 도구들: 모든 자기계발서의 엑기스를 집대성한 것이라, 한꺼번에 먹을 수가 없다. 하나씩 실천하는게 중요하다. (추천은 안 됐지만, \u0026lsquo;연봉 3억 독서법\u0026rsquo; 책을 한 문장으로 줄이면 바로 이것이다. 하나씩 해보기!) 자본주의: 어쩌면 경제 문외한을 위한 내용일 수 있지만, 기초 다지기는 늘 중요하다. 이 책은 돈 버는 법에 관한 이야기: 고명환 님의 철학이 새삼 존경스럽기도 하고, 내가 추구하던 인생 철학과 맞닿아 있어서 반갑기도 했다.  심리학 도서 베스트셀러에 늘 \u0026lsquo;돈 버는 법\u0026rsquo; 과 자기계발이 한 축에 있다면, 올해 베스트셀러의 다른 축은 아마도 자신의 마음을 보듬어줄 심리학 책이 대세였다고 생각한다. 양쪽에서 늘 눈에 띄었던 책이 \u0026lsquo;역행자\u0026rsquo; 와 \u0026lsquo;나는 왜 자꾸 내 탓을 할까\u0026rsquo; 였는데, 이 책을 올해는 읽지 않았다. 공교롭게도 두 권 모두 종이책을 선물받았는데도 말이다. (\u0026hellip;) 반골 기질이 있어서 그런지, 철지난 스테디 셀러를 찾는 편이 더 안심이 되기도 했다.\n이 분야에서 나는 \u0026lsquo;레몬심리\u0026rsquo; 의 \u0026lsquo;기분이 태도가 되지 않게\u0026rsquo; 가 훨씬 잘 맞았다. 일단 나에게 필요한 기술이었기 때문이고, 책이 쉬워서였다.\nIT 도서 일에 필요한 책을 몇 권, 블로그에 필요한 책을 몇 권 읽었다. (아, 블로그 월급보다 많이 벌 욕심은 아직까진 없다. 저 책은 서평단 목적으로 읽었다)\n그 중에서 \u0026lsquo;데이터 품질의 비밀\u0026rsquo; 은 많은 인사이트를 전달해 줬다. 실제 올해 프로젝트에 활발히 적용했고, 이전 버전에 비해 결과가 좋았다. 5 Pillas 를 팀원과 공유하는 시간도 가졌었는데, 반응이 괜찮았다.\n그 외 그 외라고 분류했지만, 나머지 세 권은 결코 추천 이유를 생략할 수 없었다.\n 불안: 작년에 읽은 걸 다시 읽었다. 우리가 불안한 이유, 우리가 불안을 해소할 수 있는 창구를 소개한다. 리뷰를 따로 써 뒀는데, 세 번째 읽고 나면 다듬을 수 있을 것 같다. 협상의 기술: 어쩌면 자기계발서일 수도 있지만, 어떻게 보면 기술서에 가깝다. 세이노가 추천한 책 중에 가장 마음에 들었다. 작별인사: 올해 책 중 유일한 소설인데, 김영하 작가가 사내 강연을 하러 온다기에 읽기 시작했었다. 살인자의 기억법보다 훨씬 잘 읽히지만, 상황과 대사는 엄청나게 심오하다. 사유하기 좋은 책이다.   이렇게 대충 올해 책을 둘러봤는데, 내년에는 이 목록을 반추해서 내가 뭘 원하는지 유추해 보거나, 아니면 내가 원하는 것에 맞는 책을 고르도록 좀 더 신경써야겠다.\n다음 시간에는 좀 더 가볍게, 영화 목록을 들고 오도록 하겠다!\n","date":"2023-12-08T22:09:34+09:00","image":"https://interp.blog/2023-book-history/feature_hud9f4e899ffe594133917a1c14e25ed0a_1742290_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/2023-book-history/","title":"2023년 독서 목록"},{"content":"Github 에서 Pull Request 를 생성하면, CI/CD 파이프라인을 통과해서 리뷰 받을 준비를 마쳤음에도 여전히 오픈되어 있는 경우가 있다. 스크럼 회의 시간에 리뷰를 요청해 보기도 하고, 직접 메시지를 보내기도 하지만.. Pull Request 가 많은 경우엔 이런 작업이 여간 귀찮은 일이 아니다.\n답답해서 내가 뛴다는 마음으로 Github Actions 를 이용해, Pull Request 가 특정 조건을 만족하면 매일 아침 팀 Slack 채널에 \u0026lsquo;리뷰 요청\u0026rsquo; 메시지를 보내는 Workflow 를 만들어 보기로 했다. 여기서는 Github Action 이나 Workflow 소개 없이, 문제 해결 과정만 적어 두었다.\n대상 Pull Request 조건  Open Approval 을 받지 않음 마지막 커밋에서 CI/CD 파이프라인을 통과함 Ready for review 레이블이 존재함  Workflow 기본 구조 우선 ChatGPT의 도움을 조금 받아 다음 2개의 Step 이 포함된 Job 을 지정하는 것부터 출발했다.\nname:Notify PR Review Requeston:schedule:- cron:\u0026#39;0 0 * * *\u0026#39;# 매일 00:00jobs:notify:steps:- name:Get Pull Requestsid:pullsuses:actions/github-script@v6with:github-token:${{secrets.GITHUB_TOKEN}}script:|// ... // return ...- name:Send Slack messageif:steps.pulls.outputs.result != \u0026#39;\u0026#39;uses:8398a7/action-slack@v3with:status:customcustom_payload:|${{ fromJSON(steps.pulls.outputs.result) }}env:SLACK_WEBHOOK_URL:${{ secrets.SLACK_WEBHOOK_URL }}actions/github-script 와 8398a7/action-slack 을 사용했고, 각각 $GITHUB_TOKEN 과 $SLACK_WEBHOOK_URL Variable 을 필요로 한다.\nGithub Token 은 이미 내장되어 있지만, Slack Webhook URL 은 직접 생성해서 등록해야 한다.\nSlack App 생성 Slack Workspace 에 App 생성이 가능한 계정에 로그인 되어 있다면, 다음을 따르면 된다.\n 다음 링크 로 이동 \u0026lsquo;From scratch\u0026rsquo; 를 선택 App 이름을 지정하고, 대상 워크스페이스를 선택 App 화면이 뜨면, \u0026lsquo;Features \u0026gt; Incoming Webhooks\u0026rsquo; 을 선택 페이지 하단에 \u0026lsquo;Add New Webhook to Workspace\u0026rsquo; 를 클릭 채널을 추가하면 채널의 Webhook URL 을 확인할 수 있다.  🪴   \u0026lsquo;Display Information\u0026rsquo;에서 App 아이콘과 이름을 자유롭게 선택할 수도 있으니 참고하자.   이제 이 Webhook URL 을 Github Secret 으로 등록하면 된다. Settings \u0026gt; Secrets and variables 에서 등록이 가능하며, 위에서 지정한 것 처럼 SLACK_WEBHOOK_URL 이라는 이름으로 등록하면 된다.\nREST API? GraphQL API! 첫 번째 step 인 actions/github-script 을 채워보자.\nREST API 를 활용한 함수를 사용하는 방법과, GraphQL 을 짜서 한 번에 쿼리하는 방법이 있다. 코드가 좀 더 간결해질 것 같아 두 번째 방법을 사용했는데, 첫 번째 방법을 통해 순차적으로 쿼리하는 것도 물론 가능하다.\nGraphQL 에 대해 잘 모르겠다면, 이 문서 를 참고하자. Github GraphQL API 에 대한 자세한 내용은 이 문서 도 참고하자.\n우선, 대상이 되는 정보(제목, URL, 리뷰 상태, 레이블, 최근 커밋의 상태) 를 모두 뽑아와야 하므로, 아래와 같은 쿼리가 필요하다.\nquery{repository(owner:\u0026#34;${context.repo.owner}\u0026#34;,name:\u0026#34;${context.repo.repo}\u0026#34;){pullRequests(states:OPEN,first:100){nodes{titleurlreviewDecisionlabels(first:10){nodes{name}}commits(last:1){nodes{commit{statusCheckRollup{state}}}}}}}}이 쿼리는 현재 담당하는 프로젝트 크기에 맞춰 몇 가지 제약을 뒀다. Open 된 Pull Request 가 100개를 넘지 않고, Label 이 10개 미만으로 추가되는 프로젝트 환경이어야 유효하다. 커다란 프로젝트에서는 참고해야 한다.\n여기 repository 를 지정할 때 ${context.repo} 의 값을 썼는데, 이는 github-scripts 에서 제공하는 변수이다. 자세한 내용은 이 소스코드 를 참고해도 되지만, 지금은 \u0026lsquo;현재 project 의 owner/repo 이름\u0026rsquo; 을 의미한다고만 알아두자.\nGithub Scripts 완성 이제 GraphQL 을 사용해서 쿼리를 실행하고, 결과를 필터링해 Map 형태로 반환해보자. 참고로 github-scripts 는 Javascript 를 사용한다.\n- name:Get Pull Requestsid:pullsuses:actions/github-script@v6with:github-token:${{secrets.GITHUB_TOKEN}}script:|const query = `...` // 위의 GraphQL 쿼리 const result = await github.graphql(query); const prs = result.repository.pullRequests.nodes; const filteredPRs = prs.filter(pr =\u0026gt; pr.reviewDecision !== \u0026#39;APPROVED\u0026#39; \u0026amp;\u0026amp; pr.labels.nodes.find(label =\u0026gt; label.name === \u0026#39;Ready for review\u0026#39;) \u0026amp;\u0026amp; pr.commits.nodes[0].commit.statusCheckRollup.state === \u0026#34;SUCCESS\u0026#34; ); if (filteredPRs.length \u0026gt; 0) { // Slack message block 생성 }filteredPRs 에는 위에서 정의한 조건을 만족하는 Pull Request 들이 담긴다. 이제 이 정보를 Slack message block 으로 만들어서 보내면 된다.\n통합 문제 여기서 두 가지 난관이 있었는데,\n Step 간에 JSON 으로 정보 교환이 가능한가 Slack message 를 일반 텍스트가 아니라, 멋지게 만드려면 어떻게 해야 하는가  첫 번째는 쉽게 해결했다. fromJSON() 을 활용하면 github-scripts 에서 반환되는 (따옴표가 전부 escape 된) JSON String 을 그대로 받아다 쓸 수 있었다. 더욱 자세한 내용은 블로그 문서 를 참고하자.\n두 번째가 조금 어려웠는데, 결국 찾았다. 다음 매뉴얼과 Playground 페이지를 통해 Slack 의 (Block-kit 이라고 하는) custom message 구조를 이해하고 만들어 볼 수 있었다.\n 매뉴얼: https://api.slack.com/reference/block-kit Playground: https://api.slack.com/tools/block-kit-builder  그러면 문제는 좀 더 간단해진다.\n github-scripts 에서는 Slack Message 구조를 전부 만들어서 JSON 으로 내보내고 action-slack 에서는 JSON 자체를 받아서 출력하면 된다.  Slack message 구조 생성 다시 github-scripts step 으로 돌아가 보자. 제일 처음에 헤더가 되는 block 을 미리 지정한다.\nlet blocks = [ {\u0026#34;type\u0026#34;: \u0026#34;header\u0026#34;, \u0026#34;text\u0026#34;: {\u0026#34;type\u0026#34;: \u0026#34;plain_text\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;👀 PR 목록\u0026#34;}}, {\u0026#34;type\u0026#34;: \u0026#34;divider\u0026#34;} ]; 그 다음, filteredPRs 결과가 존재하는 경우에 blocks 안에 메시지를 채워넣는다.\nif (filteredPRs.length \u0026gt; 0) { // Slack message block 생성  blocks.push({ \u0026#34;type\u0026#34;: \u0026#34;section\u0026#34;, \u0026#34;text\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;mrkdwn\u0026#34;, \u0026#34;text\u0026#34;: filteredPRs.map(pr =\u0026gt; `• \u0026lt;${pr.url}|*${pr.title}*\u0026gt; `).join(\u0026#34;\\n\u0026#34;) } }); } 마지막으로, blocks 를 반환하면 된다.\n// 디버깅  console.log(JSON.stringify({ blocks })); return JSON.stringify({ blocks }); Slack Step 완성 pulls step 에서 반환된 값을 JSON 으로 변환해 그대로 넣는다. 맨 처음 Step 과 크게 달라진 것은 없다.\n- name:Send Slack messageif:steps.pulls.outputs.result != \u0026#39;\u0026#39;uses:8398a7/action-slack@v3with:status:customcustom_payload:|${{ fromJSON(steps.pulls.outputs.result) }}env:SLACK_WEBHOOK_URL:${{ secrets.SLACK_WEBHOOK_URL }}마무리 작업 이제 작업은 끝났고 테스트만 남았다.\nmain 이 아닌, 특정 브랜치에서 Workflow 실행하기 우선, 위 workflow 에서 on: 절에 다음이 추가되어야 한다.\non:workflow_dispatch:# 뭘 더 넣을 필요없이 이게 전부다.나는 gh CLI 를 사용해서 로그인한 다음, 아래 명령어로 실행했다.\ngh workflow run \u0026#39;Notify PR Review Request\u0026#39; --ref {branch} Github Scripts 디버깅 문법 오류를 잡기 위해서는, Javascript Linter 가 작동하는 IDE 에서 먼저 작성한 다음, 옮겨오는 것을 추천한다.\nGraphQL 디버깅 API 문서를 뒤져보면 Personal access token 을 사용해서 쿼리를 할 수 있는 방법이 존재한다. 원하는 값이 나오는지 확인한 뒤에 Github Scripts 에 적용해 주자.\n 이 Workflow 는 특정 이벤트 기반이 아니라, 주기적으로 실행되면서 상태를 직접 체크해야 하기 때문에 Workflow 가 복잡해 진 것 같다. 그래도 Github Actions 를 이용하면, 일일히 리뷰 요청을 하지 않아도 된다. Github Scripts 에서 반환되는 값을 어떻게 받아 처리할지도 사실 막막했는데, fromJSON() 을 사용하니 간단했다.\n전혀 다른 문제를 Github Actions 로 자동화하려는 경우에도, 이 글이 여러모로 도움이 되었으면 좋겠다.\n ","date":"2023-11-22T21:38:53+09:00","image":"https://interp.blog/github-actions-pr-review-request/feature_hu3d03a01dcc18bc5be0e67db3d8d209a6_492338_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/github-actions-pr-review-request/","title":"Github Pull Request 리뷰 요청 자동화하기"},{"content":"배달의민족 개발사인 우아한형제들의 기술 블로그 에서 주제별로 발췌한, 일종의 모음집이다. 그러고 보니, 크고 유명한 대한민국 IT 기업들을 \u0026lsquo;네카라쿠배\u0026rsquo; 라고들 부르던데, 사실은 \u0026lsquo;네카라쿠우\u0026rsquo; 가 되어야하나. 쿠우~?\n회사 홍보물? 개발자 일지! 성격이 성격이니만큼 회사 홍보 책자인지 심히 의심스러울 만하다. 읽다보면 자연스럽게 \u0026lsquo;이 회사에 들어가면 이런 온보딩 과정이 있구나\u0026rsquo;, \u0026lsquo;이 회사는 이렇게 일하는구나\u0026rsquo;, \u0026lsquo;이 회사는 이렇게 생각하고 저렇게 논의하는구나\u0026rsquo;, \u0026lsquo;이 회사는\u0026hellip;\u0026rsquo; 으로 시작하기 때문이다.\n 어떤 기술 스택을 쓰는지 어떤 온보딩 프로세스가 있는지 코드 리뷰 문화는 어떤지 기술 부채는 어떻게 다루는지 과연 페어 프로그래밍을 주로 하는지 \u0026hellip;  그러나 이 책이 주는 의미는, 이런 내용이 비단 \u0026lsquo;우아한형제들\u0026rsquo; 에서만 일어나는 것은 아니기 때문이다. 아니 어쩌면, 이 글들이 다른 회사에서 하는 것과 겹치고 진부한 내용일 수도 있다.\n하지만 개발자들 스스로 글로 풀어낸 진정성이 담겨 있는 점은 분명하다. 그 진심이 닿는다면, 팔짱을 끼고 \u0026lsquo;그래 너네 회사 좋은데 뭐?\u0026rsquo; 같은 고까운 시선으로 읽을 수만은 없을 것이다. 때로는 공감하면서, 때로는 \u0026lsquo;우아한\u0026rsquo; 작은 차이에 감탄하면서 읽었으니까.\n우아한형제들 기술블로그는 최적의 방법을 찾았노라고 으스대지 않는다. 거기까지 간 험난한 여정을 토로한다. 그저 다른 회사의 이야기일수도 있지만, 그보다는 같은 개발자로서 고충을 나눌 수 있는 장, 그곳이 기술블로그일 것이다.\n사내 명언  \u0026lsquo;만드는 사람이 수고로우면 쓰는 사람이 편하고, 만드는 사람이 편하면 쓰는 사람이 수고롭다.\u0026rsquo;\n 사내에 붙어있는 말이라고 한다. 하지만 비단 우아한형제들 안에서만 적용되는 말은 것은 아닐 것이다. 고객에게 제공할 서비스를 만들 최적의 설계와 운영을 찾기 위해서 가장 먼저 필요한 것이 있다면, 더 나은 방법이 있는지 찾는 열정과 무수한 테스트와 반복 작업에도 굴하지 않는 끈기일 것이기 때문이다.\n기억에 남는 구절  절차는 절차일 뿐, 대단한 무언가가 아닙니다. 항상 스스로 물어봐야 합니다. 우리가 절차를 이용하는지, 우리가 그 절차에 그냥 속해 있는지 말이죠.\n 스프린트 회고 때 한다는 KPT (keep, problem, try) 소개글 말미에 나온 말인데, 읽고 나서 많은 생각이 들었다. 본래는 절차와 상관없이 항상 신경써야 한다는 것이겠지만, 어쩐지 무임승차적인 의미가 내포되어 있는 것 처럼 느껴졌다. 절차를 따르는 것은 그 자체로 의미가 생기지 않으며, 절차를 따르면서도 항상 의문을 가지고 있어야 한다는 것이겠다.\n 기술 블로그를 운영하는 DR (Developer Relation) 팀이 말한 \u0026lsquo;개발자 교류\u0026rsquo; 가 단순 회사 차원의 활동이 아닌, 모든 개발자를 위한 사회공헌 활동일수도 있겠다는 다소 오버스러운 생각도 들었다. 이 책도 연장선상에 있다고 생각한다. (나도 블로그를 열심히 해야겠다.)\n백엔드/프론트엔드, 신입/경력 가리지 않고 현업에 있는 개발자라면 즐거이 읽을 수 있을 것이다. 아직 개발자가 아닌데 회사 분위기를 느끼고 싶다면 읽어볼 만 하지만, 기술적인 내용이 많이 나와서 이해하기 어려울 수도 있다는 점은 참고하자.\n ※ 이 글은 골든래빗으로 부터 책을 증정받아 작성되었습니다.\n","date":"2023-11-09T15:23:26+09:00","image":"https://interp.blog/woowahan-dev/feature_hu69e33152be318b706ba0c4fa2a7ef39d_56531_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/woowahan-dev/","title":"요즘 우아한 개발"},{"content":"Argo workflow 는, 쿠버네티스 환경에서 Job 을 효율적으로 실행하기 위한 컨테이너 기반의 워크플로우 엔진이다. 그리고 오픈소스이다.\nK8s 에서 이미 Job 이나 Cronjob 을 지원하지만, 각각의 Job (여기서는 template) 에 대한 상관관계 (dependency) 를 List 나 DAG 로 지정할 수 있고, 관련이 없는 Job들을 병렬로 실행할 수 있는 것은 물론, 실행 결과를 쉽게 추적할 수 있는 등의 다양한 기능을 추가로 지원한다.\n여기서는 Argo 의 클러스터 설치는 건너뛰고, Argo 를 클러스터에서 사용할 때 갖춰야 할 기본 개념만 간단히 정리해 보았다.\nWorkflow Core concepts 에서 소개된 대로, Workflow CR (custom-resource) 는 정적인 정의 리소스 (a static definition resource) 처럼 보이지만, 일종의 워크플로우 실행 \u0026lsquo;인스턴스\u0026rsquo; 로 취급된다. 무엇을 실행할지 정의해 둔 객체이면서도, 동시에 (Job 이나 Cronjob 처럼) Succeeded 와 같은 상태를 남기는 것과 같다고 보면 된다.\nWorkflow CR 에서 정의되는 \u0026lsquo;할 일 (work)\u0026rsquo; 의 개념은 spec.templates 에서 정의된다. 할 일이 여러 개일 때, 작업 순서가 Step 형태인지, DAG 형태인지에 따라 steps 또는 tasks 라는 이름으로 세분화되기는 하지만, 기본적으로 Workflow 는 하나 또는 여러 개의 template 을 가진다고 생각하면 된다. (template = work)\nGetting Started 에서 Hello World Workflow 를 심어보도록 하자. kubectl 을 이용해 Workflow CR 자체를 클러스터에 바로 적용해도 되고, argo CLI 명령을 이용해서 입력해도 된다.\n# 둘 모두 결과는 같다. kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-workflows/master/examples/hello-world.yaml argo submit https://raw.githubusercontent.com/argoproj/argo-workflows/master/examples/hello-world.yaml Workflow 확인은 argo CLI 를 쓰는게 편하다.\nargo get @latest template template 은 여섯가지의 타입으로 나뉘어 지는데, 여기 정리하는 것보다는 각각 매뉴얼을 보는게 훨씬 나을 것이므로 종류만 간단히 소개한다.\ntemplate 정의 Definition 이라고도 하고, work 라고도 한다. 즉, 실제로 무엇을 할지 정의하는 부분이다. 아래 4가지는 모두 이름 (name) 이 반드시 포함되어야 한다.\n Container: docker image 를 내려받아, 클러스터 안에서 컨테이너를 확보해 args 를 실행한다. Script: Container 와 유사하지만 source 에 정의된 스크립트 내용을 실행한다. Shell Script 나 Python 코드 블럭이 주로 사용된다. Resource: 클러스터 안에 있는 리소스를 직접 생성하거나 삭제한다. manifest 에 정의된 리소스를 생성하거나 삭제한다. 당연하게도 이 부분엔 제약이 있는데, 연결된 ServiceAccount 에 리소스를 제어할 수 있는 적절한 RoleBinding 이 걸려있어야 한다. Suspend: 단순히 Workflow 를 잠시금 멈추게 한다. 여기서 걸려서 쉬고있을 때 argo resume 을 통해 다음으로 진행이 가능하다.  template 실행 Invocator 라고도 하고, orchestration 이라고도 한다. 즉, 앞서 정의해 둔 template 을 어떻게 실행할지 정의하는 부분이다. 따라서 template: 부분에는, 이미 정의된 template 이름을 참조하게 된다.\n Steps: 여러 개의 step 을 정의하고, 순차적으로 (혹은 병렬로) 실행한다. DAG: 여러 개의 task 를 DAG 로 정의할 수 있다. 이 때 edge 는 template 의 이름이 아닌 task 의 이름이어야 한다.  WorkflowTemplate Argo 를 접하면서 가장 헷갈렸던 부분이 바로 WorkflowTemplate CR 이었다. 아까 들은 template 이랑 무슨 관계인가?\n소개 페이지 에서 짚어준 내용을 들여다 보면, 이 CR 은 Workflow 를 템플릿한다는 뜻이고 앞선 template 과는 관련이 적다는 점을 알 수 있다.\n WorkflowTemplate CR 은 Workflow 를 재사용하기 위해 만든 CR 이다. 즉, Workflow 에서 \u0026lsquo;정적인 정의\u0026rsquo; 부분을 저장해두려고 만든 것이다. template 은 Workflow 의 \u0026lsquo;할 일\u0026rsquo; 을 정의한 것이다. Workflow CR 도, WorkflowTemplate CR 도 한 개의 (또는 여러 개의) template 을 가지고 있어야 한다.   Argo workflow 에서 주로 사용되는 그러면서 엄청나게 헷갈리는 세 가지 개념을 먼저 짚어봤다. 다음에는 어떻게 workflow 를 관리하고 모니터링 할 수 있는지 CLI 와 UI 도구를 잘 써 봐야겠다.\n","date":"2023-11-06T13:41:01+09:00","image":"https://interp.blog/argo-workflow-intro/feature_hud00911a79d15e0ce8ed34121b8f2ad3a_820902_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/argo-workflow-intro/","title":"Argo workflow 3가지 기본 개념"},{"content":"Git 에서 브랜치 (Branch) 를 합치는 방법은 merge 와 rebase 가 있다. 보통은 작업 브랜치를 Pull Request 로 등록할 때, 메인이 되는 main 브랜치 (혹은 master) 와 작업 브랜치 사이에 충돌 (conflict) 이 발생하는 경우에 사용하게 된다.\n그런데, 주변 개발자들은 merge 만 해도 충분하다고 생각하는 것 같다. 나는 rebase 를 해서 깔끔하게 만든 다음에 Pull Request 를 만드는 것을 선호한다. 물론 내 고집만 피울 필요는 전혀 없는 것이, 사실 merge 로 충돌을 제거하면 상관없기 때문이다.\n그러니 우선은 내가 먼저 알아봐야 하겠다. 어느 것이 더 나은지, 언제 merge 를 쓰고 언제 rebase 를 써야 할지 먼저 알아보도록 하자.\n    (adsbygoogle = window.adsbygoogle || []).push({});   git merge 좀 더 쉬운 방법이다. 작업 브랜치 feature 에서 main 브랜치 내용을 합치려면 다음과 같이 하면 된다.\ngit checkout feature git merge main 이러면 커밋 트리 (commit tree) 가 어떻게 생기는지 혹시 본 적이 있는가? git log 만 하게 되면 commit 들이 나열되어 있지만, git log --graph 로 보게 되면 커밋 트리가 한 줄이 아니라 두 줄이 생긴 것을 확인할 수 있다. (Github Desktop 이나 다른 도구를 사용해서도 확인할 수 있다.)\n 출처: Atlassian Git Tutorial\n  이 그림을 잘 보자. 현재 브랜치인 feature 의 헤드 커밋 (HEAD commit) 이 별표로 표시되어 있는데, 사실 merge 작업을 한다고 새로운 수정내역이 있는 것이 아닌데도 새로운 커밋이 하나 더 생긴 것을 확인할 수 있다. 바로 main 브랜치의 새로운 커밋을 연결하는 \u0026lsquo;머지 커밋 (merge commit)\u0026rsquo; 이다.\n나는 이 의미없는 (?) 커밋이 마음에 들지 않았다. 왜냐하면 그래프로 보지 않는 이상, 머지 커밋이 어떤 브랜치의 커밋들을 물고 왔는지 파악하기가 힘들다.\n작업 브랜치와 메인 브랜치만 있다면 괜찮은데, 작업 브랜치가 낳은 또 다른 작업 브랜치가 있는 경우에는 여러 개의 머지 커밋이 중첩될 수 있다. 이럴 땐 커밋 트리가 두 줄이 아니라 세줄 이상도 우습게 생겨난다. 어떤 커밋이 이 아래에서 머지되었는지 파악하기가 점점 어려워진다.\n 어.. 음.. 그냥 지저분해요\n      (adsbygoogle = window.adsbygoogle || []).push({});   git rebase 반면, rebase 는 작업 브랜치의 내용을 메인 브랜치 \u0026lsquo;위에 (onto)\u0026rsquo; 올려두는 작업을 진행하는 것이다.\ngit rebase main 작업한 커밋들을 고스란히 메인 브랜치 위에 올려두기 때문에, 다음과 같은 커밋 트리가 생긴다.\n 출처: Atlassian Git Tutorial\n  아까 그림과 다른 것이, 메인 브랜치 커밋이 따로 놀지 않고 작업 브랜치의 커밋들이 메인 브랜치 위에서 다시 커밋된 모습을 볼 수 있다. 그래서 모든 작업 커밋들이 (별표 표시로) 수정된 것 처럼 보인다.\n머지 커밋? 없다! Pull Request 오픈할 때 충돌이 발생할까? 그럴리가! 메인 브랜치에 고스란히 얹기만 하면 되는데 충돌 해결이 필요없다. 물론 이렇게만 이야기하면 당연히 rebase 를 해야겠지만, 현실은 엄청나게 귀찮고 복잡해서 외면받는 경우가 많다.\n git rebase 매뉴얼이 생각보다 복잡하다. 그냥 merge 하고싶은 생각이 들 정도다. (나처럼) SVN 을 버전 관리 시스템으로 쓴 구세대 개발자들에겐, rebase 라는 개념이 생소해서 잘 안쓰게 된다. 동감한다. 충돌 해결만 하면 되는데, 굳이 rebase 를 해야 하냐는 개발자도 물론 존재한다. 이 또한 공감한다.  세 번째 이야기를 좀 더 해보자. rebase 에는 한 가지 귀찮은 점이 있는데, 바로 작업한 커밋 마다 충돌이 일어나면 그걸 하나씩 해결해주고 \u0026lsquo;rebase 진행\u0026rsquo; 을 시켜야 하기 때문이다.\ngit rebase main # conflict on commit A !! resolving.. git rebase --continue # conflict on commit B again !! resolving.. git rebase --continue # ... A 와 B 에서의 충돌내용이 같을 경우, (운이 좋으면) 한 번만 해결해도 되지만 현실은 그렇지 않다. 그래서 rebase 를 하다보면 충돌 해결에 시간을 조금 더 많이 쓰게 된다는 점은 분명하다.\n어떤 걸 써야 할까 메인 브랜치에서는 rebase 를 하거나, squash 된 commit 만 merge 되도록 해서 커밋 트리를 깔끔하게 유지하자. 작업 브랜치에서 메인 브랜치 내용을 merge 할 때는 사실 어느 것을 써도 무방하지만, 나는 다음 기준으로 사용한다.\n 커밋이 너무 많아서, rebase 하면서 충돌 해결에 시간을 너무 많이 잡아먹을 경우엔 merge 를 사용한다.\n(개인적으로는 merge \u0026ndash;no-commit 으로 작업 내용만 반영받고 충돌을 해결한 뒤 커밋을 따로 하기도 한다) git bisect 로 디버깅을 해야 하는 경우엔 rebase 를 사용한다. 머지 커밋이 끼게 되면 bisect 하기가 쉽지 않았었다.  참고  https://www.atlassian.com/git/tutorials/merging-vs-rebasing  ","date":"2023-10-17T21:23:43+09:00","image":"https://interp.blog/git-merge-rebase/feature_hu3d03a01dcc18bc5be0e67db3d8d209a6_2538919_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/git-merge-rebase/","title":"Git merge vs. rebase"},{"content":"타고 다니는 스포티지에서 오른쪽 주간 주행등이 켜지지 않았다. 공업사에 가면 고쳐줄텐데, 공임비 내는게 아깝기도 하고 전구 하나 갈아끼는데 수리까지 맡길 필요가 있나? 그래서 DIY 로 고쳐 본 기록을 남긴다.\n여기서는, 어떻게 고쳤는지 보다 내 차량에 호환되는 부품을 찾아보는 방법을 정리해 봤다. 물론 현대/기아 자동차만 가능하다.\n어떻게 고칠까? 같은 연식은 아니지만, 주간 주행등을 고친 후기를 찾을 수 있었다.\n 본네트를 연다. 문제가 되는 전구 위치를 찾는다. 해당 위치의 소켓을 반시계방향으로 돌려 빼낸다. 전구를 갈아 끼운 다음, 역으로 다시 소켓을 끼우면 된다.  부품을 알아보자 다행히, 차량에 따라 호환가능한 부품 여부를 쉽게 알 수 있는 사이트가 제공되고 있었다. PC 웹 브라우저에서 부품 상세 검색 (WPC) 웹 페이지에 접속하면 되는데, 처음에 회원가입을 요구한다.\n회원가입 시 (1) 연식이 포함된 차종과 (2) 차대번호는 반드시 입력해야 한다. 두 정보 모두 자동차 등록증에 나와있다. 완료되었으면, 로그인해서, 아래와 같이 WPC 접속 버튼을 클릭한다.\n새 창이 뜨고, 회원가입 시 입력한 차량과 차대번호가 나타나는데 그대로 \u0026lsquo;확인\u0026rsquo; 을 누른다.\n  나의 경우엔 전기부품일 테니까, 일렉트릭 메뉴를 클릭한다. 그러면 상세한 그림이 목록과 같이 나타나는데, 헤드 램프가 가리키는 부분을 눌러도 되고, 해당 부분이 가리키는 코드를 왼쪽 목록에서 찾아서 눌러도 된다.\n그러면 헤드 램프에 대한 상세한 그림이 나타난다. 여기 보면 주간 주행등 위치를 나타내는 (b) 그림을 참고해서 품명코드를 찾고, 왼쪽 코드에서 부품번호를 찾으면 된다.\n내가 필요한 건 두 가지인데, 주간 주행등의 전구가 문제인지 소켓이 문제인지 알 수가 없었기 때문에 둘 다 구매할 생각이었다.\n 1864421058S 전구 (4,400원) 921663K000 소켓 (1,600원)  부품을 사러가자 부품번호를 가지고 온라인몰에서 구매해도 되지만 배송비도 들고 어쩐지 부품 원가보다 훨씬 비싸게 받는 사이트가 많아서, 가까운 오프라인 매장이 있을까 해서 찾아봤었다. 다행히 차로 10분 거리에 현대 모비스 부품 매장이 두 군데나 있었다!\n부품 보유점 검색 에서 부품번호를 입력한 뒤 검색하면, 가까운 보유점을 찾을 수 있다.\n방문 전에 반드시 전화로 재고 여부를 한번 더 확인하는 것이 중요하다. 실시간으로 재고 반영이 되질 않아서, 누군가가 먼저 구매해 버렸을 수도 있기 때문이다. 전화를 미리 해 두면, 부품을 빼 두기 때문에 헛걸음할 가능성을 없앨 수 있다.\n","date":"2023-08-28T11:41:01+09:00","permalink":"https://interp.blog/car-parts-search-hyundai-kia/","title":"내 현대/기아차에 호환되는 부품 검색하기"},{"content":"📙   도서 정보   저자인 \u0026lsquo;세이노\u0026rsquo; 는 인세를 받지 않는다. 종이책도 원가에 가깝게 책정되었고 전자책은 심지어 무료로 볼 수 있다. (내가 이 책을 접하게 된 결정적인 이유다) 그는 까페에 글을 쓰면서부터 수익화를 목적으로 하지 않을 것임을 천명했다. (그래서 부자가 되는 방법을 \u0026lsquo;파는\u0026rsquo; 사람들은 죄다 사기꾼이며, 실제로 부자가 아니라고 비난한다. 맞는 말이다.)\n이 책을 한줄로 평한다면 \u0026lsquo;욕쟁이 부자의 신랄한 인생 잔소리\u0026rsquo; 라고 봐야될 것 같다. 본인은 욕을 잘 안한다고는 하지만, 아무래도 책에 실린 사례가 일종의 \u0026lsquo;반례\u0026rsquo; 다 보니 별의별 연놈-년 들이 다 나온다. 욕쟁이로 비춰지는 건 어쩔 수 없다.\n    (adsbygoogle = window.adsbygoogle || []).push({});   따라할 수 있는 \u0026lsquo;가이드\u0026rsquo;는 아니다 일단 본인 이야기를 많이 한다. 찢어지게 가난했던 시절이 있었고, 그 속에서 어떻게든 살아남아 이렇게 됐다는 이야기는 어디서 많이 들어봤는데? 자신이 무일푼에서 모든 걸 걸고 했으니 다른 사람들도 부자가 되려면 모든 걸 걸어야 한다는 것이 이 책의 분위기라고 봐도 좋다.\n하지만 \u0026lsquo;성공신화\u0026rsquo; 책들이 늘 그렇듯, 성공한 사람들이 가진 본태 능력을 배제한 희망고문이라는 생각이 먼저 들었다. 왜냐하면, 세이노 역시 \u0026lsquo;범인\u0026rsquo; 은 아니라는 걸 알 수 있기 때문이다. 의사인 아버지 밑에서 나고 자랐으니 과연 공부머리가 없었을까? 좀 더 일찍 세상을 깨우친 것이 그를 부자로 만들었을 것이다. 하지만 다른 사람들도 좀 더 일찍 깬다고 같은 사람이 될 수 있나? 결코 아닐 것이다.\n그러니 저자가 말한 대로 이 책을 \u0026lsquo;바늘\u0026rsquo; 처럼 여겨서 인생을 쿡쿡 찔러보며 반추하는 목적으로 받아들여야지, \u0026lsquo;아무나 할 수 있는\u0026rsquo; 성공신화 같은 성서로 받아들여서는 곤란하다는 것이다. 그래서 어쩌면, 이 책은 \u0026lsquo;될 만한 사람들\u0026rsquo; 사이에서 \u0026lsquo;바늘\u0026rsquo; 이 되었으면 하는 바램이 담겨있는 걸지도 모른다. (그런 사람이 얼마나 있겠냐고 냉소적으로 말하지만 말이다)\n    (adsbygoogle = window.adsbygoogle || []).push({});   하지만, 부자가 되지 않아도 괜찮다고? 부자가 되고 싶지 않다는 사람들은 어떤가? \u0026lsquo;이대로 살다 적당히 가죠.\u0026rsquo; 세이노는 이런 사람들을 말리지는 않지만, 과연 미래에도 그런 소리를 하면서 평범하게 살 수 있겠냐는 말을 한다. 어떤 일이 닥칠지 모르기 때문에, 적어도 큰 돈은 우산처럼 들고 있어야 걱정 없이 세상을 살 수 있다는 것이 그의 지론이다. (그는 개인적으로 이 금액을 20억이라 생각하고, 모을 때 까지 검소하게 생활했다고 한다) 우산을 쓰려면, 이들이 그토록 거부하던 부자가 되어야 한다는 결론으로 이끌어낸다.\n그래서 이 책을 \u0026lsquo;성공신화\u0026rsquo; 로 치부해 버리기엔 아까운 면이 있다. 그처럼 커다란 부를 거머쥐자는 취지로 읽기 보다는, 그저 그의 말대로 조금 더 노력해서 조금 더 잘 사는 방법을 배운다고 생각하면 조금 편안하게 읽을 수 있지 않을까?\n(책에서 표현하는) \u0026lsquo;요즘 것\u0026rsquo; 들은 궁금해하지 않는데 알려주면 꼰대라고 한다고 한다. 하지만 적어도 우리는 그의 책을 (공짜로) 펼쳐보면서 질문을 던지기 시작한 것이다. \u0026lsquo;어떻게 하면 잘 살 수 있나요?\u0026rsquo; 그의 조언을 곱씹어보자. 일면 기업친화주의적이고 보수적인 시각이 존재할지라도, 결국 사회에서 인정받고 경쟁하며 살아야 한다면 그의 말을 전부 거부할 수는 없을 것이다.\n","date":"2023-08-21T17:27:12+09:00","image":"https://interp.blog/learning-from-say-no/feature_hud5e00e9cdefea82d3564dbc8b101970c_29727_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/learning-from-say-no/","title":"세이노의 가르침을 읽고"},{"content":"업무의 절반은 문서 작업, 나머지 절반은 코딩 작업이라고 생각한다. 코딩 작업 중에서도 가장 많이 하는 일은, 바로 \u0026lsquo;찾기\u0026rsquo; 이다. 내용을 찾을 때도 있고, 특정 파일을 찾을 때도 있다. 대부분의 경우엔 경로를 외워두거나 하긴 하는데, 정확히 외우지 않아도 되게끔 도와주는 효율 좋은 도구를 소개한다.\n물론 아래 도구는 모두 터미널 기준이고, VSCode 나 PyCharm, Atom 같은 IDE 는 개별 가이드를 참고해서 써야 하겠다. 아래 도구들은 모두 homebrew 에서 설치가 가능하므로, brew 를 이용한 설치 명령을 마지막에 추가해 두었다.\nag, the silver searcher 📌 Github\ngrep 을 대신할 친구다. 나느 grep . -rn 을 밥먹듯이 하는데, ag 를 사용하면 더욱 빠르게 찾을 수 있다.\nbrew install the_silver_searcher ag \u0026lt;pattern\u0026gt; fzf, command-line fuzzy finder 📌 Github\n단독으로 입력하면 File 을 검색한다. 파이프라인에 태우면 앞선 출력에서 검색한다. 이게 마치 \u0026lsquo;검색어 입력\u0026rsquo; 처럼 키워드를 공백으로 띄워가며 입력해도 알아서 잘 찾아주고, 정규 표현식도 잘 먹는다.\nbrew install fzf # solo fzf # or after a pipeline cat file_list.dat | fzf oh-my-zsh 에 fzf plugin 을 활성화하면, 단축키로 파일 검색 (Ctrl+T) 이나 히스토리 검색 (Ctrl+R) 이 가능하다.\nplugin 문제해결 참고로 homebrew 로 설치한 뒤 oh-my-zsh plugin 활성화를 한 다음, zsh 를 다시 실행시키면 다음 에러가 뜰 수 있다.\n[oh-my-zsh] fzf plugin: Cannot find fzf installation directory. Please add `export FZF_BASE=/path/to/fzf/install/dir` to your .zshrc 이 때는 homebrew 의 PATH 설정이 plugin 활성화 시점 이후일 가능성이 높다. 내 경우엔 $HOME/.zshrc 에서 아래 라인을 plugin=(..) 위에 두면 해결이 되었다.\n# in your $HOME/.zshrc export PATH=/opt/homebrew/bin:$PATH eval \u0026#34;$(/opt/homebrew/bin/brew shellenv)\u0026#34; # ... plugin(fzf ...) fd, simple and fast alternative to find 📌 Github\nfind 을 대신할 친구다. 파일 찾기가 더 빠르다고 한다. 참고로 README 에 한국어가 지원되는데, 아니나 다를까 Main Contributor 가 한국 분이신 정창권 님이시다. (감사합니다!)\nbrew install fd fzf 역시 파일 검색을 할 수 있지만, 내부에서는 find 결과를 얻어 처리하는 수준이다. 따라서, fzf 가 fd 를 사용하게 만드려면 다음의 환경변수가 추가로 필요하다.\nexport FZF_DEFAULT_COMMAND=\u0026#39;fd — type f\u0026#39; ","date":"2023-05-09T13:18:40+09:00","permalink":"https://interp.blog/useful-3-terminal-tools/","title":"자주 쓰는 3가지 파일 검색 터미널 도구"},{"content":"Jupyter Notebook 이란 웹 브라우저에서 Python 코드를 작성/실행하는 REPL (Read-Eval-Print Loop) 개발 도구이다. 주로 머신러닝이나 데이터분석 용도로 Python을 사용할 때 쓰이는 도구이다. 코드를 작성하고 곧바로 실행한 결과를 볼 수 있어 간편하며, Notebook 파일로 공유가 가능하다는 특징이 있다.\n원래는 Anaconda 를 활용하면서 Notebook 웹 서비스를 컴퓨터에 띄우는 게 일반적인 사용 방법이다. 하지만, Anaconda 설치나 웹 서비스를 띄우지 않고도 VSCode 에서 곧바로 사용해 볼 수 있는 가장 빠른 방법 역시 정리해 봤다. (물론 conda 를 쓰지 않는다 뿐이지, 나 또한 가상환경을 따로 설정해서 썼으니 사실상 원리는 똑같다.)\nVisual Studio Code 에서 확장 프로그램 설치 View \u0026gt; Extensions 으로 이동해서 jupyter 라고 검색하자. Microsoft 에서 공인된 확장 프로그램이 여럿 나오는데, 맨 위에 있는 Jupyter 만 설치해도 알아서 설치될 것이다.\n아래 노란색으로 칠해 둔 것은 실험적인 기능을 위한 확장 프로그램이니, 필요한 경우에만 설치하도록 하자.\n한 가지 더, Python 확장 프로그램도 설치되었는지 확인하자.\n  환경 설정 (1) Python Anaconda 없이 쓸 경우, Python 이나 Virtualenv 와 이미 친숙한 경우라면 이 방법이 좀 더 수월할 수 있다. Python 설치가 안 되어 있다면 설치하면 되는데, Python 버전은 3.8 이상이면 된다. (ipykernel 때문)\n여기에 프로젝트 디렉터리를 만들고, 거기에만 사용할 가상 환경을 꾸리려면 virtualenv 를 사용하자.\n현재 디렉터리가 프로젝트 디렉터리라고 가정하고, 다음을 실행하자. (Windows 의 경우엔 cmd, powershell 에 따라 활성화 방법이 조금 다르다.)\npython -m pip install virtualenv python -m virtualenv venv source venv/bin/activate pip install jupyter ipykernel 환경 설정 (2) Anaconda 파이썬 설치나 가상환경 만드는 것 자체가 귀찮거나, 파이썬과 친숙하지 않은 경우, 윈도우에서 한 방에 Jupyter Notebook 을 실행하고자 하는 경우라면 Anaconda 가 더 좋을 수 있다. 사용자가 필요없는 패키지도 설치하기 때문에 용량이 크고 시간이 오래 걸린다는 점은 단점이겠지만 말이다.\n다운로드 사이트에서 운영체제에 맞는 설치 파일을 내려받아 실행한 뒤, 설치가 끝나면 준비가 완료된 것이다.\n여기서 가상환경을 만들고 싶다면 다음과 같이 한다. 이렇게 하면, 프로젝트 디렉터리 내부에 venv 따위를 만들지 않아도 되는 편리함은 있다. 대신, 이 때 나오는 environment location 을 잘 기억해 두자.\nconda create -n jupyter_env conda activate jupyter_env 실제 사용 다른 예제에서는 ipykernel 을 설치하거나 웹 서비스를 띄워서 브라우저에서 접속한 뒤에 개발을 시작하는데 그럴 필요가 없다.\n 프로젝트 디렉터리를 만든다. (virtualenv 를 사용한 경우라면 작업해 둔 디렉터리가 이미 있어야 한다) VSCode 로 해당 디렉터리를 오픈한다. (File -\u0026gt; Open Folder..) 여기서 작업할 것이다. Command Palette (Ctrl+Shift+P 또는 Cmd+Shift+P) 를 열어 Create: New Jupyter Notebook 을 선택한다. Notebook 파일이 하나 생성되었다. (아직 저장은 안 됨) 이 노트북이 사용할 커널 환경을 지정해야 하는데, 우리가 만든 가상환경 또는 파이썬 실행파일을 지정하기만 하면 알아서 다 해주니까 너무 걱정말자. 다시 Command Palette 를 열어, 이번엔 Notebook: Select Notebook Kernel 을 선택한다. 반드시 Notebook 파일이 열린 상태에서 선택해야 하며, 다른 파일에서는 아무런 반응이 없으니 주의. Select Another Kernel.. 을 선택. Python Environments.. 를 선택. 이제 Anaconda 를 했건, Virtualenv 를 사용했건 간에 VSCode 가 인식할 수 있는 모든 Python binary 경로가 나온다. 원하는 경로에 있는 Python 을 선택하고, 만약 없으면 Python binary 의 경로를 직접 입력해 주자.  그러면 VSCode 가 알아서 jupyter 와 ipykernel 을 설치해 준다!\nVirtualenv 의 경우에는 직접 설치하라고 귀띔해 주긴 했는데, 내 기억엔 저게 필요 없었던 것 같지만 보험 차원에서 설명한 것이니 이해해달라.\n결과 나는 Anaconda 로 설치해 둔 게 있어서 환경만 새로 만들어 다음과 같이 바로 돌려봤다. 심지어 Notebook 파일을 저장하지 않았는데도 잘 도는 것을 확인할 수 있다!\n  응용 만약 다른 튜토리얼처럼 웹 서버를 실행한 경우엔 어떡할까? 아까 눈치챘겠지만 `Select Another Kernel..' 화면에서 Existing Jupyter Server 를 선택할 수 있다. 거기서 오픈된 웹 서버 URL 을 입력하면 똑같이 VSCode 인터페이스에서 개발이 가능하다!\n","date":"2023-05-08T09:40:22+09:00","permalink":"https://interp.blog/jupyter-notebook-vscode/","title":"Jupyter Notebook on VSCode"},{"content":"문제 pyenv 를 이용해 Python 3.7 버전 이상 (내 경우는 3.9 버전 이상) 설치할 때 다음의 에러를 만났다. (하다 보니 둘 다 만났다)\nERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib? *** WARNING: renaming \u0026#34;_hashlib\u0026#34; since importing it failed: /usr/lib64/libcrypto.so.1.1: version `OPENSSL_1_1_1\u0026#39; not found (required by /tmp/python-build.20230418192124.103279/Python-3.10.11/build/lib.linux-x86_64-3.10/_hashlib.cpython-310-x86_64-linux-gnu.so) 추적 결론은 OpenSSL 1.1.1 을 설치해야 한다는데, 내 경우엔 이 방법이 전부 힘들었다.\n 1.1.1 을 패키지 매니저로 설치할 수 없는 Linux OS 였고 Homebrew 로 설치하면 무슨 이유에선지 엄청나게 꼬였다 (ld 링크할 때 엉뚱한 곳을 본다던가..)  화면에 바로 안내되는 URL 를 살펴보면, openssl 을 수동으로 설치하는 방법이 아래에 안내되어 있다. 가장 확실한 방법이다.\n해결  Installing OpenSSL locally under your username 으로 접속 Installing OpenSSL 을 하나씩 따라하기 (매우 친절하다!)  username 부분을 바꾸는 걸 잊지 말자. 이 때, make test 가 실패할 수 있다. 그럴 땐 아쉽더라도 make install 이후 과정을 진행한다.   다음을 입력한다.  CPPFLAGS=-I$HOME/openssl/include \\ LDFLAGS=-L$HOME/openssl/lib \\ SSH=$HOME/openssl pyenv install -v 3.7.2 # 원하는 버전을 입력 SSL 에러? 간혹, 다음 에러를 마주하게 될 수 있다.\npyenv install -v 3.9.15 /tmp/python-build.20230419102453.2507312 ~ Downloading Python-3.9.15.tar.xz... -\u0026gt; https://www.python.org/ftp/python/3.9.15/Python-3.9.15.tar.xz curl: (60) SSL certificate problem: unable to get local issuer certificate More details here: https://curl.haxx.se/docs/sslcerts.html 이럴 땐, 아까 OpenSSL 설치하면서 진행했던 환경변수 설정 부분에서 다음을 주석처리한다. 다시 설치를 시도하면 성공!\n# export PATH=$HOME/openssl/bin:$PATH # export LD_LIBRARY_PATH=$HOME/openssl/lib # export LC_ALL=\u0026#34;en_US.UTF-8\u0026#34; export LDFLAGS=\u0026#34;-L /home/username/openssl/lib -Wl,-rpath,/home/username/openssl/lib\u0026#34; ","date":"2023-04-19T11:39:11+09:00","permalink":"https://interp.blog/pyenv-openssl-problem/","title":"Pyenv 로 Python 설치 할 때 Openssl 문제"},{"content":"내 Macbook M1 Pro 에는 두 개의 디스플레이가 있다.\n DELL U3818DW BenQ EX2780Q    델 38인치 와이드 모니터는 주사율이 60Hz 밖에 지원되지 않지만, 벤큐의 27인치 모니터는 게이밍 답게 144Hz 까지 지원한다. 나름 들어줄 만한 스피커도 있어서 서브로 잘 쓰는 중이다\n증상 그런데 이 \u0026lsquo;디스플레이\u0026rsquo; 옵션에서는 HiDPI 설정만 하면 주사율이 50Hz 까지만 올릴 수 있다. HiDPI 를 끄면 144Hz 까지 선택할 수 있는데 말이다.\n내가 원하는 것은, 자글거리는 폰트를 두고 고주사율로 쓰는 게 아니라, HiDPI 이면서 144Hz 로 쓰고 싶었다. 좋은 방법이 없을까?\n  해결 (1) Better Display 설치 Better Display 를 설치할 수 있다. 기본적으로 무료이고, 특정 기능을 사용하려면 구입해야 하지만 여기서는 무료 기능만 있어도 충분하다.\n설치하고 실행하면, 아래와 같이 해상도, 주사율 설정이 가능하다. HiDPI 설정하고도 주사율을 144Hz 까지 올릴 수 있다!\n  참고할 점은, 아까 디스플레이 설정에서 HiDPI 를 선택하면 자동으로 주사율 50Hz 가 선택될텐데, 이 상태에서 Better Display 를 실행시키면 해상도가 모두 보이지 않는다. 이 때는 주사율을 먼저 50Hz 보다 높은 값으로 변경하면 된다. 그러면 해상도 옵션이 늘어난다.\n해결 (2) 더욱 세밀한 HiDPI 해상도 설정 여기서 문제는, Better Display 를 해도 HiDPI 해상도 옵션이 몇개 없다는 사실이다. 나는 조금 더 큰 폰트 크기를 원했기 때문에, 두 개의 옵션 사이에 있는 중간 정도의 HiDPI 해상도를 원했다. 그렇다면 어떻게 해야 할까.\n   먼저 \u0026lsquo;디스플레이\u0026rsquo; 옵션에서 모니터를 선택한 뒤, \u0026lsquo;모든 해상도 보기\u0026rsquo; 를 클릭한다. 원하는 HiDPI 해상도를 선택한다. (나는 두 가지 옵션의 사이에 있는 1920x1080 을 선택했다) Better Display 에 가서, 아무것도 건드리지 말고 주사율 (Refresh rate) 만 144Hz 로 올린다.  그러면 원하는 해상도로 고주사율의 디스플레이를 사용할 수 있다!\n","date":"2023-04-18T14:04:01+09:00","image":"https://interp.blog/mac-display-resolution-adjustment/feature_hu43356a195e024c64166fce239cf0e8d2_1638563_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/mac-display-resolution-adjustment/","title":"Mac 디스플레이 해상도 조절 팁"},{"content":"문제 Visual Studio Code 에서 Vim Plugin 을 쓰던 중, 입력한 것을 되돌리기 위해 u 를 꾹 눌렀다.\n그러면 아래와 같이 u 라는 알파벳에 어떤 변형을 가할 것인지 묻는다. 한/영만 필요한 나에게는 필요없는 기능인데..\n  (참고로, u 를 꾹 누르는게 아니라 반복해서 입력해도 한 번만 입력되는 경우엔 블로그의 다른 포스팅을 참고하자.)\n해결 터미널에서 다음을 입력하고, VSCode 를 재시작한다.\ndefaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false 참고 출처는 여기 Stack overflow 페이지에서 찾을 수 있다.\n참고로 모든 프로그램에서 저 변형 대화창을 끄고 싶다면 다음과 같이 입력한다.\ndefaults write -g ApplePressAndHoldEnabled -bool false 윗 부분의 출처는 준호씨의 블로그 포스팅이다. (감사합니다!)\n","date":"2023-04-03T16:17:59+09:00","image":"https://interp.blog/vscode-vim-mac-key-pressing-input/feature_hu6a165a43bd573d6b65999ef2fc7c86c0_5646867_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/vscode-vim-mac-key-pressing-input/","title":"VSCode Vim 에서 키를 눌러 계속 입력하게 만들기"},{"content":"  디지털 마케팅? 데이터 분석? 솔직히 말하자. 모두들 온라인 쇼핑몰을 운영하는 것은 아닌데, 왜 이 책이 필요한가?\n부제목처럼 \u0026lsquo;디지털 마케팅 데이터 분석\u0026rsquo; 을 위한 구글 서비스, Google Analytics 4 (GA4) 를 소개하고, 사용 방법을 매우 친절히 알려주는 책이다. 하지만 어쩐지 \u0026lsquo;모두의\u0026rsquo; 책이라고 하기엔 \u0026lsquo;디지털 마케팅\u0026rsquo; 이 생소하게 느껴진다.\n디지털 마케팅이란, 웹 페이지나 앱을 통해 수익을 창출하는 방법을 말한다. 말하자면 웹이나 앱 개발이 포함된다는 뜻이기도 하다. 이러니까 더욱 생소하다.\n하지만 이 책은 그런 개발 과정을 소개하는 것이 아니라는 점을 분명히 하고 싶다. 이미 그런 마케팅을 하고 있다고 가정하기 때문이다. 그 안에서 수집할 수 있는 데이터를 효과적으로 \u0026lsquo;분석\u0026rsquo; 하기 위한 책이다. 즉, 개발과는 관련이 없다.\n 그러면 GA4 는 수익 창출, 그러니까 물건이나 서비스를 팔 때만 쓸모있는 것일까? 물론 그렇겠지만, 꼭 그렇지만은 않다고 생각한다. 블로그 같은 퍼스널 브랜딩 도구 역시 웹 페이지이기 때문에, 일종의 디지털 마케팅 플랫폼이 될 수 있다.\n쉽게 말하면, 그 옛날 싸이월드 미니홈피나 블로그 방문자 수만 쳐다보던 걸 넘어서서, GA4 를 통해 어떤 경로로 접속했고 어느 국가에서 몇 시에 접속했는지를 볼 수 있다는 뜻이다. 부족한 수치는 메꿀 방법을 고민하고, 넘치는 수치는 기뻐하면서 말이다.\n\u0026lsquo;모두\u0026rsquo; 를 위해 쉽게 썼다 무엇보다도, 이 모든 설명들, 디지털 마케팅부터 시작해서 GA4 소개까지를 매우매우 친절하게 알려준다. 흡사 IT 기초 입문서가 아닐까 착각하게 만들 정도로 용어에 각주를 세심히 달았고, GA4 의 이전 버전 개념인 UA 와의 차이는 끊임없이 언급한다. 읽다 보면 GA4 가 UA 대비 안 좋아진 것 처럼 느껴지긴 하지만\n그리고 이 책은 조금 특별한 가치가 있다. 공식 문서나 파편화된 인터넷 정보 또는 다른 서적에서는 잘 보이지 않던, \u0026lsquo;번역된 단어\u0026rsquo; 를 충분히 이해시키기 위해 집중하는 모습을 보인다는 점이다. 처음 언급되는 개념은 한글과 영문을 같이 썼고 다음부터는 한글만 언급하는 식으로 구성되어 있지만, 이렇게 번역된 단어가 모호한 경우에는 어떤 의미인지 한번 더 풀어서 설명한다.\n예를 들어, 서문에서도 나오던 \u0026lsquo;측정기준 (dimension)\u0026rsquo; 과 \u0026lsquo;측정항목 (metric)\u0026rsquo; 은 당장 이해하기 힘든 면이 있다. 하지만 수집 데이터에서 기준이 되는 문자열 데이터 (\u0026lsquo;초등학생\u0026rsquo; 이나 \u0026lsquo;대학생\u0026rsquo;) 가 기준이 되고, 이 데이터와 연결된 수치 데이터 (\u0026lsquo;평균 키\u0026rsquo; 또는 \u0026lsquo;평균 몸무게\u0026rsquo;) 가 항목이 될 것이다. 이런 부분을 세세하게 짚어주는 것이, 이 책의 장점이라 할 수 있겠다.\n또한, 책을 촤르륵 넘겨 보면 스크린샷이 엄청나게 많은 걸 확인할 수 있다. 패널과 메뉴의 위치를 구분해서 설명하는 걸 넘어서서, 화면이 전환될 때 마다 스크린샷이 반드시 들어가 있다. 데이터 분석에 필수적인 보고서 영역이 종류마다 다르고 버튼이 많아서 설명할 양이 많은데도 불구하고, 나름 효과적으로 설명하고 있다.\n분석을 하지 않아도 좋다 당장 디지털 마케팅을 하고 있지 않아도, 분석가가 될 계획이 없어도, 심지어 블로그나 웹 페이지 따위가 없는 사람이라도 이 책을 추천하는 이유가 있다.\n데이터를 수집한다는 것은, 웹 페이지 소스코드나 텍스트 입력 한 줄 까지 통째로 모은다는 뜻이 아니다 (가능하지도 않다). 책을 읽어보면 알겠지만 GA4 에서 수집하는 데이터는 방대하긴 하지만, 지극히 한정적이다.\n그렇다면 여기서, 왜 이런 데이터만 수집해 주는 것인지 우리가 이해해 볼 순 없을까? 그걸 GA4 는 어떻게 그룹지어 제공하고, 그 이유는 뭘까? 뻔한 답이지만, 간단히 말해서 그런 데이터들이 디지털 마케팅에서 가장 원하는 데이터들이기 때문이다. GA4 는 그런 면에서 거의 산업 표준에 가까운 셈이다.\n 우리는 개발자도 분석가도 아니지만, 분명 웹 페이지를 들락날락하는 \u0026lsquo;방문자\u0026rsquo; 이다. 우리가 만드는 데이터 중 어떤 데이터를 구글에서 모아 주고, 어떻게 이걸 의미있는 결과로 분석할 수 있는지를 이해하는 것도 가치있는 일이라고 생각한다.\n그렇다면, 정말 \u0026lsquo;모두\u0026rsquo; 를 위한 이 책이 데이터 분석의 세계로 친절히 안내해 줄 것이다.\n ※ 출판사의 서평 이벤트를 통해 증정받은 책으로 작성하였습니다.\n","date":"2023-03-31T17:30:00+09:00","image":"https://interp.blog/everyones-google-analytics-4/feature_huca8ebde88dd41631c3db6bf7fb81938b_217389_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/everyones-google-analytics-4/","title":"모두의 구글 애널리틱스4 를 읽고"},{"content":"책 개발자를 위한 머신러닝\u0026amp;딥러닝 을 구매해서 읽어보고 있는데, 실습을 해 보기 위해 M1 Pro 칩의 Macbook Pro 에 환경을 설정하려고 했다.\n처음에는 virtualenv 로 가상 환경을 구성하고 tensorflow 를 pip 로 설치하면 되지 않을까? 하는 순진한 생각이었다. 그런데 예제 코드를 돌려보니 뿜어져 나오는 에러에 당황하고 말았다.\n다른 가이드들도 많지만 한번 이해하는 차원에서 여기 다시 정리해 둔다.\nMiniconda 설치 Anaconda 에서 제공하는 tensorflow 관련 dependency 를 설치하기 위해, Anaconda 를 설치해야 한다. 하지만 여기서는 전체 설치를 할 필요는 없고 Miniconda 만 설치해도 된다.\n다음 경로 중 하나를 선택해 Shell script 파일을 다운로드 받는다. 두 번째가 직접 다운로드 가능한 경로이다.\n Miniconda Download page Shell script 다운로드 링크  파일이 위치한 곳에서, 다음 명령을 차례대로 입력한다.\nbash ./Miniconda3-latest-MacOSX-arm64.sh -b -p $HOME/miniconda source $HOME/miniconda/bin/activate conda conda 명령에 에러가 없으면 설치가 완료되었다. 추가로 다음을 입력해 주자.\nconda init {shell} {shell} 에는 현재 사용중인 쉘을 입력한다. bash, zsh 같은 것 말이다. 잘 모르겠다면 echo $SHELL 을 입력해서 알아내자.\nConda 환경에서 Tensorflow 설치 Apple Developer Page 에 안내된 대로 설치하면 완료된다.\nconda create -n tf-env python=3.8 conda install -c apple tensorflow-deps 위와 같이 conda environment 를 설정한다.\nPython 버전은 3.8 이 테스트되었고 다른 버전에 대해서는 자잘한 문제를 일으킬 수 있으니, 버전 업그레이드는 추천하지 않는다.\nconda activate tf-cert3.8 pip install tensorflow-macos==2.9.0 pip install tensorflow-metal==0.5.0 tensorflow-macos 나 tensorflow-metal 의 버전도 가급적이면 그대로 놔 두길 추천한다. 참고로 최신 버전은 현재 2.11.0 까지 확인되었다.\n설치 확인 import tensorflow as tf print(tf.__version__) 버전이 잘 출력되면 성공이다.\n테스트 코드 확인 여려 예제가 있겠지만, 책의 첫 번째 예제 코드를 실행해 보자.\n여기에서 Jupyter Notebook 파일로 제공되고 있으니 코드만 긁어다가 파이썬으로 실행해서 문제가 없어야 한다. (혹시 코드가 궁금하다면, 책을 한 번 읽어보길 권한다!)\nimport tensorflow as tf import numpy as np from tensorflow.keras import Sequential from tensorflow.keras.layers import Dense dense = Dense(units=1, input_shape=[1]) model = Sequential([dense]) model.compile(optimizer=\u0026#39;sgd\u0026#39;, loss=\u0026#39;mean_squared_error\u0026#39;) xs = np.array([-1.0, 0.0, 1.0, 2.0, 3.0, 4.0], dtype=float) ys = np.array([-3.0, -1.0, 1.0, 3.0, 5.0, 7.0], dtype=float) model.fit(xs, ys, epochs=500) ","date":"2023-02-27T00:00:00+09:00","image":"https://interp.blog/apple-silicon-mac-tensorflow-install/feature_huf0548c6f5090259b22a2de3fd3dc97e4_9743739_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/apple-silicon-mac-tensorflow-install/","title":"Apple Silicon Mac 에 Tensorflow 설치"},{"content":"문제 최근에 Undo 키인 u 와 Reo 키인 Ctrl+r 을 반복해서 입력해도, 딱 한 번씩만 작동하는 현상을 겪었다.\n조치 우선 VSCodeVim 의 이슈에는 몇년 전에 올라온 것 이 있는데, 최근 코멘트를 뒤지다 보니 workaround 는 찾을 수 있었다. (링크)\n Command Palette 를 열어서 Preferences: Open User Settings (JSON) 을 검색해 선택한다. 열린 JSON 파일에, 다음을 붙여넣는다.  \u0026#34;vim.normalModeKeyBindingsNonRecursive\u0026#34;: [ { \u0026#34;before\u0026#34;: [ \u0026#34;u\u0026#34; ], \u0026#34;after\u0026#34;: [], \u0026#34;commands\u0026#34;: [ { \u0026#34;command\u0026#34;: \u0026#34;undo\u0026#34; } ] }, { \u0026#34;before\u0026#34;: [ \u0026#34;\u0026lt;C-r\u0026gt;\u0026#34; ], \u0026#34;after\u0026#34;: [], \u0026#34;commands\u0026#34;: [ { \u0026#34;command\u0026#34;: \u0026#34;redo\u0026#34; } ] } ] 물론 특정 Workspace 에만 설정하고 싶다면, Preferences: Open Workspace Settings (JSON) 을 선택해 편집하면 된다.\n","date":"2023-02-21T00:00:00+09:00","image":"https://interp.blog/vscode-vim-undo-redo-key-repeat/feature_hu2a6902b8fda31323fd4b9c35c58d46fc_343150_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/vscode-vim-undo-redo-key-repeat/","title":"VSCode Vim Undo/Redo 키 반복 입력이 안 될 때"},{"content":"어느 날, GCP 에서 알람이 날아왔다. 테스트로 docker container를 하나 올려 둔 VM (Compute Engine) 에서 Disk 가 꽉 차서 아무것도 할 수 없다는 것이었다.\n디스크를 쓴다고? 이 container 는 mount 된 volume 도 없었고, container 가 하는 일은 소스에서 데이터를 받아 계산한 뒤 GCP Cloud Storage 에 저장하는 것 밖에 하지 않는데?\n문제 Docker container 만 떠 있고 아무런 작업을 하지 않는 Host 의 디스크 사용량이 계속해서 줄어든다. 결국, 디스크를 100% 가까이 쓰게 되어 시스템을 마비시킨다.\n진단 우선 해당 Host (VM 또는 on-premise) 에 접속해서 df -h 를 실행하자. / 경로에서 디스크 사용량이 압도적으로 많다면, 해당 문제에 접근한 것이다.\n이제 이 부분을 실행해 보자. (root 가 아니라면, sudoer 권한이 필요하다)\nsudo du -h -d 1 /var/lib/docker/containers 해당 경로에서 특정 container 의 디스크 사용량이 df -h 를 입력했을 때의 사용량과 비슷하다면, 이 친구가 문제다.\n분석 그렇다면 왜 디스크를 쓰는 container 가 아닌데, 이렇게 디스크를 먹었던 것일까?\ndocker logs 를 입력하면 container 의 stdout/stderr 출력 내용을 볼 수 있다. 문제는, Docker daemon 은 별다른 지시가 없다면 container 가 출력하는 내용을 전부 디스크에 쓴다는 것이다.\n바로 /var/lib/docker/containers 경로에 말이다!\n Docker docs 페이지에도 같은 내용을 경고하고 있다.\n By default, no log-rotation is performed. As a result, log-files stored by the default json-file logging driver logging driver can cause a significant amount of disk space to be used for containers that generate much output, which can lead to disk space exhaustion.\n 해결 container directory 를 지우는 것은, 문제를 완화하고 서비스를 잠시 정상으로 되돌려 놓을 순 있지만 진짜 해결책은 아니다.\n분석에서 말한 대로, container 가 출력하는 내용을 rotation 으로 기록하도록 만들어야 한다. 즉, 최근 출력만 기억하게 하고 오래된 것은 삭제하도록 말이다.\n먼저, /etc/docker/daemon.json 에 아래 내용을 넣는다. (없으면 만든다)\n{ \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;10m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;3\u0026#34; } } container 가 출력하는 최신 내용을 JSON 포맷으로 10MB 씩 3개의 파일로 저장하고, 오래된 내용은 없애도록 하는 것이다. 원하는 값으로 수정하거나, Docker docs 페이지 를 참고해 다양한 설정으로 바꿔줘도 무방하다.\n설정이 끝났다면, Docker daemon 을 재시작한다. 나의 경우엔 sudo service docker restart 로 재시작했다.\n이후 container 를 다시 실행시킨 뒤, 출력이 쌓일 때 까지 기다렸다가 /var/lib/docker/containers/ 에서 {container_id} directory 에 있는 .log 파일이 3개만 생성되어 있는지 확인하면 된다.\n","date":"2023-02-09T02:00:00+09:00","image":"https://interp.blog/docker-container-print-uses-disk/feature_hua372664d1b649d477eea3f46832f84ed_620755_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/docker-container-print-uses-disk/","title":"Docker Container 출력이 Disk 를 채운다"},{"content":"시작하면서 SSL/TLS/HTTPS 부터 알아보자.\n SSL (Secure Socket Layer): 클라이언트와 서버 간 보안 통신을 위한 프로토콜이다. TLS (Transport Layer Security): SSL 에서 발전된 프로토콜. SSL/TLS 로 묶어서 부르고 있음. HTTPS (HTTP Secure): SSL/TLS 위에서 통신하는 HTTP  결국은 셋 모두 \u0026lsquo;클라이언트와 서버가 주고받는 정보가 안전하게 만드는 프로토콜\u0026rsquo; 이라는 것인데, 그럼 TLS 에서는 어떻게 정보를 안전하게 만드는 걸까? 이해한 대로 최대한 쉽게 풀어내 보려고 한다.\n대부분의 내용은 Udemy CKA 강의를 바탕으로 정리했다.\n시나리오 (1) 암호화, 비대칭 키 태초에 (?) 클라이언트와 서버는 다음과 같이 통신을 시작한다.\n  클라이언트가 서버에 접속한다. 서버는 클라이언트에게 사용자 정보 (ID, Password) 를 요청한다. 클라이언트는 사용자 정보를 서버에게 보낸다. 이제 서버는 클라이언트의 사용자를 확인할 수 있다.   이 과정에 아무런 보안이 적용되지 않는다면, 해커가 패킷을 수집해서 ID 와 패스워드를 들여다 볼 수 있다. 평문 (plain text) 으로 전달되기 때문이다. 그렇다면 이 평문을 알아볼 수 없게 해야 한다. 암호화/복호화 (encryption/decryption) 를 해야 한다.\n서버는 암호화와 복호화가 가능한 키 (key) 를 만들어 뒀다고 가정하자.\n 서버는 클라이언트에게 키를 준다. \u0026lsquo;이걸로 암호화해서 줘\u0026rsquo; 클라이언트는 서버가 준 키를 가지고 사용자 정보를 암호화해서 보낸다. 서버는 암호화한 정보를 복호화해서 안전하게 (?) 사용자를 확인한다.   이 시나리오의 문제는? (2) 에서 키를 보내는 패킷은 암호화되지 않는다는 점이다. 이 키를 읽게 되면, (3) 에서 보낸 정보를 해커 역시 복호화 할 수 있게 된다. 그래서 나온 것이 비대칭 키 (asymmetric key) 이다. 오래전부터 사용된 RSA 같은 것들 말이다.\n이번엔 서버가 공개 키와 비공개 키를 한 쌍 (public/private key pair) 만들어 뒀다고 가정하자.\n 서버는 클라이언트에게 공개 키를 준다. \u0026lsquo;이걸로 암호화해서 줘\u0026rsquo; 클라이언트는 서버가 준 공개 키를 가지고 사용자 정보를 암호화해서 보낸다. 서버는 암호화한 정보를 비공개 키로 복호화해서 안전하게 (?) 사용자를 확인한다.   여기서 주목할 점은, 공개 키는 암호화할 때 쓰고 비공개 키는 복호화 할 때만 쓴다는 점이다. 그러면 복호화에 필요한 비공개 키는 해커가 알 수 없으니 안전해 보인다.\n시나리오 (2) 피싱, 그리고 인증서 이번엔 해커가 패킷을 수집하는 것을 포기하고, 클라이언트나 사용자를 속여서 피싱을 했다고 가정하자.\n피싱 방법은 여러 가지인데, 사회공학적 기법으로 구별하기 어려운 URL 을 사용자에게 제공하거나, 클라이언트나 DNS를 해킹하는 방법이 필요하겠다. 아무튼 해커가 준비한 가짜 사이트로 들어가게 되면, 해커가 마련한 비대칭 키를 가지고 사용자 정보가 고스란히 넘어가게 된다.\n이런 시나리오를 방지하기 위해서, 서버가 보내는 공개 키를 누군가가 보증해야 하며, \u0026lsquo;이 공개 키는 안전합니다! 안심하고 정보를 넘겨 주십시오\u0026rsquo; 라는 뜻의 인증서가 필요하다.\n 서버는 클라이언트에게 공개 키가 담긴 인증서를 준다. \u0026lsquo;이거 인증 받은 공개키야, 이걸로 암호화해서 줘\u0026rsquo; 클라이언트는 서버가 준 인증서가 진짜인지 확인한다. (사인해 준 곳에 가서 물어보거나..) 클라이언트는 서버가 준 공개 키를 가지고 사용자 정보를 암호화해서 보낸다. 서버는 암호화한 정보를 비공개 키로 복호화해서 안전하게 (?) 사용자를 확인한다.   이렇게 공개 키를 인증받고 교환하는 모든 과정을 공개 키 기반 구조 (Public Key Infrastructure, PKI) 이라고 부른다. 그리고 PKI 의 ITU 표준이 X.509 인 것이다.\n간략히 말하자면, 이 인증서에는 (1) 공개 키 (2) 서버의 신원 (호스트네임, 기관이나 개인 이름 등) (3) 인증서에 사인을 해 준 기관 (Certificate Authority, CA) 이 포함되어 있다. (CA 로부터 사인받지 않았다면 self-signed 로 표시된다)\n💡   \u0026lsquo;CA 의 비대칭 키 한 쌍\u0026rsquo; 은 Root/Intermediate Certificate 라고 한다.  Root 와 Intermediate 의 차이는 CA 의 공개 키를 어디서 인증 받았는지 여부에 달렸다. Root Certificate 의 공개 키는 Self-signed 이고, Intermediate Certificate 의 공개 키는 는 다른 CA 가 사인해 준 것이다. CA 에서 발급받은 일반 인증서는 Leaf Certificate 라고 부른다. (링크)  일반적인 인터넷 환경이라면 이 차이를 굳이 알 필요가 없지만, Kubernetes Cluster 를 구축하거나 운영할 때는 master node 에 위치한 Root Certificate 부터 다룰 수 있어야 한다. (K8s Cluster 의 다른 서비스와 보안 통신을 하기 위해서!)   자, 이제 여기서 해커가 생각할 수 있는 건 무엇일까?\nSelf-signed 인증서를 보낸다면? 위의 피싱 시나리오에서, 해커가 혼자 사인한 (self-signed) 인증서로 감싸서 던지면 되지 않을까?\n이제부터는 클라이언트 (좀 더 친숙한 표현으론, 웹 브라우저) 에서 경고를 뿜는다. \u0026ldquo;이 인증서를 받았는데, 발급 기관이 없는데요? (아니면 이상한데요?)\u0026rdquo; 라고 말이다. 쉽게 말하면, 주소창에 https:// 로 시작하는 주소를 입력했는데, 자물쇠 모양이 빨갛게 보이는 경우다.\n해커가 CA 를 만들어 사인을 받는다면? 아예 악의적인 CA 를 만들어서, 거기서 인증서를 사인해 주면 어떨까?\n대부분의 웹 브라우저는 공인된 CA 의 공개 키를 이미 내장하고 있다. 이외의 CA 와 통신하고자 한다면 브라우저가 경고를 보낸다. \u0026ldquo;이 인증서가 진짜인지 확인하기 위해, 인증서가 가리키는 CA 와 통신하려고 하는데요.. 제가 모르는 곳인데 괜찮나요?\u0026rdquo; 라고 말이다.\n정리: 결국 암호화 정리를 해 보니 결국 통신 암호화를 확실히 하기 위한 일련의 역사를 되짚은 느낌이다. 용어에 통일성이 없으니 들을 때마다 어색해지기 마련이었는데, 이렇게나마 나열해 보니 두려움이 조금 사라지긴 했다.\nCKA 시험에는 CSR (Certificate Signing Request) 보내는 방법까지 배우긴 하는데 거기까진 여기서 다루지 않아도 될 듯하다.\n","date":"2023-02-02T17:00:00+09:00","image":"https://interp.blog/ssl-tls-pki-x509-certificate/feature_hubc15a84c4d4db50a88114f33ce9d877b_934706_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/ssl-tls-pki-x509-certificate/","title":"Secure Communication 에 대한 모든 것"},{"content":"오랫동안 사무용/게이밍용으로 사용중인 기계식 키보드 레오폴드 FC750RT.\n그런데 자주 써서 그런건지, 치다 보면 몇몇 키들이 마치 팝콘 튀긴 것 처럼 \u0026lsquo;퐁\u0026rsquo; 하고 튀어나왔다. 보통 반복적으로 튕기듯 누르는 키들이 잘 튀어나왔었는데, 내구성 테스트 겸 용의선상에 있는 친구들 중 하나인 \u0026lsquo;오른쪽 방향키\u0026rsquo; 를 계속 팅팅 눌러봤다.\n 아아\u0026hellip; 갈축 스위치가 적나라하게 드러났다. 십(十)자 모양 스위치와 키 뒤쪽에 있는 십자 홈이 정확히 끼어있지 않은 것일 테다. 이리저리 검색을 해 봤는데, 홈을 조금 더 좁게 메꿀 수 있는 일종의 민간요법 (?) 을 찾았다. 바로 마스킹 테이프로 메꾸기!\n 준비물  (빠진) 키보드 (빠진) 키보드 키 마스킹 테이프  방법은 간단하다. 마스킹 테이프를 키 뒤쪽 십자 홈 크기로 작게 잘라낸 뒤, 아래와 같이 살짝 붙여둔다. 접착면이 키 안쪽으로, 보이는 면이 키 바깥 (밑면)이 되도록 한다.\n 그 다음, 그 상태 그대로 스위치에 맞추고 지그시 눌러준다. 잘 안들어갈 것 같지만, 생각보다 쏙 들어간다. 마스킹 테이프가 말려들어가면서, 키의 십자 홈을 더욱 메꿔주는 효과를 보여주는 것이다.\n마스킹 테이프가 가장 좋아보이지만, 굳이 없다면 비슷한 재료로 비슷하게 해도 좋을 것 같다.\n 얇은 종이도 가능할 것 같지만, A4 두께는 생각보다 두껍다. 차라리 휴지로 하는게 낫지 않을까? 일반 테이프는 바깥면이 미끄러워서, 홈을 메꿔주더라도 계속 빠질 것 같은 느낌이 든다. 절대로 접착제를 안에 넣지 말자. 나중에 스위치 문제가 생기거나, 청소를 해야 할 때 애로사항이 생긴다.  ","date":"2023-01-19T17:00:00+09:00","image":"https://interp.blog/keyboard-key-pop-up-problem/IMG_4745_hu19bc4a207bc10324370dbd7d4481cbeb_2603624_120x120_fill_q75_box_smart1.JPG","permalink":"https://interp.blog/keyboard-key-pop-up-problem/","title":"키보드 키가 자꾸 빠질 때"},{"content":"회사 직원들을 위해 Insight Timer 라는 앱을 무료로 사용할 수 있다는 공지를 최근에 받았다. 설치해 보니 명상 앱이라고 한다. 반신반의하며 첫 날 15분 정도의 인트로 코스를 시작했는데, 기본적인 자세와 호흡법을 알려주고 마음가짐에 대해 조곤조곤 이야기해 줬다.\n불안한 마음에 도움이 되는 듯? 해 본지 얼마 되지 않았지만 지금까지 내가 느낀 건, 번잡한 마음이 어느정도 정리된다는 것이었다.\n요즘 들어 업무나 일상에서 눈에 띄게 의욕이 줄어들었는데 \u0026lsquo;이런 걸 해서 무엇하나\u0026rsquo; 같은 마음이 계속 자리잡고 있었기 때문이다. 확실한 방향으로 갈피를 잡지 못한 것이 클 것이다. 하지만 명상을 통해 마음이 떠올린 소리를 같이 경청하면, 내가 가졌던 불안이나 불확실한 마음이 잠시 뒤로 물러나는 신기한 경험을 했다.\n딱 집어서 마음이 치유되었다거나 다음 할 일과 마음가짐이 생겨났다고 말하긴 힘들지만, 적어도 불안한 마음을 달래줄 수는 있었다.\n가라앉히려면 가만히 있어야 한다 명상은 마치 내 몸 속을 하수처리장에 맡기는 느낌이다. 걱정이나 불안이 뒤섞인 마음에 이리저리 움직여보거나 바람을 불어봐야, 그것은 더욱 탁해지고 말 것이다. 명상은 이것들을 멈추고 고요한 상태에서 나쁜 생각을 침전시키는 작업일 것이다.\n나의 불안은 무엇이었고, 그 속에서 걸러진 깨끗한 나의 성취는 또 무엇이었는지, 굳이 내가 구분짓지 않아도 내 마음이 구별해 낼 수 있는 상태를 만드는 것이다. 당장 이 마음을 내버리지 못 하더라도, 어떤 마음이 있었는지 아는 것만으로도 큰 위안이 될 수 있다. 아니면, 그 속에서 걸러진 나의 플러스, 나의 성취에 주목할 수도 있다.\n시간 아깝다고 불안한 채로 살 것인가 명상은 마치 어질러진 거실을 치우는 것과도 같다.\n사실 거실이 정돈되었건 어질러졌건 간에, 나라는 존재와는 무관한 상태이긴 하다. 하지만 우리는 (적어도 나는) 깨끗한 거실을 볼 때 더욱 안정되며, 발을 옮기는데 고민을 해야 할 정도로 물건들이 널부러져 있다면 계속 마음이 심란할 것이다. 시간을 들여서 제자리에 가져다 두고 나면, 치우는 수고가 아깝다는 생각이 사라질 것이다. 그대로 뒀다면, 나머지 시간동안 안 좋은 기분으로 생활해야 하니까.\n이렇듯 명상을 하기 전에는 시간을 버리는 일이 아닐까 주저하게 되지만, 불안한 마음을 걸러주지 않는다면 계속 불안한 채로 하루를 보내야 하지 않을까?\n 사용하고 있는 앱을 구글링 해 보니, 무료 명상 앱에서는 남바완 (\u0026hellip;) 이라고 홍보는 하더라. 프리미엄 구독으로 들을 수 있는 강사의 영어 코칭 세션을 하지 않더라도, 백그라운드 음악과 세션을 입맛에 맞춰 만들어 두면 아무런 제약없이 재생 할 수 있기 때문에 무료 앱은 맞는 것 같다.\n그 외에도 인터넷에 명상법은 엄청나게 많고, 지금까지 내가 느끼기론 단순히 \u0026lsquo;편안한 자세로 호흡 잘 하고 마음 속 떠오르는 걸 잡아보는 것\u0026rsquo; 에서 출발해도 좋을 것 같다.\n아! 넷플릭스에서 하던 명상 시리즈 도 많은 도움이 되었다.\n","date":"2022-12-24T09:00:01+09:00","image":"https://interp.blog/entering-meditation/pexels-thirdman-6956573_hu3d03a01dcc18bc5be0e67db3d8d209a6_4563622_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/entering-meditation/","title":"명상으로의 입문"},{"content":"클라이언트에서 서버로 SSH 접속을 패스워드 없이 하기 위해\n 클라이언트 컴퓨터에서, RSA 알고리즘으로 비대칭 키를 생성했다. 비대칭 키의 Public Key 를 서버의 ~/.ssh/authorized_keys 파일에 붙여넣었다.  그런데도 아직 패스워드를 입력하라고 하면?? 혹시나 해서 ssh -vvv .. 로 디버그 메시지를 출력해 보니\ndebug1: Offering public key: debug3: send packet: type 50 debug2: we sent a publickey packet, wait for reply debug3: receive packet: type 51 이런 메시지를 혹시 만났다면, 다음을 체크해 보자.\n.ssh/ 의 소유자/권한 점검 아래 사항이 모두 맞는지 점검한다.\n ~/.ssh 권한이 700 이어야 한다.  ls -al ~ | grep .ssh 결과가 d r w x - - - - - - 로 시작되어야 한다. 수정하는 방법은 chmod 700 ~/.ssh 이다. (-R 옵션을 붙이지 말자!)   ~/.ssh 소유자가 달라서는 안 된다. ~/.ssh/authorized_keys 권한이 600 이어야 한다.  ls -al ~/.ssh/authorized_keys 결과가 - r w - - - - - - - 로 시작되어야 한다. 수정하는 방법은 chmod 600 ~/.ssh/authorized_keys 이다.   ~/.ssh/authorized_keys 소유자가 달라서는 안 된다.  한 가지 더 중요한 것은, 만약 $HOME 경로가 \u0026lsquo;심볼릭 링크\u0026rsquo; 를 포함하는 경우라면, 반드시 실제 경로에서 적용해야 한다는 점이다.\nRSA 는 이제 그만.. 서버가 OpenSSH 를 쓰는 경우라면, RSA 를 곧 지원하지 않는다는 release note 가 있다. 따라서 RSA 대신 다른 알고리즘으로 된 비대칭 키를 생성해서 쓰는 것도 방법이 될 수 있다. 나는 ECDSA 를 사용해 봤다.\nssh-keygen -t ECDSA 참고자료  https://chemicloud.com/kb/article/ssh-authentication-refused-bad-ownership-or-modes-for-directory/ https://docs.digitalocean.com/support/how-to-troubleshoot-ssh-authentication-issues/ https://www.openssh.com/txt/release-8.7  ","date":"2022-12-23T13:57:59+09:00","image":"https://interp.blog/ssh-authorized-keys-problem/feature_huacae445ac6aed6ca077a2852bee8342c_81596_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/ssh-authorized-keys-problem/","title":"SSH 비대칭 키로 접속할 때 문제 해결"},{"content":"K8s Resource 를 보거나 Helm Chart 를 보거나 헷갈리는 개념 중 하나가 바로 \u0026lsquo;Headless Service\u0026rsquo; 이다.\n  흐라챠!\n  머리가 없는 서비스를 위 짤방처럼 왜 만드는 건지부터 이해하려면, 먼저 서비스가 왜 필요한지 알아야 한다.\n설명 먼저 공식 문서 설명을 먼저 보자. 영어 원문과 한국어 번역본을 적절히 믹스했다.\n 로드 밸런싱 (Load-balancing) 이나 단일 서비스 IP 가 필요하지 않은 경우엔, \u0026lsquo;헤드리스\u0026rsquo; 서비스라는 것을 만들 수 있다. .spec.clusterIP: None 을 명시적으로 지정하면 된다.\n이 헤드리스 서비스를 통해, 쿠버네티스의 구현에 의존하지 않고도 다른 서비스 디스커버리 메커니즘과 인터페이스할 수 있다.\n헤드리스 서비스의 경우 (각 node 에 상주하는) kube-proxy 가 해당 서비스를 처리하지 않는데, 즉 로드 밸런싱 또는 프록시를 하지 않는다. DNS가 자동으로 구성되는 방법은 서비스에 selector 가 정의되어 있는지에 달려있다.\n 나름 의역을 섞어가며 최대한 쉽게 풀려고 노력했지만\u0026hellip; 죄송합니다. 지금 읽어봐도 무슨 소리를 하는지 잘 모르겠다.\n아마도, 영어 설명에서 함의된 내용이 너무나 많기 때문인 것 같다.\n 내가 가장 마음에 들어하는 다른 설명을 가져와 봤다. 이번엔 스택 오버플로우 답변이다.\n Service 로 향하는 네트워크 연결은 결국 서비스 아래에 존재하는 여러 Pod 중 하나로 가게 될 겁니다. 그런데, 클라이언트가 Pod 1개가 아니라 모든 Pod 들과 통신해야 한다면요? 만약 같은 서비스 아래에 있는 Pod A 와 Pod B 가 서로 통신해야 한다면요?\nService 를 통하는 건 확실한 방법은 아닙니다. 그럼 뭘까요?\n모든 Pod 들과 통신해야 하는 클라이언트를 위해, 개별 Pod 의 IP 주소를 알아내는 게 필요하겠죠. 그러면 클라이언트가 K8s API Server 에 직접 요청해서 해당 Pod 들의 IP 리스트를 얻어내는 방법이 있습니다. 이상적인 방법은 아닙니다. 개발 중인 어플리케이션을 K8s Cluster 가 있는지조차 모르게 (K8s-agnostic) 만들고 싶어 하잖아요.\n다행히도, Kubernetes 는 클라이언트에게 Pod IP 리스트를 알려주는 방법을 DNS Lookup 을 통해 제공합니다. 대개는, 어떤 Service 를 위한 DNS Lookup 를 수행하면 DNS 서버는 IP 주소 1개를 반환합니다. 바로 Service 의 Cluster IP 죠.\n그런데 여러분이 Service 를 만들 때 Cluster IP 가 필요 없다고 알려주면, 해당 Service 에 대한 DNS Lookup 요청이 DNS 서버에 오게 될 때, Service 에 소속된 Pod IP 주소 목록을 전부 반환합니다. 즉, DNS A 레코드 1개가 아니라, 각각의 Pod 과 통신할 수 있는 A 레코드 여러 개가 반환되는 것이죠. 그러면 클라이언트는 간단하게 이 A 레코드를 순회하면서 다시 DNS Lookup 을 할 수 있고 실제 Pod 들의 IP 를 얻을 수 있습니다.\n 보통 Service 의 역할은, Service 로 들어온 요청을 여러 개의 Pod 중 하나 에만 전달하는 것이다. 하지만 이 요청이 모든 Pod 에 전달되어야 하는 경우에는 적합하지 않다.\n이를 위해서 k8s-api-server 에 요청해서, Service 에 속한 Pod 의 IP 리스트를 얻어오도록 애플리케이션을 구성할 수는 있겠지만, 그 때부터 애플리케이션은 해당 API 서버 위치에 의존해야 하기 때문에 적절한 방법이 아닌 것이다.\n위의 설명대로라면, Cluster IP 를 없앤 Service 의 경우 DNS Server 가 모든 Pod 들의 A 레코드를 직접 알려주는 (resolving) 것이다. 요청을 수신받을 Cluster IP 가 없으니, 머리가 없는 Service 라고 부를 수 있겠다.\n데모 사실 데모는 다른 블로그에서 많이 찾아볼 수 있어서, 최소한으로 재현 할 수 있는 방법을 알아보도록 하자.\nDeployment 생성 우리는 nginx 로 포트 오픈도 해 두고 curl 이나 nslookup 으로 Pod 간 통신을 체크해야 하니, praqma/network-multitool 이미지로 replica 3개의 deployment 를 하나 만들도록 하자.\nkubectl create deployment test-deploy --image=praqma/network-multitool --replicas=3 --port=80 kubectl get pods -lapp=test-deploy -o wide NAME READY STATUS ... test-deploy-7bff8c5f84-hxcfw 1/1 Running ... test-deploy-7bff8c5f84-rjdm9 1/1 Running ... test-deploy-7bff8c5f84-w5l8j 1/1 Running ... 첫 번째 Pod 의 IP 가 200.96.1.50 이다. 두 번째 Pod 에서 첫 번째 Pod 으로 접속을 시도해 보자.\n# connect to test-deploy-7bff8c5f84-hxcfw  kubectl exec test-deploy-7bff8c5f84-rjdm9 -it -- curl 200.96.1.50:80 Praqma Network MultiTool (with NGINX) - test-deploy-7bff8c5f84-hxcfw - ... 접속이 잘 된다. 하지만 여기 보이는 Pod IP 는 언제든지 바뀔 수 있기 때문에 이런 식으로 쓰면 안 된다.\nHeadless Service 생성 이제 Headless Service 를 만들어보자. 이번에는 바로 만들지 말고 manifest 를 YAML 파일로 저장해 둔 다음에 수정이 좀 필요하다.\nkubectl create service clusterip test-cs-svc --clusterip=\u0026#34;None\u0026#34; \\  --tcp=80:80 --dry-run=client -oyaml \u0026gt; test-cs-svc.yaml Headless 로 만드는 핵심 옵션이 바로 --clusterip=\u0026quot;None\u0026quot; 라는 걸 알 수 있다. 여기서 출력되는 파일을 열어서, spec.selector 를 deployment 의 것으로 바꿔줘야 한다.\napiVersion:v1kind:Servicemetadata:creationTimestamp:nulllabels:app:test-cs-svcname:test-cs-svcspec:clusterIP:Noneports:- name:80-80port:80protocol:TCPtargetPort:80selector:app:test-deploy# test-deploy deployment 가 가지고 있던 app labeltype:ClusterIPstatus:loadBalancer:{}저장해 주고, 해당 YAML 파일을 적용하자.\nkubectl apply -f test-cs-svc.yaml DNS Lookup 하기 이제 남은 일은 Service 의 domain name 을 가지고 DNS Lookup 을 한 결과를 받아오는 일이다.\n그런데, domain name 을 어떻게 아냐고? 마지막 참고 자료에 있는 K8s DNS 를 읽어봐도 좋지만, 직접 알아보기 위해서는 아까 생성한 Pod 에서 /etc/resolv.conf 가 어떻게 설정되어 있는지 확인하면 된다.\nkubectl exec test-deploy-7bff8c5f84-rjdm9 -it -- cat /etc/resolv.conf search default.svc.cluster.local svc.cluster.local ... 여기 잘 보면, 해당 Pod 위치에서 요청하는 domain name 에 default.svc.cluster.local 을 자동으로 붙여서 resolving 하려는 걸 볼 수 있다. (default namespace 에 있는 모든 Pod 들이 똑같을 것이다)\n즉, 우리는 전체 domain name 을 알 필요가 없이 Service Name 만 가지고도 DNS Lookup 을 할 수 있다.\n바로 Lookup 을 하러 가보자. 똑같이 kubectl exec 를 할 텐데, 이번에는 nslookup 을 해보도록 한다. domain name 은 그냥 Service Name 을 입력한다.\nkubectl exec test-deploy-7bff8c5f84-rjdm9 -it -- nslookup test-cs-svc Server:\t200.64.0.10 Address:\t200.64.0.10#53 Name:\ttest-cs-svc.default.svc.cluster.local Address: 200.96.1.50 Name:\ttest-cs-svc.default.svc.cluster.local Address: 200.96.0.59 Name:\ttest-cs-svc.default.svc.cluster.local Address: 200.96.2.24 여러 개의 A 레코드로 이뤄진 Pod IP 목록을 얻을 수 있다. 그리고 test-cs-svc 처럼 Service Name 만 입력했을 뿐인데 test-cs-svc.default.svc.cluster.local 로 바뀐 것도 볼 수 있다.\nHead 를 달아주면요? 이번에는 test-cs-svc-head 라는 이름의 Service 를 하나 더 만들자.\n단순히, spec.clusterIP: None 부분만 없는 test-cs-svc 나 다름없다. 아까 만들어 둔 파일에서 metadata.name 부분과 spec.clusterIP 부분만 바꿔서 kubectl apply -f 로 적용해 보자.\n수정한 다음, 아까와 같이 nslookup 을 해보자.\nkubectl exec test-deploy-7bff8c5f84-rjdm9 -it -- nslookup test-cs-svc-head Server:\t200.64.0.10 Address:\t200.64.0.10#53 Name:\ttest-cs-svc-head.default.svc.cluster.local Address: 200.68.238.114 이 IP 는 어디서 왔을까? 바로 Service 의 Cluster IP 되시겠다.\nkubectl get svc test-cs-svc-head NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE test-cs-svc-head ClusterIP 200.68.238.114 \u0026lt;none\u0026gt; 80/TCP 2m32s 주의할 점 test-cs-svc 나 test-cs-svc-head 는 DNS Lookup 에서는 차이를 보이지만, curl 결과는 차이가 없다. 더 자세히 말하면, 두 요청 모두 3개의 Pod 중 1개에만 랜덤하게 전달된다는 것이다.\n다음 명령들을 반복적으로 실행해 보자. 목적지 Pod 주소가 매번 다를 것이다.\nkubectl exec test-deploy-7bff8c5f84-rjdm9 -it -- curl test-cs-svc:80 | head -2 kubectl exec test-deploy-7bff8c5f84-rjdm9 -it -- curl test-cs-svc-head:80 | head -2 왜 이렇게 되는 것일까? Headless Service 의 경우, DNS Lookup 하는 A 레코드 순서가 랜덤으로 전달되고 curl 은 그저 맨 위의 것을 쓰기 때문이다. nslookup 을 반복적으로 해 보면 보다 더 확실해 질 것이다.\n이해를 돕기 위한 기초자료 혹시 아직도 이해가 잘 안된다면, 기초자료로 다음을 참고해보자. 혹은 CKA 시험 준비를 하는 것도 좋은 방법이다!\n K8s Service K8s DNS  ","date":"2022-12-22T11:13:12+09:00","permalink":"https://interp.blog/k8s-headless-service-why/","title":"K8s Headless Service, 왜 필요한가"},{"content":"프로그래밍 언어 키워드나 객체 이름만 추천받을 때 유용하게 쓸 수 있는 IntelliSense. VSCode 에도 물론 내장되어 있어 유용하게 쓸 순 있지만 다음 경우에는 잘 되지 않았다.\n 반복되는 문자열을 복사/붙여넣기 하지 않고 물 흐르듯 쓰고 싶을 때\n(복사할 대상이 여러개이고, 번갈아 반복되는 경우라면 더더욱.. A/B/A/B 이런 식으로) 다른 형식의 확장자로 된 파일 내용에서 반복되는 문자열을 추천받고 싶을 때  나의 경우는, 한 쪽에는 .env 파일을 열어두고 다른 쪽에는 docker-compose.yaml 을 열어둔 경우가 여기에 해당한다. 설정 가능한 변수는 .env 에 변수로 등록하고, docker-compose.yaml 파일 작업할 때 참조해서 쓰고 싶은데 자동완성이 안 돼서 힘들었다. 결국 검색해서 찾아내긴 했는데, 이게 기본 설정인지 아닌지는 잘 모르겠다.\n{ \u0026#34;editor.quickSuggestions\u0026#34;: { \u0026#34;strings\u0026#34;: \u0026#34;on\u0026#34; }, \u0026#34;editor.wordBasedSuggestions\u0026#34;: true, \u0026#34;editor.wordBasedSuggestionsMode\u0026#34;: \u0026#34;allDocuments\u0026#34; } 이렇게 두면, 필요한 파일을 열어두기만 하면 모든 문자열을 추천받을 수 있다.\n  조금 이상한 부분은, 참조해야 할 파일을 한 번 수정하거나 저장해야 적용이 되는 것 처럼 보이기는 했는데\u0026hellip; 조금 더 써보고 업데이트 해야겠다.\n","date":"2022-12-21T14:33:07+09:00","permalink":"https://interp.blog/vscode-string-suggestion-config/","title":"VSCode 문자열 자동완성 설정"},{"content":"아이폰, 아이패드, 애플워치까지 갖고 있지만 macbook 을 본격적으로 써 본지 만 1년도 안 된다. 그래서 윈도우에서 즐겨 쓰던 Home/End 가 Mac 에서는 Cmd 키와 화살표로만 이뤄지는 걸 극복하는데 너무 힘들었다. 물론 적응하면 되겠지만, 습관이란 게 무서운 거라고.\n결국 어떻게 하면 고칠까 알아보면서 하나씩 적용하고 있다. 일단 KeyBindings 에서 Home/End 키로 줄 시작과 줄 끝으로 이동하도록 해 두는 걸 적용했다. (링크)\n그런데 어째선지, Eclipse 기반의 에디터에서는 이것과 무관하게 Home/End 가 \u0026lsquo;페이지 시작/끝\u0026rsquo; 으로 작동하는게 아닌가! Page Up/Down 키가 옆에 버젓이 있는데도 말이다! 최근에 PostgreSQL (정확히는 TimescaleDB) 를 조사할 기회가 생겨서 DBeaver 를 설치했는데, 이 친구도 Eclipse 기반의 에디터라서 KeyBindings 설정 내용과 딴판으로 놀았었다.\n그렇다, 이 글을 쓰는 이유 되시겠다.\n키 설정을 바꿔야 한다  Eclipse 의 Preference (설정) 을 열어보자. 어딘지 모르겠다면 Cmd + , 를 누르면 된다. 여기서 Key 라고 검색해 보면 User Interface -\u0026gt; Key (키) 부분에 하이라이트가 되어 있다. 카테고리를 눌러 Text Editor (텍스트 편집기) 로 이동한다.  여기서 다음 항목을 입맛대로 바꾸면 된다.\n Line Start (행 시작) : Home ↖ Select Line Start (행 시작 선택) : Shift+Home ⇧↖ Line End (행 끝) : End ↘ Select Line End (행 끝 선택) : Shift+End ⇧↘ Page Up (텍스트 시작) : Page Up ⇞ Page Down (텍스트 끝) : Page Down ⇟    그래도 안 되면? 내 경우엔 이렇게 두고 Apply and Close 를 눌러도 적용이 안 되더라. 심플하게 Eclipse (여기선 DBeaver) 를 껐다 다시 실행시키면 되었다.\n","date":"2022-12-20T10:57:42+09:00","permalink":"https://interp.blog/mac-eclipse-key-binding-home-end/","title":"Mac 에서 Eclipse Home/End 키 바인딩 하기"},{"content":"세틀러와 아노 부록 때문에 게임 잡지를 사 모으던 어린 시절, PC G@M 이라는 곳에서 세틀러3 라는 게임을 줬었다. 1편도 모르고 2편도 모르지만, 아기자기한 마을 주민들이 모여 집도 짓고 밥도 짓고 타워도 지었다. 자원을 캐내서 무기도 만들고 병사도 모았다. 운동장 돌멩이가 아니라 진짜로 컴퓨터와 땅따먹기를 했다. 남의 건물을 철거하면 빈 땅이 됐고, 거기에 내가 알박기를 하면 내 땅이 됐다. 영토 행사는 이렇게 하는 거라고 확실히 (?) 배울 수 있었고, 금새 나는 이런 \u0026lsquo;땅따먹기류\u0026rsquo; 건설경영 시뮬레이션에 빠져들게 되었다.\n  당시로서는 너무나 아기자기했던 세틀러3\n  세월이 흘러, 아노 (Anno) 시리즈가 그 향수를 조금 불러일으켰다. 그러나 이 게임은 기초 재료를 모아 생산 파이프라인을 만든다는 부분만 좋았다. 파이프라인만 할 거라면 팩토리오를 해도 될 것 같았고, 세틀러의 주민들, 배가 나와 뒤뚱거리지만 할 건 다 하는 사람들이 보고 싶었다. 그래서 아노는 사놓고 진득히 하질 못했다. 어려워서 그랬을지도 모르지\n식민지를 개척하는 로봇 이야기   더 콜로니스트 (The Colonists) 를 보면서, 다시 세틀러를 만난 느낌이 들었다. 아니나 다를까. 게임 튜토리얼을 시작하면, 앞선 두 게임에서 영감을 받은 게임이라는 설명을 대놓고 한다. 배 나온 주민은 아니고 귀여운 복제 로봇들이지만, 뒤뚱거리지 않고 시킨 일을 잘 해 낸다. 다른 우주선에서 내린 복제 로봇 (컴퓨터) 과 싸우고, 땅따먹기도 할 수 있다. 그런데 하다 보니, 생산 파이프라인을 정교하게 가져가서 효율을 극대화하는 전략이 필요했다. 이건 또 아노가 아닌가?\n주어진 맵에서, 특정 조건을 달성하거나 지도 상에 존재하는 모든 적을 물리치는 등의 목표를 완수하면 되는 게임이다. 그 목표를 이루기 위해, 초반 자원을 캐고 건물을 더 짓고, 더욱 발전된 테크를 타기 위해 건물 배치와 도로 배치를 고민하는 게임이다.\n결국 생산, 생산 게임은 연구라는 개념을 통해서 아래와 같은 테크 트리를 강제하게 된다.\n 맵의 목표를 달성하기 위해, 더 높은 수준의 연구가 필요하다. 연구소를 업그레이드 하기 위해, 고급 자원 + 일정한 에너지 등급이 필요하다. 고급 자원을 생산하기 위해, 추가 생산 건물 + 일정한 에너지 등급이 필요하다. 일정한 등급의 에너지를 생산하기 위해, 식량자원이 필요하다. 식량자원을 생산하기 위해, 추가 생산 건물 + 땅이 필요하다. (부동산은 늘 중요하다) 생산 건물을 지을 수 있게, 연구가 필요하다\u0026hellip; 로 반복한다.    차근차근 연구를 통해 발전해야 한다\n  처음에 게임을 시작하면, 우주선이 지도에 착륙한다. 우주선은 나무와 1단계 에너지를 소량 생산한다. 1단계 에너지는 1단계 에너지는 물과 음식 (양고기 또는 야채) 만 있으면 만들 수 있다. 이 에너지로 일단 벌목꾼 오두막에 사는 벌목꾼 로봇을 돌릴 수 있다. 거기서부터 게임은 시작된다.\n건물 사이에 있는 도로를 만드는데는 비용이 들지 않는다. 도로 포스트에는 드나드는 자원을 통제할 수 있는 기능이 있다. 건물 사이에도 마찬가지로, 특정 건물에서 나온 자원만 받도록 할 것인지, 어느 건물에만 생산된 자원을 보낼 수 있는지도 조정이 가능하다.\n  포스트 도로에는 운송봇이 상주하며 화물을 날라다 준다\n  -- 복잡한 수출입 규칙이니 포스트 규칙이니, 이런 거 안 해도 \u0026lsquo;보이지 않는 손\u0026rsquo; 으로 인해 게임이 잘 굴러 갈 것 같다는 생각은 하지 않았으면 좋겠다. 생산 효율이 50% 쯤 나올 때 쯤, 도로에서 배달되는 자원을 아무거나 눌러보면 경악할 테니까. 채소 바구니 하나가 동남아 순회공연을 한다고!\n다양한 게임 모드 우선 튜토리얼 성격의 스토리 모드가 잘 되어 있다. 후반 미션은 많이 어렵겠지만, 그래도 게임 시스템에 익숙해졌다면 시간을 잘 투자하고 계획을 잘 세운다면 결국 모든 미션을 클리어 할 수 있을 것이다.\n랜덤 맵 역시 \u0026lsquo;샌드박스\u0026rsquo; 라는 메뉴로 지원한다. 그리고 다른 플레이어들의 정신나간 맵들도 창작마당을 통해 플레이 할 수 있다. 또한, 매 월마다 특정 맵에서 특정 목표를 향해 플레이 해 볼 수 있는 프론티어 미션이 존재한다. 미션 성공 시간이 가장 짧은 순서대로 랭킹을 볼 수 있다. 1등 기록을 보면 핵을 쓴 거 같다\n  매 월마다 갱신되는 프론티어 미션\n  다소 아쉬운 적군 AI 세틀러 시리즈는 솔직히 AI 가 어땠는지 기억나지 않는다. 그저 재밌었다는 기억 뿐이었다. 하지만 머리가 굵어져서 그런건지, 콜로니스트의 적대 AI 는 많이 무성의했다.\n우선 AI 들이 나름 공격적으로 확장을 시도하긴 하지만, 플레이어가 작정하고 벌목한 다음 감시탑을 통해 무한 확장하게 되면 거기서 1단계 영토는 고정된다. 상대 감시탑을 공격하려면 2단계 연구를 시작하면서 화살 감시탑으로 업그레이드해야 하기 때문이다. 문제는 1단계에서 영토를 쪼그라들게 만들면, 한정된 지역에서 발전하기가 쉽지 않기 떄문이다.\n  좀 더 주요 자원 위주로 공격적인 감시탑 러시를 강제해야, 플레이어가 압박을 크게 느낄 수 있을 것 같다. 이를테면, 맵에 돌 광산이 1개 뿐이면 여기를 먹어야 이길 수 있기 때문에, 무조건 내달려야 한다. 그런데 적군은 그런거 없고 그냥 빈 땅만 확장한다.\n물론 이 게임은 제한된 환경에서 효율적인 생산을 추구하는 것이 목표인 1인용 빌드에 초점이 맞춰져 있다. 컴퓨터와의 대전이 주된 요소는 아니라는 것이다. 그래도 엄연히 게임 요소인 만큼, 좀 더 신경 써 주면 좋겠다는 생각은 든다.\n 여담인데, 재밌게 하다 보니 한국어 번역이 거슬렸다. 존댓말과 반말이 섞여있고, 명명법에 통일성이 없었다. 게임 안에 있는 디스코드 버튼을 눌러, 개발자에게 DM 을 보냈다. 번역한 사람 어딨냐고.\n개발자가 답하기를, 우리는 자발적으로 참여한 사람에 한해 언어 번역을 진행하고 있고, 한국어 담당자는 한 번 하고는 가버렸다고 한다. 내가 전부 다 갈아엎고 다시 해도 되냐고 했더니, 게임 카피를 하나 주면서 땡큐라고 했다. 그 인연(?) 으로 지금까지 한국어 번역을 담당하고 있다. 번역이 이상하다면, 디스코드에 오셔서 같이 도와주세요!\n  예, 접니다..\n  ","date":"2022-12-05T09:00:01+09:00","image":"https://interp.blog/the-colonists/feature_hu425bf2ca7e0789f036c6ac51c03633d1_152255_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/the-colonists/","title":"The Colonists"},{"content":"  여기 두 명의 개발자가 있다.\n 나는 매니저가 되는 게 싫다. 회사에서도 하라는 걸 극구 거부했다. 기술을 놓지 않고 싶다. 내가 신입 때, 개발자는 40이 되면 은퇴해야 한다고 들었다. 내가 40이 되었을 때엔, 사람들은 50이 되면 은퇴해야 한다고 말했다. 이제 나는 50에 가까워지고 있는데 은퇴해야 하나? 난 여전히 엔지니어다. 그리고 이 일을 계속 할 자신이 있다.  이 책을 처음 접했을 때, 적어도 두 분께는 알려드려야 될 것 같았다. 길벗 출판사에서 새로 펴낸 소프트웨어 엔지니어 교양서 \u0026lsquo;스태프 엔지니어\u0026rsquo; 말이다.\n스태프 엔지니어? 앞선 두 분의 개발자에게 있어, 다음 커리어는 무엇일까? 물론 개발 역량만 충분하다면 계속 시니어 엔지니어를 하셔도 될거라고 생각한다. 그러나 특정 팀이나 프로젝트에만 소속되어 있어서, 권한이 제한되거나 조직 비전에 불만이 있어도 묵살당하기 일쑤였다. 그런 걸 봐 온 나로서는, 그 길이 정답이라고 콕 집을 순 없었다.\n관리자와 비교했을 때, 스태프 엔지니어는 기술 직군으로 커리어를 이어나갈 수 있는 또 다른 트랙이라고 소개한다. 한국에서는 아직 생소할 수도 있는 단어지만, 사실 스태프 엔지니어의 대표 역할인 \u0026lsquo;테크 리드\u0026rsquo; 나 \u0026lsquo;아키텍트\u0026rsquo; 같은 직함을 들어보면 그렇게 낯설지는 않다.\n관리자가 아닌 기술 커리어 트랙이 대체 왜 필요한 걸까? (역시 스태프 엔지니어이신) 이 책의 역자 장현희 님의 서문 중 일부가 답이 될 것 같았다.\n 조직의 입장에서도 이런 식의 승진 절차는 한편으로는 손해이기도 합니다. 시니어 언제니어로 좋은 성과를 내던 사람이 팀장 승진 대상이 됩니다. 이 사람이 팀장이 되면 조직은 유능한 시니어 엔지니어 한 명을 잃고 초보 팀장 한 명을 얻게 되는 셈이기 때문이지요.\n 그렇다고 스태프 엔지니어가 시니어 엔지니어의 연장선이라는 것은 아니다. 이제는 팀 간, 부서 간을 넘나들며 플레이해야 하는 역할이기 때문이다. \u0026lsquo;테크 리드\u0026rsquo; 나 \u0026lsquo;아키텍트\u0026rsquo;, \u0026lsquo;해결사\u0026rsquo;, \u0026lsquo;오른팔\u0026rsquo; 처럼 책에서 구분해 둔 스태프 엔지니어 역할을 읽다 보면 정말 다양한 사람을 만나고, 또 다양한 일을 다뤄야 한다는 사실을 알 수 있다.\n따라한다고 되는 게 아니다 길벗 출판사의 다른 커리어 조언서인 \u0026lsquo;소프트 스킬/커리어 스킬\u0026rsquo; 이나 \u0026lsquo;이펙티브 엔지니어\u0026rsquo;, \u0026lsquo;심플 소프트웨어\u0026rsquo; 와 책 디자인은 비슷한데, 이 책은 앞선 책들과 다른 점이 있다. 책의 지침을 다 따라한다고 해도 스태프 엔지니어가 될 수 없다는 점이다.\n앞선 책들은 (물론 주제가 다르긴 해도) 사실 비슷한 구석이 있었다. 전반적인 커리어 관리, 업무 태도, 효율적인 업무를 위한 조언들 말이다. \u0026ldquo;야, 너두 할 수 있어\u0026rdquo; 같은 느낌이랄까. 하지만 이 책을 읽는 동안엔 왠지 모를 압박을 받았다. \u0026ldquo;이래도 할 거야?\u0026quot; 같은. 지침서가 아니라, 다큐멘터리를 보는 느낌이었다.\n하고 싶다고 해서 되는 것도 아니다. 스태프 엔지니어가 되려면 노력과 운이 동시에 필요하다는 것이다. 개인적인 노력도 중요하지만, 네트워킹을 통해 스폰서 내지는 지지 기반을 만들어야 한다. 그러기 위해선, 자신이 어떤 일을 원하는지 어떤 역할로써 스태프 엔지니어가 될 것인지 스폰서 (대개는 팀장이나 본부장) 에게 공유해야 하는 것이 첫 번째라고 조언한다.\n하지만 스태프 엔지니어가 된다고 해서, 더욱 커진 권한을 통해 자신의 비전을 마구잡이로 주입해도 된다는 말은 아니다. 책에서 표현하는 \u0026ldquo;관리자를 놀라게 하는 일들\u0026rdquo; 이 그런 것일텐데, 결국 회사 입장에서는 회사 비전에 가장 잘 맞추는 사람을 승진시키려고 할 것이기 때문이다. 따라서, 자신이 하고자 하는 일과 회사 비전을 최대한 맞추되, 그 속에서도 회사가 우선시되어야 한다고 강조한다.\n회사와의 비전을 정 못 맞추겠다면 이직해서 스태프 엔지니어 자리에 앉는 것도 고려할 수 있다는 사실 역시 물론 짚어준다. 지지기반이 낮을 순 있지만, 다니는 회사의 규모가 크거나 스태프 엔지니어 자리가 쉽게 나지 않을 때는 고려해 볼 수 있다는 것이다.\n경험담만 들어도 이득 이 책을 집어들고 \u0026lsquo;난 이제 스태프 엔지니어가 되고 말겠어!\u0026rsquo; 라고 외치진 말자. 이 책이 당장의 업무에 직접적인 영향을 줄 수 있다고 보긴 힘들다. 반대로 말하면, 지금 내 위치를 점검해 보고 스태프 엔지니어들의 경험담을 들어볼 수 있다.\n이미 그 길을 걸어온 사람들의 경험담을 듣고, 그들이 조언하는 것을 듣는 것은 매우 소중한 기회이다. 스태프 엔지니어 같은 직함에 매달리지 말고, 그냥 잘 하는 선배 개발자들의 직업관, 마음가짐, 업무에 대한 경험담을 듣는 것만으로도 이 책은 절반의 역할을 다 했다고 생각한다. 실제로 책 후반부는 모조리 14명의 스태프 엔지니어들의 인터뷰로 준비되어 있다. 책에서 주석으로 알려주는 다양한 블로그나, 인터뷰 말미에 나오는 추천도서 역시 쏠쏠하다.\n그런 면에서, 꼭 시니어 엔지니어가 아닌 신입 개발자라도 이 책은 큰 도움이 될 것이다. 물론 그런 경우라면 \u0026lsquo;커리어 스킬\u0026rsquo; 을 읽는 게 더욱 도움이 될 거라 보는데, 그 이유는 이 책의 전반부가 너무 지엽적인 조언들로 가득하기 때문이다. 인터뷰만 보는 걸 추천하는 이유이기도 하다.\n 이 책에서 엮은 다양한 경험담과 조언들을 통해, 최소한 나의 다음 커리어에 대해 고민해 볼 수 있었다. 그리고 언제나처럼, 승진은 개인이 잘 해서 되는게 아니라는 사실, 네트워킹은 필수불가결한 요소라는 것도 같이 알아 갈 수 있었다. (본인처럼) 다음 커리어에 대해 불안감을 가진 개발자/엔지니어에게도, 이 책이 도움이 되지 않을까 생각해 본다.\n※ 출판사의 서평 이벤트를 통해 증정받은 책으로 작성하였습니다.\n","date":"2022-11-27T12:00:01+09:00","image":"https://interp.blog/staff-engineer/feature_hud1578cd0d46074ece940eaa78f048c19_92846_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/staff-engineer/","title":"스태프 엔지니어"},{"content":"  정지우 작가의 글쓰기 에세이인 \u0026lsquo;우리는 글쓰기를 너무 심각하게 생각하지\u0026rsquo; 를 읽었다. 아니 정확히는 읽다가 포기했다. 노파심에 이야기하지만, 매일 글을 펴내는 작가의 페이스북을 팔로우해서 매일 글을 읽을 정도로 그의 글이 싫은 게 아니다.\n초반부에 추천하는 이 책 때문이었다. 김봉현의 글쓰기 랩.\n마지막 글자에 눈길이 갔다. \u0026lsquo;누구보다 빠르게 남들과는 다르게\u0026rsquo; 코칭해줄 것 만 같은 기대가 들었다. 그가 힙합 관련 책까지 몇 권이나 써 낸 힙합저널리스트이자 음악 평론가라는 사실을 뒤늦게 알고 나니, 책 제목이 더욱 그럴싸 해 보였다. 하지만 오해를 방지하기 위해, Rap 이 아닌 Lab 이라는 것을, 합평회라는 이름의 글쓰기 연구소 이야기임을 알려 둔다.\nVerse 1 이 책의 앞 부분은 합평회를 하면서, 또는 작가 개인이 가지고 있는 글쓰기에 대한 생각이 담겨있다. 그러면서 자신의 글도 스리슬쩍 끼웠고, 다른 작가의 좋은 글도 선례로 끼웠다. 와이프와 함께 김소연 시인의 산문집 \u0026lsquo;사랑에는 사랑이 없다\u0026rsquo; 의 글귀를 두 번씩이나 돌려 봤다. 또 다른 책으로 새끼를 쳐 주신 것이다. 작가 두 분, 아니 세 분에게 감사 인사를 전합니다.\n앞 부분에서 크게 와닿았던 것은 두 가지인데, 하나는 글이 공감 뿐만 아니라 영감을 줘야 한다는 것이었다. 물론 여기에는 \u0026lsquo;좋은 글\u0026rsquo; 이라는 기준이 작용하는 것이고 \u0026lsquo;상업적인 글\u0026rsquo; 이라는 기준에는 조금 갸우뚱할 수 있겠단 생각이 들었다. 빠르게 소비하는 시대에 얕은 공감만 불러일으켜도 많은 조회수를 얻는 그런 글 말이다. 하지만 이 책을 읽는 사람들은 분명 좋은 글을 쓰고자 하는 열망으로 가득 차 있을 것이었다. 분명 기우일 것이다.\n나머지 하나는 자기만의 스타일을 발견하고 또 유지해야 한다는 것이다. 스타일에는 정답이 없으니까. 스타일을 잘 읽히게 만드는 노력과는 별개로 말이다. 다른 이야기일 순 있는데, -인 것 같다 라거나 -라고 생각한다 고 붙이는 게 깔끔치 못할 순 있어도 글의 흐름이 자연스럽고 개성있는 스타일이 유지된다면 못 쓸게 있냐는 것이다.\n그가 글을 쓸 때 전개하는 과정, 글감을 모으고 확장하고 자료를 찾고 재배치하고 뼈대를 만들어 살을 더 붙이는 과정을 읽는 것은 몹시 흥미로웠다. 퇴고할 때는 문장의 리듬감, 문단의 첫/마지막 문장만 남겨 글의 흐름이 깨지진 않는지 체크한다는 부분이 나에겐 주요 체크였다. 힙합을 잘 모르지만, 펀치라인의 타이밍과 플로우가 기본이듯?\nVerse 2 책의 뒷 부분은 합평회의 호스트로서 많은 사람들의 글을 보고 피드백한 내용으로 구성되어 있다. 실제 피드백 대상이 되었던 글과 피드백 자체를 고스란히 실었는데, 마치 현장에 있는 느낌이 들었다. 내 글도 아닌데, 내가 혼나는 느낌\n특히, 어떤 글은 만연체로 특징 없이 주절주절 적어 뒀는데 정말 내 글과 닮아 있었다. 그러니 신랄한 피드백이 뒤따라올 수 밖에. 쓸 때는 몰랐거나 모른 체 했을 부분들이 독자가 되면 여실히 드러나는 거였다.\n작가의 피드백을 모아 보면 전부는 아니지만 많은 곳에서 \u0026lsquo;노력하지 않은 글\u0026rsquo; 에 대한 지적이 눈에 띈다. 글쓴이는 실력은 좋은데 노력을 안 해서 글이 엉성하다, 시작은 좋은데 끝이 흐지부지 됐다, 강렬한 주제로 시작했는데 거기까지인 것 같다 등등. 좀 더 신경썼다면 어땠을까 하는 아쉬움이 묻어나는 코멘트였다. 결국 글쓰기는 엉덩이 싸움인 것이다. (물론 재능도 있어야겠지만)\n와이프가 읽기 전에, 내가 일부러 소제목을 포스트잇으로 다 가려서 줬었다. 나는 제목을 보고 읽기 시작해서 선입견이 생기지 않았을까 하는 마음에 시도해 본 것이었다. 신기하게도, 와이프가 피드백을 읽으면서 _\u0026lsquo;와 이 사람 나랑 같은 생각했어!\u0026rsquo; 를 몇 번이고 연발했다. 나만, 아니 작가만 이렇게 생각한 건 아니었구나 싶었다. 혼자만 그렇게 생각했다면 디스였겠지.\n 강원국 작가가 언젠가 한번 합평회에 대한 이야기를 한 것이 떠올랐다.\n 합평은 정말 좋은 실전에 내 글을 던지는 용기의 시간입니다.\n잘 하게 되면, 가장 잘 쓰는 사람의 수준으로 모두 상향 평준화가 될 수 있어요.\n 작가는 용기의 시간을 함께 해 주고, 또 그들의 글이 책에 실릴 수 있게 허락해 준 많은 사람들에게 감사 인사를 잊지 않았다. 어떤 글을 보니 \u0026lsquo;평소 리스펙트 하던 선생님께 메시지를 드렸고, 결국 합평회에 합류하게 되었다\u0026rsquo; 는 문장이 있었는데, 나도 욕심이 살짝 났다. 혹시 또 안하시나요?\n그 전에, 내가 읽어도 마음에 드는 글을 쓸 수 있도록 무던히 노력하는 것이 먼저인 것 같다. 그런 글이 나오면 와이프에게도 읽혀보고, 그 단계도 통과를 해야 내 글을 용기있게 꺼낼 수 있을 것 같다.\n아, 당연히 다음 에세이 책 리뷰는 이미 정해져 있고 \u0026lsquo;글쓰기를 너무 심각하게 생각하지\u0026rsquo; 않을 때 할 예정이다!\n","date":"2022-11-22T09:30:01+09:00","image":"https://interp.blog/writing-lab/feature_hud0a91aa9a3939b4d963992e27ddb49fa_236029_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/writing-lab/","title":"김봉현의 글쓰기 랩"},{"content":"18세기 프랑스의 어느 여관. 주인의 양아들로 지내는 주인공은 벙어리였다. 어느 날 한 백작이 그를 불러 손기술이 좋으니 같이 일해서 큰 돈을 벌어보지 않겠냐고 제안했다. 공교롭게도 그날 그들의 손기술은 탄로나고 테이블 건너편에 있던 장군이 홧김에 쏜 총알은 여관 주인을 향했다. 주인공은 도망자 신세가 되어 자의 반 타의 반으로 백작과 함께 전국투어를 했다. 프랑스판 고니와 평경장 스토리인가 싶지만, \u0026lsquo;서양 타짜\u0026rsquo; 라는 별명을 가진 인디 게임 카드 샤크의 초반부 내용이다.\n타짜가 되어 보자   주인공의 초반 트릭, 훔쳐보기 (\u0026hellip;)\n  영화 \u0026lsquo;타짜\u0026rsquo; 와 다른 점은, 내가 직접 손기술을 구사해 볼 수 있다는 것이다. 셔플, 딜링, 스택 더블링, 표시목 새기기, 훔쳐보기, 카드 소매넣기 등 참신한 기법을 체험해 볼 수 있다는 데 이 게임은 큰 의의가 있다.\n그래서 이 게임은 \u0026lsquo;나쁜 내 머리를 용서해라\u0026rsquo; 같은 댓글이 수두룩 달린다. 백작이 알려주는 기본 규칙을 잘 듣고 셔플에 인조깅/아웃조깅이나 카드 끼워넣기를 언제 할지 플레이어가 판단해야 하기 때문이다. 딜링할 때도, 밑장을 뺄지 다음장을 뺄지 그냥 줄지 판단해야 한다. 그나마 다행인 점은, 모든 손패를 외우라는 일은 시키지 않는다는 것이다. 대신 높은 패 (AKQJ) 를 빼돌리거나, 문양이 가장 많은 카드 개수와 그 문양을 외우는 정도면 충분하다.\n특정 기법은 QTE 범벅이라 호불호가 있을 수는 있지만, 대부분은 커맨드 입력에 집중하기만 하면 된다. 그렇다고 \u0026lsquo;아수라발발타\u0026rsquo; 를 외쳐가며 느긋하게 했다간 의심 게이지가 계속 차오르는 걸 봐야 한다. 계산이 끝났다면 신속하게 움직여야 한다.\n스토리   늘상 쫒기고 붙잡히고 죽을 뻔 하고, 이것이 타짜의 인생\n  게임은 실제 18세기 프랑스 시대상과 실존 인물을 섞어 진짜 이야기인 것 처럼 풀어낸다. 실존 인물만 넷이나 나오는데, 그 중 \u0026lsquo;평경장\u0026rsquo; 역할에는 프랑스 최후의 연금술사이자 불로불사라고 소문난 \u0026lsquo;생 제르맹 백작\u0026rsquo; 이 나온다. 루이 15세도 사건의 중심 인물로 등장하며, 초반에는 프랑스 철학자 볼테르와 수학자 달랑베르가 조연으로 등장한다.\n대강의 스토리 전개는 이렇다. 루이 15세에겐 \u0026lsquo;열두 병의 우유\u0026rsquo; 라고 불리는 치부에 가까운 사건이 있었는데, 생 제르맹 백작이 왕정을 실각시키기 위해 사기도박을 다니면서 그 정보를 수집하러 다니는 것이다. 그 비밀이 한꺼풀 벗겨질 때 마다 둘에게는 몇 번의 위기가 찾아온다.\n즉, 트럼프 카드로 도박하는 것은 게임의 내러티브를 풀기 위한 일종의 수단인 셈이다. 그럼에도 수단과 스토리 사이에는 묘한 공통점이 있다. 모두 \u0026lsquo;비밀\u0026rsquo; 에 엮여 있다는 것이다. 비밀을 만든 사람과 의심하는 사람의 대립이 발생한다. 작은 테이블 위에서 시작해, 프랑스 왕가 전체로.\n짧은 플레이타임, 기대만큼은 하는 재미 인디 게임인 만큼, 게임 볼륨에 큰 기대를 하지 않았는데 딱 그만큼의 볼륨을 자랑한다. 28종의 카드 트릭을 다 배우면 실질적으로 1회차를 마무리할 수 있다. 멀티 엔딩이 있긴 하지만 마지막 분기만 엔딩에 영향을 미치기 때문에 리플레이성이 그만큼 떨어진다. 2회차부터는 설명을 건너뛸 순 있지만 어쨌건 털어먹는 과정을 다 밟아야 하기 때문에 굳이 2회차를 돌릴 이유가 없는 셈.\n스토리와 관련없이, 트릭만 계속 사용할 수도 있는 일종의 무한 맵 역시 존재한다. 그래서 트릭에 재미를 많이 느끼는 플레이어라면 여기만 들락날락 해도 될 성 싶다. 물론 트릭을 내 맘대로 선택할 수 없고 무작위로 주어지는 3개 중 1개를 골라 플레이하는 식이라서, 조금 아쉬울 수도 있지만 시스템 상 어쩔 수 없는 선택이었다고 본다.\n 마무리하면, 앞서 말한 대로 카드 트릭을 직접 수행해 보는 맛은 일품이다. 반면, 트릭 개수가 28개라고는 하지만 몇가지 기본 트릭의 조합 개수에 지나지 않는다. 이 점은 허위광고처럼 들릴 수 있다. 그러나 그런 조합을 상황에 맞춰 쓰는 센스도 함께 느껴볼 수 있다고 본다.\n곁다리로, 한글화가 안 되다가 최근에 된 건지 쾌적한 플레이가 가능하긴 했다. 하지만 트릭을 설명하는 생 제르맹 백작의 지문을 아무리 읽어봐도 이해가 안 되는 부분이 몇 군데 보였다. 그럴 땐 그냥 반복 연습과 독자 연구 (\u0026hellip;) 를 통해 내가 규칙을 찾는 수 밖에 없었다. 이 부분은 아주 살짝 아쉬웠다.\n","date":"2022-11-21T13:00:01+09:00","image":"https://interp.blog/card-shark/feature_huebbfad1edfa8e198fe68a27ac6a615ca_2051831_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/card-shark/","title":"카드 샤크"},{"content":"  애플TV 구독을 자처하진 않았다. PS5 를 구매했더니 몇 개월, 카카오페이로 결재하는 조건으로 몇 개월 씩 무료로 받은 것 뿐이다. 하지만 그다지 볼 게 없었다. 그렇게 유명하다는 파친코 조차 중도 하차할 정도로, 드라마를 고르는 내 기준이 점점 좁아지고 있었다. 그 와중에 커뮤니티에서 어떤 드라마의 1회분의 요약을 봤다. 어디서 볼 수 있냐는 댓글에 넌지시 애플TV 독점이라는 친절한 답글이 달려있었다. 아직 무료 구독일이 남아 있어서 다행이라고 생각하며, \u0026lsquo;세브란스\u0026rsquo; 를 보기 시작했다.\n요약은 대강 이랬다. 워라밸을 꿈꾸는 제약회사 직원 몇몇이 자원해서 뇌 수술을 받는다. 출근을 하면 지하로 내려가는 엘리베이터를 타고, 그 사이에 새로운 자아로 교체된다. 퇴근을 하면 올라오는 엘리베이터 안에서 다시 원래 자아로 교체된다. 즉, 원래 나 자신은 출근해서 엘리베이터를 타자마자 바로 내리고 곧바로 퇴근이다. 야, 이 얼마나 이상적인 워라밸인가!\n일하는 자아는 어떻게 되는가 하지만 드라마는 지옥으로 떨어진 새로운 자아에 대한 이야기를 놓치지 않는다. 어떤 여자가 아무런 기억 없이 회의실에서 눈을 뜬다. 오늘이 첫 출근인 것이다. 다른 사람들은 여자를 위로하면서 곧 익숙해 질거라고 한다. 팀장이라는 사람이 제일 사근거리지만, 여자가 보기엔 어쩐지 다들 미친 것 같다. 일하는 자아는 영원히 퇴근할 수 없다. 엘리베이터를 타자마자 다시 내려야 한다. 업무만 할 수 있는, 그야말로 지옥이 따로 없다. 그녀는 바깥 자아에게 퇴사를 종용하거나 경고 메시지를 보내기 위해 자해도 해 보고, 자살도 시도했다. 모두 수포로 돌아갔고, 결국 그녀는 체념한다.\n드라마는 일터에 갇힌 자아들의 불합리함을 이질적으로 보여준다. 마치 자아를 \u0026lsquo;다 큰 아이들\u0026rsquo; 로 분류해 두고 사회성 실험을 하는 것처럼. 하는 업무들이 정상적인 것도 아니고, 목표를 달성하면 보상으로 준다는 것들이 고작 케익 조각이나 댄스 파티, 크리스탈 장식품 따위이기 때문이다. 행여나 잘못을 하면, 휴게실로 들어가 \u0026lsquo;잘못했다\u0026rsquo; 는 말을 거짓말 탐지기에 걸리지 않을 때 까지 반복해야 한다. 제약회사의 창립자를 마치 신처럼 받들어 기리는 장소, 그의 말을 정리한 책이 마치 성경처럼 한 켠에 자리하고 있는 것은 일종의 세뇌작업처럼 보인다.\n일터와 현실의 대비 요약글을 읽었을 때는, 업무의 굴레에 처음 떨어진 그 여자가 주인공이라고 생각했다. 하지만 실제로 드라마는 그녀를 보듬어주던 팀장이 진짜 주인공이다. 회사 안은 물론이고, 퇴근 후의 자아까지 가장 많이 묘사되기 때문이다. 왜 이 프로그램에 지원하게 되었는지도 알 수 있다. 진짜배기는, 본래 자아는 사회에 절어 있는 푸석한 모습이라면 새로운 일하는 자아는 매우 밝고 당차다는 것이다. 그 대비가 극명해서 몇몇 배우들의 1인 2역은 필수 요소일 수 밖에 없었다.결론적으로는 정말로 잘 했다고 본다.\n분리된 두 무대의 배경 또한 극명한 대비를 이룬다. 일터는 하얀색 바탕에 형광등, 텅 빈 공간에 80년대에나 볼법한 컴퓨터 콘솔이 파티션 사이에 놓여있다. 복도는 도대체 방향을 가늠할 수 없을 정도로 이정표 없이 하얗기만 하다. 반대로 바깥은 만년설이라도 내린 듯 소복히 눈 쌓인 도시, 우중충한 거리, 해가 빨리 떨어져버린 어두운 밤을 강조한다. 이 대비가 참 마음에 들었다. 주인공이 우울한 이유는 바로 이 극야같은 삶이 아니었을까 생각해 본다. 낮에는 내가 없으니까.\n 공고할 것만 같은 워라밸 시스템은, 비밀을 간직한 전 팀원이 팀장 (정확히는 팀장의 본래 자아) 의 눈 앞에 나타나면서 작은 균열이 생기기 시작한다. 일터의 자아들은 의심의 싹을 키우기 시작하고, 그걸 무마해야만 하는 관리팀 직원들과 대치하게 된다. 여긴 어떤 공간일까, 우리 말고 다른 팀이 있는지, 우리가 모르는 방이 있을지, 자아를 어떻게 바꾸는 것인지, 나는 바깥에서 어떤 사람인지 같은 질문을 하나씩 가지게 된다. 그리고 하나씩 풀어내게 된다.\n사실 중간에 들어온 그 여자가 그 균열을 확장한 것이다. 체념한 듯 해 보였지만, 팀원들에게 보다 근원적인 질문을 던지기 시작한다. 그리고 그녀의 정체는-\n나머지는 시즌2가 나와야 한다. 떡밥 회수가 절반도 안 되었다. 추후 전개나 결말이 어떻게 되건, 너무나 신선한 소재이기에 차기 시즌 소식에 눈을 뗄 수 없을 것 같다.\n이제 내 자아는 일하러 가야 겠다.\n","date":"2022-11-20T21:23:01+09:00","image":"https://interp.blog/severance/feature_hu02f2cd5d270c1791918f1638293a501b_1404996_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/severance/","title":"세브란스: 단절"},{"content":"김정운 교수가 쓴 에세이로, 부제는 \u0026ldquo;슈필라움의 심리학\u0026rdquo; 이다. 슈필라움 (Spielraum) 은 독일어로 \u0026lsquo;내 마음대로 할 수 있는 물리적/심리적 공간\u0026rsquo; 을 뜻한다. 전라남도 여수에서 작업실을 차려, 그 슈필라움 속에서 겪었던 경험이나 떠올랐던 생각들을 엮은 것이다.\n그의 슈필라움은 여수에 있다 작가는 교수 일을 그만두고 미술을 공부하러 일본 유학을 다녀왔다고 한다. 그리고 한 화가의 작업실에 반해, 자신도 여수에서 전망 좋은 곳에 화실을 임대했다. 그러다 문득, 여자도(汝自島) 라는 섬에 위치한 사용하지 않는 미역창고를 사서 리모델링 해 서재가 있는 작업실을 만들겠다고 다짐했다고 한다. 바닷가에 있어 책 보관이 힘들 것이다, 물이 들어차면 어떡하냐, 섬에서 대공사를 하는 비용이 만만치 않을 것이다, 갖가지 반대가 쏟아졌지만 그는 이렇게 생각했다. \u0026ldquo;한 일에 대한 후회는 오래가지 않는다\u0026rdquo; 라고.\n그렇게 그 만의 슈필라움을 구축하는 데 우여곡절이 많았지만, 그는 2층에 화실을 두고 있는 화가이자 조그만 배를 몰 수 있는 선장이면서, 해안가에 책이 가득한 작업실을 가진 작가로 원하는 것을 할 수 있게 되었다. 솔직히, 마냥 부럽기만 하다.\n작가의 독서론 작가는 이 곳에서 좋은 책을 하나씩 채워가며 살고 싶다고 했다. 다 본 책을 꽂는게 아니라, 볼 책을 꽂는 것이라고 그는 강조한다.\n독서라는 것은, 여러 책을 묶어서 읽어야지 한 권을 끝까지 읽는 것은 문학작품을 읽을 때만 하면 된다고 한다. 발췌독을 해서 좋은 책은 곁에 두고 다른 책과 엮어가며 같이 읽는 것이다. 좋은 책은, 읽을수록 다른 책들이 떠오르고 읽고 싶게 만드는 책이라고 한다. 그의 표현으로는 \u0026lsquo;새끼를 치는 책\u0026rsquo; 이라고. 고구마 줄기처럼 딸려올라오는 것이 많은 책이라고. 그게 다른 책이건, 생각이건 간에 말이다.\n책을 구입하는 것이 결코 낭비가 아님을 강조한다. 비싼 그림 한 점 살 돈으로, 책을 여러권 사서 책장을 장식하는게 더 지적으로 풍부해 보이고 저렴하다는 것이다. 작가는 여행의 목적이 좋은 책을 찾고 사는 것이라고 할 정도로, 책에 진심인 사람이다. 그가 고백하기로, 독일과 일본 유학으로 언어에 제약이 적다 보니 독서를 통한 지식 습득에 훨씬 유리하다고 했다.\n그렇다, 이런 이유로라도 나는 영어 하나만큼은 정말 편안하게 쓸 수 있도록 공부해야 겠단 생각이 들었다.\n심리학 이야기 심리학 교수인 만큼 거의 모든 에피소드에 심리학 관련 내용이 붙어 있는데, 기억나는 몇 가지만 적는다.\n 평생 즐겨 듣게 되는 노래들은, 20대 전후로 형성된다는 연구가 있다. 김조한 노래를 듣다가 나도 모르게 무릎을 탁 쳤다. 걱정의 96%는 쓸데없는 것, 일어나지 않은 것에 대한 것이라고 한다. 걱정을 문장으로 풀어내서 가나다순으로 정렬하면, 걱정이 걱정이 아니게 된단다. 걱정의 개념화! 말을 중간에 끊는 것은 매우 무례한 일이다. 의사소통에서는 순서 주고받기가 중요한데, 내 순서를 뺏기면 인간은 은연중에라도 분노할 수 밖에 없다. 나쁜 이야기에 끌리는 이유는, 원시적으로 생존에 유리한 정보를 더 잘 들으려 하기 때문이다. 하지만 현대 사회에서는 직접적인 위협이 아니니, 되도록 나쁜 이야기를 피해 다니자. 나쁜 이야기를 전달하는 사람은, 타인의 반응으로 자신의 존재를 확인하려는 불안한 인간이다. 정 불안하면, 불안과 공포로부터 해방되고자 했던 것에서 출발한 \u0026lsquo;예술\u0026rsquo; 을 즐겨라. 미술관에 가거나 음악회를 가 보라. 페이스북 창립 멤버가 고백하기를, \u0026lsquo;좋아요\u0026rsquo; 로 이어지는 시스템은 마치 술이나 도박같이 \u0026lsquo;도파민에 의한 단기 피드백\u0026rsquo; 의 올가미가 되었다고 한다. 인정 투쟁의 아주 쉽고 정량적인 결과물이다. 좋아요 개수로 인정받는 세상. 자연인이 인기가 좋은 이유는, 자유 때문이다. 불 피우는 자유, 시선의 자유 때문이다. 남 눈치 안 봐도 되는 자유, 높은 데서 먼 곳을 조망할 수 있는 자유.   책을 다 읽고 여전히 부러운 마음이 떠나진 않았지만, 나 역시도 슈필라움이 아주 없진 않구나 싶었다.\n아이들이 크면 어떻게 될지 모르겠지만, 지금은 재택근무를 핑계로 온전히 내가 쓸 수 있는 방이 있다. 피아노도 있고 책장도 있고 게임기도 있다. 아침에는 커피를 내리는 조그만 공간도 있고, 베란다에는 철봉과 작은 운동기구 그리고 이따금씩 물을 주는 화분들도 있다. 마음만 먹으면 무엇이든 할 수 있는 공간이 있으니 얼마나 다행인가. 원래부터 내가 이사오면서 조건을 내 걸긴 했지만, 이 책을 읽고는 지금 내 방이 꼭 필요했다는 걸 지지받은 기분이 들었다.\n발췌독이 효과를 발휘하려면 작가처럼 많은 책을 내 곁에 두고 돌려가며 읽어야 한다. 나는 아직 좋은 책을 찾는 선문안(選文眼) 이 부족하다 느껴져서 책을 많이 사진 않았는데, 내년부터는 즐거운 마음으로 취미생활 비용을 책 구입에 써 보는 것도 재밌겠단 생각을 했다. 주변인 중에 책 사는 것 자체를 취미로 하는 사람도 있고, 스팀 라이브러리를 채우기 위해 게임을 구매한다는 것보다는 훨씬 고상해 보이니까 (\u0026hellip;)\n오늘은 지금의 걱정거리를 일기에 죽 늘어놓고, 하나씩 \u0026lsquo;별거 아니네\u0026rsquo; 라는 코멘트를 달아봐야겠다.\n","date":"2022-10-27T22:00:36+09:00","image":"https://interp.blog/spielraum/feature_hu006da100a267c423e253c3db09ef6091_294956_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/spielraum/","title":"바닷가 작업실에서는 전혀 다른 시간이 흐른다"},{"content":"티스토리로 갔던 이유 휴고에서 티스토리로 옮긴 지 두 달 밖에 되지 않았었다.\n이유는 여러 가지가 있었다. Forestry 나 VSCode 를 열어두고 글인지 코드인지 모를 포스트를 쓰는 것이 귀찮아졌고, 하나부터 열까지 내가 조정해 줘야 하는 것 보다는 쉽게 글을 쓰고 싶어서였다. 주로 한글로 된 포스팅을 올릴 거라, 휴고에서 구축해 둔 다국어 기능을 전부 활용할 수 없겠단 생각도 들었다. 그리고 티스토리에 올려두면 적어도 다음이나 카카오에서는 검색이 좀 더 활발하지 않을까 하는, 더 많은 유입을 고려한 결정도 있었다.\n다시 휴고로 돌아온 이유 그러나, 이번에는 확실히 휴고로 돌아왔다.\n이유는 너무나 단순하고 어이없게도, 10월 15일 카카오가 사용하는 데이터센터에 화재가 발생하면서 티스토리도 같이 서비스가 중단되었기 때문이다. 현재는 로그인도 되고 글도 살릴 수는 있지만, 모바일 보기만 지원되고 다른 스킨으로 적용도 되지 않는다.\n구글 애널리틱스는 너의 사이트가 이상하다며, 조치를 취하라는 이메일을 일요일에 발송했었다. 지금은 구글 검색에 다 빠져 있을 것이다. 대부분의 티스토리 포스트가 구글 검색에서 썰물처럼 빠지고 있기 때문이다.\n물론 복구가 된다면, 다시 포스트가 검색되고 아무렇지 않게 지나갈 수 있을 것이다. 그런데 그 이틀 동안, 나 뿐만 아니라 다른 포스팅까지 정전이 일어났다는 사실이 나에겐 너무 크게 느껴졌다. 어떻게 보면 별 것 아닐 수 있다. 서비스라는 것이 장애도 있고 종료도 있을 거니까. 그렇다면 이 질문을 하지 않을 수 없다.\n 장애나 종료 이후에, 내가 쓴 글을 쉽게 백업받을 수 있을까?  백업 받은 걸 다른 곳에 쉽게 올릴 수 있을까?\n 네이버 블로그에서는 포스트를 PDF 로 떨궈준다. Confluence 백업을 받아둬도 그걸 파싱해 가는 데 한 세월이다. 결국 마크다운 만큼 기본 내용만큼은 쉽게 다른 곳에 옮길 수 있는 포맷이 없다.\n물론 티스토리도 마크다운을 지원한다. 지금도 잘 옮겨뒀다. 하지만 장애가 이렇게 나 버리면, 옮길 수가 없다. Github Pages 에 올려 둔 Hugo 는 다르다. 일단 내 컴퓨터에 로컬 저장소가 있다. 적어도 거기서 출발하면 된다. 장애가 나면 서버를 열고, 거기에 소스를 부어서 시작해도 된다. 티스토리는 그게 안 된다.\n서비스형 블로그의 한계를 너무 꼬집는다 생각할 수 있다. 이번에 그 한계가 진짜구나, 어쩔 수 없겠다 싶으니 다시 가지 않을 것이다.\n다시 처음 이유를 돌아보자 글인지 코드인지 모를 포스트를 쓰는 것은 극복해야 할 문제 같다. 다양한 자동화 기능과 snippet 을 동원해야 한다. 포스트 마다 설정 가능한 옵션 파라메터를 확보해야 한다. 다국어 기능은 쓸 수 있을 때 쓰면 된다. 너무 욕심낼 필요는 없다. 유입을 더 많이 바라보기 보다는, 포트폴리오 성격으로 꾸준히 쓰는 게 중요한 것 같다. 괜찮은 글은 한 번 봐주십사 요청도 하고 다니면 어떨까 싶다.\n플랫폼이 중요한 게 아니었다. 사실 디자인도 우선순위가 높은 작업이 아니다.\n결국 무슨 내용이 살고 있는지가 중요한 것 같다.\n","date":"2022-10-17T18:47:14+09:00","image":"https://interp.blog/return-to-hugo-from-tistory/feature_hu3febd33f93d0b0acc11c27ffcc1b350f_1647445_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/return-to-hugo-from-tistory/","title":"Tistory 에서 다시 Hugo 로"},{"content":"  빨간 책 표지보다도 묘하게 긴 제목, 그리고 고양이와 함께 글을 허둥지둥 쓰는 작가의 오너캐가 더욱 눈길을 끈다. 곽재식 작가의 글쓰기 에세이를 재밌게 읽어봤다. 나도 사실 이 분의 작품을 읽어본 건 아니었지만, 한동안 글쓰기 관련 책을 찾던 때에 \u0026lsquo;유퀴즈에 나왔던?\u0026rsquo; 하는 생각이 스쳐서 골라오게 되었다.\n\u0026lsquo;훌륭한 글\u0026rsquo; 을 쓰는 스킬이라기 보다, \u0026lsquo;글 자체\u0026rsquo; 를 꾸준히 쓸 수 있는 스킬을 알려준다는 점에서 책 제목과 통하는 면이 있다. 글을 쓰고는 싶은데, 시작도 못했거나 시작만 하고 끝을 못 냈다면.\n어떻게든 글을 쓰고 싶다면, 이 책이 도움이 될지도 모른다.\n글쓰기 스킬 창고 대방출! 책은 크게 네 부분으로 나뉘어, 글감을 찾는 방법, 글을 시작하는 방법, 글을 꾸미는 방법, 글을 꾸준히 쓸 수 있는 마음가짐을 공유한다.\n다시 말하지만, 이 책은 훌륭한 글이나 책을 쓰기 위한 나만의 필살기 같은 걸 알려주진 않는다. (그런게 과연 있을지, 있더라도 전수가 가능한지는 모르겠지만.) 그보다는, 다른 작가들도 늘 할 것만 같은, 어떤 초식들을 알려주는 데 집중한다. 스킬이란게 별 게 없거든요\n앞서 소개한 네 챕터 중, 글을 꾸미는 방법의 분량이 가장 적은데, 훌륭한 글을 쓰는데엔 결국 작가의 부던한 노력 (그리고 좋은 편집자를 만나 편집자의 말을 잘 따르는 것) 이 중요하다고 말하기 때문이다. 반대로, 작가 개인의 경험에 비춰 글감을 어떻게 찾는지, 그리고 글을 꾸준히 쓸 수 있는 마음가짐을 어떻게 유지할 수 있는지를 읽을 수 있다는 점이 차별점일 것이다.\n글감을 찾는 방법 : 상상하기 작가는 소설을 위주로 펴내기 때문에, 소설을 쓸 때 필요한 방법을 많이 알려준다. 하지만 (책에서도 강조한 것 처럼) 물론 다른 유형의 글에도 효과적으로 적용할 수 있다고 믿는다.\n작가는 책 뿐만 아니라 영화를 참 많이 봐왔다고 한다. (영화 리뷰도 인터넷에 꾸준히 올렸다고 한다.) 이 영화의 좋은 점은 무엇이었을까, 나쁜 점은 무엇이었을까를 돌이켜 생각해 보면, 거기서 글쓰기에 대한 힌트를 얻을 수 있었다고 이야기한다. 좋은 점은 살리고, 나쁜 점은 피하고. 좋고 나쁨은 평론가나 대중의 생각이 아닌, 자신만의 느낌으로 선택해야 한다. 그리고 왜 선택했는지 정도는 기준이 있어야 한다. (이것만 나열해도 좋은 리뷰 글이 된다)\n좋은 부분을 차용해서 써도 되지만, 얼개를 그대로 가져다 쓰면 표절이나 다름 없으니 시대 배경이나 공간 배경을 바꿔보란 조언을 한다. 작가 말로는 \u0026lsquo;판을 바꿔친다\u0026rsquo; 라고 한다. 정말 어디서부터 써야할지 모르겠다면, 가장 재밌게 봤던 내용을 그대로 써 보되 판을 바꿔치는 것을 추천했다. 나쁜 점은 무조건 피하라는 것도 아니다. 그중에서도, 나라면 저렇게 스토리를 안 짰을텐데 싶은 건 거기서 출발해서 새로운 글감으로 써도 된다.\n이런 건 비단 영화 뿐만 아니라 일상 사건에도 적용이 가능하다. 심지어는, 아무 일도 일어나지 않았지만 어떤 상상으로 스토리를 이끌어 낼 수도 있다. 가령, 지하철에서 할아버지께 자리를 양보했더니 별안간 \u0026lsquo;땡큐\u0026rsquo; 라고 하시곤, 앉아 계시는 내내 아무 말씀이 없으셨다고 하자 (진짜 어제 내 이야기다)\n 이 할아버지는 우리나라 사람일까 아닐까? 그저 노인분들께서 으레 하시는, \u0026lsquo;고맙다\u0026rsquo; 라는 말로 전달하기엔 쑥쓰러움이 고마움이 뒤섞여 나온 흔한 수사일 뿐일까? 그렇다고 하기엔 발음이 꽤 정확한데다 숫기가 없었다.\n 정말 별 것 아닌데도 꼬리에 꼬리를 무는 질문과 묘사로 글이 써지기 시작하는게 느껴지지 않는가? 나만 그런가\n메모와 백업의 힘  소재가 생각나면 바로 메모하자\n 책에서 대놓고 강조하는 부분이다. 메모하지 않으면 소재는 다시 기억나지 않는다. 작가는 신발 끈을 묶다가 기가 막힌 아이디어가 떠올랐는데, 끈을 다 묶고 나니 그것이 전혀 기억나지 않았다고 했다. 나 또한 많이 겪었고, 아마 다른 분들도 비슷한 경험을 가지고 있으리라 믿는다.\n마지막 챕터에는 글 쓴 것을 잘 백업하자고 조언한다. 나는 이 백업을 글 뿐만 아니라 소재에도 적용해야 한다고 생각한다. 메모라는 것은 온라인으로 작성했건 노트에 끼적였건 간에, 수명이 굉장히 짧기 때문이다. 메모를 정리하고 발전하는 과정이 반드시 필요하며, 그걸 위해서는 (제텔카스텐 같은 본격적인 관리 기법 이전에) 언제 썼고 어떤 상황에 썼고 어떤 아이디어였는지 정도는 관리되어야 한다고 생각한다.\n그래야 메모가 지속되고, 글감을 찾아 헤맬 때 큰 도움이 될 수 있을 것이다\n글을 끝까지 쓰는 방법 : 일단 써라 글을 그냥 써야 하는 이유는 마지막 챕터에 몰아서 설명한다.\n 글을 쓰지 않으려는 핑계는 많을 수 밖에 없다. 글의 질이 당장 떨어져도, 나중에 고치면 된다. 두려워 말고 써라. 글의 질보다는, 빨리 마무리해 펴 내는 것이 중요한 세상에 살고 있다. (마감!) 소설이나 에세이 책이 아니더라도, 블로그, SNS 에 짧은 글을 올릴 수 있다.\n(그걸 엮어서 책으로 출판하는 세상이다)  하루에 한 시간, 일주일에 다섯 시간을 할애할 수 있다면 (작가 기준으로) 충분한 시간이라고 한다. 그것도 칼을 썰어내듯 한 시간 딱 채워 쓰지 말고, 아이디어가 샘솟을 때 멈추지 말고 쓰는 것을 추천했다. 작가는 한 번, 저녁에 시작한 글쓰기를 새벽 동이 다 틀 때 까지 한 적이 있다고 한다.\n나도 역시, 창의적인 일을 연달아 하거나, 일거리가 레고 블록처럼 딱딱 맞아 떨어질 때에는 쉬지 않는다. 이 때는 머리도 잘 돌아가고 환경도 받쳐주는, 소위 물 들어오는 때이기 때문에 노를 멈추는 것이 손해라고 생각하기 때문이다.\n 아직 읽어야 할 글쓰기 책이 더 많이 남았지만, 내가 읽었던 책 중에서 어떤 책이 가장 쉬웠냐고 묻는다면 이 책을 주저없이 꼽을 수 있겠다. 글쓰기 책들이 공통적으로 조언하는 \u0026lsquo;써봐야 안다\u0026rsquo; 는 것을 여기서도 찾아 볼 수 있었지만, 곽재식 작가는 좀 더 친근하게, 자신의 경험담을 살려서 알려주기에 책이 좀 더 쉽게 읽혔던 것 같다.\n끝으로 작가가 추천하는 정말 정말 쓸 소재가 없거나 이야기가 막혔을 때 하는 방법을 소개한다. 그냥 고양이 이야기를 써라. 독자들에게 한 동안 고양이는 인기가 있을 법 하다며. 고양이는 귀여우니까? 🤣\n","date":"2022-10-14T10:01:07+09:00","image":"https://interp.blog/writing-no-matter-what/feature_hu3a8a89eb3d55a61bc5e38a4399262050_76946_120x120_fill_q75_box_smart1.jpeg","permalink":"https://interp.blog/writing-no-matter-what/","title":"항상 앞부분만 쓰다가 그만두는 당신을 위한 어떻게든 글쓰기"},{"content":"Alex Mathers 의 medium 글 을 간추린 것이다. 저자는 38살 생일에 이 글을 썼다고 한다.\n여러분의 가치를 키우는 데 집중해라 행복을 찾는 일, 열정을 불러 일으키는 일들을 모두 따라가는 것은 중요하지만, 전부 다 할 수 없다. 오히려 독이 된다. 물론 다양한 것을 시도하는 것은 좋다. 그 중에서 여러분의 가치를 창출하는 데 집중해야 한다.\n돈을 저축해라 젊을 때는 저축에 무관심해 질 수 있지만, 돈은 시간을 먹고 자라기 때문에 젊을 때 부터 펀드에 적립하거나 투자에 관심을 보여야 한다.\n너의 모든 것을 고칠 필요는 없다 여러분의 \u0026lsquo;문제\u0026rsquo; 에 대해 개선하라고 말하는 사람은 잠시 무시해도 좋다. 사실 여러분은 전혀 틀리지 않았다. 앙금이나 트라우마를 안고 사는 것은, 여러분의 한계를 제한하는 것이다. 경험을 쌓고, 다른 사람을 행복하게 만들고 멋진 걸 만드는 데에도 시간은 부족하다.\n사회는 너를 약하고, 우울하게 만드려 한다 네가 옳다는 것을 따라가고, 군중의 트렌드를 좆을 필요 없다. 무시해라.\n대중매체 (mainstream) 의 어느 것도 믿지 마라 대중매체는 엔터테인먼트 그 이상도 이하도 아니다. 그건 여러분을 겁주기 위해 만들어져 있어서, 대중매체가 제시하는 해답에 의존하게 만든다. 대중 매체가 아니라, 행복하게 사는 사람들로부터 충고나 동기부여를 얻어라.\n자극이 되는 일에 너무 의존하지 마라 자극이 되는 일은 인생에서 주연이 되려고 노력하기 때문에, 여러분을 제한할 것이다. 이를테면 포르노, 설탕, 커피, 니코틴, 비디오 게임 같은 것들 말이다. 더 적게 의존할 수록, 여러분은 더욱 자유로워질 것이다.\n필요한 때때로 즐기는 건 아무 상관이 없다. 하지만 여기에 의존해선 안 된다.\n다른 사람을 행복하게 만드는데 집중해라 우리는 나르시시즘 문화에서 살고 있다. 이런 문화에 맞서서, 자신을 사랑하는 것보다는 다른 사람의 인생을 가꾸는데 집중하기 시작하라. 행복해 질 것이다.\n감정 조절은 가장 중요한 스킬이다. 어떤 순간에 갑자기 욱하게 된다면, 여러분은 반드시 해야 할 일이 있는 것이다. 이런 기질은 여러분 인생을 완전히 무너뜨릴 것이다. 고요한 상태로 돌아가는 습관을 개발하는 것, 이것이 여러분이 키워야 할 가장 중요한 스킬이다.\n한 가지 일에 특출나도록 해라 수백가지를 시도하면서 어느 일에도 능숙하지 못한 것보다는, 한 가지 일에 특출나야 한다. 경험, 스킬을 다양화하는 것은 당연히 좋지만, 이렇게 해서는 한 가지 분야에 대한 마스터가 될 수 없다. 세상은 전문가를 원한다.\n아무도 믿지 마라, 하지만 품위있게 행동해라 이 말은 소시오패스가 되라는 말이 아니다. 여러분의 시간, 에너지, 자원을 보호하란 말이다. 그러니까, 사납게 굴 필요 없다. 상냥하고 공손하게 하되, 그런다고 해서 어느 누구에게도 신뢰를 받을 수 없다는 사실을 기억하면 된다.\n멈추는 걸 멈취라 신기한 것들에 몹시 흥분하지만, 이내 그 기분은 식고 (wear off) 다음 빛나는 걸 찾으러 떠난다. 이렇게 자주 멈춰서는 안 된다. 한 곳에 지루하게 머물 수 있는 힘을 키워야 한다.\n몇년동안 너를 꼼짝 못하게 할 선택을 하지 마라 매우 비싼 결정을 해야 할 상황이 있다면, 그 결정을 피해라. 가장 나쁜 결과를 예측할 수 있고 다룰 자신이 있다면, 무슨 수단을 써서라도 시도해라. 그렇지 않다면 (조금만 불분명한 부분이 있다면) 물러나라.\n운동해라 건강해지는 것은, 30대에 시작할 습관이어서는 안 된다. 지금 해야 한다. 지금 운동하고 식이습관을 개선하면, 30대가 될 늙은 몸이 정말 고마워 할 것이다. 게다가, 20대를 매우 x4 활기차게 보낼 수 있다.\n집을 떠나 독립하라 고향에서 다른 지방으로 떠나는 것은 여러분을 불안하게 만들 수 있지만, 그것보다 더 큰 의미가 있다. 지구촌 세상에서, 지리적으로 자유로워지는 것에 견디기 힘들다면 당신은 결코 자유롭지 못할 것이다.\n","date":"2022-10-13T09:05:22+09:00","image":"https://interp.blog/25%EC%82%B4%EC%97%90-%EC%95%8C%EC%95%98%EB%8D%94%EB%9D%BC%EB%A9%B4-%EC%A2%8B%EC%95%98%EC%9D%84-14%EA%B0%80%EC%A7%80/feature_hu32608014e97a9c55366d20cfc483159d_153976_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/25%EC%82%B4%EC%97%90-%EC%95%8C%EC%95%98%EB%8D%94%EB%9D%BC%EB%A9%B4-%EC%A2%8B%EC%95%98%EC%9D%84-14%EA%B0%80%EC%A7%80/","title":"25살에 알았더라면 좋았을 14가지"},{"content":"개발자들은 전통적으로 워크스테이션이나 서버에 단말기를 접속해서 개발을 진행해 왔다. 이 때 사용되는 기기를 단말, 터미널 (terminal) 이라고 했다. 과거에는 컴퓨팅 파워를 구성하는 단가가 비쌌기 때문에, 저사양의 단말 컴퓨터를 가지고 상대적으로 고사양의 서버에 접속해 일을 하는 것이다.\n물론 지금은 PC 나 노트북 역시 충분히 고사양이긴 하다. 그래도 여전히 훨씬 더 효율적이고 강력한 서버 컴퓨터가 조직마다 존재하고, 클라우드 컴퓨팅으로 인해 자원을 필요할 때 마다 (on-demand) 빌려 쓸 수 있는 시대이다. 그렇기에 터미널은 여전히 유효하고, SSH 프로토콜로 통신하는 터미널 프로그램으로 남아있게 된다.\n어디서든, 어떤 단말로도 서버에 (또는 클라우드 VM 에) 접속할 수 있다는 것은 장점이지만, 네트워크 연결이 끊기거나 다른 단말로 다시 접속하게 되면 새로운 SSH 세션이 시작되고, 텅 빈 화면에서 다시 시작하게 되는 문제가 동시에 존재한다.\n또 한 가지 문제는, 한 화면에 하나의 세션만 열 수 있다는 것이다. 아니, 지금은 다양한 터미널 프로그램에서 \u0026lsquo;다중 윈도우, 다중 탭\u0026rsquo; 을 지원하는데, 그래서 여러 세션으로 넘나드는 게 가능한데 이게 무슨 문제일까? 그런 GUI 도 없는 유닉스/리눅스 시절엔 문제였다\u0026hellip;\n이 두 문제를 해결해 줄 Terminal Multiplexer 에 대해 알아보자.\nTerminal Multiplexer : tmux, screen 우선 흔히들 쓰는 tmux 의 매뉴얼 첫 설명을 보자.\n tmux is a terminal multiplexer: it enables a number of terminals to be created, accessed, and controlled from a single screen. \u0008tmux may be detached from a screen and continue running in the background, then later reattached.\n 터미널을 다중화해서, 한 화면에 여러 개의 터미널을 다룰 수 있다고 한다. 그리고 이 터미널 조합은 프로세스로 떠 있어서, (프로세스가 죽지 않는 한) 서버에 재접속 해서 해당 터미널 조합을 그대로 쓸 수 있다는 것이다.\nscreen 의 설명은 조금 더 길고 복잡하다. (그래서 tmux 설명을 먼저 소개했다) 그 중에서 소개글을 발췌해 보면 다음과 같다.\n Screen is a full-screen window manager that multiplexes a physical terminal between several processes (typically interactive shells). When screen is called, it creates a single window with a shell in it (or the specified command) and then gets out of your way so that you can use the program as you normally would.\nThen, at any time, you can create new (full-screen) windows with other programs in them (including more shells), kill existing windows, view a list of windows, turn output logging on and off, copy-and-paste text between windows, view the scrollback history, switch between windows in whatever manner you wish, etc.\nAll windows run their programs completely independent of each other.\n screen 에서는 여러 터미널이 윈도우라는 개념으로 나뉘어지며, 여기서 실행하는 프로그램은 완전히 독립된다는 것을 강조한다.\n각자 다른 특징을 지닌 것 같지만, 결국 둘 모두 terminal multiplexer 라는 것은 변함이 없고, 앞서 언급한 특성들을 모두 공유한다. 즉, 서론에서 이야기한 문제를 전부 해결해 줄 수 있는 특징이 있다.\n 여러 터미널을 한 화면에 띄우고, 관리할 수 있다. 이 터미널 조합은, 서버에 재 접속해서 그대로 쓸 수 있다. 각 터미널 안에서 수행하는 작업들은 철저히 독립적이다.  개인적으로 두 개 중 어느 것을 써도 문제는 없을 것 같다. 몇몇은 screen 에서 최신 기능이나 자잘한 것들이 지원되지 않는다는 사람도 있었고, 몇몇은 screen 을 계속 써와서 굳이 바꿔야 할 이유를 찾지 못했다는 이야기도 들었으니까.\nbyobu https://www.byobu.org\nbyobu 는 병풍(屏風)이라는 뜻의 일본어 독음이다. Canonical 에서 우분투 서버와 클라우드 팀에 있는 Dustin Kirkland 의 개인 프로젝트 라고 한다. (와우\u0026hellip;)\n이 프로그램은 tmux 와 screen 의 wrapper 라고 보면 된다. 즉, 두 multiplexer 중 하나를 좀 더 쉽고 간단하게 쓸 수 있도록 만든 것이다. 처음에 실행하면, 둘 중 어느 것을 쓸 것인지 선택할 수 있다.\n설치 방법 나는 brew 를 설치한 다음에 byobu 를 설치했다.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; # install brew into ~/.linuxbre echo \u0026#39;eval \u0026#34;$($HOME/.linuxbrew/bin/brew shellenv)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc brew install byobu 사용 방법 유튜브 튜토리얼 영상을 보면, 모짜르트 교향곡과 함께 윈도우를 화려하게 넘나드는 것을 볼 수 있다.\nman byobu 를 입력해서 매뉴얼을 열어보자. 여기서 단축키 리스트를 알려주긴 하, 당장 내가 자주 쓰는 단축키는 이 정도다.\n F2 : 새로운 윈도우를 만든다. 이 때 새로운 세션을 시작한다. F3/F4 : 이전/다음 윈도우로 포커스를 이동한다. Shift+F2 : 스크린을 상/하로 분할해, 아래쪽에 새로운 세션을 시작한다. Ctrl+F2 : 스크린을 좌/우로 분할해, 오른쪽에 새로운 세션을 시작한다. Shift+F3/F4 : 이전/다음 스크린으로 포커스를 이동한다. F7 : 스크롤백 모드로 전환한다. 방향키 또는 PageUp/Dn 를 이동해 화면을 스크롤할 수 있고, Enter 를 치면 종료된다.  복사 : Spacebar 를 누르면 커서부터 블록을 잡을 수 있다. 블록을 다 잡고 나서 Enter 를 누르면 복사가 된다 붙여넣기 : Alt+Insert (나는 안 됐음 ㅜㅜ) Ctrl+a 누른 후 ] (이게 잘 됨!)\n(iterm2 의 경우, applications in terminal may access clipboard 옵션을 켜줘야 함)    접속하면, 자동으로 byobu 실행하기 접속하자 마자 byobu 를 실행하려면 아래를 입력하면 되는데,\nbyobu-enable man byobu-launcher-install 을 보면 알겠지만, 이게 ~/.profile 에 내용이 추가되는 거라서, shell 설정에 따라서는 적용 자체가 안 될 수도 있다. ~/.profile 의 마지막 줄 내용을 ~/.bashrc 또는 ~/.zshrc 에 옮겨줘야 한다.\nmacOS 에서 Ctrl 키가 먹지 않을 때 매뉴얼에서 나오는 Ctrl+F2 단축키가 맥북에서는 먹질 않는다. Ctrl 이 인식되지 않는다기 보단 Function Key 인식에 문제가 있는 것 같다. (그렇다고 Ctrl+Fn+F2 를 누르면 F2 효과가 난다..)\n그래서 아예 byobu 단축키를 수정했다. tmux 를 쓴다고 가정했을 때, 아래 파일을 열어보자.\n# assume that you\u0026#39;re using with tmux vi $BYOBU_PREFIX/share/byobu/keybindings/f-keys.tmux 여기서 C-F2 따위의 키워드를 검색할 수 있는데, 이걸 Function Key 가 들어가지 않는 조합으로 바꿔주자.\n참고 : https://askubuntu.com/questions/969846/ubuntu-server-using-byobu-ctrlf2-does-not-split-screen-in-vertical\n","date":"2022-10-12T08:57:42+09:00","image":"https://interp.blog/terminal-multiplexer-screen-tmux-byobu/feature_hub4489663babe27ee99de734747e32023_1798198_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/terminal-multiplexer-screen-tmux-byobu/","title":"screen, tmux, 그리고 byobu"},{"content":"두 함수 호출 모두 error 를 리턴하지만, 어디서는 errors.new() 를 쓰고 다른 데서는 fmt.Errorf() 를 써서 헷갈렸다. 링크에서 확인한 결과, 아래와 같은 설명이 되어 있었다.\n Generally, when creating a sentinel error value, the errors.New function from the errors package is used instead of the fmt.Errorf function you’ve been using thus far.\nUsing errors.New instead of fmt.Errorf does not make any foundational changes to how the error works, though, and both functions could be used interchangeably most of the time.\nThe biggest difference between the two is the errors.New function will only create an error with a static message, and the fmt.Errorf function allows formatting the string with values, similar to fmt.Printf or fmt.Sprintf. Since sentinel errors are fundamental errors with values that don’t change, it’s common to use errors.New to create them.\n 두 함수 호출로 리턴되는 error 에 특별한 차이는 없지만, 포맷이 필요하면 fmt.Errorf, 포맷이 필요없는 static error message 라면 errors.New 를 쓰는 것이다.\n","date":"2022-10-04T09:01:55+09:00","permalink":"https://interp.blog/golang-errorsnew-fmterrorf/","title":"Golang: errors.new() vs. fmt.Errorf()"},{"content":"  TOEM 은 플레이스테이션5 로 출시되었고, 흑백의 귀여운 캐릭터들과 다양한 이야깃거리가 가득한, 사진 여행 어드벤처 게임이다.\n주인공은, 할머니가 보았던 아름다운 TOEM 의 광경을 사진에 담아오기 위해 여행을 떠난다. 공짜 버스를 타기 위해선 들르는 마을마다 사람들을 도와줘야 한다.\n첫 인상 : Hidden folks?   흑백이기 때문에, 개인적으로 iOS 앱으로 출시된 Hidden Folks 와 비슷한 이미지라고 느꼈다. 물론 장르 자체도 다르고 내러티브를 전달하는 방식이 다르지만, 그래픽이 워낙 비슷하고 결국 무언가를 찾아야 한다는 공통적인 목표 때문에 비슷하다고 느낄 수도 있겠다.\n게임의 핵심 : 카메라 카메라를 활용한 플레이가 이 게임의 핵심이기 때문에, 사진 촬영으로 게임을 진행하는 것이 일반적이다. 여기에 더해, 뷰파인더로 물건 찾기나 사진기에 경적을 달아 울리기, 삼각대를 활용한 사진, 셀피, 갖가지 프레임과 필터를 활용하는 경우도 있어서 1인칭 슈터 장르를 섞은 듯하면서도 다양한 양상으로 게임을 풀어나갈 수도 있다. 한 가지 아쉬운 건, 프레임이나 필터 종류가 다양하지만 퀘스트만 하다 보면 다 활용하지 않게 되는 경우가 많다는 것이다.\n힐링이 되었어요 이 게임은 기본적으로 힐링 게임을 목표로 한다. 카세트 테이프에는 잔잔하면서도 귀를 간지럽히는 다양한 배경 음악과 함께, 마을 사람~과 유령~들의 기상천외하고 귀여운 퀘스트를 하나씩 해나가다 보면, 산 정상에서 TOEM 을 어렵지 않게 볼 수 있다. 플래티넘 달성율이 말해주듯, 주변에 관심만 조금 더 기울인다면 트로피 난이도도 어렵지 않다. 짧은 플레이 시간, 잔잔한 사운드, 귀여우면서도 소소하게 재밌는 내러티브를 느끼고 싶다면 주저없이 고를 수 있다. 반대로 도전적인 게임을 좋아한다거나, 지난한 찾기 퀘스트 따위에 시간 할애를 하기 싫어한다거나, 플레이스테이션 5가 없다면 (PS4도 안 된다) 이 게임은 추천할 수가 없겠다.\n","date":"2022-10-04T08:46:59+09:00","image":"https://interp.blog/ps5-toem/feature_hu8eaba94500fb6835fca9d147e1631908_169608_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/ps5-toem/","title":"사진 찍는 힐링 게임, TOEM"},{"content":"나와 같은 개발자 친구와 이런저런 이야기를 하던 중, 내 리뷰가 반려된 경험담을 꺼냈던 적이 있다.\n 나: 내가 클로저를 사용해서 구현했거든. 그런데 리뷰어가 그게 뭐냐고, 아예 함수로 빼달라고 하는거 있지?\n친구: 아~ 그런데, 클로저가 도대체 뭐야?\n나: 어..? 그거, 있잖아! 함수 안에 함수 만드는 거! 그런데 그 함수 외부 변수 참조할 수 있는 거!\n 그러고 나자 (친구는 가만히 있는데) 나 혼자 부끄러운 생각이 들었다. 제대로 알지도 못하고 쓰고 있었구나 😂 일단 나부터 잘 모르고 쓰고 있다는 생각이 들어, 이참에 정리를 해 두려고 한다.\n정의 프로그래밍 언어에서 Closure 는, 함수 바깥에 있는 변수를 참조하는 함수 \u0026lsquo;값\u0026rsquo; 을 말한다..고 한다.\n한국어판 위키백과 설명을 보도록 하자.\n 컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다.\n기능상으로, 클로저는 함수를 저장한 레코드(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.\n MDN 에 있는 정의도 찾아봤다.\n A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function\u0026rsquo;s scope from an inner function.\n   시방 저것이.. 뭔 소리여?\n  Golang 에서의 Closure 백문이 불여일견, 일단 보자.\npackage main import \u0026#34;fmt\u0026#34; func outer() func() int { x := 0 return func() int { x++ fmt.Println(\u0026#34;Output:\u0026#34;, x) return x } } func main() { inner_f := outer() inner_f() inner_f() } main() 에서 호출하는 두 번의 inner_f() 가 일반 함수 호출이었다고 생각해보자. 일반적인 함수에는 상태가 저장되는 곳이 없다. 즉, 입력 값에 변화가 없기 때문에 두 번의 호출이 동일한 결과를 낼 것 같다.\n하지만 현실은 그렇지 않다. inner_f 에서 받은 것은 outer() 라는 함수가 아니라 클로저이기 때문이다. 따라서 출력이 다음과 같을 것이다.\nOutput: 1 Output: 2 Python 에서의 Closure 이번에는 똑같은 결과를 내는 Python 코드를 짜 보자.\ndef outer(): x = 0 def inner(): nonlocal x x += 1 print(\u0026#34;Output:\u0026#34;, x) return x return inner inner_f = outer() inner_f() inner_f() 거의 똑같지만, Python 에서는 nonlocal 키워드를 사용해서 외부 변수를 참조하겠다고 명시해야 한다.\ndef inner() 말고 Golang 처럼 unnamed function 을 정의해서 넘겨주려면 lambda function 을 참고하면 된다.\n일급 객체, 일급 함수 잠시 일급 객체라는 개념을 먼저 짚고 넘어가자. 일급 객체가 되려면, 세 가지 조건이 있다.\n 변수에 담을 수 있는 것 인자로 전달이 가능한 것 반환값으로도 전달이 가능한 것  일급 함수는 함수형으로 된 일급 변수를 뜻하니까, 짧게 설명하면 변수처럼 다룰 수 있는 함수 일급 함수라 할 수 있다. (참조)\n대부분의 스크립트 프로그래밍 언어가 일급 함수를 취급한다. 하지만 오래된 언어들 (기본 C, Algol\u0026hellip;) 의 경우엔 세 가지 조건 중 일부만 지원하기 때문에, 일급 함수를 취급할 수 없다.\n스코프 어떤 변수의 스코프는, 다른 말로 하면 변수가 어디까지 접근 가능한지를 나타낸 개념이다. 특정 변수의 수명 (lifetime) 으로도 나타내지만, 나는 두 개념이 모두 포함된 것이라고 본다.\n앞서 본 것 처럼, 클로저는 함수가 선언된 스코프 (scope) 안에 선언된 어느 변수라도 접근이 가능하다. 즉, 함수 스코프의 상위 스코프 까지다. 예제를 다시 보자. 변수 x 가 이에 해당 한다. outer() 안에 선언된 클로저 안에는 x 가 없지만, 클로저가 선언된 스코프 (그러니까 outer() 전체) 에는 x 가 사용 가능하다. 물론 이건 클로저 역시 마찬가지다.\n수명 이야기를 했는데, outer() 가 호출되기 시작할 때 변수 x 는 스택에 쌓이고, 호출이 종료되면 x 는 스택에서 빠질 것이다. 하지만 클로저가 선언되어 있다면 이 변수 x 의 수명은 늘어나게 된다. 그럼 이렇게 수명이 늘어난 변수 x 는 어디에 저장될까?\n자유 변수 클로저에서 숨어있는 개념이 바로 \u0026lsquo;자유 변수 (free variable)\u0026rsquo; 이다. 자유변수란 수학에서 나온 개념인데, 수식 속에서 상수로 치환이 가능한 변수를 말한다. 그 외의 변수는 전부 종속 변수 (bound variable) 이라고 말한다.\n위키 예제를 잠깐 빌려 이해해보자. $\\textstyle\\sum_{n=1}^1 m/n$ 에서 자유 변수는 무엇일까? 수식에서 자유로운 m 이 바로 자유 변수고, n 은 $\\Sigma$ 에 종속된 종속 변수다.\n클로저에서 이 개념을 적용해 보자. 클로저를 선언한 스코프 바깥에 있는 변수지만, 참조를 하고 있는 변수가 자유 변수인 것이다.\n클로저가 그냥 함수였다면, 자유 변수가 어떤 값을 가지고 있건 상관 없이 작동해야 한다. 반대로 말하면 이런 자유 변수로 인해, 함수로써 닫힐 수 있게 만든 것을, 우리는 클로저 (closure) 라고 부르는 것이다. (써놓고도 무슨 말인지..)\n다시 정의를 읽어보자  컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여, 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다.\n  참고로 일급 객체 함수와 클로저는 같은 말이 아니라, 일급 객체 함수 ∋ 클로저이다. 스코프에 묶인 변수를 바인딩한다는 뜻은, 클로저가 사용할 수 있게 계속 유지한다는 말과 같을 것이다.   기능상으로, 클로저는 함수를 저장한 레코드(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.\n  클로저 = 함수를 저장한 레코드! 스코프의 인수는, 달리 말하면 클로저가 선언된 스코프에 선언된 모든 변수/객체를 말한다. 이 것들이 클로저가 만들어질 때 (=선언될 때) 정의된다는 것이다. 어디에? 바로 레코드 안에. 스코프 내의 영역이 실제로 소멸되는 시점은, 스코프가 호출이 끝난 시점 (=함수 호출이 끝난 시점) 일 것이다.\n하지만 클로저 안에서는 해당 영역으로 영원히 접근 가능한 상태로 남아있게 된다.  여기까지 해석해 보면, 간접적으로 메모리를 좀 더 쓸 것이라는 추측이 가능하다. 단순히 생각해도 지역 변수들의 수명이 클로저 때문에 계속 되도록 만들어야 하기 때문이다.\nMDN 정의도 다시 읽어보자. 이번엔 해석을 해 봤다.\n A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function\u0026rsquo;s scope from an inner function.\n클로저란, 클로저를 둘러싼 상태 (사전적 환경) 와의 참조를 함께 넣어 묶은, 함수의 조합입니다. 다른 표현으로, 클로저를 통해 함수 내부에서 함수 외부로 접근을 가능하게 만들 수 있습니다.\n 클로저를 둘러싼 상태, lexical environment 라는 말들 전부 클로저 바깥을 말한다. 사실 뒷 문장이 다 설명을 해 주고 있다.\n","date":"2022-09-18T08:33:23+09:00","image":"https://interp.blog/program-language-closure/feature_huc0f5d4c1286e8e5d1cad12c4be591944_1794231_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/program-language-closure/","title":"클로저 (Closure)"},{"content":"증상 Visual Studio Code 에서 Python 파일을 디버깅 (debugging) 하려 하면, 아무런 반응이 없고 곧바로 종료된다. 그냥 실행 자체를 하지 않은 것 처럼 말이다..!\n😂   2023년 2월 현재, 파이썬 버전이 낮으면 아래 경고 문구가 잘 나오는 것을 확인했다.그래도 Python 3.6 이하 버전을 사용해야겠다면 아래 내용을 참고하자.     분석 관련해서 메시지가 나타나지 않기 때문에, 단서를 찾기가 쉽진 않았다. 그나마 \u0026lsquo;Output\u0026rsquo; 패널에 있는 \u0026lsquo;Python\u0026rsquo; 에서 아래와 같은 로그가 한 줄 떠 있었다.\nDAP Server launched with command: /home/interp/work/project/venv/bin/python \\ /home/interp/.vscode-server/extensions/ms-python.python-2022.12.1/pythonFiles/lib/python/debugpy/adapter 저기서 .. with command: 이후의 명령어를 그대로 터미널에서 입력해 보았다.\nTraceback (most recent call last): File \u0026#34;/home/interp/.pyenv/versions/3.6.12/lib/python3.6/runpy.py\u0026#34;, line 193, in _run_module_as_main \u0026#34;__main__\u0026#34;, mod_spec) File \u0026#34;/home/interp/.pyenv/versions/3.6.12/lib/python3.6/runpy.py\u0026#34;, line 85, in _run_code exec(code, run_globals) File \u0026#34;/home/interp/.vscode-server/extensions/ms-python.python-2022.12.1/pythonFiles/lib/python/debugpy/adapter/__main__.py\u0026#34;, line 212, in \u0026lt;module\u0026gt; __import__(\u0026#34;debugpy\u0026#34;) File \u0026#34;/home/interp/.vscode-server/extensions/ms-python.python-2022.12.1/pythonFiles/lib/python/debugpy/adapter/../../debugpy/__init__.py\u0026#34;, line 28, in \u0026lt;module\u0026gt; \u0026#34;Python 3.6 and below is not supported by this version of debugpy; \u0026#34; AssertionError: Python 3.6 and below is not supported by this version of debugpy; use debugpy 1.5.1 or earlier. 원인과 해결 저기서 마지막 문장이 중요하다.\nAssertionError: Python 3.6 and below is not supported by this version of debugpy; \\ use debugpy 1.5.1 or earlier. 찾아보니 Python Extension 에서 debugpy 버전을 업그레이드 했고, 더 이상 Python 3.6 에서 호환되지 않는 것이 문제였다. Changelog를 보니, 2022.10.0 버전부터 debugpy 를 1.6.2 로 올린 것을 확인할 수 있었다.\n그러면 해결책은 간단하다. 원하는 대로 해주거나, 되돌아가거나.\n(1) Python3.6 에서 버전 업그레이드 가장 간단한 방법은 더 높은 버전의 Python을 설치하고, 해당 버전을 기본 환경으로 설정하면 된다.\nvirtualenv 없이 Python 버전만 바꾼다면, VSCode 에서 Command Palette (Ctrl/Cmd+Shift+P) 를 열어서 Python: Select Interpreter 를 선택하는 것으로 버전 선택이 가능하다.\n나는 virtualenv 를 통해 개발 환경을 구성하기 때문에 아래와 같은 순서대로 업그레이드를 진행했다. 혹시 참고가 되길 바라며 정리해 둔다.\n (requirements.txt 따위로 관리하고 있지 않는다면) pip freeze \u0026gt; requirements.txt 로 설치된 라이브러리 백업 기존 virtualenv directory 삭제 (예: venv 라고 가정하자) (python3.9 를 설치했다면) python3.9 -m virtualenv venv 으로 virtualenv directory 생성 source venv/bin/activate \u0026amp;\u0026amp; pip install -r requirements.txt 로 라이브러리 재설치  (2) Extension 다운그레이드 하기 다른 해결책으로는, VSCode Python 의 Extension 버전을 다운그레이드 하는 방법이다.\n Extension 탭에서 Python 을 찾은 다음, Install Another Version 을 선택한다. 잠시 기다리면, 버전 목록이 나타나며, 초록색 부분 (그 아래도 상관없음) 을 클릭하면 된다.\n하지만 별로 추천하고 싶진 않다. Python 3.10 까지 나온 마당에 특별한 이유가 없다면 (1) 번처럼 Python 버전을 올리는게 좋을 것 같다.\n(3) Symbolic link 경로 문제 혹시 (1) 이나 (2) 번을 전부 적용해도 (아니면 이미 Python 3.6 이상의 버전을 쓰고 있는데도) 디버깅이 안 된다면 이 해결책이 도움이 될 것이다.\n한 번은, symbolic link 경로로 workspace directory 를 열었을 때 디버깅 문제가 생겼었다. 반대로 말하면, symbolic link 경로가 아닌 실제 directory 경로로 workspace 를 열어야 한다.\n예를 들어, /home/interp/ 는 사실 symbolic link 이고, 실제 경로는 /SSD/homes/interp 이라고 가정하자. 그렇다면, File - Open Folder.. 메뉴로 directory 를 열 때, 다음 중 하나만 디버깅이 가능하다.\n /home/interp/workspace_python ❌ /SSD/homes/interp/workspace_python ✅  ","date":"2022-08-23T22:26:07+09:00","image":"https://interp.blog/vscode-python-debugging-no-response/feature_huab4f92b5cef58f16753956ed9b784205_206719_120x120_fill_box_smart1_3.png","permalink":"https://interp.blog/vscode-python-debugging-no-response/","title":"VSCode Python 디버그 반응이 없을 때"},{"content":"지난 포스팅으로 BDD 는 어떤 개발방법론이고, 어떤 면에서 이 방법이 필요한지를 정리해 봤다. 이번 포스팅을 시작으로, 직접 다양한 언어에서 BDD 를 적용하는 방법을 정리해 볼 예정이다. 첫 시간으로는 파이썬 (Python) 언어를 가지고 할 것이다. Python 라이브러리 중 하나인 behave 를 통해, BDD 테스트 프레임워크를 구성하고, 예제 시나리오를 만들어서 테스트 자동화가 어떻게 이뤄질 수 있을지 알아보자.\n예제 프로젝트 생성 💡   모든 명령어는 리눅스 OS 또는 WSL 환경에서 실행한다고 가정한다.   파이썬이 설치된 환경에서 다음과 같이 디렉터리만 만들면 된다.\nmkdir behave-test \u0026amp;\u0026amp; cd behave-test 나는 virtualenv 를 이용해 환경을 분리해 두도록 하겠다.\nvirtualenv venv source venv/bin/activate behave 설치 pip install behave 만 하면 된다.\nfeatures/steps 디렉터리 생성 behave 는 features/steps 를 필요로 한다. 만들어 주자.\nmkdir -p features/steps  디렉터리만 만들고 곧장 behave 를 실행하면, ConfigError: No feature files in $(pwd)/features 라는 메시지가 뜰 것이다.\n.feature 파일 만들기 features/hotdog.feature 라는 파일을 하나 만들어보자. 핫도그 12개에서 5개를 먹으면 반드시 7개가 남아야 한다는 내용이다. 단순 영어로 되어 있지만, 문법에 대해 더 자세히 알고 싶다면 이전 포스팅을 꼭 참고하고 오자.\nFeature:eat hotdogs Scenario:Eat 5 out of 12 Given there are 12hotdogs When I eat 5Then there should be 7remaining  이제 다시 behave 를 실행하면, 아래 구조로 되어 있는 테스트 파일이 존재하지 않다고 하면서, 스니펫 (snippet) 을 출력해 주고 내부를 구현해 달라고 한다.\n$ behave Feature: eat hotdogs # features/hotdog.feature:1 Scenario: Eat 5 out of 12 # features/hotdog.feature:3 Given there are 12 hotdogs # None When I eat 5 # None Then there should be 7 remaining # None Failing scenarios: features/hotdog.feature:3 Eat 5 out of 12 0 features passed, 1 failed, 0 skipped 0 scenarios passed, 1 failed, 0 skipped 0 steps passed, 0 failed, 0 skipped, 3 undefined Took 0m0.000s You can implement step definitions for undefined steps with these snippets: @given(u\u0026#39;there are 12 hotdogs\u0026#39;) def step_impl(context): raise NotImplementedError(u\u0026#39;STEP: Given there are 12 hotdogs\u0026#39;) @when(u\u0026#39;I eat 5\u0026#39;) def step_impl(context): raise NotImplementedError(u\u0026#39;STEP: When I eat 5\u0026#39;) @then(u\u0026#39;there should be 7 remaining\u0026#39;) def step_impl(context): raise NotImplementedError(u\u0026#39;STEP: Then there should be 7 remaining\u0026#39;) 테스트 Python 파일 만들기 방금 출력된 내용을 단순히 복사해서 features/steps/hotdog.py 라는 파일을 만들었다. 참고로 파일 이름은 상관없지만 반드시 features/steps 디렉터리에 위치해야 한다.\nfrom behave import * @given(u\u0026#39;there are 12 hotdogs\u0026#39;) def step_impl(context): raise NotImplementedError(u\u0026#39;STEP: Given there are 12 hotdogs\u0026#39;) @when(u\u0026#39;I eat 5\u0026#39;) def step_impl(context): raise NotImplementedError(u\u0026#39;STEP: When I eat 5\u0026#39;) @then(u\u0026#39;there should be 7 remaining\u0026#39;) def step_impl(context): raise NotImplementedError(u\u0026#39;STEP: Then there should be 7 remaining\u0026#39;) 시나리오의 각 구절 (GIVEN, WHEN, THEN) 에 연결되는 기준은, 각 method 에 위치한 decorator 인 @given, @when, @then 에 따라 달려있기 때문에, 파일 이름은 상관없고 해당 decorator 만 수정하지 않으면 된다. 그리고 주의할 것은, 반드시 맨 위에 from behave import * 와 같이 behave 라이브러리를 import 해야 한다는 것이다.\n 이렇게 하고 다시 behave 를 실행하면, 예상대로 NotImplementedError exception 이 발생하면서 traceback 이 출력되고, 테스트는 실패한 것으로 간주한다.\n$ behave Feature: eat hotdogs # features/hotdog.feature:1 Scenario: Eat 5 out of 12 # features/hotdog.feature:3 Given there are 12 hotdogs # features/steps/hotdog.py:3 0.000s Traceback (most recent call last): File \u0026#34;/home/behave-test/venv/lib/python3.6/site-packages/behave/model.py\u0026#34;, line 1329, in run match.run(runner.context) File \u0026#34;/home/behave-test/venv/lib/python3.6/site-packages/behave/matchers.py\u0026#34;, line 98, in run self.func(context, *args, **kwargs) File \u0026#34;features/steps/hotdog.py\u0026#34;, line 5, in step_impl raise NotImplementedError(u\u0026#39;STEP: Given there are 12 hotdogs\u0026#39;) NotImplementedError: STEP: Given there are 12 hotdogs When I eat 5 # None Then there should be 7 remaining # None Failing scenarios: features/hotdog.feature:3 Eat 5 out of 12 0 features passed, 1 failed, 0 skipped 0 scenarios passed, 1 failed, 0 skipped 0 steps passed, 1 failed, 2 skipped, 0 undefined Took 0m0.000s 테스트 파일 구현하기 이제 테스트 파일 안의 method 를 구현해 보자.\nfrom behave import * @given(u\u0026#39;there are {num_hotdog}hotdogs\u0026#39;) def step_impl(context, num_hotdog): context.hotdogs = int(num_hotdog) @when(u\u0026#39;I eat {eaten_hotdog}\u0026#39;) def step_impl(context, eaten_hotdog): context.hotdogs -= int(eaten_hotdog) @then(u\u0026#39;there should be {remaining_hotdog}remaining\u0026#39;) def step_impl(context, remaining_hotdog): assert context.hotdogs == int(remaining_hotdog) decorator 에서 숫자를 나타내는 부분을 num_hotdog 같은 식으로 파라메터로 치환한 것을 주목해 달라. 이렇게 해 두면, 나중에 숫자만 바꾼 시나리오를 추가해도, 위의 세 개 method 를 재사용할 수 있는 장점이 있다.\n그리고 behave 는 context 라는 파라메터를 입력으로 받을 수 있도록 지원한다. 해당 시나리오가 진행되는 동안 유효한 객체이며, 따라서 여기에 원하는 attribute 를 만들어 값을 저장하고 열람할 수 있다. 예제 시나리오에서는, 남은 핫도그 개수를 context.hotdogs 로 보관한다.\n 엄밀히 말하면, when 에 해당하는 method 에서 핫도그 개수를 차감하는 부분은 여기서 구현하면 안 된다. 실제 업무에 사용하려면, 여기서 \u0026lsquo;실제로 구현한 로직\u0026rsquo; 을 호출해야 한다. 그래야 검증을 할 수 있으니 말이다!\n  다시 behave 를 실행하면, 이제야 모든 테스트가 통과되었음을 알 수 있다!\n$ behave Feature: eat hotdogs # features/hotdog.feature:1 Scenario: Eat 5 out of 12 # features/hotdog.feature:3 Given there are 12 hotdogs # features/steps/hotdog.py:3 0.000s When I eat 5 # features/steps/hotdog.py:8 0.000s Then there should be 7 remaining # features/steps/hotdog.py:12 0.000s 1 feature passed, 0 failed, 0 skipped 1 scenario passed, 0 failed, 0 skipped 3 steps passed, 0 failed, 0 skipped, 0 undefined Took 0m0.000s 숫자만 바꾼 시나리오를 추가하면? 시나리오만 추가하더라도 이미 재사용이 가능한 형태로 테스트 method 를 구현했기 때문에, 아래처럼 성공적으로 작동한다.\n$ behave Feature: eat hotdogs # features/hotdog.feature:1 Scenario: Eat 5 out of 12 # features/hotdog.feature:3 Given there are 12 hotdogs # features/steps/hotdog.py:3 0.000s When I eat 5 # features/steps/hotdog.py:8 0.000s Then there should be 7 remaining # features/steps/hotdog.py:12 0.000s Scenario: Eat 10 out of 20 # features/hotdog.feature:8 Given there are 20 hotdogs # features/steps/hotdog.py:3 0.000s When I eat 10 # features/steps/hotdog.py:8 0.000s Then there should be 10 remaining # features/steps/hotdog.py:12 0.000s 1 feature passed, 0 failed, 0 skipped 2 scenarios passed, 0 failed, 0 skipped 6 steps passed, 0 failed, 0 skipped, 0 undefined Took 0m0.001s 마치며 이제 이 테스트 케이스를 구현할 때 mock 라이브러리를 통해 mocking 을 하면, 기능 검증을 충분히 할 수 있을 것이다. 시나리오를 추가하는 것은 개발자 뿐만이 아닌 비 개발자나 QA 도 할 수 있어야 하고, 개발자는 그렇게 푸시된 새로운 시나리오를 보고 커버리지를 달성하기 위해 테스트에 좀 더 집중할 수 있을 것이다.\n한 가지 맹점은, 기존 시나리오가 바뀌면 테스트 케이스 개발 과정에서 엄청난 고통이 뒤따를 수 있단 것이다. 따라서 (전에도 말했지만) 항상 시나리오는 합의 하에 신중히 추가되어야 한다.\n다음 시간에는 golang 으로 똑같은 시나리오를 테스트 해 볼 예정이다.\n","date":"2022-08-19T09:00:36+09:00","permalink":"https://interp.blog/bdd-in-python-behave/","title":"BDD in Python: Behave"},{"content":"2020년 3월, 코로나 바이러스 전파 차단을 이유로 회사는 무기한 재택 근무에 돌입하게 되었다. \u0026lsquo;이제 누구의 감시도 받지 않고 혼자 할 일만 처리하면 마음껏 놀 수 있는 것인가!\u0026rsquo; 싶었지만. 얼마 지나지 않아서 백로그를 뒤져가며, 새벽이며 밤이며 게걸스럽게 일을 찾아 하면서 회사님 충성충성 더욱 고단해졌었다.\n (본 사진은 제 책상 사진이 아닙니다)\n  왜냐하면, 정작 업무 시간에는 애들 육아며 집안일이며 인터럽트도 많았고 개인 시간을 쓸 수 있다는 자유 때문에 회사에서는 못 해 볼 것들 (e.g. 점심먹고 침대에서 낮잠! 뛰쳐나가서 동네 카페나 서점 들르기!) 을 하다보면 업무 시간을 다 못 채웠다는 이상한 강박에 시달리게 되었다. 그 못다한 일을 나름 채우려고, 저녁 먹고나서 혹시 급히 처리해야 할 버그가 생기진 않았는지 시스템은 잘 도는지 둘러보기 일쑤였다. 회고해보면, 내 뇌는 이런 작은 것까지 다 업무의 연장으로 판단하고, 지속적으로 긴장을 했던 것 같다. 물론 안 좋았다는 말이다.\n그래서, 타임 트래킹 방법을 좀 찾아봤다. 우선 \u0026ldquo;내가 얼마나 일했는지 적어도 내가 알아볼 수 있는 방법\u0026rdquo; 이어야만 했다. 처음에는 그냥 메모장에 \u0026lsquo;O시 O분 ~ X시 X분 : 무슨무슨 일 했음\u0026rsquo; 이라고 적으려 했다. 그런데, 그것보다는 더 효율적인 방법을 누가 찾지 않았을까? 누군가는 같은 고민을 했을 것이라고 믿었기 때문이다.\n그렇게 찾아낸 방법이 바로 \u0026lsquo;뽀모도로\u0026rsquo; 이다.\n뽀모도로 기법이란?  이 방법은 존 손메즈 (John Sonmez) 의 \u0026lsquo;소프트 스킬\u0026rsquo; 책에서 처음 접했다. 이 책을 읽은 건 사실 코로나 사태 이전이었는데, 방법을 고민해보다가 불현듯 책에서 나온 뽀모도로 기법을 적용하면 되지 않을까? 해서 책장에서 꺼내 다시 읽어보게 되었다.\n단순하게 설명하자면, 뽀모도로 기법은 25분 집중하고 5분 쉬기를 반복하는 것이다. 4번째 휴식마다 5분이 아닌 15분을 쉬면 된다. 이 기법의 발명가인 프란체스코 시릴로 (Francesco Cirillo) 는 \u0026lsquo;뽀모도로 타이머\u0026rsquo; 라는 25분짜리 주방용 타이머에서 아이디어를 얻었다고 한다. (뽀모도로_pomodoro_ 는 이탈리아어로 \u0026lsquo;토마토\u0026rsquo; 라는 뜻이다) 즉, 25분의 집중 시간을 1개의 뽀모도로 라는 단위로 세면, 하루에 몇 개의 뽀모도로를 채웠는지 알 수 있다.\n시간 관리 \u0026lt; 집중 향상 뽀모도로 기법은 \u0026lsquo;타임 트래킹\u0026rsquo; 이 주 목적인 방법은 아니다. 그보다는, \u0026lsquo;집중 (focus)\u0026rsquo; 에 맞춰져 있다. 25분 동안은 스마트폰도 방해 금지 모드로 설정하고, 방문도 닫는다. (방문에 작업중이란 걸개를 걸어뒀다) 아웃룩도 끄고 메신저도 알람을 꺼버린다. 그래서 집중 향상에 좀 더 초점을 맞추도록 강요하는 기법이다. 이게 결과적으론 시간 관리를 효율적으로 할 수 있도록 해 주지만 말이다.\n 집중, 집중\n  이 시간들을 기록하면 좋은 점이, 어느 시간대에 집중을 잘 하고 어느 시간대에 상대적으로 집중이 덜 되는지 (=방해를 받거나 마음의 준비가 안 되어 있는지) 를 알 수 있다. 나는 운 좋게도 재택에다가 자율 근무 기반이라서, 내가 집중이 잘 되는 시간인 새벽 시간과 오후 시간을 업무에 할애하고, 보통 아침을 먹은 직후에는 집안일도 하고 개인적인 공부를 한다. 물론 바쁠 때는 여유 부릴 새가 없지만, 내가 선택할 수 있을 때는 가장 좋은 효율을 낼 수 있도록 도와주는 귀중한 백데이터가 되는 셈이다.\n이런게 어렵더라 이것만 하면 별거 없다고 생각하겠지만, 생각보다 지키기 어렵다.  25분이 생각보다 길다. 타이머를 중간에 쳐다볼 수도 있고, 좀이 쑤실 수 있다.  처음에 적응이 어렵다면 20분으로 줄이는 걸 추천한다. 그리고 가급적 타이머가 울리기 전 까지는 안 보는 걸 추천한다. 그것 자체가 주의 분산 (distraction) 이다.   5분 휴식이 생각보다 짧다. 4개의 뽀모도로를 채우면 15분이 주어지니까 괜찮을 것 같지만, 다르게 생각하면 2시간이나 지나야 휴식 다운 휴식을 할 수 있는 것이다.  그래서 5분 휴식에는 생리적인 일 (e.g. 화장실, 물 마시기, 일어나서 몸 풀기) 외에는 아~무것도 하지 않는 것을 추천한다. 제발. 특히 스마트폰으로 웹 서핑은 되도록이면 하지 말자. 이전 업무의 대부분을 뇌내에서 소거시킨다. 몸이나 푸는게 최고. 나는 심지어 이메일이나 메신저 보는 시간도 새로 시작하는 25분 초반에 한 번에 몰아본다. 거기서 업무로 발전시켜야 할 것이나 오래 생각해야 할 거라면, 다음 뽀모도로에서 처리한다. 그 외에는 답장하고 다시 알람을 꺼버린다.   4 뽀모도로를 하고 나면, 긴 휴식시간 동안 나름 뿌듯하면서도 이제 그만 하고 싶다. 와, 내가 2시간 가량 초집중으로 했어! 기특해! 보통 이후의 반응은 둘 중 하나일 텐데, \u0026ldquo;더 해서 오늘 하루 알차게 보내야지\u0026rdquo; 와 \u0026ldquo;이쯤 했으니 나 오늘 괜찮지 않어?\u0026rdquo; 같은 편협한 생각을 일삼게 된다. 그렇다, 난 후자였다\u0026hellip; 도대체 전엔 어떻게 일 한거지  이건 어쩔 수 없다. 한계를 돌파해보겠다는 어떤 신념으로 단 한번이라도 8, 12 를 해 봐야 한다. 그렇게 해 봐야 \u0026lsquo;나 이렇게까지 집중할 수 있는 인간이었어?\u0026rsquo; 라고 보람찬 기분을 느껴보면, 다음 날에는 그만하고 싶다는 저항이 덜하게 될테니까.    뽀모도로 개수에 집착하지 말자 이런 질문을 할 수도 있겠다. \u0026lsquo;8, 12 뽀모도로는 할 수 있다는데, 16, 20도 할 수 있는 거 아닌가요?'\n음\u0026hellip; 16이면 산술적으로 (휴식시간 포함) 8시간이 좀 안 되는데, 우리나라 정규 업무시간을 일 8시간이라고 한다면 이론상으론 할 수 있다. 하지만 난 2년동안 16개의 뽀모도로를 채운적이 단 한 번도 없다. 난 고3때도 (8시간 기준으로) 그렇게 8시간을 5분, 15분씩 쉬면서 한 적이 없다. 단지 투입 시간이 많았을 뿐\u0026hellip;\n \u0026lsquo;소프트 스킬\u0026rsquo; 책에서는, 저자가 일주일에 50-55 의 뽀모도로를 목표로 한다고 나와 있다. 평일 환산하면 10-11 개 수준에 지나지 않는다. 나 또한 정말 많으면 13개, 보통은 9-10개에 그친다. 팀장님 이 글 보지 마세요! 물론 여러분이 결코 못 할 거라고 단언하는 것은 아니다. 업무 시간이 8시간이니까 그 시간을 전부 뽀모도로 기법으로 채워서 업무를 처리하겠다는 말 자체가 굉장히 어렵단 말을 해 주고 싶다.\n여담이지만, 김영하 작가는 \u0026lsquo;자신은 일을 할 때 에너지를 100% 쏟으면 큰일난다고 생각한다. 60-70% 만 써야 한다. 무슨 일이 일어날 지 모르는데 일에 모든 에너지를 쏟으면 안 된다\u0026rsquo; 라는 말을 알쓸신잡을 통해 했던 기억이 난다. 그리고 수학자 앙리 푸엥카레는 규칙적으로 오전 10시-12시까지, 오후 5-7시까지 단 4시간만 일했다고 한다. 그보다 오래 일해봐야 얻는게 거의 없다고 판단했기 때문이라나? 그러니 너무 뽀모도로 개수에 강박을 갖지 말자.\n타이머 프로그램/앱? 앱을 몇개 둘러보진 않았는데, 나에게는 애플 앱 스토어의 \u0026lsquo;Flat tomato\u0026rsquo; 가 제일 나았다. 그렇다고 이게 다른 앱 대비 특출난 건 없고 그냥 깔끔해서. 게다가 이건 결국 유료 구매를 해야 되는 거라 섣불리 추천하기가 애매하다. 다른 앱 중에선 포커스 타이머를 좀 쓰다가, 복잡해서 포기했던 기억이 난다.\n정 싫으면 PC 용으로 나온 프로그램을 쓰자. 검색해보니 윈도우에는 PowerPom, 맥에서는 flow 가 있다. 둘 다 안 써 봤지만, 옵션이나 통계 기능이 없는, 말 그대로 타이머일 가능성이 높다. 그래도 뭐라도 써 보자. 통계 기능이 없으면, 하루동안 몇 개 뽀모도로 하는지 세서 일기장에 적으면 그만이다. 중요한 것은 시간의 퀄리티  뽀모도로의 크기가 작건 크건, 색깔이 다르건 간에 중요한 것은 시간을 효율적으로 보냈다는 증거 그 자체다.\n  물론 25분-5분 루틴이 마음에 안 들면 조정할 수도 있다. 학교 때 처럼 50분-10분으로 조정해도 된다.\n\u0026lsquo;일단, 오늘 1시간만 공부해 봅시다\u0026rsquo; 라는 책에서는 결국 50분-10분의 1시간 루틴을 최종적으로 추천하기도 하니, 도전해 보는 것도 나쁘지 않다. 나는 공부만 하는 것이 아니어서, 그렇겐 안 할란다\n중요한 것은, 업무를 할 때나 다른 일을 할 때 그 시간을 확실히 집중해서 보냈느냐를 기록할 수 있고 되돌아 볼 수 있는 것이 뽀모도로 기법의 특징이다. 하지만, 그냥 방해는 받지 않고 모니터에서 멍하니 있었어도 1 뽀모도로로 계산되는 점이 맹점이라고 볼 수는 있다. 이런 아쉬움은, 뽀모도로 기능을 제공하는 앱들 대부분이, 각 뽀모도로 마다 \u0026lsquo;별점\u0026rsquo; 을 매길 수 있게 되어 있다. 방해는 안 받았는데 집중이 잘 안됐다면 높은 점수를 주지 않으면 된다. 이 기능을 활용하면 퀄리티를 좀 더 세심하게 기록할 수 있을 것이라 본다.\n나는 뽀모도로를 업무에만 쓰지 않는다. 책을 읽을 때도 쓰고 (보통 하루에 2-3 뽀모도로를 쓴다) 프로그래밍 연습을 할 때도 쓰고 (매일은 아니고, 주당 5 뽀모도로를 채우려고 노력한다. 잘 안 된다) 심지어 영화를 보거나 게임을 할 때도 쓴다. (물론 내가 원할 때 세이브를 할 수 있는 것이어야 한다) 이런 다양한 작업까지 다 합치면 하루에 16 개의 뽀모도로를 모으는 날도 있다. 물론 보낸 시간은 8시간보다 훨씬 많지만 말이다. 시간은 누구에게나 소중한 것이니, 소개한 뽀모도로 기법을 통해 훨씬 가치있게 시간을 사용할 수 있기를 바란다.\n","date":"2022-08-17T17:31:36Z","image":"https://interp.blog/%EB%BD%80%EB%AA%A8%EB%8F%84%EB%A1%9C-Pomodoro/feature_hu3acaa7fe47ae53ae1afbdbb488e3e500_4995545_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/%EB%BD%80%EB%AA%A8%EB%8F%84%EB%A1%9C-Pomodoro/","title":"뽀모도로 (Pomodoro)"},{"content":"\u0026lsquo;zsh 자동 완성\u0026rsquo; 이라는 Kubernetes 공식 문서에 따르면, 다음 명령으로 자동 완성이 가능하다고 한다.\nsource \u0026lt;(kubectl completion zsh) 그런데 Oh my zsh! 에서는 몇가지 더 설정을 해야 한다.\n $HOME/.zshrc 를 열어서, plugins 에 다음을 추가한다.  kubectl kube-ps1 zsh-syntax-highlighting zsh-autosuggestions    plugins=(git kubectl kube-ps1 zsh-syntax-highlighting zsh-autosuggestions) kubectl, kube-ps1 은 이미 설치되어 있을텐데, 아래 2개는 별도 설치가 필요할 수 있다.\n# zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git \\  ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting # zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions \\  ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 참고로 Auto-suggestion 되는 내용이 하얀색으로 나와서 타이핑하거나 알아보기가 힘들다면, 해당 내용만 다른 색으로 바꿔줄 수 있다.\n export ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=(number)' 라고 쓰면 된다. 나는 (number) 자리에 243 을 사용했다. 연한 회색이다. 자세한 color 값은 여기를 참고하자. 물론 사용하려면 $TERM 값이 xterm-256color 여야 한다.  그리고 다시 로그인하면, 탭키(\u0026lt;tab\u0026gt;) 를 통해 자동 완성이 잘 되는 것을 확인할 수 있다.\n","date":"2022-08-16T12:31:36+09:00","permalink":"https://interp.blog/oh-my-zsh-kubectl-autocomplete/","title":"Oh my zsh! 에서 kubectl 자동 완성 하기"},{"content":"이 책을 두 문장으로 요약하면, 책을 완독하는 것도 좋지만 중요한 건 책이 내 인생에 어떤 도움이 되는지 얻어야 한다. 그 부분’만' 빠르게 하면, 짧은 시간에 엄청난 양의 책을 읽을 수 있고 인생에 큰 도움이 된다는 것이다.\n한 권 읽는 데 30분 한 권을 읽을 때는 30분을 잡는다고 한다. (물론 어려우면 더 많은 시간을 써도 된다. 요점은 한 권을 통독하는게 아니고, 찾고자 하는 요점을 반복적으로 시도하는 과정에 있다.\n30분을 다음과 같이 세 파트로 나눈다.\n    (adsbygoogle = window.adsbygoogle || []).push({});   처음 : 책 고르기 우선 책을 골라야 한다. 고르는데 필요한 팁은 다음과 같다.\n 자신의 현재 인생 목표에 맞는 책이어야 한다. 목표와 동떨어진 책은 이 방법을 사용해도 효과가 적거나 없다. 목표에 맞는 책을 얼마나 읽어야 할까? 보통 7권 정도 읽으면 배울만큼 배울 수 있다고 저자는 주장한다. 기초서 2, 다양한 시각을 가진 3권, 전문서 2권. 책의 뒷면, 띠지, 속지에 적힌 글을 통해, 책의 분위기와 수준을 알 수 있다.  15분 : 빠르게 주요 페이지 찾기 책을 최대한 빠르게 읽으면서, 내가 생각하기에 중요한 페이지를 접는다. (나는 플래그 인덱스를 사용한다) 이 방법이 속독은 아닌데,\n 에필로그와 감사의 말은 넘어간다. 모든 독자를 위한 글은 아니기 때문이다. 해당 챕터 또는 문단에서, 저자가 말하고자 하는 바를 먼저 찾는다. 예제라던지, 에피소드 같은 건 이해를 도와주는 곁들임 정보일 뿐이다. 말하고자 하는 바를 찾기 위한 몇 가지 팁이 있는데, (적고보니 언어영역 특강인 줄…)  한자어가 들어있는 문장에, 더 많은 정보가 있다. “그러나, 하지만” 같은 접속사 뒤에 있는 친구가 요점이다.   중복된 내용이다 싶으면 넘어간다. 도표나 그림도 마찬가지다.  10분 : 주요 내용의 에피소드 기억 두 번째 독서는 10분을 할애하며, 표시했던 중요한 페이지들 위주로 심도있게 읽는다.\n 두 번째 독서는 첫 번째와 다른 장소에서 읽으면 도움이 된다. 중요한 부분을 요약하거나, 어떻게 자기 삶에 적용할 수 있는지 책에 적는다.  나는 대여한 책이 많아서, 옆에 노트를 두고 적었다. 단순 필사는 의미가 없다. 이 내용을 어디에 써먹어야지, 이 내용은 그때 그 것과 비슷한 것 같다 라는 식으로 요약해야 한다.   내용은 파란 펜으로 쓴다. (파란 펜이 뇌과학적으로 어쩌고… 사실 상관없을 것 같다)  5분 : 아웃풋 노트 그냥저냥한 책이라면 2단계까지 해도 좋지만, 정말 울림이 커서 곁에 두고 인생에 늘 적용해야겠다고 판단되면 ‘아웃풋 노트’ 를 작성하라고 한다. 이 노트에는,\n 목표 책 제목 에센스들  13~20자 내외의 문장 10개 정도   행동 계획  아웃풋 노트는 항상 곁에 두고 점검해야 한다. 적고나면 까먹기 때문이다.\n    (adsbygoogle = window.adsbygoogle || []).push({});   독서의 필요성, 속독의 해악 저자는 이 방법을 알려주기 전에 (다른 사람들이 늘 하는 것 처럼) 이 방법의 믿음을 주기 위해 많은 서문을 남겼다. 자신은 이 방법을 써서 성공한 사람이 되었다, 이 방법을 쓰면 어떤게 좋고 어떤게 또 좋다. 책을 읽어보면 다 도움이 되지만, 나는 이 초격차 독서법을 이 책에도 그대로 적용했기 때문에 다 넘겼다. 하다 보면 자연스럽게 장점을 취할 수 있을 거라고 기대하면서.\n인터넷이 있는데 굳이 이렇게 독서를 할 필요가 있을까? 라는 질문에는 내 생각과 일치하는 답을 내놓은 점이 흥미롭다. 책은 저자가 기를 쓰고 움직이지 않는 매체 (글과 그림)로만 설득하고 설명해야 하기 때문에 한 권을 통해 종합적으로 받아들일 수 있지만, 인터넷 정보는 단편적이고 검증되지 않은 정보가 섞여있기 때문에 통합해서 받아들이기 어려운 면이 있다는 것이다.\n 저자는 속독을 하는 것이 아무런 도움이 되지 않는다고 하면서, 대신 요점을 빠르게 파악해 내 인생에 도움 되는 것을 ‘편취’ 하는 방법이 훨씬 시간을 아낄 수 있다고 주장한다. 나도 속독엔 그다지 흥미가 없었다. 오히려 느린 속도로 통독하는 걸 좋아했었으니까. 그런데 저자가 주장하는 바는 일단 인생에 도움이 되는 정보를 빠르게 얻는다는 목적이 매력적이어서 한번 실천해보고자 한다.\n","date":"2022-08-12T11:00:36Z","image":"https://interp.blog/%EB%B6%80%EC%9E%90%EB%93%A4%EC%9D%98-%EC%B4%88%EA%B2%A9%EC%B0%A8-%EB%8F%85%EC%84%9C%EB%B2%95/feature_hu79870751a266d4e1d772c8a3de4aebe5_69104_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/%EB%B6%80%EC%9E%90%EB%93%A4%EC%9D%98-%EC%B4%88%EA%B2%A9%EC%B0%A8-%EB%8F%85%EC%84%9C%EB%B2%95/","title":"부자들의 초격차 독서법"},{"content":"작년 즈음에, 팀에 테스트 주도 개발 (Test-driven Development,TDD) 에 대해 어떤 강력한 합의 (?) 가 필요하지 않을까라고 팀장님께 주장했던 기억이 났다. 일단 나부터 좀 잘 해야 할텐데 그런데 그걸 언제 또 기억하셔서는, 올 초에 ‘TDD 말고 BDD 에 대해 조사해서 차기 프로젝트에 녹여보면 어떻겠냐’ 는 제안을 하셨다. 두 눈을 동그랗게 뜬 채 음성 채팅으로 ‘그것이… 무엇이죠?!’ 라고 되물었던 슬픈 기억이 난다.\n지금은 프로젝트를 진행 중인데 거의 설계 단계를 지났고, 프로토타이핑이 끝나간다. 바쁜 시간이 지나고서야 팀장님의 부름이 닿아, 뒤늦게나마 우리가 쥐고 있는 요구사항이 무엇인지, 어떻게 적용할 수 있는지 찾아보고 있다. 그런데 이 결과물을 팀원들에게 공유하려면 내가 먼저 ‘BDD 를 왜 써야 하는지’ 를 이해하고 설명할 수 있어야 하기에, 블로그에 정리해 보려고 한다.\nBDD 란? BDD 는 Behavior-driven Development, 즉, 제품이나 서비스의 행동에 초점을 맞춘 개발 방법론이다. 소프트웨어가 어떤 일을 해내야하는지가 가장 중요하며, 개발과 테스팅이 거기에 맞춰 진행되어야 한다는 것이다. 뭐, 당연한 소리 아닌가? 다들 이렇게 다 하잖아요, 그쵸?\nCucumber 에서의 BDD 정의는 다음과 같다.\n BDD is a way for software teams to work that closes the gap between business people and technical people by:\n Encouraging collaboration across roles to build shared understanding of the problem to be solved Working in rapid, small iterations to increase feedback and the flow of value Producing system documentation that is automatically checked against the system’s behavior   Inviqa 의 BDD 블로그 포스트에서는 이렇게 정의했다.\n BDD is a process designed to aid the management and the delivery of software development projects by improving communication between engineers and business professionals. In so doing, BDD ensures all development projects remain focused on delivering what the business actually needs while meeting all requirements of the user.\n 잘 보면 collaboration, communication 이 겹쳐 보인다.\nBDD 적용 방식 여기서 나는 BDD 의 Best Practice 나 심지어 Gherkin 문법에 대해서 자세히 조사해 정리하지 않을 것이다. 왜냐하면 나도 배우는 입장이고, 이 포스팅의 목적은 ‘BDD 가 정말 필요할까요?’ 를 밝히는 것이기 때문이다.\n정말 필요하다고 생각하면, 그때서야 더 깊이 찾아보면 될 일이다.\nDiscovery User Story 에서 실제 예제를 만든다. 이 예제는 합의되어야 한다.\n이 과정은 협업 단계이다. 워크샵을 통해 아이디어를 모으고, 구체적인 예시를 들어야 한다. 이 과정을 통해 어떤 기능이 정말 필요한지 우선순위를 정할 수도 있다. User Story 의 범위를 조정하는 작업이기도 하다.\n이런 과정을 통해, 우리가 뭘 해야 할지 결정하기 위해 빠진 정보를 알아낼 수도 있다. 처음부터 모든 정보를 들고 요구사항을 구체화할 수 없기 때문이다. 다시 채워서, 다시 이야기해야 한다.\n다시 말하지만, 여기서 산출된 예제들은 합의된 것이어야만 한다. 그렇지 않으면 다음 사이클에 영향을 끼친다.\nFormulation 예제를 자동화 가능한 형태로 문서화한다. 이 문서는 합의되어야 한다.\n문서는 Gherkin 문법 (GIVEN - WHEN - THEN) 으로 정형화한다. 이 문서 내용을 다시 모든 조직원들에게 공유해, 이렇게 테스트할 것이라고 검증받아야 한다. (다시 말하지만, 이 문서도 합의되어야 한다.)\nAutomation 문서에 맞춰 구현하고 테스트한다.\n언어 별로 다양한 라이브러리/패키지가 지원되며, BDD 또는 Cucumber, Gherkin 으로 검색하면 관련 자료가 늘 나왔었다. 내가 확인한 건 일단 Java (Mockito), Python (behave), Go (godog) 정도가 있다.\nGherkin 문법으로 정형화된 문서를 입력으로, 코드 템플릿을 출력하거나 코드 템플릿과 일치하는 테스트 케이스가 존재하면 바로 테스트 결과를 출력한다. (behave, godog 만 테스트해 봤다) 각 언어 별 실제 사용 예제는 블로그에 따로 정리할 예정이다.\nGherkin Format 그럼 도대체 Gherkin 오이피클 은 어떻게 쓰는가? 가장 간단한 방법은 세 문장으로 나타내는 것이다.\nGiven there are 12 cucumbers When I eat 5 cucumbers Then I should have 7 cucumbers GIVEN 은 전제 조건이고, WHEN 은 액션, THEN 은 그 결과이다. 이 부분을 테스트 케이스로 만드려면,\n GIVEN : 전제조건이 되도록 환경을 구성하거나 mocking 한다. WHEN : 액션을 가한다. (함수를 호출하거나) THEN : 실제 결과가 명세에서 예상한 대로 나왔는지 검증하는 코드가 필요하다.  물론 세 가지 키워드 말고도 다양한 방법으로 ‘예제’ 를 표현할 수 있다. 자세한 문법 내용은 여기를 참고하자.\n내가 생각하는 BDD BDD 가 어떤 것인지 맛을 봤으니, 이제는 왜 이 방법론이 필요한지 내 생각과 경험을 얹어 설명해 보겠다.\n 보통 프로젝트를 시작하거나 하면 TDD 를 기본으로 깔고 시작한다.\n우선 개발자는 요구사항에 맞는 테스트 케이스를 만든다. 그 요구사항은 프로젝트 안에서 개인에게 할당된 작업 내용에 관한 것일 수도 있고, 정말 고객이나 비즈니스에서 원하는 기능에 대한 요구사항 명세일 수도 있다.\n테스트 케이스를 먼저 만들고, 테스트 케이스는 물론 실패한다. 실패하지 않게 구현하고, 박수를 짝짝 치고 PR 을 연다. 리뷰를 받고 파이프라인을 통과해 프로덕션 브랜치로 기능 (또는 수정 내역) 이 반영된다.\n 문장 자체로만 보면 아주 당연하고 아름다운 순서이겠지만, 여기서 뭔가 꺼림칙한 부분이 생기게 된다. 나는 크게 두 가지가 걸리는데,\n 테스트 케이스가 요구사항을 온전히 반영했는지 검증이 가능한가? 사람은 오류와 상상의 동물이라서, 요구사항을 아무렇게나 해석해서 테스트 케이스를 만들어 둘 수 있다. 물론 코드 리뷰하면 다 나오는거, 맞다. 그런데 우리가 리뷰해야 할 것은 리펙터링과 모킹 (mocking) 이 복잡하게 뒤섞인 ‘코드’ 란 말이다. 정말 그 오류를 잘 찾아낼 수 있나? 요구사항은 대체 어떻게 만드는가? 이건 좀 더 근원적인 질문인데, 요구사항이라는 것은 언제나 ‘고객/비즈니스-개발 조직’ 또는 ‘프로젝트 리더-프로젝트 개발자’ 사이에 정량적으로 합의된 내용이어야 한다. 티켓에 적힌 내용, 회의록이 합의된 결과 아니냐고? 글쎄… 그걸 다 모아다가 볼 수 있나? UML 은 어떨까? UML 다이어그램에 대한 지식이 없는 사람은 그럼 요구사항 리뷰를 못 하는 걸까?  우리는 늘 이런 걸 겪지 않았던가? “그건 제가 하고 싶은 말이 아니었어요!” “그건 제가 원하던 것이 아니었어요!” 라는 말… 어정쩡하고 단방향의 요구사항은 늘 화를 불러오게 되어 있다.    이런 방식대로라면 (1) 사용자가 정말 원하는 요구사항을 ‘요구사항 명세’ 가 100% 커버하는지 (결과물이 너무 다양하거나 복잡하기 때문에) 쉽게 알 수도 없고 (2) 요구사항 명세가 테스트 케이스로 변환되어 100% 기능하고 있는지도 쉽게 알 수 없다는 것이다. 내가 ‘쉽게’ 라는 말을 붙이긴 했지만, 현실에서는 거의 불가능하다고 본다.\n내가 봤을 때 BDD 는 두 가지 문제를 짚어 나가는데 효과적이다. 개발 외 조직으로부터 사용자 요구사항을 받는 것 말고도, 개발조직 내부에서 요구사항을 합의하고 기능을 검증할 때도 효과적이라는 점 역시 덧붙이고 싶다.\n마치며 이렇게 설명해놓고 보니, 일선 개발자에겐 TDD 의 확장 개념이라고 여기게 될까 조심스럽다. 어차피 자연어로 된 문서를 소스로 한다는 점만 틀리지, 거기서 생성된 테스트 케이스의 코드를 구현하고 Regression 을 돌리는 작업이 기존에 하던 TDD 와 무엇이 다르냐고 할 수도 있겠다.\n하지만 TDD 를 시작하기 이전에 ‘어떻게 테스트 케이스를 만들죠’ 라는 부분에 대한 하나의 대안으로 생각해주면 좋겠다. 이 방법이 부상하기 전부터, 소프트웨어 공학에서 제시한 UML 명세나 수 많은 다이어그램에 기초해서 테스트 케이스를 만들지 않았던가. 조직에서 이런 방식으로 이미 명세-테스트 케이스 자동화가 되어 있다면 정말로 BDD 가 필요없을 순 있겠다. 하지만, UML 부터 무척 복잡하다고 느끼는 것은 비단 나 뿐일까?\nBDD 는 확실히 사용자가 정말 원하는 예제를 찾고, 보완하는데 불편함이 적다. 누구나 읽을 수 있는 언어로 되어 있으니, 비즈니스를 다루는 직원은 뭔가를 더 배울 필요가 없다. 개발자는 나름 규격화된 문서를 가지고 테스트 케이스를 만들 수 있다. 즉, 이 방법론은 조직 전체에 걸쳐 광범위한 개발 방법론이라고 볼 수 있겠다.\n다음 포스팅은, 내가 실제로 구동해 본 behave 나 godog 예제가 될지, 아니면 현업에서 적용해보고 난 뒤 받은 피드백에 대해서 이야기할지 고민 중이다. 아직 이렇다 할 피드백이 없어서, 아마도 실제로 따라 써 볼 수 있는 글을 쓰는게 현실적이리라 본다.\n","date":"2022-08-11T16:31:36Z","image":"https://interp.blog/bdd-behavior-driven-development/feature_hu6e8d6a0eefdce87b682403457a9c42fe_48694_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/bdd-behavior-driven-development/","title":"BDD (Behavior-driven Development) 소개"},{"content":"부동산 매매 거래를 할 때, 매도인이 담보대출 건을 당일 말소시키겠단 조건을 보통 넣게 되면 매수인의 대출 실행 은행 측 법무사가 와서 \u0026lsquo;상환이 완료됐는지 증명해야 하니까 증명서를 달라\u0026rsquo; 고 한다. 증명서요? 상환 다 했는데요??\n당황해서 인터넷뱅킹 홈페이지를 여기저기 뒤지고, 영업점에 전화도 해 보고, 그러다보면 시간이 쫓길 수 있다! 우리의 시간은 소중하고 나도 이사 갈 곳에 잔금 치뤄야 하는데 이게 뭐야 ㅠㅠ\n그래서 이 참에 정리해 봤다. 우리은행을 예로 들겠지만, 다 비슷할 거라 생각한다.\n대출완제 영수증 발급 받기 대출완제 영수증이란 즉, 대출 상환을 다 마쳤다는 영수증이다. \u0026lsquo;개인 \u0026gt; 조회 \u0026gt; 계좌조회 \u0026gt; 해지계좌 조회\u0026rsquo; 로 들어간다.\n조회구분에 \u0026lsquo;대출\u0026rsquo; 이 있는데, 이걸 클릭한 다음, 상환이 완료된 날짜가 포함되도록 기간을 설정해 조회하면 끝.\n그러면, 대출완제 영수증 출력 버튼과 함께, 해지된 계좌가 나타나게 되는데, 그걸 출력해 법무사에게 건네주면 끝!\n주택자금대출 상환증명서 발급 받기 연말정산 용으로 주택담보대출의 이자액을 공제받을 목적이나 기타 목적으로 상환 증명서를 떼야 할 수 있다. 주의할 점은, 이 상환 증명서는 상환한 대출 이력만 나오므로 대출이 전액 상환되었는지 증명할 수 없는 서류라는 점. 이걸 떼 주면 법무사가 \u0026lsquo;이거 아니야\u0026rsquo; 라고 고개를 절레절레\u0026hellip; 그러니 대출의 전액 상환을 증명하려면, 앞서 소개한 \u0026lsquo;대출완제 영수증\u0026rsquo; 을 발급받아야 하니 주의!\n이번에는 \u0026lsquo;개인 \u0026gt; 뱅킹관리 \u0026gt; 증명서발급 \u0026gt; 증명서신청\u0026rsquo; 으로 간다.\n그 안에서 주택자금대출상환증명서를 선택한 뒤, 발급 신청을 통해 받을 수 있다.\n","date":"2022-08-11T16:31:36Z","image":"https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/1_hud172bdad67328e68179b793afc1d9b05_48172_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/%EC%83%81%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%8C%80%EC%B6%9C-%EA%B3%84%EC%A2%8C-%EC%A6%9D%EB%AA%85%EC%84%9C-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0/","title":"상환 완료된 대출 계좌, 증명서 발급하기"},{"content":"회사에서 기계식 키보드를 아무거나 사라고 해서 i-rocks의 KR-6251 을 사서 5년 째 쓰고 있다. 2년 전부터 몇몇 키들은 한 번 누를 때마다 두 번 입력되는 느낌을 받았고, 쓰면서 이 현상이 더욱 가중되어 성가신 느낌을 지우기 힘들었다.\n그런데 이 문제를 어떻게 인터넷에서 검색하지? 감을 통 잡을 수 없으니 \u0026lsquo;그냥 새로운 키보드 하나 사야 하나?\u0026rsquo; 라고 고민하고 있었다. 이럴 때만 지름신이 오셔서는, \u0026lsquo;비싼 걸 사서 쓰라\u0026rsquo; 고 말씀하시지 그러다가 우연찮게 이런 유형의 문제를 \u0026lsquo;키 바운스\u0026rsquo; 라고 부르는 몇몇 문서를 발견할 수 있었다.\n키 바운스? 그대가 돌아서면~♪ 말 그대로, 키가 제멋대로 춤을 춰서 한번 더 스위치와 부비는(!) 현상을 말한다.\n무접점 키보드가 아닌 이상, 일반 키보드인 멤브레인을 포함, 스위치를 사용하는 기계식 키보드들은 발생할 수도 있는 증상이다. 분명히 나는 한 번 키를 눌렀다 뗐는데, 내부에서 진동으로 인해 스위치가 한번 더 (혹은 여러 번) 눌리는 현상이라고 이해하면 되겠다. 다른 말로 채터링(Chattering) 이라고도 부르더라.\n해결시도 (1) 청소 원인은 여러 가지가 있을 수 있지만, 원칙적으로는 스위치 고장이라고 생각해야 하지 않을까. 이럴 땔, 스위치 교체를 해야 한다. 혹시 키캡-스위치 접촉 불량으로 미세하게 덜렁거릴 수도 있으니 청소를 한번 해봤는데… 청소를 다 하고도 똑같은 문제가 자주 발생하는 걸 보면 그렇게 효과가 크진 않은 것 같다.\n해결시도 (2) 바이오스 업데이트 바이오스 업데이트로 키 입력에 대한 패치를 하는 방법도 있다는데, 잘 모르겠으니 제조사에서 추가 정보가 업데이트 되었는지 확인해 보는 방법도 있겠다. (당연히 내 키보드는 이미 단종이라 그런 사후지원을 기대할 수 없었다.)\n해결시도 (3) OS 설정으로 문제 억제시키기 그럼 스위치를 교체하거나 키보드를 버려야 할까? 잠깐 그 잔인한 생각을 집어넣고 타협할 방법을 알려드리도록 하겠다.\n나 역시 소프트웨어적으로 이런 반복적인 키 입력을 막을 방법이 분명히 있을거라고 생각했는데, 다양한 해결책이 있었다. 모든 OS는 \u0026lsquo;사용자 접근성\u0026rsquo;이란 메뉴가 존재한다. 화면 글씨를 일부러 키우거나 소리를 읽어주거나 하는 그런 기능들이다. 여기서 제공하는 것들 중 \u0026lsquo;탄력 키\u0026rsquo; 기능을 사용한다.\nWindows 윈도우 7 이후의 버전이라면, \u0026lsquo;제어판\u0026rsquo; 의 \u0026lsquo;접근성 센터\u0026rsquo; 에서 \u0026lsquo;키보드를 사용하기 쉽게 설정\u0026rsquo; 항목으로 들어간다. 여기에서 \u0026lsquo;필터 키 켜기\u0026rsquo; 를 적용하면 된다. 그러나 애석하게도 필터 키의 바운스 타임을 뜻하는 \u0026lsquo;탄력 키 입력 인식 시간\u0026rsquo; 간격을 0.5초 이하로 조정할 수 없다. 이 말은, 키를 반복해서 탁탁 칠 때 0.5초보다 빠른 간격으로 치면 모두 무시된다는 소리고, 생각보다 빠른 입력을 할 때 (특히 백스페이스를 반복해서 누를 때) 복장이 터질 가능성이 높다. 결국 이걸 낮추려면 레지스트리를 건드려야 하는데, [이 포스팅][2]을 참고해서 조정이 가능하다.\nLinux (Ubuntu) 나 같은 리눅스 사용자는 그럼 어떡해야 할까. Ubuntu 기준으로 설명하면, \u0026lsquo;설정\u0026rsquo; – \u0026lsquo;접근성\u0026rsquo; – \u0026lsquo;자판 입력\u0026rsquo; 에 있는 \u0026lsquo;탄력 키\u0026rsquo; 를 켜서 허용 지연 시간 바(Bar)를 거의 왼쪽으로 갖다 두면 윈도우의 최소 단위인 0.5초보다 간격이 낮아져서, 반복 입력을 해도 무시되는 경우가 거의 없는데다가 키 바운싱이 완화되는 것을 확인할 수 있다.\n결론 위 네이버 포스팅에도 언급되지만, 100% 해결책은 아니다. \u0026lsquo;다\u0026rsquo; 를 치는데 \u0026lsquo;ㄷ\u0026rsquo; 키가 바운싱이 되는 사이에 \u0026lsquo;ㅏ\u0026rsquo;가 입력되면 OS 입장에서는 \u0026lsquo;ㄷㄷ\u0026rsquo; 같은 중복 키로 인식하지 않으므로 \u0026lsquo;닫\u0026rsquo; 같은 문자가 입력되기 때문이다. 이런 문제는 지금 포스팅을 쓰는데도 발생하고 있다 (이런!)\n결국 지름신을 모셔야 할 것 같지만… 어느 정도 완화할 수는 있겠다 싶어서 작성한다.\n","date":"2022-08-11T02:25:04Z","image":"https://interp.blog/images/featured/keyboard-key-bounce.jpg","permalink":"https://interp.blog/keyboard-key-bouncing-problem/","title":"키보드 키 바운싱 문제 해결"},{"content":"서브리미널 (Subliminal) 은 식역하 (識閾下) 라고도 하는데, 인지하는 영역 밖에서 우리가 인지한 것들을 말한다. 김현정의 노래를 뒤로 감아 돌리면 ‘MP3 다운 말고 제발 앨범 사주세요’ 처럼 들리는 식의 이른바 백마스킹 (backmasking) 도 그 일종이고, 연구에는 실패했노라 결론났지만 영상에 중간 중간 메시지를 짧은 시간 반복적으로 노출하면, 시청자들이 인지하기 전에 그 메시지를 따른다는 이론도 있었다.\n그렇다면 식역상 (識閾上) 은 어떤 모습일까? 우리가 인지하고 있다지만 사실은 그게 충분한 것이 아니라면? 우리가 인지하는 방법이 사실은 틀린 것이라면?\n1인칭 퍼즐 슈터 게임의 계보를 잇는 게임, 슈퍼리미널 (Superliminal) 엔딩을 봤다. 우리의 인지방식, 그러니까 관점에 대한 내러티브를 통해 교훈을 주는 퍼즐 게임이라고 보면 된다. 간단하게 말하면, 보이는 대로 플레이 한다는 참신함은 있었지만 그보다는 지금껏 나온 여러 게임의 믹스처럼 느껴졌다.\n스탠리 패러블? 안티챔버? 포탈? 처음엔 스탠리 패러블같이 배배 꼬여있는 법칙들과, 알 수 없는 나레이션들이 주위를 감쌌다. 그렇다고 멀티 엔딩이 존재하는 것도 아니고 철학적인 메시지가 그 만큼 다채롭진 않다. 배배 꼬여있는 법칙을 풀기 위해선 말도 안되는 생각들을 끼워넣어야 하는데, 이건 마치 안티챔버를 연상케 한다.\n하지만 오히려 이 게임이 메시지를 던지는 방식은, 내러티브와 제4의 벽을 이용한 스탠리 보다는 안티챔버와 비슷한 결을 내고 있다. 그리고 기본적인 퍼즐 플레이 자체는 어쩔 수 없이 포탈과 비슷하다. 물건을 버튼 위에 놓아둬야 문이 열리는 루트는 누가 봐도 포탈이다.\n이런 특성을 고스란히 믹스해 두면서도, 고유의 정체성을 유지하는 것은 어렵다. 아니, 셋 다 내가 봤을 땐 대단한 게임들이라서, 오히려 세 가지 색을 섞고 비어있는 걸 창조한게 아닌가 하는 질 나쁜 의심마저 들 정도다. 사실은 ‘보이는 대로 만들자’ 라고 만들었더니 저런 것들이 다 들어가 있던 것일 수도 있잖아. 하지만 포탈이야 거의 모든 게임에 영향을 줬다고 봐도 무방하니까 기본 값으로 쳐도, 이 게임은 굳이 비교를 하자면 스탠리의 스킨을 쓴 안티 챔버다.\n단순하진 못한 게임 규칙 게임의 볼륨이 생각보다 크지 않은데, 왜냐하면 아까 말 했듯 선형적인 구조기 때문에 리플레이를 전혀 할 필요가 없다. 퍼즐 자체의 난이도 1인칭 퍼즐 슈터 장르 안에서는 쉬운 순서로 랭크될 게임이다. 그런데 이런 딜레마는 제작사가 생각하지 않을 수 없었을 텐데, 바로 인지영역 밖의 퍼즐 디자인 자체가 굉장히 힘들다는 것을 반증한다.\n지금까지 언급되건 언급되지 않았건, 1인칭 퍼즐은 단순하고 체계적인 법칙으로 게임의 동력을 만든다. 포탈은 ‘물리 법칙’, 탈로스의 법칙은 ‘전기’, 그리고 더 위트니스 (The Witness) 는 ‘그리기’ 라는 도구로 설명할 수 있으니, 어떤 방식으로도 디자인 해도 푸는 사람이 존재할 수 있다. 안티 챔버는 비슷한 딜레마를 겪었을 진 몰라도, 게임 자체가 미쳤기 때문에 (…) 말도 안되는 법칙을 섞어낼 수도 있었던데다 매터 건의 법칙은 일면 단순했기 때문에 (호불호가 있겠지만) 정복 욕구가 생길 수 있었다. 스탠리는 애당초 퍼즐 정복이 아닌 엔딩 정복 게임 같은 거니까 차치하고.\n그런데 슈퍼리미널에선, 조금만 어렵게 만들어도 풀 수 있는 사람이 엄청나게 제한되며, 누가 이런걸 공략으로 올리면 ‘아니 이게 무슨 억지야’ 라는 댓글이 달리기 뻔하기 때문이다. 그 균형을 맞추려면 디자인 패턴에 제약이 생길 수 밖에 없다. 게임이 그 부분을 얼마나 잘 풀어냈는지는 직접 플레이 해보시길.\n불가능을 가능으로 이 게임이 주는 메시지는 ‘불가능 할 거 같지만 다르게 보면 가능할지도?‘ 라는 것이다. 사실상 이게 전부긴 한데, 후반부로 진입할 수록 이 메시지와 내가 풀고 있는 퍼즐 사이에 심각한 괴리가 생겼다. 그래서 어떡하란 건지, 더 이상 현실이 아닌 공간에 플레이러를 가두고는 “할 수 없었던 걸 하니까 좋지요?” 라는 메시지가 갑자기 들어오면 쉽사리 공감이 가질 않는다. 그 때부턴 그냥 게임을 ‘게임답게’ 받아들이고 퍼즐 푸는데만 집중하게 되었으니까.\n하지만 이 게임이 가지고 있는 기본적인 참신함, 1인칭 퍼즐에 목말라 있던 유저들에겐 더할 나위 없이 좋은 신작이라 말할 수 있다. 그 참신함이 어디선가 본 것 같으면서도 크게 와닿지 않는 점이 아쉬울 뿐이다.\n이제 또 다른 관점에서 하루를 시작해 볼 차례다. 게임에서처럼, 알람 소리가 당신을 깨울 것이다.\n","date":"2022-08-11T09:00:36+09:00","image":"https://interp.blog/superliminal/feature_hu14ac134b036f205a0754b4c9051bb789_74057_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/superliminal/","title":"Superliminal"},{"content":" 인스타툰으로 (나를 포함한) 많은 팔로워를 둔 지수 작가의 첫 번째 에세이. 인스타그램에선 몇 장의 사진으로 하나의 포스트를 이루는데, 다양한 관계와 이따금씩 드는 기분에 대하여 친근하면서도 진솔한 해석을 남긴다. 독자에게 공감을 남기면서도, 따뜻한 위로를 건네주는 것 같다.\n책은 주로 작가의 일상에서 출발해 어떤 생각에 도달했는지를 풀어나가지만, 비단 작가 개인만이 느꼈던 것은 아니었을 보편적인 감정이기 때문에 공감하기 쉬운 주제들로 엮었다. 너도 이런 비슷한 경험을 해보지 않았을까? 그런 질문이 결코 강압적이지 않고, 너가 무슨 생각이 들던 나는 그랬다며 미소짓는 듯하다. 이 책은 마치 김토끼의 얼굴을 닮았다.\n기억나는 문구 몇 가지 기억나는 부분을 표시했는데, 필사를 해 보니 다음이 남았다. (허락받고 발췌해야 하나?!)\n 나를 찾아가는 여정에 지름길은 없다. 누구도 명쾌하게 답해 주지 않는다.\n인생에는 긴지 짧은지 대 볼 수 있는 명확한 줄자가 없기 때문이다.\n 다른 사람이 이뤄낸 것을 내가 꼭 이뤄야 할 필요는 없다. 모든 분야를 잘 하는 사람은 현실적으로 존재하지 않는데도, 우리는 예전보다 남들과 비교하기 좋은 세상에 살고 있다. 유튜브, 인스타그램, 페이스북, 블로그, 연예 기사를 보면서 우리보다 잘난 사람들의 이야기를 끊임없이 듣는다. 때로는 그 이야기 속에 \u0026lsquo;여러분도 저 처럼 될 수 있어요!\u0026rsquo; 라며 그들만의 줄자를 나에게 들이밀 때도 있다. 잠시 그 소음을 내려놓고, 내가 정말 원하는 것은 무엇인지 나만의 줄자를 만들어야 한다. 중요한 건, 그게 다른 사람의 것보다 하찮고 짧아도 아무런 상관이 없다는 것!\n 볼링 내기할 때만 그러면 좋으련만 나는 평소에도 내 손을 떠난 일에 시간과 정신을 쏟곤 한다.\n할 수 있는게 아무것도 없어졌을 때 오히려 더 악착같이 집착할 때도 있다.\n볼링공을 던져놓고 허공에다 대고 허우적거리는 것처럼 말이다.\n 나 또한 어쩔 수 없는 일에 걱정이 많은 타입인데, 비유가 너무나도 찰지다. 내 손에서 떠난 볼링공을 손짓 발짓을 해가며 기다리는 것. 기우제가 따로 없다.\n (구독자들에게) 고마운 것은 그뿐이 아니다.\n그들은 콘텐츠를 소비하는 사람이기에 앞서 나와 공감대를 형성하는 사람들이다.\n그 존재 덕에 큰 위로를 받는다.\n 내 이야기를 들어주는 사람, 내 생각에 반응해주는 사람이 있다는 것은 얼마나 고마운가. 작가가 다른 사람들에게 영향을 줄 수 있는 것만큼이나, 구독자들도 작가에게 응원을 보내주는 것이라 여긴다면, 글을 쓰거나 그림을 그리면서 내가 가는 방향이 틀리진 않았다는 뜻이지 않을까.\n 세계 여행 경비 마련을 위해 단기로 일거리를 구한 프리랜서, 사직서 한 장을 늘 품고 다니는 마케터, 꿈의 회사로 이직할 작정으로 경력을 쌓는 회사원, 자기가 만든 아이스크림을 먹지 않는 아이스크림 회사 사장, 책보다는 커피를 좋아하는 서점 주인, 틈틈이 쓴 소설로 매해 신춘문예에 응모하는 독서실 아르바이트생 등등…\n 기가막힌 플로우를 타고 흐르는 래핑 같아서, 가장 애정하는 문구이다. 특히 ‘아이스크림 안 먹는 사장’ 에서 머리가 뎅- 울렸다. 우리는 회사 이름 뒤에, 직함 뒤에, 직업 뒤에 숨어서 우리 삶을 과하게 일반화시키고 있는 건 아닐까? 그 안에서 우리는 반짝반짝 다른 사람과 전혀 다른 빛깔을 때깔나게 발산할 수 있는데, 그 뒤에 숨어버려서 남들 하는 만큼만 하고 말아버리는 것일지도.\n에세이의 힘 이 책을 읽으면서, 때때로 내 과거는 다른 사람의 과거와 ‘똑’ 같을 수가 없더라도, 그 안에서 내가 생각한 것들을 이렇게 남들에게 공유하는 것만으로도 쉽게 공감을 이끌어 낼 수 있을 것 같은 용기를 얻었다. 물론 이렇게 잘 할 순 없겠지만, 누구나 처음부터 잘 하는 것은 아니었을 테니까. 책에서 이야기하는 마지막 구절. 의무적으로 꿈을 꾸는, 노력하는 시간을 들여야 언젠간 꿈에 닿을 수 있다고 한다. 이렇게 공돌이 한 명은, 전공과 전혀 다른 기묘한 꿈을 꾸어 본다. 나는 이제부터 토끼지 않을 거니까.\n","date":"2022-08-08T00:48:00Z","image":"https://interp.blog/images/2022-10-16-toki-cover.png","permalink":"https://interp.blog/rabbit-run-away-in-this-case/","title":"그럴 땐 바로 토끼시죠"},{"content":"살인 혐의로 수감된 범죄자가, CIA 가 주도하는 프로그램에 참여한다. 정보가 없기 때문에, 죽어도 기록이 남지 않는 비밀 요원이 된다. 코드네임은 \u0026lsquo;식스\u0026rsquo;. 몇년 뒤, 누군가가 CIA 의 극비 정보를 넘긴다는 첩보를 입수하고, 그를 제거하기 위해 식스가 나선다. 잡고 보니 그 역시 같은 프로그램 소속이었고 식스를 알아본다. 극비 정보가 담긴 칩은 사실 CIA 의 치부라며 식스에게 넘겨주고, 식스는 이 칩을 숨기게 된다. 센터장은 그가 숨기고 있다고 확신하며, 소시오패스 프리랜서 킬러인 \u0026lsquo;로이드\u0026rsquo; 에게 그를 제거하라고 지시한다.\n주연들  마블 시네마틱 유니버스를 주도한 루소 형제의 넷플릭스 영화이다. 그래서 크리스 에반스라는 이름이 있는 것이 자연스러워 보인다. 그런데, 막상 영화를 보고 있으면 \u0026lsquo;그래서 캡틴 아메리카는 어디 있나요?\u0026rsquo; 같은 생각이 든다. 그보다는 \u0026lsquo;나이브스 아웃\u0026rsquo; 의 랜섬이 콧수염 붙이고 포마드를 더 씨게 발라 나왔다고 보는 편이 맞다. 이마저도 틀린 비유일 정도로, 유니크한 소시오패스 연기를 잘 했다고 생각한다. \u0026lsquo;나이브스 아웃\u0026rsquo; 영화 이야기가 나왔으니 또 언급해야 할 사람이 아나 데 아르마스이다. 같은 영화에서 이민자 가정부 역할로 나왔던 순진한 소녀는 어디로 가고, 여기서는 단발에 액션도 불사하는 요원으로 분했다. \u0026lsquo;블레이드 러너 2049\u0026rsquo; 에서도 출연한 걸 보니, 다른 주연들간의 연결고리가 제법 있는 편. 라이언 고슬링이 저렇게 벌크업을 했던 영화가.. 있구나, 블레이드 러너. 그래도 여기서는 육탄 액션을 마음껏 선보인다. 특유의 능글맞음이 영화에도 녹아있지만, 그것이 라이언 레이놀즈의 깨방정보다는 훨씬 진지하다. ~그리고 이런 농담따먹기는 로이드가 더 많이 한다.~  \u0026lsquo;본 시리즈\u0026rsquo; 를 생각하고 왔는데? 일단 여러 도시를 누빈다는 설정 + 정보기관이 버린 먼치킨 주인공 + 싸이코 빌런 설정은 제이슨 본 시리즈의 공식을 따라했다고 생각한다. 맨몸 액션도 다수 섞은 걸 보면 거의 계승한 듯 싶다. 하지만 차이점은 분명한데, 일단 ~카 체이싱 장면이 없잖아!~ 식스가 탈출하거나 진입하는데 개연성이 심히 떨어진다. 그냥 목표에 접근하거나 목적을 이루는 과정은 생략되었다. 이런 사이다를 좋아할 사람들도 있겠지만, 나는 잘 모르겠다.\n그리고 긴장을 가하거나 해소하는 과정에서 왜 저래? 싶은 장면이 한 두개가 아니다. 지나보니 로이드 편에 선 사람은 없었던 게 되고, 프로그램을 주도했던 \u0026lsquo;피츠\u0026rsquo; 의 퇴장은 너무 뻔했다. 일단 다 차치하고, 잔인한 소시오패스라고 하면서, 난 이대로 못 간다며 식스와 1:1 맞짱을 뜬다고? 아니, 이 장면은 \u0026lsquo;강력3반\u0026rsquo; 엔딩 생각나는데\u0026hellip; 맙소사. 저기서도 윤태영이 사이코패스 악역이잖아\n그렇다면 액션은 좋은지? 볼 당시에 피곤해서 그런건지는 모르겠는데, 잠이 솔솔 왔다는 점만 이야기하고 싶다. 딱 넷플릭스 용 킬링 타임 블록버스터 느낌이다. \u0026lsquo;레드 노티스\u0026rsquo; 보다는 스케일이 크고 더욱 짜임새가 좋기는 한데, 재미 면에선 별반 차이는 없는 듯 하다.\n★★★\n","date":"2022-08-06T23:38:00Z","image":"https://interp.blog/images/2022-10-16-grey-man-poster.jpeg","permalink":"https://interp.blog/the-gray-man-2022/","title":"그레이 맨 (The Gray Man, 2022)"},{"content":" \u0026ldquo;다섯 번째로 좋아하는 영화가 뭐예요?\u0026rdquo;\n 이 질문은 장강명 작가의 \u0026lsquo;책 한번 써봅시다\u0026rsquo; 에서, 나의 개성을 알아내는 질문으로 제시된 것 중 하나이다. 여기에 답하려면 가장 좋아하는 영화를 골라내고, 어떤 기준으로 영화의 순위가 갈라지는지 알아야 한다. 이런 질문은 글감을 찾아내기에도 안성 맞춤이라고 한다.\n그래서 무턱대고, 왓챠에 기록한 내 영화 리스트를 죽 꺼내들어서 별점이 가장 높은 영화 중 5편만 꼽아봤다. 참고로 내 왓챠 평균 별점은 3.9점이다. 후해도 너무 후하다 (\u0026hellip;) 물론 철학적으로 사유하기 좋은 영화도 많고, 고전 영화도 심심찮게 많이 봤다. 하지만 어디까지나 개인적인 기준의 BEST5 이니 편한 마음으로 봐주시길.\n❗   스포일러가 있을 수 있습니다!   5. 반지의 제왕 : 두 개의 탑 (2002) 이 시리즈의 첫 번째 영화인 \u0026lsquo;반지 원정대\u0026rsquo; 는 내가 영화관에서 본 두 번째 영화다. (첫 번째는 스티븐 스필버그의 A.I.) 이 계기로 모든 시리즈를 영화관에서 보게 되었는데, 순전히 옛날 추억으로 다섯손가락에 꼽은 것만은 아니다.\n시리즈 두 번째 영화인 \u0026lsquo;두 개의 탑\u0026rsquo; 은 본격적인 오크의 침공이 그려지기 때문에 스케일 면에서 장엄함을 느낄 수 있다. 지금까지도 이런 전투 스케일을 그려내는 판타지 영화가 없다고 할 정도니까. 그리고 마지막 간달프의 증원은 길이 회자될 만 하다.\n하지만 역시 후술할 다른 영화들보다 오래된 영화라 그런지, 추억속에서 건져올릴 만한 것이 없는 영화이기도 하다.\n4. 본 얼티메이텀 (2007) 개인적으로 본 시리즈를 다 좋아하지만, 세 편 모두 넣을 순 없어서 가장 애정하는 한 편만 넣기로 했다. 아, 그 다음에 나온 영화들이요? 그게 뭐였죠? ㅎㅎㅜㅜ\n대사나 명장면은 1편인 \u0026lsquo;본 아이덴티티\u0026rsquo; 가 더 많이 떠오르는데, 아무래도 거의 모든 비밀을 알게된 본이 활약하는 세 번째 시리즈가 전체적으로 더 기억에 남는다. 그리고 마지막 엔딩까지 완벽하게!\n설정이 무엇보다 매력적이다. 기억을 잃었는데, 알고 보니 내가 킹왕짱 센 특급 비밀 요원?! 옛날 성룡의 영화들에서 볼 수 있는 임기응변 식의 액션이나 탈출 씬이 많아, 덜 작위적면서도 손에 땀을 쥐게 만들었다.\n반지의 제왕보다 순위가 높은 점은, 일단 지루하지 않다는 점이다. 반대로, 상위권 영화보다 순위가 낮은 점은, 리플레이성은 확실히 떨어진다는 점이다. (그래도 한 예닐곱번은 본 듯)\n3. 초속 5센티미터 (2007) 이제부터는 얼마나 영화를 많이 봤느냐에 따라 순위가 매겨진다. 개인적으로 볼 때 마다 감상이 조금씩 달라지는 영화를 매우 좋아하는데, 그러자면 먼저 해석할 여지가 많거나 아니면 어느 한 부분이 특출난 영화여야 한다. 재미있는 건, 해석할 여지가 많은 영화들은 TOP5 에 모두 들지 못했다.\n사실 TOP3 를 뽑으라면 왓챠고 뭐고 보지 않고 이 세 편을 자신있게 꺼낼 수 있었다. 그 중에서 가장 짧은 (!) 초속 5센티미터가 3위이다. 이 영화는 그냥 \u0026lsquo;예쁘다\u0026rsquo;.\n신카이 마코토 감독의 단편 애니메이션 \u0026lsquo;별의 목소리\u0026rsquo; 를 투니버스에서 심야에 방영해 준 적이 있었다. 우연히 보게 되었는데, 인체 비율이 좀 아쉽긴 하지만 배경에서 느껴지는 장인정신에 감탄했다. 괜히 \u0026lsquo;빛의 마술사\u0026rsquo; 라고 불리는 게 아니다.\n초속 5센티미터는 어릴적의 풋풋함, 싱그러움, 방황, 사랑을 정말로 예쁜 배경에 담아낸 작품이다. 지금 다시 보라고 하면 오글거릴텐데, 당시의 나는 몇 번이고 돌려봤던 기억이 있다. 물론 스토리 자체에는 호불호가 갈릴 수 있지만, 그렇게 찜찜하게 끝내는 게 이루어질 수 없는 첫사랑을 잘 표현했다고 생각한다.\n2. 라라랜드 (2016) 초속 5센티미터가 철없는 20대 초반에 돌려보기를 했다면, 이번엔 요즘 와이프와 자주 돌려보는 영화 \u0026lsquo;라라랜드\u0026rsquo; 가 2위이다. 이 영화는 다들 알다시피 음악에 공을 들였고, 정말로 다시 봐도 좋은 영화임에 틀림없다. 그런데 우리는 돌려볼 때 마다 마지막 장면을 주로 이야기하곤 한다.\n결국 세스와 미아는 서로의 꿈을 응원하고 헤어지는데, 마지막에서 우연히 재회한 장면을 \u0026lsquo;만약에\u0026hellip;?\u0026rsquo; 로 압축된 미니 뮤지컬로 표현하는게 기가 막히고 코가 막힌다. 아쉽게 헤어진 연인에 미련이 남을 때 늘 하는 생각들이 다들 이런 것 아니겠는가. 서로 아련해진 미아와 세스는 마지막 장면에서 눈빛을 주고 받으며 영화는 끝이 난다.\n1. 타짜 (2006)  \u0026ldquo;타짜를 아냐구요? 내가 본 영화 중 최고였어요\u0026rdquo;\n 와이프와 친구들은 이제 내가 타짜 대사 드립 좀 그만 쳤으면 좋겠다고 한다. 미안하다, 상황만 맞으면 드립을 치고 싶어 입이 근질거린다. 곽철용이 유행을 타기 훨씬 전부터, 거의 모든 대사를 줄줄이 꿰고 있었다. 왜냐고? 대사 하나하나 거를 타선이 없기 때문이다. 나는 타짜가 최동훈 감독의 역작이라고 생각한다. \u0026lsquo;전우치\u0026lsquo;도 좋아하고 \u0026lsquo;암살\u0026rsquo; 도 좋아하지만, 아무래도 타짜 뿐이다.\n소재가 매력적이기도 하지만, 그것보다는 인물들의 개성에 딱 맞는 대사와 그 합을 아주 오밀조밀 잘 짜뒀기 때문이다. 그래서 이 영화는 지루하지가 않다. 다음 장면이 아 그거였지 싶어도 기대가 된다. 그 환상의 티키타카를 볼 생각을 하면 말이다.\n마치며 이렇게 모아보니 나는 자주 본 순서대로 순위를 매겼다. 좋아한 만큼 자주 봤을테니 당연한 거 아닌가? 물론 자주 보지 않았음에도 기억에 남는 영화는 많다. 이런 영화를 또 모아서 \u0026lsquo;아차상!\u0026rsquo; 같은 포스팅을 하면 좋겠지만, 언제 시간이 될런지. 어쨌거나, 이렇게 나만의 순위를 매겨보고 그 이유를 탐구해보는 시간도 나쁘지 않은 것 같다. 다른 분들도 한번 해 보길 바라며, 다음에는 다른 분야에서 나만의 순위표를 만들어 볼 생각에 벌써 신났다. 감사해요, 장강명 작가님!\n","date":"2022-08-04T18:09:24Z","image":"https://interp.blog/my-life-best-5-movies/feature_hu4a51e4871b403f30b8570d7c92308e00_435442_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/my-life-best-5-movies/","title":"내 인생 영화 BEST 5"},{"content":"😉   이 포스팅의 대표 이미지는 Unsplash 에서 찾은 Glenn Carstens-Peters 의 사진이다. Thanks, Glenn!   Unsplash   https://unsplash.com/\nUnsplash 는 노트 서비스인 Notion 사용자들에게 친숙할 수 있는데, 페이지의 커버 이미지를 선택할 때 Unsplash 에서 손쉽게 검색하고 등록할 수 있는 기능을 제공하기 때문이다. 블로깅 도구인 Ghost 에서는 본문에 이미지를 추가할 때 동일한 기능을 제공하고 있어, 다른 두 곳보다 상대적으로 유명하다 할 수 있겠다.\n저작권  ✅ 자유롭게 다운로드하고 사용할 수 있음. ✅ 상업적 사용이 가능함. ✅ 사용에 어떠한 조건도 없지만, 출처 언급을 해 주면 더욱 좋을 것. ❌ 수정 없이 재판매 금지 ❌ 다른 스톡/배경화면 모음 서비스에 게재 금지  자세한 내용은 https://unsplash.com/license 를 참고한다.\n    (adsbygoogle = window.adsbygoogle || []).push({});   Pexels   https://www.pexels.com/\n최근에 찾은 또 다른 스톡 서비스인 Pexels 는 한국어 인터페이스를 지원하면서, Unsplash 에서 보던 사진 느낌을 볼 수 있다. 게다가 비디오까지 내려받을 수 있다.\n저작권  ✅ 자유롭게 다운로드하고 사용할 수 있음. ✅ 상업적 사용이 가능함. ✅ 수정 가능함. ✅ 사용에 어떠한 조건도 없지만, 출처 언급을 해 주면 더욱 좋을 것. ❌ 식별할 수 있는 인물이 부정적 이미지로 소비되는 것 금지 ❌ 식별할 수 있는 인물/브랜드를 통해 홍보 금지 ❌ 수정 없이 재판매 금지 ❌ 다른 스톡/배경화면 모음 서비스에 게재 금지  자세한 내용은 https://www.pexels.com/ko-kr/license 를 참고한다.\nPixabay   https://pixabay.com/\nPexels 에서 사진과 비디오를 제공하는 것에 더해, 여기 Pixabay 에서는 벡터, 일러스트레이터, 음악과 사운드 이펙트까지 내려받을 수 있다. 물론 한국어 인터페이스를 지원한다.\n저작권 별도로 저작권 설명 페이지는 없고 FAQ 를 통해 간접 추측이 가능하다.\n ✅ 자유롭게 다운로드하고 사용할 수 있음. ✅ 수정을 거친 뒤, 상업적 사용이 가능함. (FAQ 문서를 참고) ✅ 사용에 어떠한 조건도 없지만, 출처 언급을 해 주면 더욱 좋을 것. ❌ 식별할 수 있는 인물이 부정적 이미지로 소비되는 것 금지 ❌ 식별할 수 있는 인물/브랜드를 통해 홍보 금지 ❌ 수정 없이 상업적 사용/재판매 금지 ❌ 수정을 하더라도 상표 등록을 할 수 없음. ❌ 다른 스톡/배경화면 모음 서비스에 게재 금지  자세한 내용은 https://pixabay.com/ko/service/faq/ 를 참고한다.\n마치며 미디어를 프린팅해서 판매한다거나, 특정 제품을 위한 로고나 브랜딩을 위한 이미지 작업을 위해 사용하는 것이 아니라면야 어떤 식으로 사용해도 상관없을 것 같다. 재판매 역시도 원본 그대로는 불가능하지만, 나름의 창의력을 더한 수정본의 경우엔 판매가 가능하다는 것이 세 사이트의 공통적인 지침이다.\n세 사이트 모두 다량의 사진을 보유하고 있고, 실력있는 작가들의 멋진 작품 투고가 현재까지 누적되고 있으니 유용하다고 생각한다. 블로그를 꾸미거나 프레젠테이션을 꾸밀 때, 단순히 디자인이나 사진 영감을 얻기 위해 둘러보면 좋을 것 같다. 개인적으로는 이미지 자체를 내려받을 때는 Unsplash 를 자주 사용했는데, 다른 두 서비스에는 비디오를 제공하니 같이 써봐야겠다.\n","date":"2022-07-28T01:39:19Z","image":"https://interp.blog/images/2022-07-28-glenn-carstens-peters-loatw2afdyu-unsplash.jpg","permalink":"https://interp.blog/license-free-image-3-sites/","title":"저작권 걱정 없는 무료 이미지 사이트 3개"},{"content":"줄거리 셰프라는 직업에 자부심이 강한 주인공 칼은, 파워 블로거 평론가를 맞이하기 위해 자신만의 코스 요리를 준비하지만, 레스토랑에서 늘 만들던 대로 하라는 사장의 만류에 막히고 만다. 평론가에게 혹평을 받게 되고, 트위터를 통해 많은 사람들의 입방아에 오르내리고 만다.\n사업가 아내와 이혼한 뒤, 10살 아들을 주기적으로 돌보던 어느 날, 트위터가 뭔지 몰랐던 칼은 아들을 통해 사용하는 방법을 배우고 계정을 만들게 된다. 그리고 평론가에게 욕설과 함께 다시 와서 먹어보라는 \u0026lsquo;답글\u0026rsquo; 을 남긴다. 이 스레드는 공개되어 세간의 관심을 모으게 되고, 평론가 역시 재도전을 흥미진진하게 받아들이며 레스토랑으로 향한다.\n하지만 다시 한 번, 칼은 만들던 메뉴를 대접하라는 사장의 압박을 받았고, 이 레스토랑은 내 것이지 네 것이 아니란 말과 함께 만들던지 나가던지 선택을 하라고 한다. 결국 칼은 다 집어던지고 나갔다가, \u0026ldquo;이 셰프는 쫄아서 안 나왔네\u0026rdquo; 라는 평론가의 트윗을 보고 다시 찾아가 면전에 욕설을 토해낸다.\n그리고 깔끔하게 망했다. 칼을 불러주는 사람은 없었다. 그 때 마침, 전 아내가 처갓집이 있는 곳에 아들 보모 역할로 같이 가자며, 가면 좋은 수가 생기지 않겠냐고 제안했다. 사실 아내는 그의 독단적인 기질을 살리려면 푸드트럭을 하는게 차라리 낫겠다고 제안한 적이 있었고, 실제로 아내는 전 남편에게 미리 부탁해, 푸드트럭을 하나 받아가게끔 말을 다 맞춰 둔 상태.\n물론 그렇게 받은 트럭은 고물이었지만, 레스토랑에서 자기만 보고 그만두고 따라나온 마틴과 함께 트럭을 치우고 새 출발을 한다. 그리고 아들 역시 큰 도움을 준다. 요리도 하고, 트위터로 홍보도 하면서. 그렇게 집으로 가는 동안 푸드트럭은 가는 곳 마다 성행했고, 세 사람 특히 칼과 아들의 우정도 돈독해진다.\n대사  “그렇다 치고 음식이나 문화 말이야, 베녜 같은거”\n”여기서도 팔잖아”\n”완전히 달라. 여기서도 맛있는 건, 거기서 먹었던 기억이 떠오르는 거야”\n 주인공인 칼은 유독 음식의 본고장에서 먹는 것이 진짜 맛이라고 말하는데, 너무 마음에 드는 표현이다. 정말 음식 자체만 놓고 보면 한국에서 똑같이 만들면 맛은 똑같이 나겠지만 지역의 공기, 환경에 크게 좌우한다고 생각한다. 극단적으로 그 때의 기분, 날씨같은 우연의 요소까지 머리가 기억하고, 단지 그 음식이 그 때의 기억을 당기는 방아쇠가 되는 것이라고 믿기 때문이다.\n결국 둘은 뉴올리언스에 가서 베녜를 먹으러 갔다.\n여담  존 파브로가 아이언맨 1,2 감독이었다니, 영화보기 직전까지 몰랐다. 그래서 로다주와 스칼렛 요한슨이 나온 걸지도 모르겠다. (다른 배우도 쟁쟁하다, 사장님이 더스틴 호프만이라고요?) 전처로 나온 소피아 베르가라가 정말 예쁘다. 만날 때 마다 입고 있는 옷이 바뀌는데, 패션쇼인가? 스칼렛 요한슨도 물론 예쁘다. 파스타 기다리는데, 왜 어께 다 흘러내리게 누워 계세요? 로다주가 맡은 캐릭터는 결벽증에 의심병 환자에 전남편끼리 만나서 한다는 소리부터 저질이다. 물론 캐릭터가 그렇다는 것이다. 결국 영화는 해피엔딩으로 끝난다. 평론가 아조씨는 ‘내가 알던 그 칼이 돌아왔다’ 며 사업제안을 하고, 셰프 전권을 보장해주는 조건으로 레스토랑으로 칼을 스카웃 해간다.  ","date":"2022-07-17T17:41:57Z","image":"https://interp.blog/images/2022-07-18-untitled.png","permalink":"https://interp.blog/chef-2014/","title":"아메리칸 셰프"},{"content":"Go 여행 세 번째 시간이다. 지난 시간에는 flow control statement 에 대해서 알아봤다. 이번에는 Go 언어의 다양한 자료형에 대해 정리해 봤다.\nA tour of Go  English: https://go.dev/tour/ 한국어판: https://go-tour-ko.appspot.com/  Pointer  C/C++ 처럼, golang 에도 포인터가 있다. NULL 표현은 nil 이다. 그 외엔.. 뭐 C pointer 쓰는 거랑 별로 다를게 없다.  func main() { i, j := 42, 2701 p := \u0026amp;i // point to i  fmt.Println(*p) // read i through the pointer = 42  *p = 21 // set i through the pointer  fmt.Println(i) // see the new value of i = 21  p = \u0026amp;j // point to j  *p = *p / 37 // divide j through the pointer  fmt.Println(j) // see the new value of j = 73  } Struct C 의 struct 와 동일한, field 들의 모음이다.\nC 였다면 typedef type struct Vertex { ... } Vertex; 이라고 typedef 를 곁들여야 하지만, 여기서는 type 만 써도 된다. 사실상 type 하나가 위의 typedef ... 전체를 모두 커버한다.\n var [변수명] [타입] 처럼 type [타입명] struct 인 것을 잘 기억해 두자. struct 형 변수를 초기화할 때는 { } 로 써야 한다. 각 field 는 . 을 사용해서 참조할 수 있다.  type Vertex struct { X int Y int } func main() { fmt.Println(Vertex{1, 2}) // {1, 2} 라고 표시된다.  } Struct Pointer 원래 C 같았으면 struct pointer 변수에서 특정 필드를 참조하려면 (*p).X 이런 식으로, 포인터의 struct 값을 dereference 한 다음에 참조하거나, p-\u0026gt;X 같은 식으로 \u0026lsquo;포인터 변수\u0026rsquo; 라는 걸 나타내서 참조하는데.. 여기서는 둘 다 귀찮으니까 p 가 struct pointer 라도 p.X 로 참조가 가능하게 했다.\nfunc main() { v := Vertex{1, 2} p := \u0026amp;v p.X = 1e9 // 이렇게만 참조하고 값까지 할당하는데, 아무런 문제가 없다. fmt.Println(v) // {1000000000 2} }  Struct Literals Struct 형 변수 초기화할 때 취할 수 있는 방법을 소개한다.\n  보통 unnamed list 를 할 것이다. Vertex{1,2} 처럼\u0026hellip;\n  named list 도 가능한데, [field name]: 으로 쓴다. function 의 default parameter 와는 달리, 여기선 순서는 상관없다.\n  값을 넣지 않으면, 각 필드의 기본값이 들어간다. (여기서는 int 니까 0)\nvar ( v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 p = \u0026amp;Vertex{1, 2} // has type *Vertex )\nfunc main() { fmt.Println(v1, v2, v3, p) // {12} {1 0} {0 0} \u0026amp;{1 2} }\n  Array Slice 와는 달리, 사이즈가 고정된다.\n C 처럼 length 가 뒤에 오지 않고, 앞에 온다. 출력하면 struct 와는 달리 꺽쇠 [ ] 로 출력된다. 하지만 literal 선언은 (slice 와 마찬가지로) { } 안에서 원소를 나열해야 한다.  var a [10]int Slice Array 에서 length number 만 지우면, slice 가 된다.\nvar a []int  array 또는 slice 에서 index range 를 지정할 수 있는데, C array index 를 생각해도 헷갈릴 수 있는 부분이다.  수학적으로 정확한 range 표현은 [n:m) 이다. 마지막 인덱스에 해당하는 원소는 포함이 안 된다.    func main() { primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] // 3, 5, 7, 11 인가?  fmt.Println(s) // [3 5 7] 만 출력된다.  }  Slice 는 단독으로 쓰이기도 하지만, 보통은 array 의 특정 구간을 나타내기 위해서도 쓰인다. 주의할 점은, Slice 가 바뀌면 연결된 array 도 같이 바뀐다는 것이다 (\u0026hellip;)  func main() { names := [4]string{ // 어.. 비틀즈 성님덜?  \u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, } fmt.Println(names) a := names[0:2] // [John Paul]  b := names[1:3] // [Paul George]  fmt.Println(a, b) b[0] = \u0026#34;XXX\u0026#34; // 아니 왜 폴 메카트니 성님을 지워여;;  fmt.Println(a, b) // 폴의 이름이 다 바뀌어 있음.  fmt.Println(names) // 그리고 원래 array 에도 영향이..  }  [n:m] 으로 구간을 나눌 때 양쪽 end 를 생략할 수도 있고, 둘 다 생략할 수도 있다.  왼쪽 생략 = 0 오른쪽 생략 = 끝까지 양쪽 생략 = 그냥 그 array/slice 전체 (\u0026hellip;)   slice 안에 당연히 struct 를 쓸 수 있다. 그래서 이런 괴상망측한 하지만 자주 보게 될 선언도 있다.  // 이런게 가능합니다...  //  // 이렇게 typed value 를 바로 선언하는 걸 literal 이라고 하는데,  // slice 건 struct 건 간에 literal 은 [] 가 아니라 {} 로 해야 한다.  s := []struct { i int b bool }{ {2, true}, {3, false}, {5, true} }  slice 는 length len() 과 와 capacity cap() 을 지원한다.  len() : 실제 원소들의 개수 cap() : 하위 array 의 개수 (array 는 fixed-width 라고 했다)  이게 언제 필요하냐면, slicing 할 수 있는 길이를 가늠할 때 (만약 cap 이 6인데 [:7] 이렇게 쓰면 에러가 나버린다. 중요한 건, underlying array 에서, slice 의 first element 가 가리키는 위치 부터 끝까지의 길이이다 (끝 인덱스는 상관없는게 또 헷갈린다..)      func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length.  s = s[:0] // 끝이 지정되어 있지 않으니 cap 은 6임. length 는 당연히 0이고.  printSlice(s) // Extend its length.  s = s[:5] // 0~4 까지니까 length 는 5이고, 역시 끝이 지정되어 있지 않아서 cap 은 6임.  printSlice(s) // Drop its first two values.  s = s[2:] // 마지막 slice 를 또 slicing 하지만, \u0026#39;처음 array\u0026#39; 에서 2번째 element 부터의 array 길이가 cap 이므로  // 5,7,11,13 -\u0026gt; 4임. ㄱ-  // 그런데 또 length 는 \u0026#39;마지막 slice\u0026#39; 에서의 2번째부터니까 5,7,11 만 있어서 3임 (...)  printSlice(s) }  slice 에 아무 값도 없으면, 그 값은 nil 과 같다.  func main() { var s []int fmt.Println(s, len(s), cap(s)) if s == nil { fmt.Println(\u0026#34;nil!\u0026#34;) } }  make() 로 slice 를 만들 수 있다. 직접 값을 입력하는게 아니라, 변수를 통해 slice 를 선언할 수 있다는 차이가 있다.  length, capacity 를 별도로 입력할 수 있는 정도? length 가 0이면 비어 있는데, 그걸 잘라내면 0이 채워진다?? ㄱ-    func main() { b := make([]int, 0, 5) printSlice(\u0026#34;b\u0026#34;, b) c := b[:2] printSlice(\u0026#34;c\u0026#34;, c) d := c[2:5] printSlice(\u0026#34;d\u0026#34;, d) } /* b len=0 cap=5 [] c len=2 cap=5 [0 0] d len=3 cap=3 [0 0 0] */  slice 안에 slice 를 담을 수 있음. 이러면 2차원 배열이 됨. 이 때는 [][]string 처럼 slice type 앞에 slice 를 쓰겠다고 선언하면 됨. (2차원 배열이 된다)  그리고 각 원소도 slice literal 임을 명시해야 한다.   아래는 2차원 배열 예제 프로그램인데, 주목할 건 for 문이 1개만 쓰였단 거다.  대신 strings.Join() 을 써서 내부 원소 (board[i]) 를 String 으로 만들어 출력했다는 점..    func main() { // Create a tic-tac-toe board.  board := [][]string{ []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, } // The players take turns.  board[0][0] = \u0026#34;X\u0026#34; board[2][2] = \u0026#34;O\u0026#34; board[1][2] = \u0026#34;X\u0026#34; board[1][0] = \u0026#34;O\u0026#34; board[0][2] = \u0026#34;X\u0026#34; for i := 0; i \u0026lt; len(board); i++ { fmt.Printf(\u0026#34;%s\\\\n\u0026#34;, strings.Join(board[i], \u0026#34; \u0026#34;)) } }  익히 알겠지만, slice 는 append() 가 가능하다. 첫 번째 파라메터는 소스 slice, 나머지는 쭉 원소(들) 을/를 입력하면 된다.  그럼 cap 은 어떻게 되나요? 직접 실험해보자 (\u0026hellip;)    func main() { var s []int printSlice(s) // append works on nil slices.  s = append(s, 0) printSlice(s) // The slice grows as needed.  s = append(s, 1) printSlice(s) // We can add more than one element at a time.  s = append(s, 2, 3, 4) // 여기서 재밌는 건 cap 이 5가 아니라 6이 된다는 거다.  printSlice(s) } /* len=0 cap=0 [] len=1 cap=1 [0] len=2 cap=2 [0 1] len=5 cap=6 [0 1 2 3 4] */ 마지막 줄이 왜 cap 이 6이 되는지는, go blog 에 있는 Slices-intro 를 살펴보자. 특히 ‘Growing slices (the copy and append functions)’ 처음에 make 하는 부분을 보면 된다.\n Slice 에서의 for 는 for each 같은 구문을 사용할 수 있다.  range [slice] 로 initialize 를 하게 되는데, 리턴되는 게 2개다. 인덱스와 실제 값. ※ 인덱스를 안 쓰게 되면 (어차피 compile 에서 에러를 내겠지만) _ 처리해야 한다. value 를 안 쓰려면, value 자리를 _ 로 감싸도 되지만, 단순히 인덱스’만’ 받아도 된다.  인덱스만 받아서 슬라이스를 인덱스+1 로 참조할 용도로 쓰는.. 뭐 그런?      for idx, value := range slice_var { .. } // 인덱스만 쓰고 싶으면  for idx := range slice_var { .. } ","date":"2022-07-03T17:06:37Z","permalink":"https://interp.blog/tour-of-go-pointer-struct-array-slice/","title":"A tour of Go: Pointer, Struct, Array, Slice"},{"content":"GeekNews 를 보다보니 Atlassian JIRA 와 Bitbucket 서비스가 너무 구려서 못 써먹겠다는 코멘트를 모아 둔 사이트를 발견했다. (사이트 주소도 비범하게 https://ifuckinghatejira.com/ 이다..!)\n 개인적으로 Confluence 사용에 익숙해져서 큰 불만은 없지만, Issue Tracker 로는 Github/Gitlab 을 쓰는게 백번 낫다는 입장이기는 하다 ㅎㅎ\n 아무튼, 이 사이트 페이지에 나와있는 강조 표현이 애니메이션으로 차례차례 이뤄지고 있는 게 눈에 띄었다. 그것도 반듯한 모양이 아니라, 마치 사람이 수작업으로 글을 읽어내려가면서 표시하는 것 처럼 친숙해 보였다. 당장 F12 키를 눌러서 어떤 스크립트가 쓰여졌는지 확인해 봤다.\n공식 사이트는 https://roughnotation.com/ 이고, 다양한 효과를 \u0026lsquo;ANNOTATE\u0026rsquo; 버튼을 눌러 라이브로 볼 수 있다. 밑줄, 네모, 동그라미, 하이라이트, 취소선, X선 등의 효과가 가능하며, 애니메이션을 수행하지 않도록 지정할 수도 있다고 한다.\n그리고 여기서도 동일한 효과를 적용해 보았다!\nimport { annotate } from 'https://unpkg.com/rough-notation?module'; const n2 = document.querySelector('span.rn-circle'); const n4 = document.querySelector('span.rn-underline'); const a2 = annotate(n2, { type: 'circle', color: 'red', padding: 10 }); const a4 = annotate(n4, { type: 'highlight', color: '#ff0066', iterations: 1, multiline: true }); a2.show(); a4.show();","date":"2022-06-24T03:01:26Z","image":"https://interp.blog/images/2022-06-24-68747470733a2f2f726f7567686e6f746174696f6e2e636f6d2f696d616765732f736f6369616c2e706e67.png","permalink":"https://interp.blog/rough-highlight-js/","title":"Rough Notation"},{"content":"태그? Go 언어의 struct 타입에는 각 필드마다 태그를 붙일 수 있다. (struct tag 라고도 불린다) 이렇게 아무렇게나 태그를 붙여둘 수 있다. 물론 다른 함수나 패키지에서 이런 태그를 파싱해서 다룰 수 있어야 하겠지만.\ntype Employee struct { Name string `mandatory` ID uint64 `mandatory` Phone string `optional` } encoding/json 은 json 으로 시작하는 태그를 지원하는데, 아래와 같이 흔히들 볼 수 있는 것들이다.\ntype Employee struct { Name string `json:\u0026#34;name\u0026#34;` ID uint64 `json:\u0026#34;id\u0026#34;` Phone string `json:\u0026#34;phone_number\u0026#34;` } 이 태그를 가지고 있으면, json.Marshal() 을 할 때 구조체 필드 값을 자동으로 JSON 문서로 변환해준다. 또는 json.Unmarshal() 을 통해, 입력된 JSON 문서 바이트 배열을 해당 구조체의 각 필드에 맞춰 알아서 변환해 준다.\nomitempty 옵션 오늘 알아볼 것은, 이런 태그 뒤에 붙는 옵션들 중에서 omitempty 에 대한 내용이다. 이 옵션은 말 그대로 \u0026lsquo;비어있는 필드 값은 생략하겠다\u0026rsquo; 라는 뜻이다.\n결론만 말하면, 이 옵션은 Marshalling 할 때만 효과가 있다. Go Playground Link 에 아래 예제 코드를 넣어뒀으니, 직접 실행해보고 확인해보는 것을 추천한다.\n값이 비어있다? Go 언어의 자료형 기본값이 들어가 있으면 값이 비어 있다고 간주한다. 이 부분은 이전 포스팅인 Go Tour 문서에 더욱 자세한 내용이 들어있다.\n 실수형 = 0 문자형 = \u0026quot;\u0026quot; boolean 형 = false 포인터형 = nil  Unmarshalling (JSON -\u0026gt; struct) 안 해도 되는데, 일단 의심을 거두기 위해 Unmarshalling 부터 테스트 해보자. 위의 Employee struct type 에다가, 다음 JSON String 을 Unmarshalling 해보려고 한다.\n{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34; } func main() { var e Employee if err := json.Unmarshal([]byte(jsonString), \u0026amp;e); err != nil { panic(err) } fmt.Printf(\u0026#34;[%s]\\n\u0026#34;, e.Phone) } 그 결과는, 뻔하긴 하지만 대괄호만 나올 것이다. ([]) 그럼 여기서 e.Phone 에 값이 있었다면 어떻게 될까? 이 \u0026ldquo;010-\u0026rdquo; 값은 Unmarshalling 을 해도 그대로 남는다.\nvar e Employee e.Phone = \u0026#34;010-\u0026#34; ... 그렇다면, 이번에는 omitempty 를 Employee.Phone 에 붙이고 위의 두 실험을 해보자. 결과는 같은가? 그렇다. 값이 없으면 없는대로, 있으면 있는대로 출력된다.\ntype Employee struct { Name string `json:\u0026#34;name\u0026#34;` ID uint64 `json:\u0026#34;id\u0026#34;` Phone string `json:\u0026#34;phone_number,omitempty\u0026#34;` } Marshalling (struct -\u0026gt; JSON) 이번에는 저장된 값을 JSON 으로 나눠보자. 우선, omitempty 옵션을 다시 빼고, e.Phone 에는 아무런 값을 넣어보지 않았다.\nfunc main() { var e Employee e.Name = \u0026#34;John Doe\u0026#34; e.ID = 1 if jsonReturned, err := json.Marshal(e); err != nil { panic(err) } else { fmt.Println(string(jsonReturned)) } } {\u0026quot;name\u0026quot;:\u0026quot;John Doe\u0026quot;,\u0026quot;id\u0026quot;:1,\u0026quot;phone_number\u0026quot;:\u0026quot;\u0026quot;}  phone_number 라는 필드가 생겼다. struct 필드 값이 비어 있어도 JSON 에는 필드가 보인다는 것이다.\n이걸 방지하기 위해 omitempty 가 필요하다. 해당 옵션을 다시 Employee.Phone 에 넣고 동일한 코드를 돌려보면 다음과 같이 출력된다.\n{\u0026quot;name\u0026quot;:\u0026quot;John Doe\u0026quot;,\u0026quot;id\u0026quot;:1}  사소한 문제? 아까 Go 언어 기본값이 들어있는 필드는 JSON encoding package 에서 비어있는 필드로 간주한다는 말을 했었다. 그런데, 이 값들이 유의미한 값이라면 어떻게 해야 할까? 이 때는 omitempty 옵션 사용을 자제해야 한다.\n예를 들면, 통장 내역을 나타내는 struct type 에서, 잔고를 나타내는 balance 필드가 있다고 가정하자. 만약, 이 필드가 정확히 0을 가진다면 이 0이란 숫자는 유효한 숫자다. 그런데 이 필드에 대고 omitempty 를 붙이게 되면, 사용자가 반환받을 JSON 문서에 balance 자체가 없게 되고 큰 혼란 (?) 이 올 수 있다. 잔고라는 필드는 프로그램에서 필수적으로 있을 것이라 가정하기 때문에 일종의 AssertionError 에 빠질 수 있다는 뜻이다.\nMarshalling 할 때 JSON 문서의 다이어트 목적으로 이 옵션을 종종 쓸 텐데, 항상 주의해서 써야 한다는 것으로 끝맺는다.\n","date":"2022-06-21T16:19:07Z","permalink":"https://interp.blog/golang-struct-tag/","title":"Golang struct tag: omitempty"},{"content":"다른 사람을 지적하기 위한 것이 아니라 그저 내가 답답해서 페북에도 두번이나 올렸던 건데, 아인슈타인이 이미 한 말이었다. 역시 범인 (凡人)인 내가 생각한 것들은, 누군가가 이미 생각한 것이리라\u0026hellip;\n 쉽게 설명할 수 없으면, 아는 것이 아니다.\n(혹은, ‘6살 꼬마에게 설명할 수 없으면 아는 것이 아니다’)\n 변명하느니, 모른다고 하자 \u0026lsquo;이건 뭐죠?\u0026rsquo; 라고 물어봤을 때 논리정연하게 설명할 수 없는 경우가 생긴다. 그러면 으레 이런 변명이 나오곤 한다.\n 아, 이거 전에는 알고 있었는데 말이죠\u0026hellip; 분명히 공부했거든요 (해 봤거든요). 그런데, 왜 기억이 안 날까요?! 이런 저런 그런거 같은데 말이죠\u0026hellip;  이렇게 얼버무리느니, 쿨하게 ‘모릅니다’ 라고 대답하는 게 더 낫다. 저런 변명이 오히려 신뢰를 더 깎는다고 생각한다. 모르면 아는 사람이 알려주기라도 할 텐데, \u0026lsquo;알았는데 까먹었어요\u0026rsquo; 라고 하면 마치 내가 잘못해서 그걸 잃어버린 것 같이 들려서다.\n그럼 다 외워야 하나요? 그렇다면 어떤 개념의 정의나 역사를 항상 기억하고 외우고 있어야 할까? 외운다기 보다는 이해하고 있어야 할 것이다.\n중요한 건 어떻게 그 목표에 접근하냐는 것일텐데, 오랫동안 기억하려면 무작정 외워서는 안 될 것이다. 그 속에 담긴 원리는 무엇인지, 왜 이런 개념이 필요했는지를 이해하지 않고 외우기만 한다면, 금세 기억 저편으로 사라질 것이다.\n그리고 어디까지나 쉽게 설명하는 것이다. 정의를 다 외우고 다니는 것은, 걸어다니는 사전이 되라는 이야기나 다를 바 없다. 상대방이 이해할 수 있는 표현으로 바꿔서 이야기할 수 있어야 \u0026lsquo;쉽게 설명하는 것\u0026rsquo; 이 된다. 그러자면 그 원리를 이해하고, 딸려 나오는 개념들에 대해서도 스스로 이해하고 다시 정의해보는 습관이 필요하다. \u0026lsquo;아웃풋\u0026rsquo; 이 필요한 것이다.\n","date":"2022-06-20T05:30:47Z","image":"https://interp.blog/uploads/2018/07/einstein.jpg","permalink":"https://interp.blog/if-you-cannot-explain/","title":"설명할 수 없으면, 아는 것이 아니다"},{"content":"지난 시간에 이어서, 여기서는 Flow Control Statement 에 대해 정리해 보았다.\nA tour of Go  English: https://go.dev/tour/ 한국어판: https://go-tour-ko.appspot.com/  If, else 조건문은 다른 프로그래밍 언어와 마찬가지로 if, else 그리고 else if 의 조합으로 구성된다. 조건 절 (condition clause) 에 있는 수식을 검증 (evaluation 이라고도 한다) 한 결과가 참이면 해당 블록이 수행된다.\na := 1 if a == 1 { // ... } if funcTrue() { // ... } 여러 개의 수식들을 넣어도 되고, 마지막 수식이 boolean 으로 검증되거나 반환되어야 한다. 수식 간에는 세미콜론(;)으로 구분한다. 이 부분에서 가장 널리 쓰이는 패턴이 바로 error 객체가 반환되었는지 검증하는 구문이다.\nif err := funcTest(); err != nil { // error handling with `err` object } 참고로 저기 err 는 조건 블록 안에서만 사용할 수 있다. 바깥에서는 참조할 수 없고, 대신 다른 else if 나 else 블록에서는 참조가 가능하다.\nif a := getInt(testStr); a == 0 { // ok } else if a == 1 { // ok } else { // ok } fmt.Print(a) // error 심지어는 else if 에서 선언된 변수가 있는데 if 에서 쓸 수 있을까? 된다! hoisting 해서 쓴다. 이 쯤 생각해보니, if block 전체에 선언된 변수들에 대해 evaluation 을 먼저 하는 것으로 보인다.\nfunc pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } else { fmt.Printf(\u0026#34;%g \u0026gt;= %g\\n\u0026#34;, v, lim) // 여기선 가능 \t} return lim // 여기서 v 를 참조할 수 없다. } performance 를 중요시한다면 필요한 변수는 inner-block 에서 선언해 쓰는게 좋을 거 같긴 한데.. 아직 언어에 대해 잘 모르겠으니 참고만 하자.\n    (adsbygoogle = window.adsbygoogle || []).push({});   For basic for 다른 프로그래밍 늘 그렇듯, init; condition; post 로 이루어져 있다. init 에는 마치 지역 변수 선언과 같은 모양을 한다 (bash 를 떠올리면 된다) 그리고 여타 다른 언어와 달리 (C, Java, \u0026hellip;) 괄호가 없다는 점을 주목하자. 그러나 반드시 브라켓 { } 은 필요하다.\nsum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } Continued for init 과 post 은 optional 이다. 이게 비어 있으면 condition 만 남아 while 과 같은 기능을 한다.\nsum := 0 for ; sum \u0026lt; 10; { // for sum \u0026lt; 10 { // 둘 중 아무거나 써도 똑같다. // 그리고 위 처럼 쓴 뒤 go fmt 를 돌리면 세미콜론이 알아서 빠진다. sum += sum } 리스트나 맵을 순회할 때도 continued for 의 일종이라고 보면 된다. 이 때는 range 를 사용한다.\nvar myMap map[string]string myMap = make(map[string]string) // ... for myKey, myValue := range myMap { // ... } While 다른 말로, golang 은 while 이 없다\u0026hellip; 대신 for 만 적으면 된다.\nfor { // ... } Switch C/C++, Java 의 switch 라고 생각하면 된다. 차이점은,\n C 처럼 단일 값 (e.g. int, character) 이 아니라 string 도 사용이 가능하고 case 에 variable 을 넣어도 된다. 각 case 마다 break 를 다 집어넣지 않아도 된다.  func main() { fmt.Print(\u0026#34;Go runs on \u0026#34;) var darwin_os = \u0026#34;darwin\u0026#34; // 이걸 타겟으로 써도.. 된다고?  switch os := runtime.GOOS; os { case darwin_os: // ㅇㅇ 되네 \tfmt.Println(\u0026#34;OS X.\u0026#34;) case \u0026#34;linux\u0026#34;: fmt.Println(\u0026#34;Linux.\u0026#34;) default: fmt.Printf(\u0026#34;%s.\\n\u0026#34;, os) } } 참고로 case: 만 쓰면 case True: 와 같은 의미가 된다.\n위의 차이점을 생각해보면, 마치 기다란 if-else 를 switch 로 치환할 수 있을 것 처럼 보이지만 사실 두 가지 제약을 고려해서 선택해야 한다.\n 가독성 문제를 고려해야 한다. if 안에서 변수 선언/할당이 가능하지만, case 에서는 변수 선언이 안 된다.  defer 이 키워드로 시작하는 구문은 해당 함수가 끝날 때 까지 실행이 유예된다. 이 키워드는 블록에 종속된 개념이 아니라 함수에 종속된 개념이다. 따라서, 어느 inner block 에서 쓰이건 간에 이 구문을 지난다면, 함수가 끝날 때에야 구문이 수행된다.\ndefer 뒤에 오는 구문은 반드시 함수 호출이어야 한다. 변수 선언이거나 변수 값 할당같은 식은 안 된다. (+= 도 안 됨)\n재미있는 건, defer 줄을 만나는 시점에 argument 값이 결정된다. 이후에 argument 로 들어간 variable 이 바뀌더라도, defer 의 실제 수행 시점에서는 영향이 없는 것을 아래 코드로 확인할 수 있다.\nfunc main() { var abc = \u0026#34;hello\u0026#34; // 아래 세 줄을 브라켓으로 감싸 블록으로 만든다 한 들, 결과는 동일함 (함수 레벨이기 때문) \tabc += \u0026#34; world\u0026#34; defer fmt.Println(abc) // 뒤에 느낌표는 여기서 평가가 안 되지만, 출력은 마지막에 된다. \tabc += \u0026#34; !!\u0026#34; fmt.Println(abc) // 여기서는 전부 출력된다. } /* hello world !! hello world */ defer 를 하나의 함수 안에서 여러 개 선언할 수 있다. 실행 순서는 LIFO, 즉 먼저 들어간 수식이 나중에 실행된다.\nfor i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } // 맞춰보자. 0이 먼저 나올까 9가 먼저 나올까? ","date":"2022-06-20T02:36:25Z","permalink":"https://interp.blog/tour-of-go-flow-control-stmts/","title":"A tour of Go: Flow control statements"},{"content":"미라클 모닝을 제대로 공부해 보진 않았지만, 나의 기상 패턴과 일치하는 부분이 많아 내 입맛대로 먼저 적용해보려고 여기저기 찾아봤다. 시작은 무라카미 하루키의 생활 패턴이었는데, 일단 4-5시에 일어나서 창작 작업을 한다. 반드시 그날 정한 정량의 원고를 작성한다. 그리고 나머지 시간은 대부분 달리거나, 가끔 수영하거나 여가시간을 보낸다고 한다. 그마저도 그에게는 일일 수 있지만, 확실한 루틴을 지키고 일을 하는 것이다.\n무엇을 할 것인가 미라클 모닝 모임을 몇 군데 둘러보면 다들 \u0026lsquo;일어나서 뭘 한다\u0026rsquo; 를 공유하는데 초점이 맞춰져 있다. 일어나는데 초점이 맞춰져 있으면, 일어나는 동기부여가 안 되기 때문에 패턴을 만들기 쉽지 않다. \u0026lsquo;무엇을 할 것인가\u0026rsquo; 에 초점이 맞춰져 있어야 한다.\n알맞은 예인지는 모르겠지만, 나는 학창시절 때 \u0026lsquo;지각이다!\u0026rsquo; 싶으면 일어나는 것과 비슷하지 않을까 생각했다. 자취하고 나서도 결혼을 하고 나서도 쭉 새벽에 잘 일어났는데, 대부분은 하고 있는 게임을 얼른 하고 싶어서 였다. 반대로 할 게임이 없다거나 별로 할 일이 없다면 계속 누워 있었다. 떠오르는 햇살이 일단 내 눈꺼풀을 1mm 라도 열어젖히면, 그 다음은 뇌 안의 할 일 목록이 재빠르게 몸을 일으키게 만들어야 한다.\n성공할 수 있는 일인가 지난 번에 \u0026lsquo;스마트폰을 절대 아침에 하지 마세요\u0026rsquo; 라는 말을 들었다고 한 적이 있다. 아침에 무엇을 하는지도 중요하지만, 그것은 하루키의 아침 루틴처럼 정량적이면서도, 반드시 성공하는 루틴이어야 한다고 생각한다. 이게 개인적으로는 \u0026lsquo;미라클 모닝\u0026rsquo; 의 핵심이라 생각한다. 스마트폰을 하게 되면, 뇌의 할 일 목록을 스마트폰에 저당잡히는 셈이다. 그리고 거기에는 성공이나 실패같은 끝 지점이 없다. 다른 일로 전환하지 못하고 하루 종일 스마트폰을 봐야 한다는 것이다.\n그래서 나에게 맞는 작은 루틴은 무엇일까 나열해봤다. 딱 힘들 수준의 운동을 하는 것도 좋을 것 같다. 글쓰기 연습삼아 지금처럼 글을 매일 1개씩 쓰는 것도 방법이다. 매일 30분씩 피아노 연습을 해도 좋을 것 같다. 읽지 못한 책을 잡고 50페이지씩 읽는다는 목표 또한 좋다. 무엇이든지 정량적이고, 끝이 있다.\n아침의 인수인계 내일의 나에게 아침을 온전히 넘겨주려는 노력도 필요하다. 야식과 술은 숙면을 방해하기 딱 좋은 친구들이다. 자기 전에 내일 할 일 목록을 종이로 하다못해 머릿속에 어렴풋이라도 남겨 두면 멍모닝을 막을 수 있다. 할 일 목록은 닥치는 대로 살아선 안 되고, 항상 내가 가고자 하는 방향에 맞게 설정되어 있는지 반드시 파악해야 한다.\n 미라클 모닝 참가자들은 \u0026lsquo;자기 계발\u0026rsquo; 이 아닌 \u0026lsquo;셀프 케어\u0026rsquo; 라는 목적이 더 강하다고들 한다. 이렇게 하면서 원대한 꿈이나 목표를 이룰 수도 있겠지만, 그보다는 하루를 올바르게 시작하는 것으로 더 행복한 삶을 살기 위한 목적이지 않을까, 그렇게 난 공감했다.\n","date":"2022-06-18T22:48:59Z","image":"https://interp.blog/images/2022-06-18-ishan-seefromthesky-ivctht8rajo-unsplash2.jpg","permalink":"https://interp.blog/miracle-morning/","title":"미라클 모닝"},{"content":"A tour of Go 시리즈를 두 번씩 돌아보고, 나름 배운 것들을 연이어 적어보려 한다. 첫 번째로 패키지, 변수, 함수 정의와 사용에 대한 내용이다. 이 문서는 번역이 아니라서, 개인적으로 중요했던 부분만 있을 수도 있고 투어 예제에서 다루지 않은 부분이 섞여있을 수 있으니 편하게 봐주셨으면 한다. 화면 안 넘기고 스크롤만으로 볼 수 있다는 장점 정도?\nA tour of Go Go 언어의 튜토리얼 페이지라고 보면 된다. 다양한 언어로 번역되어 있으니 영어 원문으로 봐도 좋고 한국어판으로 봐도 좋다.\n English: https://go.dev/tour/ 한국어판: https://go-tour-ko.appspot.com/  Package 모든 *.go 파일의 첫 줄에는, 이 파일이 속한 \u0026lsquo;패키지\u0026rsquo; 이름을 작성한다. main.go 는 이렇게 패키지 이름이 지정될 것이다.\npackage main 다음 줄에는, 이 파일에서 사용할 다른 패키지들을 작성할 수 있다. 이렇게 각각 패키지 이름과 함께 import 를 해도 되지만,\n// separated import \u0026#34;fmt\u0026#34; import \u0026#34;math\u0026#34; 이렇게 뭉쳐서 선언하는게 보통이다.\n// factored (better) import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) Function declaration 다양한 방식으로 함수 시그니처를 선언할 수 있다.\n// 기본적인 형태. return type 까지 적어야 함. func add(x int, y int) int { .. } // input 타입이 다 같으면 이렇게 typing 을 몰아서 할 수도 있음 (가독성은 좀 떨어짐) func add(x, y int) int { .. } // return 도 여러 개 가능함. func swap(x, y string) (string, string) { .. } // return 에 변수명을 입력해도 됨. 이 때는 변수명이 함수 내부에서 사용되고, naked return 으로 리턴함 (\u0026#39;return\u0026#39; 만 씀) // \u0026lt;\u0026lt; 가독성이 심하게 떨어지므로 짧은 함수일 때만 쓰는걸 추천함. func split(sum int) (x, y int) { .. }     (adsbygoogle = window.adsbygoogle || []).push({});   Variable declaration 변수 또한 다양한 방식으로 선언이 가능한데, 크게 두 가지 방법으로 할 수 있다.\n var 키워드를 통한 선언 := 를 사용해 선언+할당 동시에 하기  var c, python, java bool // 여러 변수가 전부 같은 타입이면 이렇게 변수명 리스트와 마지막 타입 한 번만 적어서 정의해도 됨.  // 이건 패키지 레벨, 즉, 다른 함수도 c, python, java 를 모두 접근할 수 있다.  func main() { var i int // 순서는 var [변수명] [타입] 이다. 이건 함수 레벨이다. \tfmt.Println(i, c, python, java) } 변수 선언과 함께 값을 할당하는 initializer 방법도 다양하다.\nvar i, j int = 1, 2 // 지정된 타입에 맞춰 넣는다. 여러 개를 이렇게 동시에 넣어도 된다. (이 경우에 j = \u0026#34;str\u0026#34; 하면 에러 난다) var c, python, java = true, false, \u0026#34;no!\u0026#34; // 타입 지정이 되어 있지 않아도, 값에 따라 개별로 설정된다. 앞부터 bool, bool, string 이 된다.  // 이렇게 factored 방식으로 지정할 수도 있고, 가독성 역시 좋아진다~ var ( ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 // bit-wise operator 조심 ) := 도 알아보자. 단, 이 방법은 전역 변수 (=패키지 레벨 변수) 에서는 사용이 불가능하다. 이 때는 var 로만 선언이 가능하다.\nfunc blahblah() { k := 3 // var k = 3 과 같다. var == : 라는 뜻. \tc, python, java := true, false, \u0026#34;no!\u0026#34; ... } Exported variable/function 첫 문자가 대문자인 함수나 전역 변수 이름은, 패키지 이름.이름 형식으로 다른 패키지에서 참조가 가능하다. 아래와 같이 쓰고 custommath_pi.go 라고 저장했다고 하면, custommath.hiddenPi 로는 참조가 안 되고 custommath.Pi() 는 참조가 가능하다.\npackage custommath var hiddenPi float64 func Pi() float64 { ... } 주목할 부분은,\n 파일 이름이 아니라 패키지 이름으로 참조한다는 것이다. 다른 말로, 같은 패키지 안이기만 하면, 다른 파일에서도 모든 변수/함수 참조가 가능하다는 것이다. (같은 패키지에서 중복된 변수/함수 이름은 허용되지 않는 이유..)  Variable types, default values bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 // 복소수임.. e.g. 3+2i   C/C++ 개발자들에겐 uintptr, rune, complex 타입이 좀 생소할 수 있다. 주석으로 설명해 뒀으니 이해해주면 좋겠다. int, uint, uintptr 은 물론, 32-bit system 에서는 4바이트, 64-bit system 에서는 8바이트이다.  이제 각 타입의 기본값을 알아보자.\n 정수/실수형은 전부 0 (float 역시 0.0 이 아니라 0) boolean 은 false string 은 “” (empty) (formatting 에서 주목할 부분은 %q 로 하면 quota 가 붙는다는 거다 (\u0026hellip;)) 포인터형은 전부 nil  Variable type-casting Go 언어에서 type casting 은 type conversion 이라고 불린다. 그냥 캐스팅 하듯 type 을 앞에 쓰고 괄호로 감싸면 형변환이 된다.\ni := 42 f := float64(i) u := uint(f) s := string(i) 다른 대부분의 언어에서는 암묵적 캐스팅이 가능한데, Go 언어는 이 부분에서 엄격하다. 따라서 이 구문은 안 된다.\nvar i int = 1 var f float64 = i // i 가 int 여서 안 됨. 1.0 으로 들어가지 않음 Constant const 키워드를 쓰면 된다.\nconst Pi = 3.14 func main() { const world = \u0026#34;세계\u0026#34; } 다음의 특징을 가진다.\n  패키지 레벨, 함수 레벨 둘 다 가능하다.\n  var 이나 := 로 선언할 수 없다. 이 말은, 별도의 타입 선언을 하지 않고 상수 값과 함께 선언한다.\n  별도 타입 선언이 안 되므로, 정수형 상수 (numeric constant) 를 넣을 때는 내부적으로 필요한 type 을 (마음대로) 결정한다. 예를 들어,\nconst Big = 1 \u0026lt;\u0026lt; 100 이렇게 선언하면 Big 은 int 형이 아니라 float64 쯤 될 것이다. 이 말은 Big 을 int 처럼 쓰려고 들면 type conversion error 를 만날 수 있다는 것이다.\n  ","date":"2022-06-16T10:26:18+09:00","permalink":"https://interp.blog/tour-of-go-package-function-variable/","title":"A tour of Go: Package, Function, Variable"},{"content":"손맛은 추천 개인적으로, FPS 는 무엇보다 타격감이 좋아야 한다. 적을 모조리 헤쳐가는 부분에서는 둠 리부트 시리즈가 떠오른다면, 리터널은 (나중에 손이 익으면 무쌍난무를 펼치지만) 리듬 게임을 하듯이 요리조리 돌파하는 맛이 탁월하다. 하나는 과부화 시스템이고, 다른 하나는 접근전을 강제한다는 것이다.\n   타이밍에 맞춰 누르다보면 리듬 게임이 따로 없다\n    과부화 시스템은 재장전 시간을 초기화하는 기본적인 기능도 있지만, 무기의 특성이나 아티팩트의 특성에 따라 부가 효과를 가져오기 때문에 이 타이밍을 놓치지 않아야 한다. 근접 전용 검을 초반부에 얻게 되면 일반 몹을 한 방에 제거할 수 있다. 하지만 그러려면 탄막을 뚫어가며 위험을 무릅쓰고 적에게 접근해야 하므로 집중을 요구한다.  반복 플레이는 안 추천 로그라이크 답게, 죽으면 모든 아이템, 상태는 초기화되고 처음 스테이지부터 시작한다. 단, \u0026lsquo;에테르\u0026rsquo; 라 불리는 영구 화폐와 (스테이지 최초 클리어 할 때 마다 주는) 영구 기술들은 남아있다. 리터널은 6개의 스테이지로 나뉘어 있고, 1-2-3, 4-5-6 의 하나의 시퀀스로 이뤄져 있다. 3스테이지까지 다 깨더라도, 4스테이지에는 아이템과 상태가 초기화 된 채로 시작한다.\n문제는, 6개의 스테이지를 다 깨면 와! 잘 했어요! 라고 플래티넘 트로피를 주지 않는다. 6스테이지를 다 깨면 게임에서 \u0026lsquo;진엔딩이 있으니 더 해보세욧!\u0026rsquo; 이라고 안내해 준다. 그러면 (집 이벤트를 다 안 봤다면 다 봐야 하고,) 태양의 메달이라는 파편을 1~6 스테이지에 걸쳐 또 다 모은 뒤 6스테이지 보스를 잡아야 진엔딩을 볼 수 있다. 벌써부터 피곤하다.\n그런데 진엔딩을 보고 나서도 게임은 끝나지 않는다. 1~6 스테이지에서 수집할 수 있는 외계 아카이브/외계 문자/정찰 기록을 모두 모으는 골드 트로피 6개가 존재한다. 문제는 이 아이템들이 나오는 맵 파트가 고정되어 있고, 스테이지가 생성될 때마다 (정확히는 문을 열 때 마다) 랜덤이라서 무조건 복불복이다. 그렇다고 맵 파트가 무한정 생성되는 것도 아니고 각 스테이지마다 파트 개수는 고정이기 때문에, 못 찾으면 리셋하고 처음부터 강제로 다시 해야 한다! (1, 4 스테이지는 아무래도 많이 죽다보니 다른 스테이지보다 자주 들르게 되고, 그래서 좀 더 딸 확률이 높긴 하다.)\n플래티넘 트로피 팁 그냥 소소한 팁을 적어둔다.\n (PSN 유저 한 정) 세이브 데이터 클라우드 동기화를 끈다. 스테이지 1/4 에서 최대한 탐방해서 원하는 장비/상태를 맞추고, 순환 중지를 한 다음 세이브 파일을 클라우드에 올린다. 2-3, 5-6 스테이지 탐방이 실패하면, 이걸 불러서 다시 한다.  내 기준으로 스테이지 1/4 를 꼼꼼히 도는데 약 7-10 분 가량 필요했다. 이 시간이 너무 아까워서 작은 꼼수를 썼다. 중요한 것은 2-3, 5-6 에서 어떤 기록이라도 갱신에 성공했다면, 반드시 그 상태에서 순환 재시작을 눌러 다시 해야 한다. 기쁜 마음에 세이브를 다시 불러오면, 기록 갱신이 날아가버린다.   모든 외계 문자, 정찰 기록이 담긴 이 가이드를 참고해 보자.  특정 정찰 기록이 빠져 있다면, 여기서 검색해서 해당 파트의 맵이 뜨는 지역까지만 탐방한다. 다 열어봤는데 안 나오면, 미련없이 더 진행하지 말고 리셋한다. 여기서 \u0026lsquo;guaranteed spawn\u0026rsquo; 은, 맵 방문 시 반드시 획득 가능하다는 것이다. 반대로 말하면, 같은 맵에 갔더라도 외계 문자가 나오지 않을 가능성도 있다! (이게 가장 힘든 부분\u0026hellip;) 외계 문자는 번호가 적혀있지 않으므로, 어디가 빠졌는지 게임에서 확인할 길이 없다. 그냥 반복 플레이를 해 보고, 스크린샷을 보고, 눈에 익지 않은 곳이 어디인지 추측해서 플레이하는 길 밖에 없다. (제일 더럽다\u0026hellip;)    ","date":"2022-06-12T07:06:18+09:00","image":"https://interp.blog/images/2022-06-12-returnal/featured.jpg","permalink":"https://interp.blog/retrunal/","title":"리터널 (Returnal)"},{"content":"커뮤니티 글에서 최근 꾸준글로 보이는 한 친구가 있다. 자신을 컴퓨터공학과 학생으로 소개하면서, 알고리즘 문제를 풀다보니 너무 어려워서 전공을 바꿀까, 자신은 보잘것 없는 개발자가 될 것이라며 자학을 꾸준히 하고 있었다. 무슨 문제를 못 풀어서 저러는 건지는 모르겠지만, 갑자기 내 대학원 때 생각이 나서, 주저리 적어본다.\n슈퍼 개발자의 존재 개발조직 사이에서, \u0026lsquo;100명의 개발자 중 1-2명의 슈퍼 개발자들이 나머지 개발자들보다 일을 잘 한다\u0026rsquo; 라는 말을 흔히들 한다. 이런 슈퍼 개발자를 모셔 와야 조직의 퍼포먼스가 올라간다는 것이다. 그러면 이 \u0026lsquo;나머지 개발자\u0026rsquo; 들의 운명은 어떻게 되는 것인가? 조직의 입장에서, 슈퍼 개발자를 모셔 왔으면, 나머지 중 하위 10명 정도는 잘라내도 괜찮을가? 개인의 입장에서, 내가 슈퍼 개발자가 아니면, 모가지를 내놓고 회사를 다녀야 할까?\n내 생각엔, 이런 뛰어난 개발자는 축구로 치면 스타 플레이어의 크랙 (crack) 이다. 대치 상태를 뒤집고 돌파할 수 있는 천재적인 능력이나 역량을 지닌 선수를 말한다. 프로그래머는 문제를 해결하는 사람들이므로, 어떤 문제에 부딪혔을 때, 누구보다도 문제를 빠르게 해결하거나 그 방법을 제시할 수 있는 사람들이 슈퍼 개발자라면, 괜찮은 비유인 듯 하다. (어렵지만) 축구에서도 스타 플레이어 혼자 끝까지 달려 수비수를 제끼고 골을 넣을 수 있다. 프로그래머도 혼자 끝까지 코딩해서 문제를 풀 수 있다. 이 부분도 어느 정도 맞다.\n하지만 한 골이 아니라 경기 전체, 한 문제가 아니라 조직 비즈니스 전체에서는 실패할 확률을 줄이면서 성공으로 이끌어야 하는 책임이 있다. 한 두번이면 몰라도, 축구선수가 크래킹을 시도 때도 없이 한다던지 독단적으로 볼키핑을 하거나 요구한다면, 상대방이 수비 전술을 바꿔 꽁꽁 묶어버릴 수도 있고, 다른 선수의 사기를 떨어뜨릴 수 있다. 감독은, 그 선수의 뒤에서 볼을 주고 받아 줄 다른 선수들과 긴밀한 유대를 가지도록 독려해야 하며, 스타 플레이어의 역량과 조직 운용에 균형을 맞춰야 한다.\n혼자 하는 프로그래밍도 마찬가지인데, 뒤에서 따라가며 이해하고 테스트를 하거나 리뷰를 해 줄 다른 개발자가 필요하다. 그렇지 않으면, 문제 해결에 혈안이 된 나머지 다른 버그를 놓치거나 코드 품질의 저하, 조직 문화 저하를 가져올 수 있다. \u0026lsquo;혼자 가면 빨리 가고, 함께 가면 멀리 간다\u0026rsquo; 라는 말이 괜히 있는 게 아니다.\n결국 시스템만 남는다 하지만 현실적으로, 슈퍼 개발자, 스타 플레이어가 물론 경기를, 비즈니스를 성공적으로 이끄는 모습은 그렇게 놀랄만한 일이 아니다. 그들은 비단 한 골이 아니라, 아예 제품을 일신시켜줄 그런 멋진 도약을 해내곤 한다. 인정한다. 하지만 조직 입장에서는 이럴 때 일 수록 경계해야 한다. 매니저는 항상 \u0026ldquo;저 선수/개발자가 떠나면 우린 어떡하지?\u0026rdquo; 라는 고민을 해야 한다.\n조직은 그 자리에 머문다. 스타 플레이어 뿐만 아니라 일반 개발자, 매니저까지 모조리 떠날 수 \u0026lsquo;있다\u0026rsquo;. 남는 건 바로 제품(코드)와 시스템이다. 이것들이 스타 플레이어에 의존한다면, 떠나고 나서도 제대로 작동할 가능성은 제로에 가깝다. 조직 입장에서는, 이 부분이 핵심이다. 그래서 잘 하는 개발자를 모셔오는 것도 좋지만, 이렇게 영입하고서도 조직 시스템을 해치진 않는지 고민해야 한다.\n개발자의 역할 이제 개발자 개인의 관점에서 생각해보자. 사실 \u0026lsquo;나는 슈퍼 개발자가 아니구나\u0026rsquo; 라는 생각을 늘 하고 있었는데, 이런 고민을 이렇게 글로 풀어보고 싶었다.\n앞서 말했듯이 조직은 슈퍼 개발자에 의존하지 않아도 작동할 시스템과 제품 코드를 유지하고자 한다. 내 결론은, 이 시스템을 잘 이해하고 따르기만 해도, 내부 코드를 잘 이해하고 있기만 해도 조직에서의 가치는 올라갈 수 있다. 더 나아가면, 조직을 너무 잘 이해한 나머지, 문제 해결을 할 수 있는 슈퍼 플레이어에게 패스를 잘 할 수 있는, 플레이메이킹을 할 수 있다. 이런 개발자를, 사일로 (silo) 를 연결해 주는 브릿지 (bridge) 역할을 한다고 한다. 조직에서는 정말 보배같은 존재다.\n그런데 이 부분에서도 경쟁력이 필요하다. 시스템을 잘 이해한다는 것은, 시스템 안에서 정보를 누구보다 빨리 찾아낼 줄 알아야 하고 다른 팀과 소통을 빠르게 할 수 있어야 한다는 뜻이다. 내부 코드를 잘 이해하고 있다는 것은, 자기가 담당하거나 담당했던 부분에 대해서는 누구보다 자신있게 대답할 준비가 되어 있어야 한다는 것이다. 그냥 이해하면 그냥 임금노동자일 뿐이다.\n만약 시스템이 정말 안 맞는다, 코드가 정말 어렵다면 방법은 두 가지다. (야근을 강요하는 것으로 들렸다면 미안하지만) 자투리 시간에 공부를 더 해서 경쟁력을 올리거나, 그렇게 해도 안 되겠으면 자기에게 더 잘 맞을 것 같은 조직으로 이직해야 한다.\n개발도 사람이 한다 결론은, 개발도 결국 사람이 하는 것이다. (물론 기본은 해야겠지만) 개발 능력이 슈퍼 개발자에 비해 부족하다고 좌절할 필요는 없다. 나도 그런 벽은 꽤나 많이 경험해 봤고, 좌절도 해 보고 노력도 해 봤지만 큰 소용이 없다. 그보다는, 다른 방면으로 조직에 기여할 수 있는 부분이 있는지 찾아보는 편이 훨씬 빠르다.\n나는 개인적으로 문서화하는 걸 즐겨해서 보고 들은 것, 경험한 것을 사내 위키에 정리해 둔다. 한 가지 원칙은 \u0026lsquo;이 문서는 반드시 남들이 볼 것이다\u0026rsquo; 라는 생각으로 탈고해야 한다. 그렇게 하지 않으면 미래의 나 조차 문서를 이해하지 못하기 때문이다. 이런 습관이 커리어에 많은 도움이 되었다.\n회사에 취직하지 않았다고 하더라도, 똑같은 공식을 오픈소스 프로젝트나 동아리, 하다못해 개인 토이 프로젝트에 적용하면 어떨까. 개발조직 세상에는, 코딩 외에 할 일이 너무나도 많다.\n","date":"2022-06-03T06:36:33+09:00","permalink":"https://interp.blog/you-are-not-a-genius-programmer/","title":"슈퍼 개발자만 쓸모가 있을까"},{"content":" 길벗 출판사에서 나온 비슷한 디자인의 책이 몇 권 있다. IT 교양서로 분류된 책 중에서 어두운 표지색을 내려오는 세로 제목 사이에 아이콘이 끼워져 있는데, \u0026lsquo;소프트웨어 장인\u0026rsquo;, \u0026lsquo;소프트 스킬\u0026rsquo;, \u0026lsquo;커리어 스킬\u0026rsquo; 세 권이 있다. 우연히도 세 권을 다 읽어봤는데, 이 시리즈 (?) 에서 한 권 더 추가된 \u0026lsquo;심플 소프트웨어\u0026rsquo; 를 최근에 도서관에서 빌려보게 되었다.\n앞선 세 권과 비슷하게, 이 책 역시 작가의 블로그 내용을 엮어 낸 것이다. (https://www.codesimplicity.com/)\n하지만 책에서만 소개되는 챕터가 존재하고, 챕터 간에 흐름이 끊기거나 하지 않고 나름 긴밀히 엮여있기 때문에 단순한 번역본으로 보기엔 무리가 있다. 한 챕터의 내용이 길지 않기 때문에, 가볍게 끊어 읽기에도 좋다. (무엇보다 다른 책들에 비해 책이 얇다. 아주 큰 차이점이다!)\n이왕 할 거면, 잘 하려고 노력하자. 책 뒷면에 보면 \u0026lsquo;할 거면 잘 해라!\u0026rsquo; 라고 적혀있다. 나는 처음에 이 뒷면을 보고, 자뭇 도발적이라고 생각했다. 하지만 읽다 보니, \u0026lsquo;못 하면 안 돼!\u0026rsquo; 라는 뜻이 아니었다. 이왕 개발자를 할 거라면 잘 하고 싶은 마음으로 책을 펼쳤으면 하는 저자의 바람이라고 이해해주면 좋겠다.\n단순한 개발을 해야 하는 이유 모든 챕터의 시작은 바로 \u0026lsquo;단순함\u0026rsquo; 에서 출발한다. 단순해지면, 아래 목표들을 이루기가 수월하다는 것이다.\n 테스팅이 쉽다. 버그가 적다. 기능 추가를 해도 코드 품질이 크게 떨어지지 않는다. (다른) 개발자가 이해하기 쉽다. 보안이 향상된다.  먼저, 이해하고 공부하기 저자는 먼저, 개발자는 자신이 뭘 개발하는지 완벽히 이해하려고 노력해야 한다고 한다. 그동안 만나왔던 개발자의 10% ~ 20% 만이, 무엇을 개발하고 있는지 이해하고 있었다고 한다. 만약 무엇을 개발하고 있는지, 내가 보는 코드에 있는 개념이나 기법, 단어 중 어느 하나라도 모르고 있다면, 내가 참고하고 있는 설계에서 모르는 것이 하나라도 있다면, 무조건 그 부분을 이해하고 개발을 계속하라고 조언한다.\n이해가 잘 안되면, 공부를 해야 한다. 더 자세한 설명을 해 주는 매뉴얼이나 참고서를 보거나, 프로그래밍 언어를 다시 배워야 할 수도 있다. 다른 사람에게 물어봐야 할 수도 있다. 이해가 되지 않았는데 일을 하는 것은 일종의 헛일이 될 수 있다고, 저자는 몇 번이고 지적한다. 당장은 문제가 해결될 지 몰라도, 결국 유지보수와 설계 변경으로 인한 비용을 몇 배나 지불하고 나서야 잘못됐다는 것을 깨닫는다고 말이다.\n    (adsbygoogle = window.adsbygoogle || []).push({});   생산성 향상을 조직에 불어넣기 리펙터링이나 생산성 향상을 위한 도구나 기법 도입은, 심플 소프트웨어를 지향하기 위한 수단이므로 항상 염두에 둬야 하는 부분이다. 하지만 현실은 씁슬하게도, 다른 개발자나 상사에 의해 반려되는 아이디어이기도 하다. \u0026ldquo;다 좋은 거 알지, 그런데 제품 출시부터 먼저 해야 하지 않을까?\u0026rdquo;\n맞는 말이다. 그래서 저자가 남긴 조언은 다음과 같다.\n 개발자가 생각하는 진짜 문제를 확인해라. 혼자 생각하거나, 다른 사람이 지적한 생산성 관련 문제를 가지고 가지 마라. 개발자가 짜증난다고 생각한 부분이 어디인지 파악해라. 암달의 법칙을 적용해서, 가장 쉽게 할 수 있으면서 효과가 가장 좋은 문제를 먼저 해결하라. 그러면 개발자의 신뢰를 얻을 수 있고, 보다 큰 리펙터링 업무를 지지해 줄 우군을 만들 수 있다. 이 계획을 막는 사람이 소수 남아있을 수 있다. 하지만 대부분은 업무를 효율적으로 처리하고 싶어하므로, 다수의 의견이 될 수 있다. 그렇다고 소수를 맹목적으로 비난하면 안 된다. 항상 친절하게 대하되, 회유하거나 협상하거나, 아니면 무시해라.  단순한 개발을 위한 것: 리펙터링 리펙터링으로 돌아가면, 기능 추가를 하기 전에 리펙터링을 먼저 해두라고 조언한다. 그래야지만, 기능 추가에 따르는 코드 품질 저하를 막을 수 있다는 것이다.\n전적으로 동의한다. 내 생각을 덧붙이자면, 나는 이 과정이 기능을 추가하기 전에 코드를 이해하는 과정이라고 생각한다. (앞서 말했던 \u0026lsquo;이해하고 공부하기\u0026rsquo; 와 연결된다.) 비유를 섞자면, 일종의 집안일이다. 귀찮지만, 그리고 티는 별로 안나지만, 꼭 해야 하는 일. 하지 않으면 삶이 팍팍해지고, 치우지 않은 것들이 장애물이나 위협이 되지만, 하고 나면 효율적으로 삶을 영위할 수 있는 그런 일 말이다.\n물론 저자는 무분별한 리펙터링을 경계한다. 집에 불이 났는데 정원을 가꾸는 꼴이란다. 리펙터링은 항상 기능 중심에서 이뤄져야 한다. 그리고 리펙터링은 해도 해도 끝이 없기 때문에, 한계를 정해두라고 한다. 어느 정도 해야 다른 사람들이 알아볼 수 있을지를 생각한다면, 그 쯤 했을 때 그만 둘 수 있을 것이다.\n사용자는 문제를 알려주고, 개발자는 문제를 해결한다. 나는 이 책의 초입에 \u0026lsquo;설계 2원칙\u0026rsquo; 이라고 말한 것 보다, 이 1원칙만 고수해야 한다고 생각한다. (참고로 설계 2원칙이란 것은 별게 없고, 개발 비용이 크더라도 유지보수 비용이 훨씬 크게 줄어들면 반드시 해야 한다는 것과, 유지보수 비용과 코드 복잡성은 비례한다는 것이었다.)\n아마 저자가 (간접적이나마) 가장 많이 언급한 개념이 이것이 아닐까 한다. 사용자가 제기한 문제만 효율적으로 풀어도, 훌륭한 개발자이다. 개발자가 문제를 만들어 알아서 해결하려 들면, 그것은 개발자의 오만이고, 코드 복잡성을 비정상적으로 증가시키는 요인이 된다.\n위에서 \u0026lsquo;리펙터링\u0026rsquo; 이야기를 할 때, 개발자가 겪는 진짜 문제를 수집하란 말을 했었다. 이 경우에는 \u0026lsquo;개발자\u0026rsquo; 가 사용자가 된다.\n마지막으로 이 외에도 \u0026lsquo;테스트할 때 고려해야 할 것\u0026rsquo; 이나 \u0026lsquo;오픈 소스 프로젝트를 성공적으로 이끌었던 경험담\u0026rsquo; 등을 같이 공유하고 있으니, 쉽게 읽히는 책이니만큼 다른 개발자 분들에게 추천하고픈 책이다.\n마지막으로 언급하고픈 챕터가 하나 있는데, 내용은 짧지만 메시지는 강력하다. 하지만 개발에 국한된 내용은 아니어서 짧게 소개하고자 한다.\n 성공은 혁신이 아니라 실행에서 온다.\n 이 제목을 보자마자, \u0026lsquo;생활의 달인\u0026rsquo; 에서 어떤 맛집 사장님이 음식을 준비하는 과정이 전파를 탄 기억이 어렴풋이 났다. 새벽 5시에 일어나 몇 시간 동안 갖가지 재료들로 음식을 준비고 있노라면, PD 가 \u0026lsquo;이런거 다 보여주셔도 돼요?\u0026rsquo; 라고 묻는데, 사장님이 자신만만한 미소를 지으시던 것 같다. 마치 \u0026lsquo;할 수 있으면 해보시던가\u0026rsquo; 같은 느낌.\n아무리 좋은 아이디어라도 실행하지 않으면 쓸모가 없다. 이론가는 이론가일 뿐이고, 발명가는 발명가일 뿐이다라고 저자는 말한다. 전혀 다른 각도로 큰 교훈을 얻은 것 같아서, 이 책이 큰 도움이 되었다.\n    (adsbygoogle = window.adsbygoogle || []).push({});   ","date":"2022-05-09T17:43:44+09:00","image":"https://interp.blog/simple-software/book_hu256dae5f239615f5a9a5f888ebdb8cf5_70504_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/simple-software/","title":"심플 소프트웨어"},{"content":"VSCode 에서도 Vim 환경을 쓰고 싶어서 VSCodeVim 을 설치해서 쓰고 있다.\n그런데 위와 같이 markdown 편집을 할 때 처럼 줄 분리가 이뤄져서 (line wrapping) 사실 한 줄인데 여러 줄로 보여지는 경우에는, 커서를 아래로 내릴 경우에 실제 다음 줄 로 이동한다. 화면에 보이는 줄이 아니라, 실제 줄로 이동하기 때문에, 커서를 옮길 때 여간 불편한 게 아니다.\n해결 방법 Vim 도 사실 line wrapping 이 되었을 때 같은 문제가 있고, (문제라기 보다는 특성인데) 원하는 방법대로 우회할 수 있는 방법을 여기서 찾았다. 이 방법을 그대로 VSCode 에도 적용한 것이다.\n먼저 Settings 를 열어서 Vim: Normal Mode Key Bindings 로 이동하면, Edit in settings.json 링크가 있다. 이걸 눌러서 다음을 추가하자.\n\u0026#34;vim.normalModeKeyBindings\u0026#34;: [ { \u0026#34;before\u0026#34;: [\u0026#34;\u0026lt;Up\u0026gt;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;g\u0026#34;, \u0026#34;k\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;\u0026lt;Down\u0026gt;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;g\u0026#34;, \u0026#34;j\u0026#34;] } ] 적용하고 곧바로 편집 중인 파일로 돌아오면 적용이 되어 있는 걸 볼 수 있다. 이제 커서를 위/아래로 움직여도 화면에 보이는 윗줄/아랫줄로 이동한다!\n","date":"2022-04-15T02:45:00+09:00","permalink":"https://interp.blog/vim-wrapping-line-cursor-up-down/","title":"VSCodeVim: 분리된 줄 위/아래로 커서 이동하기"},{"content":"쿠버네티스에서 서비스를 개발하거나 운영하다 보면 자주 접하게 될 개념 중 하나가, 바로 이 Controller 와 Operator 일 것이다. 어떤 경우에는, 동일한 서비스를 두고 \u0026lsquo;이건 Controller 야\u0026rsquo; 라고 말 할 때도 있고 \u0026lsquo;이 Operator 는\u0026hellip;\u0026rsquo; 이라고 불릴 때도 있어서 헷갈릴 수 있다. 심지어 공식 문서에서도 두 개념에 대한 비교는 하지 않고 있어서 명확한 구분이 필요한 것 같다.\n와중에 이 문서를 발견했는데, 요약하자면 이렇다.\nController  So in the Kubernetes world, a controller will basically monitor and measure the cluster resources state to adjust those resources that diverge from the desired state.\n 더 줄여보면, Controller 는 (1) K8s 리소스의 상태를 체크하고 (2) 이 리소스들의 상태를 \u0026lsquo;목표 상태 (desired state)\u0026rsquo; 로 조정하는 역할을 한다.\nReplicaSet, StatefulSet, DaemonSet 이 대표적인 Controller 들이다. 이 리소스에 속해 있는 Pod 들의 상태를 \u0026lsquo;목표 상태\u0026rsquo; 로 만들기 위해, Pod 을 추가하거나 삭제한다.\nOperator CoreOS 에서 정의하는 Operator 는 다음과 같다.\n An Operator is a method of packaging, deploying and managing a Kubernetes application.\n 그런데 이 개념을 구현하기 위해서는 필연적으로 Controller 가 들어가게 된다.\n그렇다면 Controller 와 비교했을 때 Operator 의 차이점은 무엇일까?\nOperator vs. Controller 여기에서 말하는 \u0026lsquo;Kubernetes application\u0026rsquo; 란, 사용자가 직접 지정할 수 있는 CRD (Custom Resource Definition) 과 거기서 파생된 CR (Custom Resource) 까지 포함하고 있는 것이다.\n예를 들면, Orange 라는 CRD 를 하나 만들어 보자.\napiVersion:apiextensions.k8s.io/v1beta1kind:CustomResourceDefinitionmetadata:name:oranges.example.comspec:group:example.comversion:v1scope:Namespacednames:plural:orangessingular:orangekind:Orangesubresources:status:{}이 정의 (definition)를 가지고, orange1 이란 CR 을 하나 만들 수 있을 것이다.\n특정 Orange CR 이 만들어지거나 수정될 때, 삭제될 때엔 뭘 해야 하는지 정의하는 코드를 만들 수 있을 것이다. 예를 들면, Orange CR 에는 1개의 Service 와 1개의 Pod 이 만들어져야 한다고 해보자. 그걸 Golang 으로 아주 간단히 표현하면,\nfunc (h *orangeHandler) Handle(ctx context.Context, req reconcile.Request) (reconcile.Result, error) { // Get the Orange instance \torange := \u0026amp;examplev1.Orange{} if err := sdk.Get(ctx, req.NamespacedName, orange); err != nil { if errors.IsNotFound(err) { return reconcile.Result{}, nil } return reconcile.Result{}, errors.Wrap(err, \u0026#34;failed to get Orange instance\u0026#34;) } // Create the Pod for the Orange instance \tpod := \u0026amp;corev1.Pod{ ObjectMeta: metav1.ObjectMeta{ Name: orange.Name + \u0026#34;-pod\u0026#34;, Namespace: orange.Namespace, Labels: map[string]string{ \u0026#34;app\u0026#34;: orange.Name, }, }, Spec: corev1.PodSpec{ Containers: []corev1.Container{...}, }, } if err := sdk.Create(ctx, pod); err != nil { return reconcile.Result{}, errors.Wrap(err, \u0026#34;failed to create Pod\u0026#34;) } // Create the Service for the Orange instance \tservice := \u0026amp;corev1.Service{ ObjectMeta: metav1.ObjectMeta{ Name: orange.Name + \u0026#34;-service\u0026#34;, Namespace: orange.Namespace, Labels: map[string]string{ \u0026#34;app\u0026#34;: orange.Name, }, }, Spec: corev1.ServiceSpec{ Selector: map[string]string{ \u0026#34;app\u0026#34;: orange.Name, }, Ports: []corev1.ServicePort{...}, Type: corev1.ServiceTypeClusterIP, }, } if err := sdk.Create(ctx, service); err != nil { // Error creating the Service \treturn reconcile.Result{}, errors.Wrap(err, \u0026#34;failed to create Service\u0026#34;) } return reconcile.Result{}, nil } 이처럼 내부에 구현된 Reconcile Loop Code (특정 CR이 수정되는 이벤트를 관찰하고, 이벤트에 맞춰 코드를 실행하는 루프) 는 일종의 Orange Controller 라고도 부를 수 있다. (또는 이 코드가 실행되는 pod 도 controller 라고 볼 수 있다)\n하지만 이렇게 Orange CR 을 관리하는 application 자체를 가리킬 때, 또는 이렇게 관리하는 전체 패턴을 Orange CR 의 Operator 라고 부를 수 있다. 바꿔 말해서, 실재하는 K8s 리소스인 Service 와 Pod 을 만드는 역할은 Controller 에서 이뤄지지만, Orange CR 의 명세를 관리하는 전체 과정은 Operator 라고 부를 수 있다.\n    (adsbygoogle = window.adsbygoogle || []).push({});   정리하면 개인적으로 Controller 는 기술적인 개념이고, Operator 는 좀 더 포괄적이면서 논리적인 개념으로 받아들여진다. 문서에서도 \u0026lsquo;모든 Operator 는 CR 을 관리하기 위해 쓰이는 Controller 라고 부를 수 있다.\u0026rsquo; 라고 하고 있으니까 말이다.\n그리고 Controller 나 Operator 모두 어떤 프레임워크일 뿐이지, 프로그래밍 언어에 국한된 것은 아니라고 언급한다. 나 역시 Go 언어와 Python 으로 모두 구현해 봤기 때문이다. 다만 용어를 사용할 때 좀 더 확실히 이해하고 쓴다면 헷갈릴 여지가 없기를 바란다.\n","date":"2022-03-15T02:44:57Z","permalink":"https://interp.blog/kubernetes-operator-vs-controller/","title":"K8s Operator vs. Controller"},{"content":" 책 제목이 나에겐 조금 자극적이었는데, 마치 이렇게 지내는 내가 나의 부모님 때문이라는 일종의 책임전가 같은 느낌이 들어서였다. 물론 실제 내용은 그렇진 않고 무던하면서도 세세하게 양육법에 대한 상담 내용이나 저자의 생각을 공유한다.\n당장 생각나는 것은 이 정도이다.\n (전부는 아니지만) 대개 양육에서 어려움을 느끼는 부분은, 내가 자라면서 겪은 부분이 반영된 것이다. 그 부분이 나의 부모님의 잘못일 수도 있고, 환경적인 문제일 수도 있고, 시대 또는 집안에서 요구한 (혹은 묵인한) 양육법의 문제일 수도 있다. 사람은 누구나 실수를 하고, 상대방에게 (의도했건 의도치 않았건 간에) 상처를 줄 수 있다. 그것은 자연스러운 것이니, 과거를 후회하며 좌절하면 안 된다. 중요한 것은, 상처를 줄 수 있다는 사실을 인정하고 상처를 치유할 노력을 지속적으로 하는 것이다. 치유는 당장 될 수도, 오랜 시간이 걸릴 수도 있지만, 중요한 건 그 노력 자체다. 아이는 감정의 동물이다. 성인은 이성적으로 감정을 제한할 능력이 어느 정도 있어도, 아이는 그렇지 못하기 때문에 이해를 구하거나 동일한 사고로 문제를 판단하면 안 된다. 부모는 아이의 감정을 받아줄 그릇이 되려고 노력해야 한다. 당연히 모든 감정을 받아줄 수는 없겠지만, 그렇게 노력을 해야 한다. 그래야 아이가 불안해하지 않는다. 부모 역시 부모의 감정을 공유하고 나눌 수 있는 사람이 반드시 필요하다. 배우자가 되면 가장 좋고, 여건이 안 된다면 보모나 양육자의 부모가 그 역할을 해야 한다. 여기에서 중요한 건, 상대방을 감정 쓰레기통으로 만들면 안 된다는 점이다. 서로 감정을 쪼개 환원할 수 있는 관계를 반드시 구축해야 한다. 아이에게 놀이나 배움의 선택지를 제한하는 방법은 좋다. 선택지가 많아지면 더욱 산만해진다. 갓난 아이를 울리면서까지 방치하는, 그러다 이내 잠들게 만드는 소위 \u0026lsquo;수면 교육\u0026rsquo; 은 반대한다. 아이는 그 동안 느꼈던 외롭고 두려운 감정을 체념해 버리기 때문에 대개 자라면서 문제가 불거지게 된다. 정 하고 싶다면 대신 \u0026lsquo;수면 유도\u0026rsquo; 를 추천한다. 아이가 원하는 것이 있다면 최대한 들어주자. 집안일을 해야 하는데 놀아달라고 하면, 정말 급한 게 아닌 이상 놀아주자. 아이가 부모와 같이 잠들고 싶다면 잠을 자도록 하자. 아이가 이상한 집착을 할 때가 있는데, 그 집착은 평생 가지 않는다. 그런 버릇을 일부러 고치려 들지 말고, 아이가 불안하지 않은 상태로 유지해주는 게 중요하다. (실제로 공감이 많이 가는 내용이었다)  저자가 여성이라 임신 과정에서 느낀 심경의 변화를 잘 묘사한 부분도 있는데, 임산부를 도와주는 남편 입장에서 참고할 부분이 많기 때문에 허투루 봐선 안 된다는 생각도 든다. 나는 가족계획상 더 이상 참고할 일은 없지만, 그 때 그랬지 하기도 하고, 어루만져주지 못한 감정에 대해선 반성도 할 수 있었다.\n아이는 감정을 언어화할 능력이 매우 부족하기 때문에, \u0026lsquo;왜 그랬니\u0026rsquo; 나 \u0026lsquo;무슨 생각으로 그랬니\u0026rsquo; 같은 주관식에 답을 하지 못한다. (대개 딴청을 피운다) 그래서 양육하는 사람이 너는 이런 감정일지도 모른다고 언어로 묘사해 줘야 한다. 그래야 아이가 이 감정과 그 문장을 일치시켜서 배우게 되는 것이다. 울거나 떼 쓰는 감정을 명확히 해 주면, 아이가 이해하고 악용하거나 해서 상황이 악화되진 않을까 생각할 순 있다. 하지만, 앞서 말했듯 다 한 때인 데다가 오히려 감정을 이해하면 최소한 울거나 떼를 쓰지는 않는다.\n그리고 아이는 미래를 염두에 두는 능력 또한 부족하기 때문에, 무작정 혼을 내거나 \u0026lsquo;이렇게 되면 이렇게 할거야\u0026rsquo; 같은 협박에 무신경하다. 부모의 목소리와 기분만 상할 뿐이다. 따라서 현재의 감정 상태를 이해하려 노력하고 어루만져주는 게 훨씬 낫다고 조언한다.\n","date":"2022-03-02T00:00:06Z","image":"https://interp.blog/the-book-you-wish-your-parents-had-read/book_hu6cf4f16d1ed18f075bfb6651de49f6ec_36396_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/the-book-you-wish-your-parents-had-read/","title":"나의 부모님이 이 책을 읽었더라면"},{"content":"메타크리틱과 오픈크리틱에서 GOTY 급 평점을 받은 그 게임, 그 때문인지 모든 스트리머와 게이머의 기대를 한 몸에 받아 수 많은 이슈를 한 몸에 받아내고 있는 \u0026lsquo;프롬 소프트웨어\u0026rsquo; 의 2022년 신작 \u0026lsquo;엘든 링\u0026rsquo; 을 10시간 가량 해 보고 난 소감을 적어본다.\n10시간 가량 했지만, 이제 겨우 멀기트를 잡았다. 새로운 지역을 싸돌아 다니면서 맵 아이템만 줍줍하고 보이는 축복들만 밝혔더니 스톰빌 전은 거진 다 밝혔다. (보스 잡은게 몇 없어서 그렇지\u0026hellip;)\n스카이림 + 블러드본 인생 게임에 대한 이야기를 시작하게 되면, \u0026lsquo;엘더 스크롤 5: 스카이림\u0026rsquo; 과 \u0026lsquo;블러드본\u0026rsquo; 은 항상 나에게 두 손가락 안에 드는 게임으로 꼽힌다. 이 두 개를 합친 듯하다. 혹자는 \u0026lsquo;젤다:야생의 숨결\u0026rsquo; 의 오픈월드가 느껴진다고도 하고, \u0026lsquo;베르세르크\u0026rsquo; 에서 모티브를 따온 만큼 그 느낌이 잘 살아있다고도 하던데\u0026hellip; 둘 다 접해보지 않아서 잘 모르겠다. 그보다는, 북유럽 풍의 디자인을 공유하면서 오픈월드였던 스카이림이 개인적으로 먼저 떠올랐다.\n블러드본은 좀 늦게 시작했는데, PS4 구입 자체가 늦어서 발매된지 2년 좀 안되어서 했던 기억이 난다. 그런데도 나는 잠을 줄여가면서 필드와 보스를 하나씩 넘겼다. (출근은 해야 하니까) 신혼 초에 그 때는 아이도 없어서 가능했던 것 같다.\n갑자기 블러드본 한 이야기를 꺼낸 이유는, 그 때의 느낌을 엘든 링에도 받고 있기 때문이다. 지금은 두 아이가 있어 육아도 신경써야 하고 집안일의 양도 월등히 많고 해야 할 다른 일들이 많은데도 말이다. 다크소울 3나 세키로는 정해진 시간에 하고 종료 버튼을 누르기가 수월했는데, 왜 그럴까\u0026hellip;\n  임의로 생성할 수 있는 성배 던전은, 블러드본 고유의 특징이다.\n  블러드본은 회차를 넘기고 나면 할 수 있는 일이 좀 더 많은데, 바로 성배던전으로 파밍하는 것이다. 물론 초회차 유저에게는, 이렇게 무수히 많은 비석이 부담으로 다가올 수 있다. 나도 그랬으니까. 이것이 다크 소울과 세키로와 다른 점인데, 아무리 화톳불/불상을 넘나들며 스토리를 진행한다 하더라도 일종의 선형적 구조를 지닐 수 밖에 없는 점보다는, 사이드 퀘스트인 성배 던전으로 추가 업그레이드와 모험을 할 수 있는 선택지를 넓혔다는 것이다.\n엘든 링이 딱 이런 식인데, 더 이상 스토리 진행이 안 되겠거든 \u0026lsquo;강해져서 돌아와라\u0026rsquo; 식의 진행이 가능하다는 것이다. 그러다 새로운 이벤트를 마주하기도 하고, 또 다른 보스를 만나기도 하고, 탐험을 진행하다가 돌아와서 다시 말을 걸면 전혀 다른 정보를 주기도 하고, 아이템을 줍고 만들고 모험을 계속 하는 것이다.\n하나 더 곁들이자면, 엘든 링 지하 던전 중에 \u0026lsquo;시프라 강\u0026rsquo; 이란 곳이 있다. 여기 엘리베이터 타고 내려가면 첫 인상은 마치 스카이림의 \u0026lsquo;블랙 리치\u0026rsquo; 에 다다른 듯한 인상을 준다.\n  왼쪽이 시프라 강, 오른쪽이 블랙 리치. 그야말로 지하의 몽환세계\u0026hellip;\n  지적되는 단점들에 대해서 이렇게 흡인력이 강하지만 최초 스팀 평가는 \u0026lsquo;복합적\u0026rsquo; 이었다. 기대에 대비해 실망한 사용자가 많았다는 것이다. 물론 PC 판에서 특히 심한 \u0026lsquo;스터터링\u0026rsquo; 문제는 무조건 고쳐야 하는 문제이고 백번 까여야 한다. (다행히 나는 보스전에서 그런 문제를 마주하지 않아서 덜 화나긴 하지만)\n그런데 그 외의 논란거리에 대해선 \u0026lsquo;글쎄\u0026rsquo; 다. 너무 큰 관심을 한 몸에 받아서 그런지, 엄청나게 높은 평론가 평점과 별개로 퍼포먼스 부분에서 심각하게 까이고 있다고 생각한다.\n대표적으로 그래픽이 다른 AAA 게임에 비해 낮다는 것은, 마치 \u0026lsquo;포켓몬스터 : 아르세우스\u0026rsquo; 와 \u0026lsquo;야숨\u0026rsquo; 의 필드 배경을 비교하는 것 같은 느낌이 강하게 들었다. 내부 사정이야 잘 모르겠지만, 알음알음 공개된 개발사 규모를 생각해 보면, 제한된 자원으로 선택과 집중을 했다고 너그러이 봐줄 수도 있지 않을까.\n물론 이런 건 있겠지. 소위 \u0026lsquo;망자들\u0026rsquo; 로 지칭되는 다크소울 시리즈를 즐겨하는 게이머 풀의 외연 확장을 위해, \u0026lsquo;엘든 링은 좀 더 쉬울거가, 오픈월드 같은 느낌으로다가 발매합니다\u0026rsquo; 라고 홍보를 했으니 말이다. 마치 메타크리틱에서 붙이는 MUST PLAY 딱지를 꼭 받고, 너도 나도 이 게임을 안 사고는 못 배기는 킬러 타이틀로 부상시키려는 노력이 없었다고는 말 못하겠다. 그래서 일반 게이머들이 보니까 \u0026lsquo;뭐야, 이거 평점은 그렇게 높더니 버그도 있고 그래픽도 별로고 게임은 어렵고 불친절하고\u0026hellip;\u0026rsquo; 가 되는 것일 수도?\n   이게 붙으면, 너도나도 찍먹하게 되는데 문제는\u0026hellip;\n   문제는, 아직도 이 게임은 다크소울 시리즈를 즐겨하는 게이머만 좋아할 법하다는 것이다. 그러니까, 실제 홍보와 게임 진행은 좀 다른 양상이라는 것이다.\n그런데 돌이켜보면, 이게 정말 문제일까? 몬스터 헌터가 일반 게이머도 손쉽게 접근할 수 있는 게임이 아니듯이, 다크소울 시리즈 역시 그렇다고 생각한다. 그런 테이스트 강한 게임을 하나 더 출시했는데, 좀 더 다양한 선택지를 줘서 게이머가 도전할 수 있는 옵션을 많이 제공해 준 것만으로도 게임 자체는 일신했다고 생각한다. 평론가들은 아마 (게임을 많이 하다보니) 대부분 \u0026lsquo;망자\u0026rsquo; 일 가능성이 크고, 거기에 비춰서 \u0026lsquo;그래픽이 후져도 졸잼이네요\u0026rsquo; 하고 평점을 높게 주진 않았을지.\n그런데 정말 스터터링은 문제다. 주변에서 들어보니 1060에서도 발생하고 3080ti 에서도 발생하는데 이게 대체 뭐람?\n마치며 결론은 예약 구매는 하면 안 된다 (\u0026hellip;) 취향에 맞는지는 출시 직후 실황이나 클립을 통해서 얼마든지 확인할 수 있다. 정 찍먹을 하고 싶다면, 스팀에서 구매한 다음 한 시간만 빡세게 돌리고 아니다 싶으면 환불을 하는 방법이 있다. 농담이 아니라 정말이다.\n다크소울 시리즈를 (잘 못해도) 좋아한다면, 이 게임은 최적의 선택이 될 것이다. 나름대로 친절하고 돌아다닐 구석이 너무 많고, 의외의 발견에 희열을 느낄 수 있을 것이니.\n시리즈 전문 공략 유튜버/방송인 \u0026lsquo;이클리피아\u0026rsquo; 님의 첫날 실황 방송을 아주 잠깐 봤는데, 그 때 들었던 이 게임의 평이 다음과 같았다. 딱 열시간 하면서 이 평론이 뇌리에서 떠나질 않아서 붙여둔다.\n 이거, 다크소울 올스타 같아요.\n ","date":"2022-02-28T08:53:20Z","image":"https://interp.blog/images/2022-02-28-elden-ring/featured.jpg","permalink":"https://interp.blog/elden-ring-10h-review/","title":"엘든 링, 10시간 리뷰"},{"content":" 저자인 아리카와 마유미는 50가지 이상의 직업을 가져 본 40대의 베스트셀러 작가라고 한다. 이 책은 자기계발서이긴 하지만, 시간을 효율적으로 쓰는 기술을 알려주는 책은 아니다.\n책에서 이야기하는 \u0026lsquo;8가지 기술\u0026rsquo;이란 사실, 마음가짐에 대한 조언이다.\n 시간을 보내는 기분에 집중한다. 목적의식을 갖고 시간을 쓴다. 나만의 철학으로 우선순위를 매긴다. 지금 하고 싶은 일을 미루지 않는다. 너무 깊은 생각은 행동으로 끊는다. 나를 행복하게 만드는 관계에 집중한다. 지속가능한 삶을 위해 시간을 쌓는다. 일상의 호사스러움을 놓치지 않는다.  그러나 이 항목은 어쩐지 억지로 끼워 맞춘 듯 해 보이고, 아마 저자가 한편씩 내키는대로 (?) 썼다가, 마지막에야 분류를 할 때 \u0026lsquo;그나마 이 정도면 구색이 괜찮다\u0026rsquo; 고 판단한 것일지도 모르겠다. 나름대로 다시 정리해 보자면 이 책은 이런 걸 이야기하고 싶었던 것 같다.\n 내가 하고 싶은 게 있으면 무조건 그걸 할 시간을 할당해라. 그 다음 나머지를 할당해라. 중요한 일인데 기한이 없는 일 vs. 중요하지 않은데 기한이 있는 일 -\u0026gt; 무조건 전자! 내가 하는 행동에는 반드시 합당한 목적이 있어야 한다. 목적이 없으면 당장 중단하라. 여러 조건으로 내가 하기 싫어도 해야 할 일이 있다면, 이왕 할 거 즐겁게 해라. 마음만 즐겁게 하지 말고, 이왕 할 거 제대로, 좀 기분 좋아지라고 데코레이션을 가미해서라도 누려라. 미루지 마라. 그렇다고, 내일 해도 될 일을 오늘 하란 소리가 아니다. 내일 할 일은 내일 꼭 하자. 아직도 뭐가 중요한지 내 마음의 소리를 잘 모르겠으면, 참고해라. 내가 행복한 걸 먼저 찾는다. 나는 불행한데, 남\u0026rsquo;만\u0026rsquo; 행복한 건 하지 마라. 내가 불행하면 반드시 떨쳐내라. 내 감정을 상하게 하는 사람, 일은 꼭 피해 다녀라. 나도 행복하고 남도 행복한 것, 바로 좋은 관계의 시작과 유지는 꼭 하라. 모든 일에는 때가 있다. 지금 할 수 있고 나중에 못 할 일이라고 생각되면, 지금 최우선으로 해라.  사실상 1, 2, 3 번이 대전제에 가깝고, 4번에 대한 내용이 곳곳에 퍼져있는 식이다. 마음의 소리를 잘 들어보고 1-2-3 을 생각해서 시간을 계획하고 보내야 한다는 것이다.\n사실 이 책을 선택한 이유는 (도서관에서 빌려왔는데), 책을 우연히 펼쳐보다 한 눈에 딱 들어오는 구절이 있어서다.\n 시간이라는 것은 \u0026lsquo;상자\u0026rsquo; 와 같습니다. 누구나가 가지고 있는 같은 크기의 상자에 시간이라는 \u0026lsquo;돌\u0026rsquo;을 넣는다고 생각하면 이해하기 쉽겠지요. 그 돌을 넣는 방법은 크게 두 가지로 나눌 수 있습니다.\n 우선 큰 돌을 넣고 빈틈에 작은 돌을 넣는 사람 작은 돌부터 넣어서 큰 돌을 넣지 못하는 사람그래서 우리는 시간이라는 상자에 제일 빛나는 돌을 먼저 담아야 합니다.   시간을 어떻게 보낼까? 보다는 내가 보내는 시간은 나에게 의미가 있는가? 없다면 어떻게 진지하고 재미있게 그 시간을 보낼 수 있을까? 를 되돌아볼 수 있는 소중한 시간이 될 수 있을 것이다.\n무엇보다도, 책이 정말\u0026hellip; 정말 술술 읽힌다. 222페이지라 많지는 않은데, 여기에 여백도 많고 한 페이지에 적힌 글자 수도 적었기 때문도 있지만, 아무래도 어려운 내용 없이 옆에서 조언하는 걸 듣는 마음으로 가볍게 읽을 수 있었던 것 같았다. 😊\n","date":"2022-02-13T22:26:07+09:00","image":"https://interp.blog/being-busy-habit/book_hu69495637bfd1fa4fea12d00086bc65d6_146484_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/being-busy-habit/","title":"바쁜 것도 습관입니다"},{"content":"🚧   이미지 정렬이 필요합니다\u0026hellip;!   요약  원래는 홈페이지에서 하라는 대로 하면 된다. 비밀번호를 잘 입력했는데 서버 접속이 안 된다면, 혹시 2단계 인증을 쓰고 있지는 않은지? 2단계 인증을 쓰는 경우라면, 앱 비밀번호를 별도로 발급받는다.  참고 카카오 메일 뿐만 아니라 네이버 메일이나 네이버 캘린더 동기화도 비슷하다. 아래에 ‘부록’ 으로 달아뒀으니 참고하면 된다.\n설정 방법  PC 에서 브라우저를 열고, 카카오 메일을 접속한다.  모바일 브라우저에서 카카오 메일을 접속하면 카카오톡으로 리다이렉트 되는데, 카카오톡에서는 해당 설정을 진행할 수 없다. 반드시 PC 로 접속한다.   환경설정 \u0026gt; IMAP/POP3 을 클릭해서, IMAP 사용을 체크하고 저장한다. 설정 앱으로 가서 ‘메일 \u0026gt; 계정’ 을 차례대로 누른다.   4. 그 다음 ‘계정 추가’ 를 누른 다음 ‘기타’ 를 선택한다. 이후에 'Mail 계정 추가' 를 선택한다.  5. 기본 정보를 입력한다. 이메일과 암호는 쓰던 걸 쓰면 되고 이름이나 설명은 자유롭게 입력한다. 6. IMAP 또는 POP 을 선택하는 탭이 있는데, 어느 것을 선택하던 상관없지만 IMAP 으로 진행한다.   이제 안내된 대로 주소를 설정한다. 공식 FAQ 문서, 7번 항목)\n- 아이디 : 카카오메일 아이디 (ooooo@kakao.com 에서 앞 부분) - 비밀번호 : 카카오 계정 비밀번호 - IMAP (받는서버) : imap.kakao.com:993 (SSL) - SMTP (보내는서버) : smtp.kakao.com:465 (SSL) SSL 은 아마 처음 설정할 때 바로 시도할 것이다. 포트 번호는 당장 신경 쓰지 않아도 되는데, 나중에 계정 저장을 한 다음에 포트 세부설정이 가능한 곳이 있긴 하다.\n    (adsbygoogle = window.adsbygoogle || []).push({});   비밀번호가 맞는데 되지 않아요 혹시 2단계 인증을 쓰고 있지 않은지? 그렇다면 기존 비밀번호로는 인증을 할 수 없다. 사람이 로그인을 했다면 카카오톡에 들어가서 인증하기를 눌러줬겠지만, 이건 아이폰이니까.\n그래서 ‘앱 비밀번호’ 라는 걸 발급받아야 한다. PC 에서도 발급이 가능하지만, 어차피 아이폰에서 복사해서 바로 붙여넣을 예정이니, 모바일로 해 보자.\n 이번에는 모바일 기기에서 ‘카카오톡’ 앱을 실행한다. ‘\u0026hellip;’ 버튼을 누르고, 오른쪽 위에 있는 톱니바퀴를 누른다.  개인/보안 → ‘카카오 계정’을 누르고, 나오는 화면에서 ‘2단계 인증’ 을 누른다.   4. 비밀번호를 입력한 뒤, ‘앱 비밀번호’를 누른다. 5. 앱 이름을 원하는 대로 입력하고, ‘생성’ 을 누르면 앱 비밀번호가 뜬다. 앱 비밀번호는 다시 볼 수 없기 때문에, 복사해 두거나 메모해 둬야 한다. 비밀번호를 놓쳤다면, 삭제했다가 다시 만들면 되니까 걱정하지 말자.   이 앱 비밀번호를, 원래 비밀번호 대신 입력하면 서버 접속이 가능하다.\n네이버는 어디서? 이번에도 모바일 환경에서 해 볼 것이다. 네이버 앱으로 해도 되고, 일반 브라우저 에서 해도 상관없다.\n 네이버에 로그인 한다. 오른쪽 위에 있는 프로필 아이콘을 누른 뒤, 다시 왼쪽 위에 있는 프로필 아이콘을 누른다. \u0026lsquo;내 정보 및 프로필 관리\u0026rsquo; 에 있는 본인 계정을 누른다. 보안 설정 및 비밀번호 변경을 클릭한다.  2단계 인증 항목에서 관리하기를 클릭한다.  조금 스크롤을 내리면, 애플리케이션 비밀번호 관리 항목이 보인다.  종류에서 아이폰을 선택해도 되지만, 카카오에서의 이름 설정에 지나지 않기 때문에, 아무거나 입력해도 된다. 생성하기 버튼을 누르면 비밀번호가 보인다. 마찬가지로, 지금 복사하거나 메모해두지 않으면 나중에 다시 볼 수 있는 방법이 없다.    ","date":"2022-02-04T16:35:37Z","image":"https://interp.blog/images/2022-02-04-kakao-email/feature-image.jpg","permalink":"https://interp.blog/kakao-naver-email-iphone-connect/","title":"카카오/네이버 메일 아이폰 연동"},{"content":"CKA (Certified K8s Administrator) 를 2021년 12월 말에 합격 통지를 받았다. 합격을 받고 나서 정리한 팁을 공유하고자 한다.\n강의 매우 유명한 Udemy 의 Mumshard 강의를 완강했다. 내가 너무 초보여서 그런지는 몰라도, 기초 강의도 기본을 다지고 한번 더 리마인드 하자는 차원에서 완강을 했고, 결론적으로는 시험 뿐만 아니라 업무에도 큰 도움이 되고 있다.\n 이해가 쏙쏙 되는 강의 지속적인 업데이트 KodeCloud 를 통한 인터렉티브 연습 문제 (엄청 많다!) 3개의 모의고사 (요점은 다 나온다)   유료 (이긴 한데 상시 할인이라 큰 부담은 없다. 등록하면 평생 수강이니, 할인율이 높을 때를 노려 구매해 두는 것을 추천.) 영어 (수준이 높다기 보다는 그냥 귀찮다. 영어 자막은, 거의 자동 생성인 경우가 많기 때문에 별 도움이 안 된다.)  시험 등록 보통 시험을 Linux Foundation 에서 볼 텐데, 그럼 아래와 같은 절차로 시험을 준비한다.\n Global Candidate Agreement 를 읽고 \u0026lsquo;동의\u0026rsquo; 를 누른다. 이름을 확인한다. 반드시 신분증에 있는 영어이름과 일치해야 한다. (여권이나 국제운전면허증 등등) 일치하지 않거나 하면 피곤해진다고 한다. 시험에 사용될 OS 를 지정한다. 보통 우분투를 사용한다. 시험 일정을 예약한다. 한번 시험 등록에 들어오면 시험 일정을 잡는데 유효기간이 있다. 그래서 가급적 스케줄을 확인하고 얼른 시험 일정을 예약해야 한다. 시스템 환경을 체크할 수 있다.  Chrome 확장 프로그램 을 반드시 설치하고 시험을 시작해야 한다. 비인가된 프로그램을 사용하는지 감독관이 반드시 체크한다. 작업관리자를 \u0026lsquo;간단히\u0026rsquo; 버전으로 띄우도록 요청한다. 책상은 컴퓨터/노트북 외엔 깨끗해야 하며 (외부 모니터는 된다고 하던데 나는 치웠다) 책상 아래도 깨끗해야 한다. 이걸 증명하기 위해 웹캠이 필요하다. 노트북 내장 웹캠도 가능하다 (내가 그랬으니까) 방 안엔 누구도 있어선 안 되고, 밝고 조용한 환경이어야 한다. 단, 수험자 뒤에서 밝은 빛이 나오면 안 된다 (감독관 방해)   다음 글을 읽어 본다. 만약 시간이 없으면 Important Instructions 만 읽어 보자.  Important Instructions: CKA, CKAD Handbook   시험 준비가 모두 끝났다고 생각되면, killer.sh 에 들어가서 모의고사 세션을 시작해보자.  killer.sh Linux Foundation 에서 제공하는 마지막 모의고사 성격의 mock-up exam 환경이다.\n 저기서도 경고하지만, 실제 시험보다 훨씬 까다롭고 광범위한 질문이 나온다. 좌절할 필요 없다. 2개의 세션이 제공되는데, 한 개당 36시간의 유효기간이 있다. 2시간 타이머가 돌긴 하지만, 타이머가 끝난다고 시험이 닫히진 않는다. 심리적인 압박 용이니, 2시간 시간관리 한다 생각하고 신경 써가며 풀어보자. 2개 세션 모두 같은 문제 세트를 가지고 있다. 하나는 시험 치듯 풀고, 끝나면 정답과 함께 채점을 해 주기 때문에 두 번째 세션은 오답노트 풀듯이 훓는 걸 추천한다.      (adsbygoogle = window.adsbygoogle || []).push({});   팁 시험 환경 준비  감독관은 말 하지 않는다. 대신 채팅으로 말한다.  시험 전 20분부터 입장이 가능한데, 감독관이 준비되어야 사실 입장이 가능하다 (\u0026hellip;) 감독관을 만나면 하는 일은, 신분증으로 신원 확인, 방 주위를 둘러보기, 책상 보기, 책상 아래보기.. 정도만 했다. 시험 중간에는 웬만하면 어떤 채팅도 올라오지 않는다. 내가 본 건 딱 ‘15분 남았습니다’ 였다. (내가 겪어 본 건 아니지만) 만약 허용되지 않은 웹 사이트를 실수로라도 방문하면, 경고성 채팅창이 올라올 것이다. 그런데 같은 짓을 4번 (3번?) 더 하면 시험이 그냥 종료되니 주의. (자세한 내용은 위 문서에서 인스트럭션을 읽어보면 된다)   북마크 사용은 가능하다, 물론 허용된 사이트 안의 웹 페이지만이다. 크롬이나 엣지 브라우저로 문제가 생길 수 있다는 이야기가 있다. 그러면 감독관이 비발디 (Vivaldi) 브라우저를 권한다고 한다.  문제는, 환경설정에 시간을 다 뺏기고 (준비에 시간을 주긴 할테지만 2 시간 스케쥴이 틀어진다) 준비해 간 북마크 호환하기 어려울 수 있으므로 당황할 여지가 생긴다. 추천: 그냥 ‘Vivaldi’ 브라우저를 설치하고, 거기다 환경을 구성해 두자. (물론 크롬 확장 프로그램 미리 깔아두는 것 잊지 말고)   영어 해석에 애를 먹는다면, Google 번역 크롬 확장 프로그램을 설치해서 써도 된다.  K8s Docs 의 한글 번역본을 읽어도 아무런 제지가 없다. 문제 몇 개는 해석이 조금만 틀려도 산으로 가는 것들이 있다. (NetworkPolicy 를 생성할 때 라던지) 하지만 번역기는 만능이 아니다. 참고용으로만 쓰는 걸 추천한다.    시험칠 때  클러스터 몇 개가 주어지고, 매 문제마다 처음에 context 를 바꾸라고 한다. 안 바꿔도 된다는 확신이 있어도 반드시 바꾸자. 안 바꾸면 정답이 엉뚱한 클러스터에 반영되고 채점도 안 된다. 15-20 개의 문제가 주어진다고 하고, 각 문제마다 배점이 있다. 컷 라인은 66점이니 쉬운 것을 먼저 푸는게 좋다. 다른 합격 후기에서는, kubectl 자동 완성을 위해 cheat sheet 를 적용하라고 하는데, 나는 이게 시험 환경에 이미 적용이 되어 있었다.  kubectl = k 명령어 자동 완성 가능 (예) k des\u0026lt;tab\u0026gt; → k describe 리소스 이름 자동 완성 가능 (예) interp 라는 ns 가 있다고 하면, then k get pod -n int\u0026lt;tab\u0026gt; → k get pod -n interp   리소스를 지우거나 업데이트 하기 전에, 반드시 그 리소스를 백업해 두자. 혹시 그 리소스를 원상복구 시킬 때가 있을 수 있는데, 백업 없이는 다른 방법이 없다.      (adsbygoogle = window.adsbygoogle || []).push({});   공부할 때  오픈북 시험에서 가장 중요한 건, 어떤 문제를 마주쳤을 때 어디를 봐야 하는지 기억해 두는 것이다.  좀 더 구체적으로, 어떤 키워드로 K8s docs 를 검색해야 하는지를 기억하는 것이 중요하다.   하지만 아래 키워드는 찾아보기도 전에 타이핑할 수 있도록 기억해두는 게 좋다.  Pod 을 생성할 때: k run {name} --image= ... --dry-run=client -o yaml 로 YAML 파일을 얻어서 수정한 뒤 k apply -f {yaml_file} 로 입력 리소스를 생성할 때 (가능하다면):  k create 명령어로 어떤 리소스를 만들 수 있는지 보고, k create {resource} --help 로 해당 리소스를 만들 수 있는 다양한 예제를 확인한 뒤, 역시 --dry-run=client -oyaml 을 붙여 YAML 파일을 얻을 수도 있다.      ","date":"2022-01-18T22:38:42Z","image":"https://interp.blog/images/featured/cka-exam.jpg","permalink":"https://interp.blog/cka-exam-review/","title":"CKA 시험 후기"},{"content":"Tale 테마로 블로그를 처음 시작하려고 보고 있는데, 여기서 SCSS 내용을 변경해도 hugo server -D 를 하니까 변경 내용이 적용이 되지 않았다. 여기선 잘 된다고 나와 있는데, 어떻게 해결했는지 자세히 적어본다.\n 자세히 보니 이미 컴파일이 완료된 CSS 파일이 resources/_gen/assets/scss/scss/ 에 존재하고 있었다. 설마 이것 때문인가? 삭제를 하고 다시 hugo server -D 를 해보면 다음 문구가 반겨준다. Building sites … ERROR 2020/01/31 00:27:39 Transformation failed: TOCSS: failed to transform \u0026#34;scss/tale.scss\u0026#34; (text/x-scss): this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information Built in 16 ms Error: Error building site: logged 1 error(s)   그렇다, extension version 이 아닌 일반 hugo 를 설치한 것이었다! Install Hugo 페이지에 다시 들어가 재설치하니 잘 되었다.\n","date":"2020-01-31T00:35:23+09:00","permalink":"https://interp.blog/hugo-scss-rebuild/","title":"Hugo SCSS Rebuild"},{"content":"MapR (현재는 HPE Data Fabric) 의 Monitoring (Node) Metric 문서를 보다가, CPUNICE 라는 컬럼 이름에 다음과 같은 설명이 있다. Amount of CPU time used by processes with a positive nice value. 오잉, 프로세스의 CPU 사용 시간인 것 까진 알겠는데, 양(positive) 의 좋은 값이라니?\n실은, nice value가 다음과 같은 뜻이라고 한다.\n Nice 값은 CPU의 스케줄링 우선순위를 의미합니다. 값의 범위는 +19 ~ -20으로, 숫자가 높을 수록 우선 순위는 낮습니다. man 2 getpriority 를 참고하시면, 더 자세한 정보가 나와 있습니다. 프로세스를 실행할 때 nice 명령어로 우선 순위를 부여할 수 있고, renice 명령어로 우선 순위를 조정할 수 있습니다. 우선 순위를 높이기 위해선, 슈퍼 유저 권한이 (root) 필요합니다. (출처)\n 참고로, getpriority() 는 프로세스의 현재 우선순위를 반환하는 인터페이스 이다. setpriority() 역시 존재하는데, 이 함수를 실행할 때 값을 낮추려면 sudoer 권한이 있어야 한다고 한다.\n","date":"2019-11-28T01:53:59Z","permalink":"https://interp.blog/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EA%B0%92-nice/","title":"프로세서의 우선순위 값 : nice"},{"content":"생각이 글이 되고 글이 정제된 다른 글이 되는 연계를 계속 해야 하는데. 어느 샌가 단편적인 이미지, 몇 분짜리 동영상, 흘러가는 명언에 시간을 소비하고 있는 것은 아닌지, 양심의 가책을 느낀다. 생각의 소스가 되는 것들이 저급한 것이라고 할 순 없겠지만, 그게 내 손에서 일궈진 것이 아니라서 값지지 않게 느껴진다. 유망주 투수의 현란한 로케이션이 담긴 GIF, 대중 매체를 알지 못하면 이해할 수 없는 드립, 당신을 움직이게 만들 것이라고 광고하는 몇 컷 짜리 자기계발서 요약 슬라이드들이 그런 것이다.\n이전에 내가 후배들에게 이런 말을 한 적이 있다.\n 시장의 궁극적인 목적은 너의 돈을 소비하게 만드는 것이다. 그러려면 먼저 너의 시간을 사들이는 것에 혈안이 되어 있다. 그것이 바겐 세일, 심지어 공짜라 할 지라도. 한번 소비하기 시작하면, 너의 의지와 방향은 돈을 쓰지 않으면 안 될 지경으로 만든다. 와닿지 않는다고? 조금 완곡하게 말하자면, 조금의 불편함을 느끼게 만든다는 것이고, 마치 내가 이런 소비를 해서 내 인생에 도움이 될 것이라고 착각하게 만든다. 이전에는 없이도 잘 살았는데. 마치 욕구가 개방된 것 처럼.\n 사실 전혀 다른 주제 같아 보이는데, 인터넷과 유튜브는 정말이지 이런 자유시장에서 더욱 첨예하게 사람의 욕구를 개방하기 시작했다는 점에서 이어진다. 인터넷이란 것이 없었을 때, 집전화를 먹통으로 만들고 PC통신에 접속했을 때, ADSL 이 개통되었을 때, 지식인으로 모든 것을 묻고 답할 때, 싸이월드에서 일촌평을 남길 때, 그리고 지금 모든 인플루언서들과 모든 개인들이 저마다의 소리를 내며 자유시장에서 자리를 잡으려고 할 때. 시간의 흐름은 생산자와 소비자의 간격을 무너뜨리고, 정보 독점 체제를 무력화시킨 것 처럼 느껴지게 한다. 모두가 생산자이며 모두가 소비자가 되는 더욱 복잡하고 현란하고 귀찮은 세상이 되었다.\nAI 와 로봇이 결합된 4차 산업혁명에 우려를 나타내는 많은 학자와 저자들이 한 목소리로 이야기하는 대안이 \u0026lsquo;자아성찰\u0026rsquo; 이라고 하는데, 나는 이게 이미 필수라고 생각한다. 나를 아는 방법 역시 쉽지 않고, 그런 걸 찾기 위한 수단으로 기술을 쓰는 것에 결코 반대하지 않는다. 하지만, 여기서 이야기하고 싶은 것은, 기술이 수단을 집어삼켜 나를 휘두르게 놔두지 말자는 것일 뿐. 그런 바보가 되지 말자.\n","date":"2019-08-29T22:41:30Z","permalink":"https://interp.blog/%EB%B0%94%EB%B3%B4%EA%B0%80-%EB%90%98%EA%B3%A0-%EC%9E%88%EB%8B%A4/","title":"바보가 되고 있다"},{"content":"Vim 과 SSH 에 찌들어 있었는데, 이번 Visual Studio Code 의 베타 기능인 Remote Deployment 를 연결해 보고 나서, 학생 때 쓰던 IDE 로 돌아간 것 같아 너무 좋았다. 언제까지고 구식 도구를 쓰며 부심을 부릴 수만은 없다. 설치 과정이 조금 험난했지만, 간단히 요약해서 써본다.\n클라이언트 OS 는 윈도우 10 (빌드 1809), 서버 OS 는 Cent OS 7 기준으로 작성한다.\n클라이언트 (윈도우) 준비 처음에 준비할 때는 Visual Studio Code Insider 버전을 설치하라고 되어 있었는데, 이제는 꼭 그럴 필요 없는 것 같다. 일반 Visual Studio Code 를 설치해도 된다.\n다음으로, SSH 클라이언트를 설치한다. 윈도우 10 빌드 1807 이상 버전의 윈도우 OS 라면 여기 링크 안내를 따르거나, 아래 요약된 스크린샷을 보면 된다.\n시작 \u0026gt; 설정 앱에서, \u0026lsquo;앱\u0026rsquo; 을 클릭한 뒤 \u0026lsquo;앱 및 기능\u0026rsquo; 탭의 \u0026lsquo;선택적 기능 관리\u0026rsquo; 를 클릭한다. 그 다음 아래 \u0026lsquo;OpenSSH 클라이언트\u0026rsquo; 를 찾아 설치한다. OpenSSH 서버는 설치할 필요가 없다.\n 만약에 여러분이 윈도우 10 빌드 1807 이하 버전의 윈도우 OS 라면… 조금 귀찮아진다. 이 문서 에 따르면, Git for windows 를 설치하면서 옵션에서 Use Git and optional Unix tools from the Command Prompt 를 선택하면 된다.\n그러면, 같이 설치된 mingw 내부의 SSH 를 클라이언트로 사용한다고 한다. 물론 난 테스트해 보진 않았다! 권한 문제 등등으로 생각보다 꼬일 가능성이 있으므로, 조심해야 한다.\n 이제 ssh key 를 만들어야 한다. 비대칭 키에 대한 지식이 없다면 암호 대신 SSH Key 로 인증하기 포스팅을 참고하면 된다. 혹시 PuTTY 에서 생성한 비공개 키를 등록하고 쓰고 있으니 이걸로 충분하지 않을까? 그렇게 준비하면.. 실제 접속할 때 아마 잘 안 될 것이다.\nVisual Studio Code 는 OpenSSH (또는 Git 의 ssh) 클라이언트를 쓰기 때문에, Key 호환성 문제로 \u0026lsquo;invalid format\u0026rsquo; 에러를 발생시킬 수 있다. 그러니 순순히 (?) 실행 명령 창 (cmd) 을 열어서 다음을 입력하자. 기존에 쓰던 키 저장 경로가 존재한다면, 다른 경로로 설정하는 것을 추천한다. 이 방법은 Visual Studio Code 페이지의 Troubleshooting 에 등록된 내용이다.\nssh-keygen -t rsa -b 4096 서버 (리눅스) 준비 원활한 서비스가 가능한 리눅스 OS 목록은 여기를 참고하면 된다. Cent OS 7 은 잘 되므로 별 다른 설정 없이 가능하다. 지원이 안 되는 리눅스들은 workaround 가 있는데 (특시 Cent OS 6) 생각보다 까다롭고 원치 않는 상황이 발생할 수 있기 때문에 신중해야 한다.\n접속하고자 하는 계정의 ~/.ssh/authorized_keys 파일에다가, 아까 만들었던 Key Pair 중 \u0026lsquo;공개 키\u0026rsquo; 정보를 입력해야 한다. 해당 파일이 없으면 만들면 되고, 있으면 파일 끝에 추가 (append) 해주면 된다.\n~/.ssh/authorized_keys 파일의 권한이 600 (계정에서만 읽기/쓰기가 가능) 인지 반드시 체크하고, 아니라면 chmod 명령으로 바꿔주도록 한다. (이건 SSH 일반 접속 때문에 하는 작업이지, Visual Studio Code 라서 하는 것이 아니다.)\nVisual Studio Code 준비 우여곡절 끝에 준비를 다 했으면, Visual Studio Code 를 열어서 Remote Deployment 를 설치하자. 그 다음, 명령 팔레트를 열어서 (Shift + Ctrl + P) Remote-SSH: Open Configuration File… 을 선택한다. 설정 파일 경로는 수정하거나 기존에 잡아주는 경로를 쓰건 상관없다.\n예시는 이렇다.\nHost 192.168.0.10 HostName 192.168.0.10 User interp IdentityFile \u0026#34;C:\\Users\\interp\\ssh_key\\id_rsa\u0026#34;  Host : 목록에 나올 이름이다. 보통은 HostName 과 같이 지정해주거나 Username@HostName 으로 지정한다. HostName : 실제 접속할 호스트 주소 User : 접속할 사용자 계정 이름 IdentifyFile : 생성한 Key Pair 중 \u0026lsquo;비공개 키\u0026rsquo; 경로  Remote 로 접속! 이제 설정 파일을 저장하고, 명령 팔레트를 열어서 (Shift + Ctrl + P) Remote-SSH: Connect to Host… 을 선택한다. 아까 저장한 Host 가 1개만 떠 있을텐데, 접속하면 아예 새로운 Visual Studio Code 창이 하나 더 뜨게 된다.\n이것저것 하는 것 같으니 잠시 기다리면, 접속이 되었다는 메시지와 함께 \u0026lsquo;절대로 저 작은 터미널을 닫지 말아주세요\u0026rsquo; 라는 경고문이 뜬다. 최소화시키고 작업을 하면 된다!\n","date":"2019-06-26T05:11:21Z","permalink":"https://interp.blog/visual-studio-code-remote-deployment/","title":"Visual Studio Code Remote Deployment"},{"content":"처음에는 경력직을 선호했고, 나도 그랬다.\n개발자를 충원하자는 계획에 맞춰, 공고를 등록하고 경력직 이력서를 받으면서 이 정도 커리어면 뭐든지 붙을 수 있을거라고 생각했을 것이다. 하지만 그 때의 실패들이 쌓여 이제는 경력직이나 신입이나 동일 선상에 놓고 평가하고 있다.\n내가 몸 담고 있는 필드는 국내에서 잘 하지 않는 분야다. 없진 않지만, 사용자 경험과 컴퓨터 구조를 동시에 신경 써야 하는 조직이다. (물론 개발자 1인이 모두 신경 쓰는 것은 아니다.) 그런데, 소위 SI 업체나 프리랜서 개발자들의 면접을 보면 괜히 미안해진다. 면접이 매끄럽지 못해서 미안한게 아니고, 이미 그들의 표정에서 \u0026lsquo;이걸 대체 왜 물어보는 건지\u0026rsquo; 싶은 느낌이 표정에 드러나기 때문이다.\n이야기를 나눠보면, 지원자 중 절반은 말 그대로 \u0026lsquo;잘못 왔다\u0026rsquo;. 그냥 솔루션 개발 쯤으로 알고 왔는데, 열어보니 이건 이상하다 싶었겠지. 나머지 반은 본인 실력을 다 못 보여준다. 왜냐하면 전혀 새로운 분야에서 요구되는 능력들이 자기가 일궈온 것과 좀 다르니까 거부감이 드는 것이다. 그래서 나도, 그들도 같이 지친다.\n어느 대기업 연구원 관리직의 댓글을 봤다. 오히려 박사/포닥 후 입사한 친구들이 너무 협소한 시각으로 보고서를 작성하기 때문에 설득력이 떨어진다는 것이다. 자기 분야에서만 논거를 찾아서 주장하거나, 다른 분야 사람이 오펜스라도 할라 치면 \u0026lsquo;당신이 뭘 알아\u0026rsquo; 라는 스탠스를 취한 경우를 많이 봤단다. 학교에서는 비즈니스나 의사소통을 가르쳐주지 않기 때문이라고 하면서. 차라리 회사에서 신나게 구르던 동일 경력의 친구들이 더 뛰어난 경우를 많이 봐왔다고 한다.\n이 이야기를 왜 꺼냈을까. 박사과정을 마친 사람들을, 하이 커리어를 쌓으신 많은 경력 개발자를 폄훼하기 위해서인가. 아니다. 그냥, 좋은 능력을 가지신 분들이 보인 부적응 현상들이 안타까워서 그랬다. 이제는 경력과 신입을 동일선상에 놓고 보고 있다. 기술 질문도 차이가 거의 없어졌다. 다만 한 가지, 소통하는 능력이 있는지를 본다. 달리 말하면 배우고자 하는 열의가 있는지 반드시 보고 다음 면접으로 올린다.\n나는 꼬리에 꼬리를 무는 질문을 좋아한다. 그래야 이 사람의 대응 방식을 볼 수 있다. 꼬리를 물렸을 때 대개는 따가워한다. 싫은 거다. 그래도 답하고 되물어봐야 한다. 힌트를 달라고 해도 좋다. 시험이 아니라 면접인데, 좀 물어보면 어떤가. 나와 논쟁을 한 지원자도 있었다. 내용이 좀 틀려도 괜찮았다. 둘 모두 기술면접을 통과했다.\n비즈니스는, 의사소통은 학교에서 가르쳐주지 않는다. 그런데… 경력은 이미 경험한 것들이다. 경력을 뽑는 가장 큰 이유는, 적응력이 신입보다 좋을 거라 기대하기 때문이다. 그것이 기술적이건 의사소통 능력이건 간에 말이다. 둘 다 못하면, 지금처럼 동일 선상에 세울 수 밖에 없을 것이다.\n최소한 자신이 가진 아집 정도는 벗어주면 좋겠다. 그래야 저런 소리 안 듣고 귀한 평가를 받을 것이다.\n","date":"2019-05-12T12:40:26Z","permalink":"https://interp.blog/%EA%B2%BD%EB%A0%A5%EC%A7%81-%EB%A9%B4%EC%A0%91-%EB%8B%A8%EC%83%81/","title":"경력직 면접의 단상"},{"content":"메모로 남긴다.\n 사람은 모두 다르다. 아주 많이. 각자의 장점이 드러나도록 경험하게 해주고 발전하게 하라. 그리고, 장점과 그 성과를 열심히 칭찬해줘라. 무언가를 잘하는 사람은 결국 그걸 좋아하게 되어 있다. 무언가를 잘하고 좋아하게 되면, 자신의 자존감이 올라간다. 자존감이 올라간 후엔, 자존감을 지키지 위해서 알아서 움직인다.  이 말을 관통하는 TODO 는 딱 하나. 장점이 드러나도록 밀어주고, 칭찬해줘라.\n철칙처럼 지켜야 한다는 생각이 들었다. 여기에 내 생각을 덧붙인다.\n 뭘 잘하는지 찾는 건 굉장히 어렵다. 잘 한다고 생각했는데 통수맞을 확률이 생각보다 높다. 잘 하는데 하기 싫어하는 경우에 대한 과정도 중요하다. 일이란게 늘 그렇듯, 그 사람이 잘 하는 것만 시킬 수 없다. 이에 대한 과정 역시 중요하다. 사람이 늘 그렇듯, 단점이 크게 보인다. 못 본 척 하려고 노력하는 것도 쉽지 않을 정도로.  결론은, 이 철칙을 쉽게 지킬 수 없지만 지키기 위해 노력해야 된다는 것.\n참고로, 이 원칙은 육아에도 적용된다고 한다. 덧붙인 내 생각도 육아에 적용되겠단 생각을 해 본다.\n","date":"2019-05-09T06:29:40Z","permalink":"https://interp.blog/%EB%A6%AC%EB%8D%94%EC%9D%98-1%EC%9B%90%EC%B9%99/","title":"리더의 1원칙"},{"content":"\u0026lsquo;알고리즘 산책\u0026rsquo; 책 요약이다. 공측도라는 개념이나, 귀류법을 사용한 증명 등의 내용을 까먹지 않으려고 정리한다. 물론 이미 다 어릴 적 배웠겠지만, 다시 공부한다는 마음으로 정리하는 것이다.\n최대공측도는 최대공약수 같은 개념이다. 선분 A와 B가 특정한 길이로 측정이 가능할 때, 이 길이 중 가장 긴 길이를 최대공측도라고 하는 것이다. 이 값을 코딩으로 구하려면, 최대공약수를 계산하는 방법과 다르지 않을 것이다. (여기서 공측도 값이 되는 선분 길이는 자연수여야 한다.)\n그런데 19세기 조지 크리스털이 증명한 것은, 정사각형의 변과 대각선의 변을 동시에 측정할 수 있는 선분은 없다는 것이다. 왜일까? (다시 말하지만 공측도는 자연수이다.)\n귀류법을 통해, 정사각형의 변과 대각선의 변을 동시에 측정할 수 있는 선분이 있다고 가정해보자. 요약하자면, 이 선분으로 정사각형을 그리고, 또 그 정사각형에서 한 변과 대각선을 측정할 수 있는 선분 (공측도) 이 있고, 계속 이런 식으로 정사각형을 그려나가다 보면, 어느 순간 가장 작은 정사각형이 나올 것이다. 하지만 가정에 따르면, 이 경우에도 대각선과 공측도가 되는 선분이 존재할 수 있게 된다. 그렇다면 더 작은 정사각형을 그릴 수 있게 되므로 모순이 생긴다.\n그래서 대각선은 자연수가 아니라는 단서가 되었고, 이로 인해 무리수 $\\sqrt{2}$ 를 발견할 수 있게 되었다고 한다.\n","date":"2019-04-27T11:32:38Z","permalink":"https://interp.blog/%EA%B3%B5%EC%B8%A1%EB%8F%84%EC%99%80-%EB%AC%B4%EB%A6%AC%EC%88%98/","title":"공측도와 무리수"},{"content":"정갈한 한정식도 아니고, 욕쟁이 할머니가 내어 주는 재미있는 맛이 담긴 한 끼도 아니고, 그냥 쓱쓱 싹싹 콩나물과 보리밥에 눈물 참기름 한 방울, 매운 인생 맛 큰 숟갈 넣어 아구와구 비벼먹을 건데. 일기장은 이뻐봤자 나만 만족하는 것이다. 그런데 난 그게 중요하다고 보거든.\n개인적인 이야기와 바깥의 이야기를 구분했으면 해서 만든 것이 블로그였는데, 이제는 그 경계가 모호해진 것 같다. 그 외줄타기를 잘 해야 내 아이덴티티가 쇼윈도에 걸리는 것이긴 하지만, 난 양산형 마네킹이 아니니까 으레 생각하는 사람들과는 다른 기괴한 포즈를 취할 수 있다. 혐오감을 줄 수도 있고, 저놈 저거 노력하네 같은 행인들의 빈말 몇 마디 정도는 듣겠지.\n어릴 적에 그림을 그리거나 글을 쓰면 반 친구들 몇몇이 우루루 와선 돌려보곤 했다. 별 것 없는 내용, 뻔한 전개지만 내 나름 가장 활발한 리뷰어 (Reviewer) 들이었노라고 자부할 수 있다. 칭찬과 비난이 뚜렷이 섞인 말들은 이내 비난도 지쳐버린 자들의 과거속으로 숨어버렸다. 나도 그랬으니까. 그리고 내 글도 숨었다.\n숨기 싫어서 나온건데, 아직도 예쁜 일기장을 고르려 핫트랙스를 기웃거리는 중학생의 심정에서 벗어나질 못했다. 플랫폼은 뭘 하지? NAS 를 사서 내 개인 서버를 꾸며볼까? 책을 읽으려면 아이패드를 사야지? (글 쓰는데 왜 갑자기 아이패드야) 정신을 차려보니, 고민은 목적을 한참 벗어나서 멋대로 날뛰고 있었다.\n이제 이런 고민 다 필요가 없다. 묵묵히 쓰는게 짱이다. 예쁜 낙서장은 이제 그만 골라야겠다.\n","date":"2019-04-23T21:46:13Z","permalink":"https://interp.blog/%EC%98%88%EC%81%9C-%EB%82%99%EC%84%9C%EC%9E%A5%EC%9D%84-%EC%9B%90%ED%96%88%EB%8D%98-%EA%B1%B8%EA%B9%8C/","title":"예쁜 낙서장을 원했던 걸까"},{"content":"좌우명이 뭐냐고 물으신다면, 곁에 두고 보는 말 같은 진부한 설명 대신에 \u0026lsquo;예상치 못한 상황에서 생각이나 행동의 근거가 되는 첫 번째 기준이나 신념을 말로 표현한 것\u0026rsquo; 이라고 하고 싶다. 우리는 모든 상황을 가정하고 살 수도 없고, 모든 것을 경험하며 살 수도 없다. 모든 것이라는 집합 자체가 유한하지 않은 것이 첫번째고, 우리의 생 또한 무한하지 않은 것이 그 다음이다.\n그래서 내 좌우명은 무어냐고 또 물으신다면, 조금 생각을 해 봐야겠다. 내 초등학교 시절은 으레 다른 친구들이 그랬듯 위인전에서 나온 명언 중 마음에 드는 하나를 골라 좌우명이라고 정하고 다녔기 때문에, 당시 내 좌우명도 \u0026lsquo;시간을 금 같이 보라\u0026rsquo; 였다. 어, 이거 최영 장군은 조금 다르게 이야기한 것 같은데, 아무튼 난 이게 마음에 들었다. 시간은 소중히 써야 한다. 지나간 시간은 저축할 수 없기 때문에 매 순간 의미가 있어야 한다고 생각했나보다. 일기를 읽어보면 그런 것 같다.\n어린 시절의 어떤 치기로 선택받은 이 좌우명에 기름칠을 조금 해서, 지금의 내 좌우명을 정해본다. \u0026lsquo;더욱 오늘을 의미있게 살자\u0026rsquo;. 너무 달라졌는데? 하지만 의미는 확실히 살았다고 말하고 싶다. 시간이라는 단어는 단위로 설명할 수 없는 추상화된 개념이다. 시간을 소중히 써야 한다면, 특정 시간 단위를 집중해서 살자고 말하는게 더 설득력있어 보였다. 매 초 열심히 살자? 그렇다면 이미 성공한 횟수보다 실패한 횟수가 더 많다. 좌절 느끼기 딱 좋은 말이구만. 단위를 넓게 잡아 \u0026lsquo;하루\u0026rsquo; 라고 지었다.\n그냥 의미있게 살면 되지, 더욱은 뭘까. \u0026lsquo;어제의 나\u0026rsquo;를 통해 반성하고 칭찬하면서 \u0026lsquo;오늘의 나\u0026rsquo;를 더 의미있게 살게 할 수는 없을까? 하는 뜻이다. 이 말 대로 엄밀히 구분하자면, 어제와 오늘은 연속성이 없다. 하지만 인생이라는 끈 위에서는 모두 이어져있으니까. 그 위에서 줄타기를 해야 한다면 어제의 내가 했던 의미를 발전시켜 갈 수도 있고 잘못된 방향을 바로 잡아 앞으로 나아갈 수 있지 않을까.\n뜬금없지만, 영화 \u0026lsquo;아저씨\u0026rsquo; 에서 차태식 대사 중 유명한 것이 있다. \u0026lsquo;너흰 내일만 보고 살지.. 난 오늘만 보고 살아..\u0026rsquo; (뒷 말은 욕이니까 생략하고) 내일을 보고 사는 것은 오늘을 희생해서 내일의 불확실한 나에게 짐을 덜어주는 의미도 되겠지만, 오늘을 소비하고 내일의 나에게 책임을 떠넘긴다는 이중적인 의미로도 해석할 수 있다. 나는 둘 다 마음에 들지 않는다. 오늘의 내가 내일의 나에게 방향을 제시하고 이뤄놓은 것에 대한 설명은 해 줄 수 있겠지만, (계획에 없는데 의도적으로) 내일 해야 할 일을 오늘 몰아 하는게 과연 맞는가? 신용 카드를 긁으면서 내일의 내가 좌절해 줄 거라고 충동적으로 결정하는 게 과연 맞는가 말이다.\n그래서, 미래의 내가 덜 부끄럽게 과거의 내가 제시한 방향이 헛되지 않게 오늘은 의미있게 살아야 한다. 그 의미가 뭐냐? 글쎄, 그건 매일 달라질 수 있겠다. 위기를 극복하고, 성취를 만끽하고, 사고에 대처하고, 기쁠 때 기쁘고 슬플 때 슬퍼하고…\n물론 의미없는 날을 보낼 수도 있다. 내 의지와 다르게 흘러가는 날이 있을 것이고, 아니 오히려 그런 날들이 한 해에 더 많이 일어날 것이다. 그래도 지켜야 하는 것은, 그렇지 않은 날까지 내 의지와 무관하게 흘러가는 것 처럼 간주해서는 안 되는 소중한 시간들이기 때문이다. 지금 이 시간도 그렇다.\n 덧. 이걸 하려면 반드시 해야 할 일이 있다. 일기를 써야 한다. 무슨 내용이든 좋지만, 칭찬 6에 반성 3, 감상 1 정도의 비율로 적어주면 가장 좋다. 기분에 따라 감상 10이 될 수도 반성 10이 될 수도 있지만 너무 한 쪽으로 치우쳐 적으면 나중에 읽을 때 좀 오글거리고 읽기 싫어진다.\n","date":"2019-04-18T01:33:12Z","image":"https://interp.blog/uploads/flying_bg.jpg","permalink":"https://interp.blog/%EB%8D%94%EC%9A%B1-%EC%98%A4%EB%8A%98%EC%9D%84-%EC%9D%98%EB%AF%B8%EC%9E%88%EA%B2%8C-%EC%82%B4%EC%9E%90/","title":"더욱 오늘을 의미있게 살자"},{"content":"Windows Server 2016에서 OpenSSH 를 설치하고, cmd 에서 다음과 같이 RSA 키를 생성한다.\n$ ssh-keygen -t rsa 그러고 Public Key 를 SSH Server 에 위치한 authorized_keys 파일에 추가하고 접속을 시도하면?\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions for \u0026#39;C:\\\\Users\\\\interp/.ssh/id_rsa\u0026#39; are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Load key \u0026#34;C:\\\\Users\\\\interp/.ssh/id_rsa\u0026#34;: bad permissions interp@192.168.0.30\u0026#39;s password: 오잉? 내 파일이 맞는데 이게 뭘까. Private Key 파일에 마우스 우클릭을 하고 봤더니 여러 사용자가 읽기 권한으로 걸려 있는 것을 확인할 수 있었다. 이건 아니다… 등록된 사용자를 전부 지우고 현재 사용자에게 모든 권한을 준 다음에, 확인을 눌러 권한 변경을 해 준다.\n\u0026lsquo;편집\u0026rsquo; 에 가서 등록된 사용자를 지우려고 하면, 상속으로 인해 지울 수 없다는 괴상한 에러가 뜰 것이다. 그러니까 위 화면에서 \u0026lsquo;고급\u0026rsquo; 으로 간 다음, 아래 캡처에 있는 \u0026lsquo;상속 사용 안 함\u0026rsquo; 을 클릭하면 자동으로 지워진다. 그 다음 시도하면, 잘 된다!\n출처 : https://superuser.com/questions/1296024/windows-ssh-permissions-for-private-key-are-too-open\n","date":"2019-03-18T04:50:30Z","image":"https://interp.blog/images/featured/ssh-rsa.jpg","permalink":"https://interp.blog/windows-ssh-rsa-key-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/","title":"Windows SSH RSA Key 문제 해결"},{"content":"햇살이 드리우는 책상 앞에 따뜻한 아메리카노 한 잔을 두고, 논문을 집어들어 책갈피 너머의 페이지로 넘겨 보는 나 자신을 상상하는 모습을 그려본 적이 있다. 학창 시절 때는, 집중해서 공부하는 지금 이 순간의 내 모습을 내가 본다면 어떤 기분일지 상상한 적도 있다. 그러면 이내 흐트러지고, 방금 전 몰두하던 이는 찾아볼 수 없게 되었다.\n자신이 그리는 이상을 직접 행하고 있을 때는, 그 상황을 자신이 그려왔던 것인지 알 수 없는 경우가 많다. 왜냐하면, 실제로는 그 장면이 아름답거나 만족하는 순간이 될 수 없기 때문이다. 바로 이런 장면을 보려고 하는 나 자신이 잠시 사라지는 순간이다. 숙제를 하거나, 일을 하거나, 연습을 하거나, 게임을 하거나, 그 장면 자체는 멋져보일 수 있겠지만 그 속에 있는 정신은 이루 말할 수 없는 수 많은 것들에 신경을 쓴다. 그것들은, 안에 들어있는 것들은 결코 아름답거나 원한 것이 아니다. 물론 이 과정, 이 결과를 상상하는 사람이 돌리는 쳇바퀴일 수 있다. 하지만 이 순간을 바라보는 사람은 동시에 존재하지 않는다.\n알아차리게 되더라도, 그 순간의 심적 평화는 깨지기 마련이다. 마치 유체이탈이라도 한 양, 관찰자로 빠져나간 빈 껍데기 같은 정신은 그 순간을 유지할 힘을 잃어버린다.\n우리는 사실 뒹굴거리고 싶고, 닥치는 대로 먹고 마시고 싶다. 그러나 우리가 계속 \u0026lsquo;우리의 이상적인 순간\u0026rsquo;을 그려야 하는 이유는, 객관화라고 착각하지만 사실 사회에서 배워 온 \u0026lsquo;편견\u0026rsquo; 속에서 우리를 가두고자 하는 희미한 의지 때문이다. 그 편견의 이미지를 지키는 이유는, 바로 주위 사람들 때문이다. 내 시선이 아닌 다른 시선에 의존한다. 왜? 우리는 언제나 외롭기 때문이다.\n외로움을 선택한 사람들이 있다. 햇살도 없는 바로 그 곳에서.\n","date":"2019-02-11T06:44:30Z","permalink":"https://interp.blog/%EC%9A%B0%EB%A6%AC%EC%9D%98-%EC%9D%B4%EC%83%81%EC%A0%81%EC%9D%B8-%EC%88%9C%EA%B0%84/","title":"우리의 이상적인 순간"},{"content":" The world will not be destroyed by those who do evil but by those who watch and do nothing. 세상은 악당들 때문에 망하는 게 아니라, 악한을 보고도 아무것도 하지 않는 자들 때문에 망한다.\n– Albert Einstein\n 이 말을 선거철에 쓰면 투표를 독려하는 것이고, 경찰서 앞에 붙어있으면 투철한 신고정신을 고취시키는 것이다. 책상 앞에 붙인다면 어떻게 될까. 나쁜 습관이나 언행, 과오를 그냥 보고 넘기면 내가 망한다. The life will not be destroyed by wrong things I did but by me who watch and do nothing afterward.\n이게 내 천성이고 고치기 힘든 것이라서 쉽게 포기하는 것이다. 악당은 원래 더 똑똑하고 힘 세다. 하지만 우리는 힘을 모아서 신고도 하고 투표도 한다. 그 과정이 하루 아침에 이뤄지지도 않는다. 뜻을 모으고, 힘을 모으고, 계획을 세운다. 결과가 잘 안될 수도 있다. 하지만 노력한다. 만약 성공하면, 통제 불가능해 보였던 악한이 사라지고 평화를 맞을 수 있다는 그 기대감으로.\n인생도 마찬가지다. 끊임없이 나와 투쟁해야 한다. 사실 힘든 것도 잘 안다. 하지만 우리는 기대한다. 통제 불가능한 내 약점이 사라지고 좀 더 멋진, 그리고 더 나은 인간으로서 인정받으면서, 나에게도 다음 과업을 처리할 수 있는 시간을 주는 것.\n이 스트레스는 필연적으로 부여받은 하나의 업보일 뿐이다. 피하려 하면 할수록 절대로 피할 수 없다는 사실을 깨닫게 될 것이다. 가만히 지켜보고 아무것도 하지 않는 자는 인생을 망친다.\n","date":"2018-11-15T04:15:23Z","permalink":"https://interp.blog/%EB%82%98%EC%81%9C-%EA%B1%B4-%EB%8B%B9%EC%97%B0%ED%95%9C%EA%B2%8C-%EC%95%84%EB%8B%88%EB%8B%A4/","title":"나쁜 건 당연한게 아니다"},{"content":"Gitlab Community 에서 필요로 하는 기능인데, 이렇게 수동으로 할 수 있어서 간단히 남긴다. Gitlab 에 있는 merge request 에 보면 다음 옵션이 있는데, 전부 체크가 해제되어 있다.\n Merge Request 에 성공한 Source Branch 를 삭제 Merge Request 할 때 Commit 을 하나로 뭉쳐서 Merge (=Squash Merge)  이 체크박스를 개발자가 일일해 해 줘야 하는 문제가 있다. 그래서 어떤 개발자는 체크하는 것을 까먹었다가 master branch 의 commit tree 를 엉망으로 만들기도 한다. 이 문제를 그냥 없애기 위해, 체크박스 표시를 그대로 두도록 하면 어떨까 고민하던 차에, 해결방법을 알아냈다.\n /opt/gitlab/embedded/service/gitlab-rails/app/views/shared/issuable/form/_merge_params.html.haml 을 편집기로 연다. check_box_tag 항목으로 시작하는 줄이 두 군데 있는데, 아래와 같이 다음 내용을 \u0026lsquo;추가\u0026rsquo; 한다.  = check_box_tag \u0026#39;merge_request[force_remove_source_branch]\u0026#39;, \u0026#39;1\u0026#39;, issuable.force_remove_source_branch?, class: \u0026#39;form-check-input\u0026#39;\u0026lt;span style=\u0026#34;color: #ff0000;\u0026#34;\u0026gt;, checked: \u0026#39;checked\u0026#39;\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color: #0000ff;\u0026#34;\u0026gt;# ... blahblah\u0026lt;/span\u0026gt; = check_box_tag \u0026#39;merge_request[squash]\u0026#39;, \u0026#39;1\u0026#39;, issuable.squash, class: \u0026#39;form-check-input\u0026#39;\u0026lt;span style=\u0026#34;color: #ff0000;\u0026#34;\u0026gt;, checked: \u0026#39;checked\u0026#39;\u0026lt;/span\u0026gt;``` 다 했다면 gitlab-ctl reconfigure \u0026amp;\u0026amp; gitlab-ctl restart 로 Gitlab 서버를 재시작한다.\n","date":"2018-11-13T05:03:22Z","permalink":"https://interp.blog/set-gitlab-merge-request-checked/","title":"Gitlab merge request 옵션 기본으로 두기"},{"content":"무더위가 찾아온 일상, 낮과 밤의 하늘은 여전히 아름답다.\n낮 / 구로디지털단지\n밤 / 온수역\n","date":"2018-08-15T04:06:31Z","permalink":"https://interp.blog/%EB%AC%B4%EB%8D%94%EC%9A%B4-%EB%82%AE%EA%B3%BC-%EB%B0%A4/","title":"무더운 낮과 밤"},{"content":"객체를 움직일 때 방향키로 이동하면, 예전에는 한 칸씩 움직이는 것 처럼 느껴졌는데 최근에 들어서는 정말 1픽셀 만큼만 이동해서 귀찮음을 유발하곤 한다. 이렇게 답답하게 움직이는 걸 되돌리기 위한 해결 방법이다. 별 건 없지만\u0026hellip;\n  보기 탭으로 표시 항목에서 \u0026lsquo;확장 아이콘\u0026rsquo;이 아주 작게 보인다. \u0026lsquo;눈금 및 안내선\u0026rsquo; 이란 제목의 창이 뜨며, 여기서 \u0026lsquo;개체를 눈금에 맞춰 이동\u0026rsquo; 을 클릭한다.  끝이다. 참고로 개체 이동 간격을 제어하려면 (3) 번에서 눈금 간격을 조정하면 된다!\n","date":"2018-08-12T06:53:39Z","permalink":"https://interp.blog/powerpoint-shape-move-faster/","title":"Powerpoint 에서 방향키 이동이 너무 느릴 때"},{"content":"고요한 호숫가에 조약돌을 던지면, 주위에서 파장이 일어나지만 이내 움직이지 않는 수심 속으로 들어간다. 작은 물웅덩이에 조약돌을 던지면, 존재를 잃어버릴 만큼 가지고 있던 흙탕물을 사방으로 튀겨낸다. 물웅덩이의 입장에서는 날아오는 돌의 의미를 알 수 없다. 자신의 존재가 부정당하기 직전인데 그럴 여유가 없을 것이다. 하지만 호수는 여유가 있다. 일단 의미를 파악하는데 약간의 시간이 걸리긴 하겠지만, 어느샌가 돌을 받아주고는 깊숙한 어딘가에 넣어둔다.\n자신에게 잔소리하지 않았으면 하는 태도로 일관하는 사람이 있다. 필요한 커뮤니케이션도 잔소리로 받아서 문제다. 마치 그 지적을 받아들면 자신의 과업이 부정당하는 것 처럼. 그냥 문제가 있으면 그런가보다 하고 받아들이면 되고, 오해하고 있다면 해명해주면 된다. 그게 전부다. 화내고, 우울해하고, 보복할 준비를 하는 등의 불필요한 행동은 에너지 낭비다.\n조직 생활에서는 하나의 목표를 위해 지적도 당하고 지적도 하며 살아야 한다. 동상이몽라고 할 만큼 사람은 생각하는 바가 전혀 다르다. 그 사이를 메꾸기 위한 고통스런 의사소통은 피할 수 없다. 예민하게 굴거나, 아예 기만하는 행동은 의사소통에 도움이 되지 않는다. 지적을 받을 때는 최대한 고요하게, 필요한 대응만 하고 묻어두는 것이 차라리 좋다.\n","date":"2018-07-16T02:46:58Z","image":"https://interp.blog/uploads/2018/07/lake.jpg","permalink":"https://interp.blog/%EA%B3%A0%EC%9A%94%ED%95%9C-%EB%A7%88%EC%9D%8C%EC%97%90-%EC%A1%B0%EC%95%BD%EB%8F%8C-%ED%95%98%EB%82%98/","title":"고요한 마음에 조약돌 하나"},{"content":"이 책은, 접근부터 굉장히 쉬웠다. 리디북스1에서 무료 대여 기간이 있었고, 동시에 많은 북 큐레이션 페이지에서 이 줄거리를 카드 뉴스나 동영상2으로 홍보했기 때문이다. 그리고 줄거리가 충분히 구미가 당길 만한 내용이었다. 과거를 버리고 평범한 삶을 살아가는 남자에게 들이닥친 불행한 과거로부터의 편지 한 통. 악한을 죽여달라는 그 때의 약속을 반드시 지켜달라는 내용이란다. 이 남자의 과거는? 편지의 발신인은? 궁금한 나머지 빠르게 읽어내려갔다.\n줄거리 도입부는 주인공의 평범한 일상을 소개한다. 레스토랑과 바를 겸하는 식당의 공동 창업자이자 바텐더로, 사랑하는 아내와 초등학교를 다니는 귀여운 딸을 둔 가장으로. 하지만 그는 어두운 과거를 꽁꽁 숨겨둔 채 살아간다.\n그는 사실 얼굴에 다 드러날 정도의 큰 멍을 가진 사내로, 어릴적 멸시와 동정을 이기지 못하고 강도짓을 일삼는다. 그러다 시비가 붙어 야쿠자에게 쫓기는 신세가 되었고, 그 와중에 한 노인을 만난다.\n노인은, 자신의 딸이 파렴치한 두 남성에게 납치되어 겁탈당한 뒤 살해당했다고 한다. 그런데 그 두 피의자에게 사형 선고가 아닌 15년형이 내려진 것에 분노하며, 자신은 이제 기력이 다 했으니 원하는 대로 돈을 받고 두 사람을 죽여달라는 약속을 하나 해줄 수 없겠느냐고 한다. 주인공은 심하게 갈등하지만, 야쿠자에게 붙잡혀 송장이 되기 싫었던 주인공은 \u0026lsquo;지키지 않아도 될 약속\u0026rsquo; 쯤으로 생각하고 약속을 한 뒤 돈을 받는다.\n그 뒤 성형수술과 무연고자의 호적을 통해, 가족이 생기고 전혀 다른 삶을 이어나가고 있었는데\u0026hellip; 15년 후 집으로 편지 한 통. 바로 그들이 출소했다는 소식. 약속을 지키지 않으면 가족을 해치고 똑같은 고통을 느끼게 해주겠다고 협박한다. 주인공은 어떻게 해야 할까.\n복선 회수 드라마를 즐겨 본다면, 책에서 다발성 복선을 느낄 수 있다. 이런 장면들은 자체로는 별 의미가 없거나 생뚱맞은 장면들이 많지만, 전개 과정에서 이 숨겨둔 힘이 마치 콤보처럼 터진다. 아니 왜 갑자기 생판 남의 자식과 남자 주인공을 오버랩 시키지? 남자가 사귀자는데 여자의 저 오묘한 표정은 뭐지?\n그런데 역으로, 누가 봐도 복선같이 보이는 장면들이 사실은 아무런 의미없는 장면이 되는 경우가 간혹 있다. 메인 커플을 훼방놓기 위해 유학길에서 돌아온 남자 주인공의 소꿉동생이, 질투 몇 번 하더니만 둘 사이를 축하해주는 들러리로 전락한다든지.\n아무튼, 이 책은 복선 회수라는 점에선 소홀히 하려 들진 않는다. 결말에 도착하면 뭔가 \u0026lsquo;아, 잠깐만. 그래서 그때?!\u0026rsquo; 라는 느낌표가 계속 뜬다. 아쉬운 것은, 갑자기 이 모든 원흉이 된 숨겨진 과거사를 드러내는 시점이 갑작스럽다는 것이다. 마치 (작가는 절대 그렇게 쓰지 않았겠지만) \u0026lsquo;자, 이 사건으로 내가 결말을 다 설명할건데, 사실은 앞에 뿌려둔 복선을 회수하고 싶어서 ㅎㅎ\u0026rsquo; 라고 하는 것 같았다.\n몰입도 그렇다고 이게 \u0026lsquo;결말을 이끄는 힘이 부족하다\u0026rsquo; 라고는 할 수 없다. 다음 내용이 사실 궁금해질 수 밖에 없도록 만들었으니까.\n주인공은 편지를 받고 편지의 발신인을 찾기 위해 (밤에 일을 하니까) 낮에 돌아다니다가 와이프에게도 의심받고 동업자에게도 의심받는 상황에 처한다. 그런데 편지를 보낸 사람은, \u0026lsquo;나는 영혼이다. 너가 뭘 하는지 다 보고 있다. 뭐하냐, 출소했다니까 그때 했던 약속대로 죽여달라\u0026rsquo; 라고 한다. 그러면서 (그 영혼은) 회사에도 전화를 하고, 안 받으니까 스마트폰을 배달해서 지시를 하고, 상황은 점점 더 옥죄어 오는데 누가 이러는지는 전혀 갈피를 못 잡는 것이다.\n스포일러 : : 정말 영혼인가? 날 쫓던 야쿠자인가? 같이 나쁜 짓을 했던 녀석 중 한명의 짓인가? 그 노인이 자주 간다던 \u0026lsquo;억울한 피해자 모임\u0026rsquo; 의 사람 중 한명인가? 그 와중에 타겟 두 명 중 한명에게 찾아가지만 차마 죽이지 못했는데, 다음날 타겟은 살해당하고 자신은 누명을 썼다.\n이제 정말 끝인가, 벼랑 끝으로 내모는 속도가 빠르다. 결말에 다다르면 전부 ta-da 하고 보여주지만, 그 전까지는 독자들도 끝자락으로 내몬다.\n마치며 교보문고에 갔더니 이 책이 소설 베스트셀러 4위더라. 솔직히 많이 놀랐다. 절박한 주인공으로 만들어버리면서 동시에 주인공의 기민한 위기대응을 보여주는 빠른 전개, 주인공 주변에 흩뿌려진 많은 주변인들 사이에서 벌어지는 복선들의 철저한 회수에는 점수를 후하게 주지만 스토리 전체를 놓고 봤을 때는 끝에서 힘을 다 빼버리는 느낌이 강했기 때문이다. 좀\u0026hellip; 실소가 나올 정도로.\n마치기 전에, 나는 엉뚱한 곳에 시선이 갔다. 주인공이 동료에게 돈을 주고 새로운 호적을 받는 장면이 있다. 주인공이 \u0026lsquo;이 사람은 누구야?\u0026rsquo; 라고 묻자, \u0026lsquo;그 사람은 연고도 없고, 지금 어떻게 됐는지는 묻지마\u0026rsquo; 라고 답한다. 이 호적의 원래 주인이 범인이었으면 어땠을까. 너무 뻔했을까. 나는 결말을 알기 전에는 이 장면이 보이지 않았으니, 나에겐 꽤나 신선했을 것 같다.\n  https://ridibooks.com/v2/Detail?id=1013000004\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.youtube.com/watch?v=2AZjY5PGPhg\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2018-07-14T15:16:15Z","image":"https://interp.blog/%EB%8F%8C%EC%9D%B4%ED%82%AC-%EC%88%98-%EC%97%86%EB%8A%94-%EC%95%BD%EC%86%8D/inevitablepromise_hu654bfb8f2ead5605b563894937802a0e_167097_120x120_fill_q75_box_smart1.jpg","permalink":"https://interp.blog/%EB%8F%8C%EC%9D%B4%ED%82%AC-%EC%88%98-%EC%97%86%EB%8A%94-%EC%95%BD%EC%86%8D/","title":"돌이킬 수 없는 약속"},{"content":"요즘 말하는 욜로(YOLO) 에 가까운 삶을 사는 친구가 있다. 일단 불안한 계약직인데다 계약 텀도 굉장히 짧은 직종에 근무한다. 그런데도 잘 놀러 다닌다. 너무나도. 그러면서 늘 걱정을 늘어놓는다. 좋은 남자 만나 결혼해야지, 정규직도 되면 좋겠지, 계속 놀러 다니고는 싶지…\n이런, 쓰고 보니 이 친구는 욜로가 아니다. 내일 살 걱정을 하기는 하니까. 아무튼, 이 친구의 문제는 뭘까, 혹시 쾌락의 끝자락에서 내려오기 싫은 발버둥을 치는 것은 아닐까, 아니면 더 큰 것을 가질 수 없는 공허함을 느낀 걸까.\n술을 마시던 게임을 하던, 그 때만 즐거을 뿐이다. 숙취에 고통받을 때, 게임 종료 버튼 앞에 있을 때, 우리는 다시 비어있음을 느낀다. 쾌락의 순간에는 더 큰 역치를 넘어서지 못하는 한계에 부딪히며 파열을 발생시키는 게 아닐까. 그것이 허무감인지, 어떤건지 잘 모르겠다.\n더 큰 보상을 바라는 뇌의 요구와, 중독적인 일 외에 할 수 있는 일을 하나씩 배제시키는 습관의 힘이 합쳐진 것을 우리는 중독이라고 한다. 올바른 (적어도 사회적으로 올바르다고 여겨지는) \u0026lsquo;성취\u0026rsquo;의 대부분은, 즉각적인 보상으로 이어지지 않는다. 그래서 상벌이 바로 튀어나오는 행위에 우리는 열광한다. 시간을 들여 보상이 주어지는 성취에 점점 관심을 잃는 것이다. 하는 방법도, 버틸 힘도 잃어버린다.\n습관은 더 무서운데, 뇌의 보상기제가 작동하건 말건 이 녀석은 항상 LRU (Least Recently Used) 리스트처럼 행위를 관리한다는 것이다. 자주 한 일일수록 쉽게 선택되고, 전혀 해보지 않은 일 (하지만 한번 쯤 해봐야지 하며 버킷리스트에 채워넣었던 일) 은 선택되기 힘들게 한다. 즉, 새로운 도전은 그만큼의 비용이 들지만, 곁에 둔 습관은 그렇지 않다는 것이다. 반복적인 행동은, 그것이 나쁘건 좋건 간에, 여유 시간에 \u0026lsquo;그냥 할 만한 것들\u0026rsquo;의 유력한 후보로 항상 존재할 것이다. 그 후보는 2선, 3선을 밥먹듯이 할테고, 질 나쁜 행동이 고착화되면 언젠가는 부패할 것이다.\n잘못된 습관과 보상기제로 인해 정해진 중독적 행위가 과연 현재를 즐기자라는 다소 낙관적인 말로만 포장될 수 있는지에 대해 숙고해 봐야 한다는 것이다. (잘못됐다는 말을 쓰는걸 별로 좋아하지 않지만, 뭔가 내가 하는 일이 이상하다고 생각된다면 그건 잘못된 거다. 애석하게도.)\n소미의 옆집 아저씨도 \u0026lsquo;오늘만 산다\u0026rsquo;고 말하지만, 욜로라고 하지 않는다. 다음을 걱정을 하는 자에게, 중독을 이어가는 이 허무함은 더 고통스럽지 않을까? 그래서 이 신조어는, 실제로 그런 극단적인 허무감을 회피하지 못한 비웃음의 단어는 아닌지, 아니면 정말 해탈했다고 자랑하고 싶은건지 의심스럽기만 하다.\n","date":"2018-06-03T15:18:03Z","permalink":"https://interp.blog/%EC%A4%91%EB%8F%85%EC%A0%81-%EC%8A%B5%EA%B4%80/","title":"중독적 습관"},{"content":"두 여자가 서로 다른 방향을 보고 있지만, 그 얼굴 안에서는 마주보기도 하는 듯, 흑심을 품고 있는 듯한 이미지가 프랙탈처럼 나타나 있는 기괴한 표지에 담긴 내용은 대체 어떤 사연일까?\n출판사 \u0026lsquo;황금가지\u0026rsquo;에서 만든 새로운 라인업 \u0026lsquo;수상한 서재\u0026rsquo; 시리즈의 첫 작품인 김수안 작가의 암보스1를 읽어봤다. 시간이 없어 서울-대구를 오가는 KTX 안에서 읽었는데, 다소 두꺼운 외형과는 달리 꽤나 빨리 따라갈 수 있었다.\n암보스 (ambos)2 는 스페인어로 \u0026lsquo;양쪽, 두 사람\u0026rsquo; 이란 뜻이다. 두 여자가 주인공인 것을 표현하고자 했겠으나, 실제로 스페인어는 남성형/여성형 명사가 따로 존재한다. 그래서 표지만 보고는 왜 암바스 (ambas) 라는 여성형 명사를 채택하지 않았을까 자뭇 궁금해졌다. arm boss 같은 느낌도 있어서 나중에 작가 인터뷰를 보니, 두 주인공만을 위한 제목이 아닌 여러 인물들의 관계 자체를 암보스로 봤기 때문이라고 한다.\n줄거리 신문 기자 이한나는 어느 날 방화사건 현장에 있었고, 목격한 모든 정보를 회사에 전달한 뒤 의식을 잃었다. 이대로 죽는건가? 아니, 죽는 것도 나쁘지 않겠지. 무능하고 철면피인 아버지가 진 빚이며, 헤어진 남자친구며, 내가 잘못 굴린 펜으로 사람이 곤란에 겪었으니까. 깨어나보니, 이한나는 다른 사람이 되어 있었다. 같은 날 옥상에서 뛰어내렸지만 가까스로 목숨을 건졌던 강유진이란 사람으로. 이한나는 퇴원하자 마자 강유진의 집을 찾아갔는데, 별안간 이한나의 모습을 한 누군가가 뒤따라 찾아왔다. 그는 강유진이었다. 몸이 뒤바뀐 것이다. 어떻게 된 일일까.\n초자연은 중요한 게 아니다 하지만 책은 왜 이들의 몸이 바뀌었는지는 독자들에게 이야기해주지 않는다. 누군가가 상대방의 몸을 원했다면, 영화 \u0026lsquo;더 게임\u0026rsquo;3 의 강회장 (변희봉 扮) 같은 캐릭터가 나와야 하겠지만, 여기선 어느 누구도 그런 역을 자처하지 않는다. 그보다는, 서로의 삶에서 느끼는 \u0026lsquo;잃은 것과 얻은 것의 의미\u0026rsquo;를 알아가고 행동하는 데에 많은 부분을 할애한다. 강유진은 비만에 집에 틀어박혀 지내기 일쑤지만 돈이 많았고, 이한나는 예쁜데다 활기차고 자기주관이 강했지만 안하무인 아버지로 인해 많은 빚을 졌다.\n설마 강유진의 모습을 한 이한나가 \u0026lsquo;나는 열심히 운동해서 살을 빼야지\u0026rsquo; 라거나 \u0026lsquo;이제부터 사람들과 잘 어울려야지\u0026rsquo; 같은 뭐 이런 희망적인 스토리를 기대하지는 말자. 그들은 언젠가 다시 본래의 상태로 돌아갈 것이라고 확신하고 있었다. 정확히 말하자면 강유진이 \u0026lsquo;그렇게 될 것\u0026rsquo;이라고 이야기했지만. 아무튼 그렇게 돌아가버린다고 가정했을 때 이들은 어떤 행동을 하게 될 것인가. 상대방의 미스터리한 행적이 서로의 시선을 통해 서술되기 시작한다.\n갑자기 교차되는 사건 시간이 지나면서 연쇄살인사건, 그리고 그 범인을 찾는 형사가 교차되어 나타난다. 일면 관련없어 보이는 사건 이야기가 갑자기 주인공 일행의 서사와 겹치면서 충돌하기 시작한다. 그것도 아주 빠르게. 파열음은 의외로 강하고, 당사자들의 추리 게임은 꼬리에 꼬리를 문다.\n이 시점에서 가장 눈에 띄는 것은 단연 박선호 형사일 것이다. 우락부락한 체격과 어울리지 않게 집요하리만치 파고드는 집중력이 소설 내내 돋보인다. 그 옆을 따르는 부사수 칠범 역시 파트너 역할에 충실한다. 이한나의 가족과 주변인, 그리고 강유진의 증언 등을 토대로, 사건 이후 사람이 뭔가 달라졌다는 의혹을 끝까지 물고 늘어지는데, 이 부분에서 주인공 일행과의 긴박한 밀당이 계속 이뤄진다. 결국 살인사건은 실마리를 찾고 해결되지만, 이게 정말 끝일까?\n소설이 이야기 하는 방식 소설이 가지는 강점은 심리 묘사와 비유에 많은 에너지를 쏟았고 그걸 고스란히 전달하려고 노력했단 점이다. 사건의 진위가 아니라, 사건에 휘말린 인물의 세세한 면면을 나타내려고 애를 썼다. 그래서 스토리 자체에 태클을 걸면서 본다면 자칫 넘어지기 쉬울 것 같아 보이긴 하지만, 그런 세세한 부분을 너그러이 이해해준다면 재밌게 읽힐 소설이 될 것이다.\n작중 이한나의 시점, 박선호 (를 포함한 외부)의 시점에서는 이한나와 강유진을 지칭하는 자아가 서로 다른 것이 신선했다. 이한나의 시점에서 서술될 때는 \u0026lsquo;나\u0026rsquo; 와 \u0026lsquo;(내 모습을 한) 강유진\u0026rsquo; 이지만, 그 외에는 외모대로 \u0026lsquo;강유진\u0026rsquo; 과 \u0026lsquo;이한나\u0026rsquo; 로 서술된다. 박선호가 이를 눈치챈 종반부에서는 서술이 다시 뒤바뀌긴 하지만. 그래서 이 부분을 따라가기가 조금 피곤해 질 수는 있겠다.\n마치며 독자에게 추리할 여지를 많이 주는 것 같지만, 사실 복선은 야속하게 정류장을 지나치는 시내버스 같이 지나간다. 어느샌가 소설 속 인물들의 추리보다 한발 앞서 나간게 아닐까, 그랬던 거였어! 라고 생각하고 있다면, 조심해야 한다. 끈적한 손으로 뒤통수를 후려갈겨서 뒷맛이 찜찜하다. 이게 뭐야, 꼭 그렇게 했어야만 했냐! 같은 느낌. 하지만, 역으로 생각해보면 책을 한번 더 돌려보게 만드는 매력을 지니고는 있다고 볼 수 있다.\n소설 중에 이런 내용이 있다. 강유진의 모습을 한 이한나가 창문을 바라본다. 창문에는 강유진이 보인다. 내가 정말 나인지, 상대방이 내 모습을 하고 유리창에 나타난건지, 정말로 상대방이 내가 된건지. 나는 누구일까.\n사람의 몸이 뒤바뀐다는 초자연적인 전개에만 관심을 가지면 이 소설은 거기서 끝난다. 상대방의 거죽을 쓰고 자신도 몰랐던 민낯이 드러나는 것을 보고 나면 다른 생각이 들 것이다.\n  http://www.yes24.com/24/goods/59681102\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://spdic.naver.com/#/entry/esko/2890825\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://movie.naver.com/movie/bi/mi/basic.nhn?code=66617\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2018-04-24T13:44:54Z","image":"https://interp.blog/uploads/2018/04/010-2.jpg","permalink":"https://interp.blog/%EC%95%94%EB%B3%B4%EC%8A%A4-ambos/","title":"암보스 (ambos)"},{"content":"Test-And-Set (TAS) TAS 를 이용해서 간단한 동시성 제어를 할 수 있다. testAndSet 이라는 function 을 가지고 아래의 do...while 문을 쓰레드 A, B 에서 동시에 호출한다고 해 보자. 이 때 lock 은 같은 변수이다.\nfunction TestAndSet(boolean_ref lock) { boolean initial = lock lock = true return initial } do { while(TestAndSet(\u0026amp;amp;lock)) ; // do nothing  // critical section  lock = false; // remainder section } while(true); 우선 TestAndSet() 은 다음과 같은 일을 한다. 말 그대로 \u0026lsquo;지금 값이 무엇인지 검사하고, 값을 바꾼다\u0026rsquo; 는 것이다.\n lock의 현재 값을 저장해 둔다. lock의 값을 true 로 설정한다. 저장한 lock 의 값을 반환한다.  그럼 이걸로 어떻게 아래 block 의 critical section 에 대한 동시성 제어를 할 수 있을까? Thread A 가 먼저 실행했다고 가정하면, 이런 시나리오가 된다.\n A : TestAndSet() 의 반환값이 false 이다. while 문을 빠져나온다. B : TestAndSet() 의 반환값이 true 이다. (A가 true로 두고 나왔기 때문에) while 문에서 계속 돈다. A : Critical Section 수행 후, lock 을 false 로 바꾼다. B : 여러 번의 TestAndSet() 호출 후에, 드디어 반환값이 false 가 되었다  (A가 false 로 두고 나왔기 때문에) while 문을 빠져나온다.  자, 그런데 뭔가 이상하다. 이렇게 이상적으로 동작하지 않을 것 같다. TestAndSet() 함수를 라인별로 동시에 실행한다고 하면 이런 사단이 날 수 있다.\n A : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다. B : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다. A : TestAndSet() 에서 lock 값을 true 로 바꾼다. B : TestAndSet() 에서 lock 값을 true 로 바꾼다. A : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다. B : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다. A \u0026amp; B : 모두 동시에 critical section 을 수행한다.  그럼 어떡하나? TestAndSet() 은 그래서 저런 함수만으로는 안 되고 Test-And-Set 의 연산이 일관되도록 조정해야 한다. 함수 안에 spinlock 을 쓰면 되겠네요? 싶겠지만 lock 구현하자고 lock 을 또 만드는 건 아닌 것 같다. 그래서 Test-And-Set 은 CPU에서 지원하는 Atomic Instruction 을 사용한다.\nFetch-And-Add : Ticket Lock Atomic Operation 으로 구현할 수 있는 Lock 중에 Ticket Lock 이 있는데, Fetch-And-Add 로 구현할 수 있는 방법을 알아보자.\nticketLock_init(int *next_ticket, int *now_serving) { *now_serving = *next_ticket = 0; } ticketLock_acquire(int *next_ticket, int *now_serving) { my_ticket = fetch_and_inc(next_ticket); while(*now_serving != my_ticket) {} } ticketLock_release(int *now_serving) { now_serving++; } TAS 의 케이스를 이해하고 본다면 별 다른 설명이 필요 없을 것 같다.\n Table Lock 초기화를 한다. A : Table Lock 을 얻으려 한다. 이미 얻었던 my_ticket (0) 과 now_serving (0) 이 같은 값이므로 곧바로 빠져나온다. B : Table Lock 을 얻으려 한다. 이미 얻었던 my_ticket (1) 과 now_serving (0) 이 다른 값이므로 while 문에서 대기한다. C : Table Lock 을 얻으려 한다. 이미 얻었던 my_ticket (2) 과 now_serving (0) 이 다른 값이므로 while 문에서 대기한다. A : Table Lock 을 해제한다. now_serving (0) 을 증가시켜 now_serving (1) 을 만든다. B : 비로소 Table Lock 을 얻었다. (C는 여전히 대기 중이다.)  여기서 핵심은 fetch_and_inc 인데, 마찬가지로 얻어오는 루틴과 값을 증가시키는 루틴이 따로 떨어져 있으면 중복된 티켓을 들고 기다리는 쓰레드들이 발생할 수 있다. 따라서 이것도 atomic operation 이 되어야 한다.\n","date":"2018-04-24T02:31:38Z","permalink":"https://interp.blog/atomic-operation-%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/","title":"Atomic Operation 으로 하는 동시성 제어"},{"content":"알고리즘 강의를 들었다면, 가장 빠른 정렬 알고리즘이 뭐냐는 질문에 곧장 Quicksort 라고 답할 수 있을 것이다. 실제로 현업에서도 적용하기 가장 편하기 때문에 많이 차용되는 편이다. 그런데 모든 문제를 쉽게 풀 수 있는 은탄은 세상에 존재하지 않듯, Quicksort 역시 특정 케이스에서는 성능이 낮게 나오는 경우가 있다. 더 심각한(?) 것은, 이 특정 케이스가 현실에서는 꽤나 자주 발생한다는 것이다.\n그 케이스란 바로 \u0026lsquo;거의 정렬된 데이터\u0026rsquo; 이다. 거의 정렬된 데이터라면 pivoting – partitioning 을 반복할 필요도 없이 Bubble Sort 나, 심지어는 Insertion Sort 를 해도 된다. Bubble Sort 의 경우엔 알고리즘 복잡도가 n2 이지만 compare 과정에서 조기에 끝날 가능성이 매우 높아 비용이 거의 발생하지 않을 것이고, Insertion Sort 도 비슷한 이유로 빠르게 끝날 것이다. 하지만 모든 정렬 케이스가 거의 정렬된 데이터만 있지 않기 때문에 쓰지 않는 것일 뿐이다.\n만약에 데이터 순열이 \u0026lsquo;**거의 정렬된 데이터의 N 벌\u0026rsquo;**이라고 하자. 1, 2, 3, …, 10, 2, 3, 4, …, 20 이런 식으로 말이다. (여기서는 2벌) 그림을 그리자면 산이 N 개 생긴 것 처럼 보일 것이다. 이런 경우에는 Bubble Sort 가 큰 힘을 쓰지 못한다. 특정 원소가 산의 제 위치에 찾아가야 하는데, 조기에 끝났던 아까의 경우와는 달리 재수가 없다면 거의 모든 원소 개수와 비교해 봐야 하기 때문이다. 이럴 경우 역시 특효약이 있는데, 산마다 Mergesort 를 하면 쉽다.\n오늘 이야기할 Timsort 는 Mergesort 의 변형이라고 보면 된다. 아까 \u0026lsquo;산마다 Mergesort\u0026rsquo; 를 한다고 했는데, 어느 지점부터 산으로 봐야할지를 판단하는 알고리즘이 선행된다. 그리고 Mergesort 도 단순히 1개씩 건너뛰는 방법에서 좀 더 나은 방법을 제시한다.\n결론부터 말하자면 Timsort 는 무작위 데이터에서 Quicksort 보다 뒤쳐진다. 프로젝트할 때 적용해 본 결과로는 30~50% 정도 느렸다. 하지만 말했다시피, 현실 데이터는 어느 정도 정렬된 데이터의 덩어리를 가지고 있는 경우가 매우 많기 때문에, 그 부분에서는 확실한 성능 차이를 보였다.\n자, 이제 한 번 알아보자.\n1단계 : Run 데이터 순열에서 이미 정렬이 끝난 부분 데이터들을 Run 이라고 한다. 1, 2, 1, 2, 3, 1, … 같이 주어졌을 때, 1, 2 와 1, 2, 3 을 Run 으로 인식하는 것이다. Timsort 에서는, 데이터 순열을 이런 Run 들로 찾거나 만들어서 확보하는 과정을 거친다. 이게 1단계이다.\nTimsort 는 Run 이 너무 짧으면 나중에 의미가 없으므로, 최소 길이를 정해서 Run 을 만들도록 한다. 보통은 길이가 16인 Run 부터 의미있게 쓰길래, 나도 똑같이 16으로 조건을 설정했다.\nRun 은 데이터 처음부터 정렬되어 있는 위치까지를 찾는다. 이 길이가 16 미만이라면, 해당 범위는 기억해 두고 다음 Run 을 찾는다. 이렇게 길이가 16 이상의 Run 을 만들 수 있는데, 이 때 쓰는 알고리즘은 사실 아무거나 가져다 써도 된다. 길이가 짧을 때의 정렬 알고리즘은 어느 것을 쓰나 대동소이하기 때문에, 나는 Insertion Sort를 썼다.\n2단계 : Merge 1단계 이후로는, 이제 데이터 순열에 Run 여러개가 연속되어 있다. 만약 Run 이 1개뿐이라면? 축하한다. 아주 작은 원소 개수를 정렬하려 했거나, 이미 정렬된 데이터를 넣었단 것이니 이번 단계를 하지 않아도 된다.\n앞의 두 Run 을 불러서 Mergesort 하면 되는데, 여기서 Timsort 만의 트릭이 두 개 존재한다.\n하나는, Merge 에 참여할 두 Run 의 최소값/최대값을 서로 비교해서, 아예 이긴 구간이나 아예 진 구간을 미리 산정해 두는 것이다. 이 부분은 사실상 Mergesort 과정에서 비교 대상이 될 필요가 없다. 괜한 compare 연산만 낭비하지 말고 처음에 (혹은 나중에) 순순히 들어와주기만 하면 된다. 이 전처리 과정이 끝나면, 남아있는 Run 끼리 Merge 과정을 거친다.\n두 번째는, Merge 과정에서 만약 한 쪽이 계속 이기는 상황 (오름차순 정렬이라고 가정했을 때, 한 쪽의 Run 이 계속 작은 원소를 가지고 있을 때) 라면 더 이상의 비교는 무의미하다. 이런 연속 위닝 회수를 정해서, 이후에는 \u0026lsquo;어디까지 이기는지 binary search 로 찾아서 한 번에 그냥 옮기자\u0026rsquo; 라는 건너뛰기 모드 (galloping mode) 로 전환된다. 코드를 참조했을 땐, 이 위닝 회수는 3이었다. 스윕승?\n건너뛰기 모드 (galloping mode) 에서는, 지고 있던 Run 의 첫 번째 원소가 이기고 있던 Run 의 어느 원소에서 비로소 이기는지를 찾는 것이다. 처음엔 한 칸, 다음엔 두 칸, 그 다음엔 네 칸씩 뛰며 이길 때 까지 찾는다. 그러다가 찾았다면, 직전 구간 사이를 Binary Search 를 통해 최초로 이긴 위치를 찾아내면 된다.\n그 다음은? 이기고 있던 Run 의 처음부터 발견된 위치 직전까지를 통째로 memcpy 하면 된다.\n마치며 이걸 구현할 때는 급한 나머지 그냥 구현했었는데, (물론 어딘가에선 하고 있겠지만) Mergesort 자체가 병렬 구현이 가능하므로 Timsort 역시 병렬 구현이 가능하리라 본다. Run 을 만드는 작업은 병렬로 할 수 있을까 고민이 되지만, Merge 과정은 작업 큐만으로도 쉽게 그려낼 수 있다.\n역시 이것도 만병통치약이 될 수 없다. 상황에 맞춰 적절히 섞어써야 한다. 이런 정렬 알고리즘도 있구나 하며 배웠던 소중한 기회로 여기고 있다.\n","date":"2018-04-23T01:36:57Z","permalink":"https://interp.blog/timsort/","title":"Timsort"},{"content":"마음이 붕.\n몸은 여기 있는데, 어디로 가고 있는지조차 모를 정도로 격랑(激浪)에 떠밀려 가는 것처럼.\n조각난 지식들은 어딘가에 있겠지만, 약에 쓰려고 하면 개똥도 찾을 수 없는 것 처럼 내 단편의 끄적임을 찾기 힘들 때마다 드는 생각이 있다. 이걸 전부 모아뒀다면. 다짐은 용오름처럼 솟구치지만 이내 잠잠한 바다 속으로 꺼져버린다. 정리할 시간이 없진 않았을 텐데, 하면서.\n정리와 분류는 결국 데이터를 다루는 사람, 데이터 소프트웨어를 만드는 개발자 둘 모두에게 있어 경쟁력이자 기본이라고 생각한다. 어떻게 효율적으로 정리를 할 것인지 매번 고민한다. 사무실에서도, 집에서도, 혼자 스탠드등에 앉아 있으면서도. 정리해 두면, 잘 꺼내 쓸 수 있을거란 기대가 있으니까. 이 때 또 물어본다. 정말 꺼내 쓸만한 것들인지는 확인해 보았느냐고. 설마 폐지를 정리하려 드는 것은 아닐까 하고. 그래서 정리에는 비움이 필요하다.\n지금 이 생각에도 비움이 필요하다. 마음 속에 부는 바람줄을 하나씩 잠재워야 한다. 초가 타지 않도록, 그나마 따뜻한 이 믿음이 꺼지지 않도록. 이걸 먼저 정리해야겠다. 그래야 지금 앉아있는 곳으로 마음이 돌아올테니까.\n ","date":"2018-04-19T02:57:40Z","permalink":"https://interp.blog/%EC%A0%95%EB%A6%AC%EB%8A%94-%EB%B9%84%EC%9B%80%EC%9C%BC%EB%A1%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%A7%88%EC%9D%8C%EB%B6%80%ED%84%B0/","title":"정리는 비움으로, 그리고 마음부터"},{"content":"회사가 고객에게 제공해야 할 것을 개념적으로 정의할 때 제품의 철학이라는 말을 사용한다. 제품의 시그니처이자 조직 내부를 움직이는 시금석이 되는데, 이걸 등한시하면 발생하는 문제에 대해 이야기하려고 한다.\n철학이라면 어떤 것을 말하는 걸까. \u0026lsquo;탐색 속도가 빨라야 한다, 로그인 없이도 정보 제공이 되어야 한다, 고객의 소리에 즉각적으로 귀를 기울인다\u0026rsquo; 같은 개념이 철학이지, \u0026lsquo;탐색 속도의 TPS 목표치, 로그인 폼의 형태, 고객이 원하는 것을 나열하는 것\u0026rsquo; 자체로 철학이라고 하지 않는다. 이건 요구사항이지, 철학이 아니다.\n그런데 후술한 구체적인 것들이 실제로 중요하기 때문에 (특히 고객이 원하는 것) 철학을 도외시하게 된다. 이래서는 안 된다. 조직이 하나로 뭉칠 수 있는 것은 그 철학에 있는데, 결정권자가 그걸 무시한 채 업무를 단장하는 순간 조직이 와해되는 것은 정말 시간문제다. 회사가 소규모이고, 창립멤버이며, 모두 새로운 이정표로 나아가는 데 동의를 하면 모르겠지만 조직이 커질수록 그런 함정에 빠지기 쉽다.\n당장의 이익이나 트렌드를 급히 따라가는 것은, 이유를 막론하고 숙고해야 할 문제이다. 단순히 예측되지 않은 미래에 대한 불안만으로 이야기하는 것이 아니다. 배의 크기가 클수록 키를 급하게 돌리면 배 자체에 문제가 발생하기 쉽다. 그걸 막기 위한 것이 조직이 동의한 (혹은 입사 때부터 배웠거나 인정했던) 가치인 것이다. 방향을 틀었다면, 조직 내부에서 큰 합의가 필요한데, 여기에 드는 비용을 무시할 수 없다. 그런데, 아무런 합의 없이 진행한다면 더 큰 비용을 감수하는 것이다. 다만, 문제가 터지기 전까진 보이지 않을 뿐.\n이걸 지켜내는 것이 정말 어려운 것임을 나는 안다. 초반에는 이걸 지킬 수 있었고, 유연하게 움직이기도 쉬웠을 것이다. 하지만 무작정 강요로 이끌어나간다면, 언젠가는 더 큰 이자를 내야 한다는 사실을 기억해야 할 것이다.\n","date":"2018-03-10T12:30:51Z","permalink":"https://interp.blog/%EC%A1%B0%EC%A7%81-%EC%B2%A0%ED%95%99%EA%B3%BC-%EA%B3%A0%EA%B0%9D%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/","title":"조직 철학과 고객의 요구사항"},{"content":"「완벽한 공부법」1 과 「일취월장」2 두 책에서 언급되는 \u0026lsquo;메타인지\u0026rsquo; 라는 개념이 있다. \u0026lsquo;자신의 생각에 대해 판단하는 능력\u0026rsquo; 이라는 것인데, 나무위키 에서는 다음과 같이 쪼개놓았다.\n 선언 지식 – 자신이 학습하는 부분에 대해서 얼마만큼의 지식과 능력을 가지고 있는지 아는 것. 절차 지식 – 어떤 일을 하는 데 얼마만큼의 노력과 시간이 들어갈 지 아는 것. 전략 지식 – 지식을 습득 할 때 어떤 방법을 선택해야 할지 아는 것.  사실 우등생은 다른 학생들보다 기억력이나 연산력이 월등히 좋거나 하진 않지만, 이 \u0026lsquo;메타인지\u0026rsquo; 능력에서 월등한 차이를 보인다고 한다. (정확히 기억나진 않지만) 어떤 실험을 하나 했는데, 학생들에게 제한 시간 안에 전부 외울 수 없는 영어단어들을 외우게 했다.\n그리고는 시험을 쳤다. 시험 결과는 우등생이나 다른 학생들이나 별다른 차이가 없었다. 그런데, 시험 후 채점을 하지 않고 몇 개나 맞췄을까라고 물어 본 결과는 달랐다. 우등생으로 분류된 학생들이 정확히 채점 결과와 일치하는 답을 내놨지만, 다른 학생들은 잘 모르겠다고 했단다.\n적을 아는 것도 중요하지만 또 나도 알아야 백전불태(百战不殆)3다. 혹시 적만 알아가는데 지치진 않았는지? 시험 문제를 그저 풀기 위해 학원에 가서 유형 분석을 하고 인강을 듣는건 아닌지 생각해 볼 필요가 있다. 내가 어디가 부족한지를 알고, 부족한 부분을 채우려는 전략적인 행동이 중요하다.\n「완공」 을 읽다가 이 대목에서 눈에 띄었던 이야기는, 메타인지를 키우려면 결국 혼자만의 공부를 해야 한다는 거다. 우등생들은 보통 혼자 공부하는 시간을 적어도 세시간 이상 둔다고 한다.\n일도 그렇지 않을까. 회사에서 주어진 일을 처리하는 것도 밥벌이로서 중요한 일이지만, 업무와 무관하게 내가 부족한 점은 무엇인지, 내가 쌓아야 하는 것은 어떤 지식인지를 스스로 탐구할 시간이 필요하다고 생각한다. 그것이 업무를 도와주는 지식이건 향후의 커리어에 도움이 되는 것이건 간에 말이다.\n    책 「드라이브」4 의 저자 다니엘 핑크의 TED 강연5에서는, 협업 도구를 만드는 호주의 회사 Atlassian 을 소개한다. (내가 너무나 잘 쓰고 있는 Confluence 를 만든 회사이다.) 여기서는 업무 시간의 일정 부분을 떼서, 맡은 업무와 아무 상관없는 일을 해서 발표하는 시간을 가져 왔다고 한다. 거기서 놀라운 기능들이 나오기 시작했고, 회사는 이 비율을 20% 가까이 올렸다고 한다. 우리가 잘 알고 있는 구글 역시 이런 방식으로 새로운 기능을 자율적으로 얻을 수 있었고, Gmail 과 같은 놀라운 앱이 나온 것이다.\n이런 법칙을 개인에게도 적용해서, 외부의 과제를 잠시 내려놓고 내가 부족한 것은 없는지, 내가 비효율적으로 했거나 잘못 가고 있는 것은 아닌지 살펴보고 행동하는 시간을 가지는 것이 중요하지 않을까.\n(여담으로, 위의 강연은 양초 문제, 위키피디아의 성공 등과 같은 흥미로운 이야기를 하니 한번 보길 권한다.)\n  http://www.yes24.com/24/goods/34569935?scode=032\u0026OzSrank=1\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://www.yes24.com/24/Goods/57501187?Acode=101\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://cndic.naver.com/zh/entry?entryID=c_38f7bfe4d2\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://www.yes24.com/24/goods/5819980?scode=032\u0026OzSrank=5\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.ted.com/talks/dan_pink_on_motivation?language=ko\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2018-03-06T06:43:00Z","permalink":"https://interp.blog/%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80-%EC%A0%81%EC%9D%84-%EC%95%8C%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%82%98%EB%A5%BC-%EC%95%8C%EC%9E%90/","title":"메타인지 – 적을 알기 전에 나를 알자"},{"content":"맡은 일을 하려면 쭉쭉 할 수 있을 것 같은데, 그럴 의지가 텅 비어버린 것 같다. 이 의지라는 것은 커피나 술 같은 것으로 긴급 보충이 가능하겠지만 그러기도 싫다. 그냥, 삼일절과 토요일 사이의 한가로운 근무일을 몇 가지 단상으로 때우다 보면 고것이 조금 고여있지 않을까? 그걸로 다시 일을 재개하겠노라 다짐하면서 블로그에 글을 하나 더 얹어 본다.\n어떻게 살 것인가? 라는 주제에 대해 이야기한 적이 있는데, 주변 사람들에게 긍정적인 영향을 줄 수 있는 사람이 되고 싶구나 라고 문득 생각난 적이 있다. 누군가에게 도움을 주고 웃어도 주고 들어도 주는. 그래서 처음에는 웃는 연습을 하고 지식을 채웠었다. (그것이 전문적인 것이던 가십거리가 되었던 간에) 그런데 이상했다. 여전히 날 찾는 사람이 별로 없는 것 같았다. 뭐가 문제지? 아, 마케팅을 잘 못했구나. 1인 기업이니 셀프 마케팅이니 그런 개념을 잊고 있었구나, 라고 생각했었다. 며칠 전까지는.\n마케팅 같은 거창하고 전문적인 개념으로 이 문제를 대하면 피로감이 몰려왔다. 와이프의 선배는 인맥을 관리하기 위해 분기에 한 번씩 아무런 일이 없는데도 주변 사람에게 전화를 한다고 했다. 아무런 일이 없는데도 말이다. 시시껄렁한 말이 오가면 그대로 통화는 끝난다. 이 이야길 처음 들었을 때도 비슷한 피곤이 느껴졌다. 왜 그래야 하지? 저 선배는 마케팅을 참으로 잘 하는구나.\n그런데 완전히 잘못 생각하고 있었단 생각이 들었다. 도움을 필요로 하는 사람은 \u0026lsquo;도와달라\u0026rsquo; 고 말하는 경우가 거의 없다. 처한 환경이 극단적인 경우이거나 술에 취했거나 한다면 조금 이야기가 다르겠지만, 대개는 도움을 줄 사람이 아주 명확한데다 질문하기가 거리낌이 없는 상태라야 저 말이 나온다. 그런데, 도움을 줄 사람이 명확한 경우도 거의 없고, 그 사람이 호의적으로 나올지도 모른다면? 반대로, 호의는 가지고 있는데 뭘 도와줘야 할지 모르겠다면?\n어떤 사람에게 도움이 되고자 한다면, 그 \u0026lsquo;사람\u0026rsquo; 이라는 것이 특정 타겟이 아닌 주변 사람 전부를 의미하는 거라면 접근법이 완전히 달라져야 한다. 내 문에 노크를 하며 도와달라고 말할 때 까지 기다려서도 안 되고, 주변인들이 필요해 보이는 것을 미리 준비하려고 해도 안 된다. 나도 그 사람에게 도움이 될지 안 될지 모르고, 그 사람도 나를 필요로 하는지 그렇지 않은지 모른다.\n그러니 먼저 가서, 위의 그 선배가 한 것처럼 시답잖은 이야기를 늘어놓으며 나의 존재를 알린다. 그 과정이 불편하다면 어쩔 수 없다. 하지만 적어도 그대가 뭘 필요로 하고 내가 뭘 해 줄 수 있는지 알아볼 기회가 생긴다. 그리고 내가 할 수 있는 일을 찾아서 도와줘라. 고민을 들어주고 웃어줘라. 뭔가 더 준비하지 말고, 갖춰진 상태에서 최대한 도와줘라.\n설령 도움이 안 되더라도, 적어도 나의 호의는 그대가 느낄 수 있게.\n다시 일을 시작해야겠다.\n","date":"2018-03-02T06:56:41Z","permalink":"https://interp.blog/%EB%A8%BC%EC%A0%80-%EB%8B%A4%EA%B0%80%EA%B0%80-%EB%8F%84%EC%99%80%EC%A3%BC%EA%B8%B0/","title":"먼저 다가가 도와주기"},{"content":"gdb/ddd 에서 commands 를 사용하면 간편하게 breakpoint 의 상태를 출력할 수 있다. 물론 다양하게 응용이 가능하겠지만, 매뉴얼에서 제시한 케이스가 굉장히 편해서 따로 정리한다.\n참고 : http://sourceware.org/gdb/onlinedocs/gdb/Break-Commands.html\nBreakpoint 상황을 출력하기 10 *sAddr = malloc(aSize); 11 if (*sAddr != NULL) 12 ... 위 코드에서 if 문에 breakpoint 를 걸고, 할당받은 시작 주소와 그 크기를 보고자 한다. 한두번 발생하는 거라면 breakpoint 를 걸어 둔 다음 print 나 graph display (ddd 전용) 으로 띄워서 관찰하면 된다. 그런데 이게 100번 200번이면 하염없이 엔터를 치게 된다.\n이럴 때 다음과 같이 입력한다.\n(gdb) b 10 # 10번째 라인에 breakpoint (gdb) commands # 아무 것도 입력하지 않으면 최근 breakpoint 에 대한 command 입력 \u0026gt; silent # breakpoint 에 멈췄단 메시지를 출력하지 말아달라 \u0026gt; printf \u0026#34;alloc address is %p\\n and its size is %ld\u0026#34;, *sAddr, aSize \u0026gt; cont # 흔히 입력하는 cont 와 동일하다. \u0026gt; end # command 입력 종료 이러고 cont 를 날리면.. breakpoint 에서 멈추는 대신 해당 command 가 수행된다! 즉, 계속해서 주소와 할당 크기가 출력된다. 아주 편하다…\nCall Stack 보기 일종의 응용인데, commands 내부에는 우리가 흔히 쓰는 명령어를 입력하면 된다.\n(gdb) commands \u0026gt; silent \u0026gt; bt 5 # backtrace (callstack) 을 출력하되, 안쪽에서 5개 까지만 출력 \u0026gt; cont \u0026gt; end Commands 의 초기화 commands 명령어를 입력한 다음, 바로 end 로 끝내면 된다.\n(gdb) commands \u0026gt; end ","date":"2018-02-06T08:46:05Z","permalink":"https://interp.blog/gdb-commands-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/","title":"gdb commands 이용하기"},{"content":"Intel VTune 으로 Memory Bandwidth 를 분석하려면, 분석할 수 있는 커널 드라이버를 로딩시켜야 한다. (참고로 메모리 분석은 리눅스에서만 가능하다.) 해당 작업을 하지 않고 \u0026lsquo;General Exploration \u0026gt; Analyze memory bandwidth\u0026rsquo; 를 체크하면 엄한 경고창이 반길 것이다.\n이 문서를 참고해도 좋지만, VTune 이 설치된 경로에서 sepdk/src/README.txt 를 보는 게 더 쉽다. 이 내용을 요약하면,\n 커널 환경변수를 체크한다. 프로파일링이 가능하고 모듈 로딩이 가능해야 한다.  CONFIG_MODULES=y CONFIG_MODULE_UNLOAD=y CONFIG_PROFILING=y   커널 드라이버를 컴파일시킬 헤더파일이 필요하다. Linux 배포판에 따라, 커널 개발용 패키지를 내려받아 설치한다.\n(언급한 Linux 배포판이 없으면 소스를 직접 받아둔다.)  Redhat 5/Fedora/CentOS : yum install kernel-devel Ubuntu/Debian : apt-get install build-essential linux-headers-`uname-r`   VTune이 필요로 하는 커널 드라이버를 컴파일하고 로드시킨다.  cd ${VTune Directory}/spedk/src ./build_driver (이 때 2번에서 설치한 커널 헤더파일의 위치를 정확히 입력해야 한다.) ./insmod-sep3  로딩 확인을 위해서는 ./insmod-sep3 -q 라고 입력해 보자. 언로딩 시키려면 ./rmmod-sep3 이라고 입력하자.      ","date":"2018-01-22T05:19:48Z","permalink":"https://interp.blog/vtune-memory-bandwidth/","title":"Intel VTune Memory Bandwidth 분석하기"},{"content":"Office 2016 부터인지 모르겠지만, 커서가 부드럽게 움직이는 애니메이션이 추가되었다. 실제 입력 속도는 같을지 모르겠는데, 문서 작업을 하고 있자니 조금 답답한 느낌이 들었다. 조금 느리게 입력되는 느낌? 처음에는 엑셀에서 셀 이동 할 때만 그런 줄 알았더니, 파워포인트나 워드를 작업할 때도 신경이 쓰였다. 그래서 이걸 끌 수 있는 방법을 두 가지 찾았는데, 하나는 레지스트리를 수정하는 방법이라 엄청나게 귀찮았다. 다른 하나는 그 것보단 간단했다.\n아래 스크린샷 순서대로 따라가 체크를 해제하면 된다.\n    (adsbygoogle = window.adsbygoogle || []).push({});    제어판 \u0026gt; 시스템으로 들어간 다음, 고급 시스템 설정으로 들어간다. 고급 탭에서, 성능 항목에 \u0026lsquo;설정…\u0026rsquo; 을 클릭한다. \u0026lsquo;시각 효과\u0026rsquo; 탭에서, 창의 제어 및 요소에 애니메이션 효과 추가 항목의 체크를 해제한다. 그리고 확인.      (adsbygoogle = window.adsbygoogle || []).push({});   ","date":"2018-01-16T12:14:29Z","image":"https://interp.blog/images/2018-01-16-office-animation-off/office-animation.jpg","permalink":"https://interp.blog/office-2016-%EC%BB%A4%EC%84%9C-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%81%84%EA%B8%B0/","title":"Office 2016 커서 애니메이션 끄기"},{"content":"사내 사정으로 인해 Gitlab의 External_Url 을 실제 서버 주소와 다르게 설정해서 쓰고 있다.\n물론 실제 nginx 에도 해당 도메인으로 접근할 수 있도록 설정해야 하는 게 맞다. 그렇지 않으면, 첨부파일과 아바타 이미지가 모두 깨져나온다. 하지만 그러기 전에 Gitlab 차원에서 상대 경로로 아바타를 출력할 수 있도록 수정하는 방법 \u0026lsquo;도\u0026rsquo; 있으니 편법으로 수정했다. 아래는 그 편법 내용을 다룬다.\n아바타 상대 경로 설정 /opt/gitlab/embedded/service/gitlab-rails/app/models/concerns/avatarable.rb 파일에서 절대 경로로 수정하는 코드가 있는데, url_base 에 덧붙이는 코드들을 전부 주석처리하면 된다.\nmodule Avatarable extend ActiveSupport::Concern def avatar_path(only_path: true) return unless self[:avatar].present? asset_host = ActionController::Base.asset_host use_asset_host = asset_host.present? # Avatars for private and internal groups and projects require authentication to be viewed, # which means they can only be served by Rails, on the regular GitLab host. # If an asset host is configured, we need to return the fully qualified URL # instead of only the avatar path, so that Rails doesn\u0026#39;t prefix it with the asset host. if use_asset_host \u0026amp;\u0026amp; respond_to?(:public?) \u0026amp;\u0026amp; !public? use_asset_host = false only_path = false end url_base = \u0026#34;\u0026#34; # if use_asset_host # url_base \u0026lt;\u0026lt; asset_host unless only_path # else # url_base \u0026lt;\u0026lt; gitlab_config.base_url unless only_path # url_base \u0026lt;\u0026lt; gitlab_config.relative_url_root # end url_base + avatar.url end end 당연히 gitlab-ctl reconfigure \u0026amp;\u0026amp; gitlab-ctl restart 를 해 줘야 한다.\n참고 : https://gitlab.com/gitlab-org/gitlab-ce/merge_requests/11001/diffs#note_28659864\n첨부파일 상대 경로 설정 단서가 없어서 맨땅에 헤딩하듯이 뒤지고 다녔다. Markdown 언어에서 링크를 담당하는 라이브러리가 있는데, 이름이 \u0026lsquo;banzai\u0026rsquo; 이다 (…) 무슨 생각으로 이름을 지은건지 도저히 모르겠지만 여기를 수정해야 한다.\nfilter/upload_link_filter.rb 를 보면, build_url() 이란 함수가 있다. 여기서 Geo node 여부에 따라 base_path 를 설정하는 코드가 있는데, 여기서 원하는 내부 주소로 변경하면 된다.\ndef build_url(uri) base_path = if Gitlab::Geo.secondary? Gitlab::Geo.primary_node.url else # Gitlab.config.gitlab.url \u0026#34;http://your.address.com/\u0026#34; end if group urls = Gitlab::Routing.url_helpers # we need to get last 2 parts of the uri which are secret and filename uri_parts = uri.split(File::SEPARATOR) file_path = urls.show_group_uploads_path(group, uri_parts[-2], uri_parts[-1]) File.join(base_path, file_path) else File.join(base_path, project.full_path, uri) end end Gitlab 11 버전 으로 업그레이드 되면서부터 해당 파일은 삭제되고, absolute_link_filter.rb 와 external_link_filter.rb , relative_link_filter.rb 가 남아있다. 여기 있는 Gitlab.config.gitlab.url 을 원하는 주소로 바꿔주면 가능하다. (relative.rb 의 경우 Gitlab.config.gitlab.base_url)\n","date":"2018-01-08T02:35:20Z","permalink":"https://interp.blog/gitlab-%EC%95%84%EB%B0%94%ED%83%80-%EC%83%81%EB%8C%80-%EA%B2%BD%EB%A1%9C-%EC%84%A4%EC%A0%95/","title":"Gitlab 아바타/첨부파일 상대 경로 설정"},{"content":"매니저 자리에 처음 앉았을 때와 다르게, 언젠가부터 남과 대화하는 것을 기피하는 내 모습을 자주 발견하게 되었다. 의욕이 넘쳐서 이거저거 캐묻고 알아가던 때가 있었는데, 그러면서 반발도 부딪히고 구성원들이 나만큼 의욕적이지 않은 것 같고, 의심하고 실망하고를 반복하다 보니 이렇게 된 것 일까. \u0026lsquo;지쳤다\u0026rsquo; 나 \u0026lsquo;질렸다\u0026rsquo; 라고 해도 괜찮을 수준이었다.\n그런데 대화를 그만두면 더 좋지 않은 것 같다. 그냥 시간을 버리는 것 같다. 대화가 멈추면, 서로가 원하는 것을 모르고 각자 하고 싶은 대로 흘러간다.\n대화를 해서 손해를 보는 경우도 있다. 감정이 상할 수도 있다. 하지만 그 차이를 나도 양보하고 너도 양보해서 맞춰야 한다. 대화를 자주 해서 업무 방해가 일어난다거나, 쓸데없는 일이라고 여겨질 수도 있겠는데… 서로 대화하지 않고 흘러가게 두는 것이, 더 큰 손해를 끼칠 가능성이 높다고 생각한다.\n그래서 오늘도, 대화하기 싫어하는 나를 달래가며 다른 사람들에게 말해야 할 가장 적절한 질문과 주제를 찾고 있다.\n","date":"2018-01-05T04:48:10Z","image":"https://interp.blog/uploads/2018/01/exhibition_see_visitors_gallery_museum_art-1035105.jpgd_.jpg","permalink":"https://interp.blog/%EB%8C%80%ED%99%94%EB%8A%94-%ED%95%84%EC%9A%94%ED%95%B4/","title":"대화는 필요해"},{"content":"Github 과 비슷한 서비스인 Gitlab 은 오픈소스이기 때문에 Community Edition 을 쓰건, Enterprise Edition 을 쓰건 on-premise 환경에서 설치한 뒤 마음대로 수정해서 사용이 가능하다. 수정하는 범위를 한정하지 않는다면, 루비 (*.rb) 파일까지 건드릴 수 있다.\n여기서는 Gitlab에서 문서 작성에 필요한 Markdown 의 Parser 부분을 미세하게 수정해서, 입맛에 맞게 바꾸기 위한 방법을 정리해 둔다. Ruby 개발자가 아니라서 전체 순서가 정공법처럼 보이진 않겠지만.\n그런데 뭘 수정하나요? 내가 수정하고 싶었던 내용은, Enter 키를 한 번만 쳐도 줄이 바뀌도록 보이게 하는 것이었다. 원래 Markdown 문법에선 Enter 키를 두 번 치면 문단 바꿈, 줄 끝에 스페이스를 두 번 넣으면 줄바꿈이 된다. 그런데 Enter 키를 한 번만 쳐도 줄바꿈이 되면 좋겠다는 개발자가 많았다. 저기요, Markdown 안 써보셨어요? 라고 따질 순 없었다\nGitlab 10.x : Redcarpet Gitlab 10.x 에서는 Markdown Parser 를 Redcarpet 으로 사용한다. 아마 Jekyll 도 기본적으로 Redcarpet 을 사용하는 것으로 알고 있다. 만약 Ruby의 Redcarpet 을 Markdown Parser 로 쓰는 경우라면 똑같이 적용이 가능하다.\nParser C 파일 수정하기 /opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/redcarpet-3.4.0/ 으로 들어가면 Redcarpet의 소스코드가 존재한다. 여기서 ext/redcarpet 디렉토리가 Parser C 파일들이 위치한 곳이다.\n여기 markdown.c 파일을 보니 char_linebreak() 라는 함수가 존재한다. 여기서 해당 부분을 주석처리했다.\n/* char_linebreak • \u0026#39;\\n\u0026#39; preceded by two spaces (assuming linebreak != 0) */ static size_t char_linebreak(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size) { //if (offset \u0026lt; 2 || data[-1] != \u0026#39; \u0026#39; || data[-2] != \u0026#39; \u0026#39;)  // return 0; /* removing the last space from ob and rendering */  while (ob-\u0026gt;size \u0026amp;\u0026amp; ob-\u0026gt;data[ob-\u0026gt;size - 1] == \u0026#39; \u0026#39;) ob-\u0026gt;size--; return rndr-\u0026gt;cb.linebreak(ob, rndr-\u0026gt;opaque) ? 1 : 0; } 라이브러리 생성/복사 수정이 끝나면 반드시 ext/redcarpet 디렉토리에서 make 를 수행해 주도록 하자. 그러면 Shared Library 파일인 redcarpet.so 이 생성된다.\n이 파일을, 다음 경로에 모두 복사해주도록 하자.\n /opt/gitlab/embedded/lib/ruby/gems/2.3.0/extensions/x86_64-linux/2.3.0/redcarpet-3.4.0/ /opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/redcarpet-3.4.0/lib/  Gitlab 재부팅 마지막으로 gitlab-ctl reconfigure \u0026amp;\u0026amp; gitlab-ctl restart 를 실행시켜 Gitlab 을 재부팅 하자.\nGitlab 11.x 이후 : Commonmark 11.x 부터는 Redcarpet 이 아니라 Commonmark 를 기본 파서로 사용한다. 구조가 달라져서 찾는게 귀찮아서 그렇지, 기본 원리는 비슷하다. 2칸 이상의 space 를 준 채로 줄바꿈하게 되면 CMARK_NODE_LINEBREAK, 그렇지 않고 줄바꿈하면 CMARK_NODE_SOFTBREAK 상태로 전이된다.\n옵션을 알아보고 정확히 적용했다면 더 없이 깔끔했겠지만, 나는 마음이 급했기 때문에 참고할 만한 소스코드만 붙이고 그만두기로 했다.\nhtml.c:283 부터다. 여기서 직접 줄바꿈을 하도록 강제했다.\ncase CMARK_NODE_SOFTBREAK: if (options \u0026amp;amp; CMARK_OPT_HARDBREAKS) { cmark_strbuf_puts(html, \u0026#34;\u0026lt;br/\u0026gt;\\n\u0026#34;); } else if (options \u0026amp;amp; CMARK_OPT_NOBREAKS) { // cmark_strbuf_putc(html, \u0026#39; \u0026#39;); // 수정 전  cmark_strbuf_puts(html, \u0026#34;\u0026lt;br/\u0026gt;\\n\u0026#34;); // 수정 후  } else { cmark_strbuf_putc(html, \u0026#39;\\n\u0026#39;); } break; 이렇게 하고 make 를 쳤더니, 어라? 빌드가 안 된다. 이 때는 banzai filter 가 위치한 곳의 ruby 파일을 수정하면 된다. /opt/gitlab/embedded/service/gitlab-rails/ 까지 들어간 다음 lib/banzai/filter/markdown_engines/common_mark.rb 을 편집한다.\nRENDER_OPTIONS = [ :DEFAULT, # default rendering system. Nothing special. :HARDBREAKS # Treat `\\n` as hardbreaks (by adding `\u0026lt;br/\u0026gt;`). # 이 옵션을 추가한다. ].freeze 반드시, Gitlab 재부팅을 잊지말자! gitlab-ctl reconfigure \u0026amp;\u0026amp; gitlab-ctl restart 이다. Commonmark 는 라이브러리를 수정한 것이 아니라서 make 같은 건 안 해도 된다.\n이 방법으로 했을 때 한 가지 아쉬운 점은(?) 일부러 soft break 를 시도하는 경우에, 내부에서 line break 까지 겹쳐서 인식하기 때문에 결론적으로 \u0026lt;br/\u0026gt; 이 두번 붙는 사태가 일어난다. 깔끔하게 \u0026lt;p\u0026gt; 로 감싼 문단을 얻고 싶을 때는 이 방법이 소용이 없어서, 어쩔 수 없이 commonmark 를 한번 빌드하는 수밖에 없나.. 하는 생각이 들었다.\n","date":"2018-01-03T02:29:21Z","permalink":"https://interp.blog/gitlab-markdown-parser-configuration/","title":"Gitlab Markdown Parser 고치기"},{"content":"oh-my-zsh 테마 작업을 agnoster 를 기반으로 고쳐서 사용 중이다. 그런데 주석을 보면 다음 색깔만 지원하는 것 처럼 나온다.\n white, black, red, blue, green, yellow, cyan, magenta\n 위의 색깔 외에 다른 색상을 설정하려면, 다음 작업이 필요하다.\n 터미널 종류가 xterm-256color 여야 한다. (xterm 으로 설정되어 있으면 제대로 출력이 안된다.) oh-my-zsh 에서, %{%K{---}%} 또는 %{%F{---}%} 를 가지고 색깔을 찾는다. 이 때 --- 대신 0~255 사이의 숫자를 입력한다. 0~255 숫자와 대응되는 색상을 찾아야 하는데, 여기를 참고하자.  ","date":"2017-12-13T05:43:01Z","permalink":"https://interp.blog/oh-zsh-%EC%83%89%EA%B9%94-%EA%B3%A0%EB%A5%B4%EA%B8%B0/","title":"oh-my-zsh 색깔 고르기"},{"content":"이제 자기계발서들은, 목표에 대한 진척을 강요하거나 쥐어짜려는 설득을 더 이상 하지 않게 되었다. 아니면, 그런 글귀와 말을 사람들이 더 이상 찾지 않는 것일지도 모른다. 사람들이 열광하는 주제가, 맹목적인 믿음이나 노력을 채찍질하는 것에서 벗어나 자신에 대한 탐구로 옮겨가고 있는 것처럼 보인다. \u0026lsquo;어떻게\u0026rsquo; 라기 보다는 \u0026lsquo;왜\u0026rsquo; 에 좀 더 가까운 것 같다.\n\u0026lsquo;어떻게\u0026rsquo; 가 아닌, \u0026lsquo;왜\u0026rsquo; 조금만 시간을 거슬러 올라가도 공부에 대한 방법론, 단기간에 끝내기, 맹목적으로 바라보기, 노력은 배신하지 않는 등의 주제가 가득했다. 공부 잘 하면 좋고, 노력은 배신하지 않는 것도 동의한다. 그런데 그걸 왜 하냐고, 설마 남 좋으라고 하는건가? 그 흐름에 나를 넣어야 하는데, 그렇지 않다면 과연 자기계발이 맞는 걸까?\n최근 자기계발서의 내용들은 그렇지가 않다. 남 눈치보지 말자, 내 인생은 내가 책임진다, 모두가 날 좋아할 수는 없다, 뭐 이런 거다. 일종의 위로이자 응원이다. 베네딕트 컴베비치가 레터스라이브에서 매우 격앙된 어조로 낭독한 영상을 줄이면 \u0026lsquo;남에게 눈치보지 말고 그냥 해라고!' 라는 것이었다. 화난 듯 말하지만, 사실은 위로이자 응원이다. 남에게 눈치보고 있다는 것은, 말 그대로 내가 아닌 남이 원하는 삶을 살고 있는 것이다. 그냥 해보라는 말도, 뭘 하고 싶고 뭘 할 수 있는지 찾아서 하라는 것이다.\n내가 한 일은 남들도 다 할 수 있다 목 마른 사람이 우물을 파겠지만, 지금껏 우리는 우물을 어떻게 파느냐, 어디에 우물이 잘 나오느냐만 들었을 뿐이다. 정말 목이 마른지, 배가 고픈지, 잠이 오는지는 생각해보지 못한 게 아닐까. 다른 사람과 다른 \u0026lsquo;나\u0026rsquo; 이기 때문에.\n내가 할 수 있는 일은, 남들도 다 할 수 있다.\n그렇지만, 남들이 하지 않기 때문에 내가 특별하다. 이런 장황한 이야기를 한 이유는 두 가지이다. 다른 모든 사람이 각자 누리고 있는 우물을 나도 파내서 마시기엔 시간이 부족하다는 점을 인정하기 위해, 그리고 나만의 특별함을 강조하기 위해서다. 살면서 느꼈던, 소중한 경험을 잘 간직하고 계속 행복할 수 있는 방법을 찾아나가는 것을, \u0026lsquo;어떻게\u0026rsquo; 라는 주위에 널린 해답에서는 찾지 말길 바란다.\n","date":"2017-12-11T03:20:57Z","permalink":"https://interp.blog/%EC%99%9C%EC%97%90%EC%84%9C-%EC%B0%BE%EB%8A%94-%ED%8A%B9%EB%B3%84%ED%95%9C-%EB%82%98/","title":"‘왜’에서 찾는 특별한 나"},{"content":"먼저, Windows 10 에서 지원하는 Linux Subsystem 기능에 대해 이야기한다. 잘 모르겠다면 이 글을 읽고 설치에 도전해 보자. 그런데 글 내용을 보면 이거랑 관련 없다. Babun, Mintty, Git on Bash, Putty 전부 포함이다\n SSH에 접속한 서버에서 X11 Forwarding 을 받고 싶은 경우를 이야기한다. 단적으로, 접속한 서버에서 파이어폭스 브라우저를 실행하면 내 윈도우 화면에 브라우저 창이 실행되는 거다. 이걸 따로 이야기하고 싶지 않으니 Xming 이나 VcXsrv 을 참고해 설치해보자.  참고로, 이 방법은 Client측 PC의 X Server로 접근하는 무식한 방법이므로, 일반 데스크탑 PC에서 서버로 접속했을 때엔 사용할 수 없을 것 같다. 좀 더 알아보고 보충해야겠다.\n그리고, ssh_config 에서 X11ForwardTrusted 를 확인하지 않았었다. 이걸 설정하니까 Server에서 DISPLAY를 따로 설정하지 않아도 잘 된다? xauth generate 를 한번 더 해보긴 했는데.. 한번 더 실험이 필요하다.\nWindows에서 한 일 클라이언트 PC에서 작업한 일이다. 참고로 나는 Ubuntu 를 Linux Subsystem 으로 설치했는데, 어느 리눅스 버전이어도 상관 없을 것이다.\n Xming 또는 VcXsrv 를 설치해서 실행시켰다. 트레이 아이콘에 \u0026lsquo;X\u0026rsquo; 라고 떠 있으면 완료. (이걸 X Server 라고 부른다) Ubuntu Console을 하나 열어서,/etc/ssh/ssh_config (sshd_config 가 아니다) 파일을 확인했다. 여기에서 ForwardX11 yes, ForwardX11Trusted yes 를 확인했다. (주석 처리되어 있다면 주석을 제거, sudo 권한 필요) SSH 접속을 하면, 다음 에러 메시지가 떠서 보기 싫었다. No xauth data; using fake authentication data for X11 forwarding. 그래서 다음과 같이 처리했다. $ xauth list # ~/.Xauthority 파일이 없었다! $ xauth generate :0 . trusted # ~/.Xauthority 파일을 만들어준다고 한다..  (Optional) Xming 또는 VcXsrv 의 설치 디렉토리에 가면 X0.hosts라는 파일이 있다. 여기서 Server의 Hostname 또는 IP를 적어줘야 한다.  Server에서 한 일 직접 SSH로 접속하고 나서 설정해야 할 것을 적었다.\n /etc/ssh/sshd_config 에서 X11UseLocalHost 가 yes 로 되어 있거나, 활성화되어 있지 않아야 한다. 만약 no로 되어 있으면 yes 로 변경해야 한다. $DISPLAY 환경 변수를 아예 Windows (클라이언트 PC) 의 Hostname 또는 IP 주소로 설정해버린다. export DISPLAY=192.168.0.xxx:0 참고로, 뒤에 :0 또는 :10 같이 여러 예제가 인터넷에 나도는데, Windows 에서 X 아이콘에 마우스를 가져다 대면 Hostname:X.X 라고 나올 것이다. X.X 를 저기에 쓰는 것이다. (나는 0.0 이라고 떠서 그냥 0만 적었다.) firefox 를 실행해 보자. 끝.  ","date":"2017-11-29T08:32:52Z","permalink":"https://interp.blog/x11-windows-linux-subsystem/","title":"X11 on Windows Linux Subsystem"},{"content":"대학생 때 팀 프로젝트로 윈도우 어플리케이션을 끄적이던 때가 있었다. 그 때 C# 기반으로 진행했었는데, 나는 뷰에 집중했던지라 디자인하고 프로퍼티 만지기 바빴고 뼈대는 다른 친구가 만들어 줬었던 기억이 난다. 그 때부터 C/C++ 와는 다르지만 비슷한 이름의 이 언어에 왠지 모를 끌림이 있었다. 하지만 배울 기회는 없었지..\n바로 그 언어, C#을 현업에서 당장 써먹어야 하는 상황이 발생했다. (이런 상황이 왜 발생했는지 한탄은 나중에 일단 하기로 하고) 어쩔 수 없이 배움의 기회로 삼는 수 밖에 없다.\ndotnet test 및 xUnit을 사용하여 .NET Core에서 C# 유닛 테스트라는 MS 문서를 기반으로 실습을 했는데, 여기서 중요한 것은, 내가 만들어야 하는 라이브러리의 Target Framework가 .NET Core 가 아니라 .NET Framework 4.0 이다. xUnit은 최소 .NET Framework 4.5 이상에서만 돌아간다.\n그럼 나는 테스트를 못 하는 것인가? 실제론 그렇지는 않았다. xUnit 프로젝트만 .NET Framework 4.5 로 두고, 라이브러리 프로젝트는 .NET Framework 4.0 으로 설정해서 테스트를 진행해 봤다. 대부분의 내용은 위의 문서를 요약한 것에 지나지 않지만, 중간에 Target Framework를 설정하는 부분에 대해서도 설명하겠다.\n사전 준비 혹시나 해서 적어둔다. 다 필요없고 .NET Core SDK 를 설치해주자.\n .NET Framework 4.0, .NET Framework 4.5 SDK 가 설치되어 있어야 한다. (Visual Studio 설치하면서 같이 설치하는게 속편하다) .NET Framework 4.5 이후의 TargetFramework를 가져가는 경우엔 .NET Core SDK 를 설치하는 것으로 끝날지도 모른다는 어렴풋한 추측을 해 본다. (Target Framework를 수정한 다음 dotnet restore 를 하면?)  그리고 아래 실습은 Visual Studio 가 아니라 Powershell 에서 진행한다. 사내 빌드할 때 Visual Studio를 안 쓰기 때문이다. 단지 그 뿐이다..\n솔루션/프로젝트 준비  디렉토리를 하나 만든다. 여기서는 testSolution 라고 하자. dotnet new sln 을 실행한다. 솔루션 파일이 생성된다. 내부에 디렉토리를 하나 만든다. 여기서는 projLibrary 라고 하자. projLibrary 에 들어가서 dotnet new classlib 명령으로 프로젝트를 만든다. classlib 라고 입력하면 해당 프로젝트는 라이브러리를 생성하는 것이 된다. 다시 testSolution 디렉토리로 돌아와서, dotnet sln add projLibrary/projLibrary.csproj 를 입력한다.\n이제 솔루션에 해당 프로젝트가 등록된다. testSolution내부에 테스트용 디렉토리를 하나 만든다. 여기서는 projTest 라고 하자. projTest 에 들어가서 dotnet new xuint 를 입력해 테스트용 프로젝트를 만든다.\nxuint 라고 입력하면, 해당 프로젝트는 테스트를 위한 것이 된다. 다시 testSolution 디렉토리로 돌아와서, dotnet sln add projTest/projTest.csproj 를 입력한다. 이제 솔루션에 해당 프로젝트가 등록된다. 마지막으로 테스트 프로젝트에 라이브러리 프로젝트를 참조할 수 있도록 연결해야 한다.\nprojTest 에 들어가서 dotnet add reference ../projLibrary/projLibrary.csproj 를 입력한다.  그러면 아래와 같이 디렉토리와 파일이 구성되어야 한다. (자동으로 생성되는 Class1.cs 는 제외했다.)\n/testSolution testSolution.sln /projLibrary projLibrary.csproj /projTest # other referenced files (xunit) projTest.csproj Test Framework 수정 projLibrary 에 있는 projLibrary.csproj를 열어서 아래를 수정한다.\n\u0026lt;TargetFramework\u0026gt;net40\u0026lt;/TargetFramework\u0026gt; 만들고자 하는 프레임워크 버전을 명시하면 되고, 버전은 [여기][2]를 참고한다. 여러 개의 버전을 명시할 경우에는 세미콜론(;) 으로 구분하면 된다.\n역으로, projTest 에 있는 projTest.csproj 는 이렇게 수정해야 한다.\n\u0026lt;TargetFramework\u0026gt;net45\u0026lt;/TargetFramework\u0026gt; 기본적으로 netcore2.0 으로 설정되어 있을텐데, 이러면 net40 과 호환이 안되어서 참조조차 안되는 불상사가 발생한다. net45 또는 그 이상의 .NET Framework를 지정하되, netcore1.x 에 대응되는 버전으로만 지정하면 될 것으로 보인다.\n테스트 작성 projLibrary에서 Class1.cs 에 다음을 추가하자.\nusing System; namespace ProjLibrary { public class Class1 { public bool IsPrime(int candidate) { throw new NotImplem\u0026lt;span style=\u0026#34;display: inline-block; width: 0px; overflow: hidden; line-height: 0;\u0026#34; data-mce-type=\u0026#34;bookmark\u0026#34; class=\u0026#34;mce_SELRES_start\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;entedException(\u0026#34;Please create a test first\u0026#34;); } } } 아직 구현을 안 한 거다. 이제 projTest에서 Class1.cs에 다음을 추가한다\nusing Xunit; using ProjLibrary; namespace Prime.UnitTests.Services { public class TestClass1 { private readonly Class1 _service; public Class1_IsPrimeShould() { _service = new Class1(); } [Fact] public void ReturnFalseGivenValueOf1() { var result = _service.IsPrime(1); Assert.False(result, \u0026#34;1 should not be prime\u0026#34;); } } } 테스트 다 끝났다. 이제 솔루션 디렉토리에서 dotnet test 를 힘차게 불러보자.\n에러가 날 것이다. 당연히 테스트 코드에서 result 값이 FALSE가 나오기를 기대하는데, 지금은 그냥 Exception 으로 떨어지기 때문이다.\nprojLibrary에서 IsPrime() 함수의 리턴을 FALSE로 바꿔주면 테스트가 성공하는 것을 확인할 수 있다.\n[1]: [2]: https://docs.microsoft.com/en-us/dotnet/standard/net-standard\n","date":"2017-11-29T03:28:03Z","permalink":"https://interp.blog/csharp-xunit-practice/","title":"C# xUnit 실습"},{"content":"Upgrade 8.x 로 쓰다가 10.x 로 업그레이드를 진행했다. 아니.. 그런데 Postgresql Database 버전이 다르다고? 알고보니 이렇게 대격변을 일으키면 안 되던 거였다. 그래서 겸사겸사 9.5.10 으로 다시 설치하니까 된다.\n gitlab-ctl reconfigure 를 설치 직후에 반드시 해 줘야 한다. 가끔 gitlab-ctl pg-upgrade 를 꼭 하라는 말이 있던데, 내가 해보니까 gitlab-ctl reconfigure 할 때 알아서 한다 (…) 했던 거 또 하는 느낌. gitlab-ctl restart 를 할 때 postgresql 이나 다른 곳에서 \u0026lsquo;down, up, want up\u0026rsquo; 이런 게 뜨면 서비스가 온전히 수행될 수 없는 상황이다. gitlab-ctl tail 을 실행시켜 로그를 뒤져봐야 한다. 에러가 났거나, 무한히 반복되는 메시지가 없는지 확인하자.  Runner 우리 회사 Gitlab 구조는 웹 서비스 주소와 내부 공유 주소가 다르다. (도메인을 거의 리다이렉트 비슷하게 해놨기 때문이기도 하지만) 비공개 저장소다 보니, 웹 접속은 외부에서 되었면서 Clone 은 똑같은 주소로 절대 받을 수 없게 해 놨다. 이게 Gitlab Runner 를 바보로 만들었다 (…)\nGitlab Runner는 .gitlab-ci.yml 의 구성에 상관없이, 선작업으로 해당 저장소를 Cloning 하거나 Fetching 하게 된다. (양자택일은 웹 페이지의 Runner 관리 페이지에서 설정이 가능하다.) 이건 Runner의 Executer를 Docker를 하던 Shell 을 하던 똑같다. 문제는 내가 언급했던 대로, 이 저장소 주소를 웹 주소에 기반해서 가져가기 때문에, 항상 실패했다는 것이다.\n짜증이 치밀 즈음, 아예 이 작업을 끌 수는 없을까 하고 봤더니… 역시나 답은 있었다.\nvariables: GIT_STRATEGY: none 이렇게 두면, Runner의 옵션을 Cloning 으로 줬건 Fetching 으로 줬건 간에 하지 않는다.\n즉, 모든 작업을 온전히 CI 명령에 맡기는 것이다. 위험하기도 하고, 캐싱도 안 되고 약점이 많지만, 나는 상관이 없었다. 직접 내부 주소의 저장소로 접근해서 받아오면 그만!\nRepository 에 SSH Key 등록 그런데, 문제가 생겼다. 아래와 같이 \u0026lsquo;gitlab-runner\u0026rsquo; 사용자로 Runner Service를 등록하고, 실행시켰다고 가정하자.\ngitlab-runner install --user gitlab-runner gitlab-runner start ps aux | grep gitlab-runner # gitlab-runner run 이 잘 되고 있어야 한다. 나는 Executer를 Shell 로 쓰고 있는데, 이 친구가 내부 저장소로 (그것도 SSH 주소로) 접근하려면… SSH Public Key를 넣어줘야 된다. 넣지 않으면 인증에서 실패한다. 그런데 Gitlab Runner 의 Shell 사용자는 위에서 보이는 것 처럼 \u0026lsquo;gitlab-runner\u0026rsquo; 인데.. 얘는 Gitlab 계정도 없는 가상 사용자다. 어떻게 Public Key를 등록할까?\nGitlab은, 각 사용자 계정의 SSH Public Key를 관리해 주기도 하지만 Project 별로 SSH Key를 등록할 수도 있다. Project 페이지의 Settings \u0026gt; Repository 에서 Deploy Keys 부분을 펼쳐보자. 그러면 익숙한 SSH Key 등록 폼이 나온다. 여기에, 아까 언급한 \u0026lsquo;gitlab-runner\u0026rsquo; 의 SSH Key를 등록하면 된다. (당연히 gitlab-runner 계정에서 SSH Key 생성을 해야한다.)\n그러면.gitlab-ci.yml 에 마구잡이로 'git clone git@~~~~:\u0026lt;user or group\u0026gt;/\u0026lt;project\u0026gt;.git' 이런 식으로 스크립트를 적어도 아주 잘 clone 되는 걸 확인할 수 있다!\nCreate New Branch 의 기본 Branch 바꾸기 Issue 페이지에서 Create New Branch (9.x 에서는 New Branch) 를 하면, Branch의 이름이 \u0026lsquo;421 – invalid table error\u0026rsquo; 이런 식으로 뜬다. 이슈 번호와 이슈 제목.\n그런데 내부적으로는 이슈 제목에 한글을 많이 써서 Branch 이름을 출력하고 싶지 않았다. 그리고 규격화된 이름 (ISSUE#XXXX) 으로 Branch를 생성하고픈 욕구가 치밀었다. (참고로 Push Rule 에서 Branch Naming Rule에 저렇게 규칙을 쓰고, Create New Branch 를 누르면 절대로 Branch가 생기지 않는다.)\nGitlab에 이미 #21143 으로 이슈가 등록되었고, 10.3 에서 업데이트가 된다지만… 이렇게 되면 사용자가 매번 Push Rule을 피하려고 Branch 이름을 일일이 쳐넣는 어처구니없는 상황이 계속된다. 그래서 코드를 찾아내서 고치는 편이 낫다고 생각했다.\nRuby는 쥐뿔도 모르지만 코드는 코드일 뿐.\n이슈에 대한 브랜치를 생성하는 작업은 이 Merge Request 에서 반영된 것이다. 여기 Diff를 쭉 봤더니 to_branch_name 이 눈에 띈다. 오호라. 하지만 어디서 수정해야 할까?\nGitlab을 Omnibus 로 정직하게 설치했다면 소스코드 경로는 /opt/gitlab/embedded/service/gitlab-rails/ 에 있다. 여기서 grep으로 to_branch_name 을 검색해 보면?\ncd /opt/gitlab/embedded/service/gitlab-rails/ grep to_branch_name . -rn # ./embedded/service/gitlab-rails/app/models/issue.rb:XXX def to_branch_name # 이하 생략 vi app/models/issue.rb 여기서 \u0026quot;#{iid}-#{title.parameterize}\u0026quot; 라고 정의된 부분을 적절히 바꿔주자. 나는 \u0026quot;ISSUE##{iid}\u0026quot; 로 심플하게 바꿨다.\n이것만 바꾸면 \u0026lsquo;Create New Branch\u0026rsquo; 를 누를 때 잘 될 것 같다. 하지만 Issue 페이지에서 \u0026lsquo;연관된 Issue Branch\u0026rsquo; 목록에 연결되지 않는다. 수정한 파일 /opt/gitlab/embedded/service/gitlab-rails/app/models/issue.rb 에서, 더 수정할 것이 남아있다. 다음 함수를 수정해야 한다.\n has_related_branch related_branches  수정 방법은 간단한데, Branch와 비교하는 Regular Expression 의 문법을 찾아보자. /\\A${iid}-(?!\\d+-stable)/i 라고 되어 있을 것이다. 이걸 실제로 irb 에서 테스트해 보면, 420-title 같은 건 되는데 420-0-stable 은 인식이 안 되는 것을 알 수 있다. (뭔가.. 이상하다) 아무튼 이걸 적절한 Regular Expression 으로 바꿔 주도록 하자. Ruby의 Regexp 에 익숙치 않다면 Rubular 사이트의 도움을 받아보도록 하자. (내 경우는 간단하게 /\\AISSUE#{iid}/i 라고 했다.)\n수정을 했다. 하지만 끝이 아니다. 마무리를 해 줘야 한다. 실제 Gitlab이 서비스되고 있는 경로는 /var/opt/gitlab 이므로, 해당 경로로 적용을 시켜줘야 한다. 어떻게?\n간단하다. gitlab-ctl reconfigure \u0026amp;\u0026amp; gitlab-ctl restart 를 입력하자.\n","date":"2017-11-15T09:17:58Z","permalink":"https://interp.blog/gitlab-%EC%82%BD%EC%A7%88%EA%B8%B0/","title":"Gitlab 10.x 삽질기"},{"content":"자주 쓰긴 하지만, 곧바로 생각나지 않을 것을 대비해서\u0026hellip; 서버실 서버 사양을 전부 체크하려다 보니 어쩔 수 없이 정리했다.\nCPU / Memory 확인 CPU / Memory 는 사실 쉽다. /proc/cpuinfo 와 /proc/meminfo 안에 들어있기 때문이다.\n$ cat /proc/cpuinfo | grep \u0026#34;model name\u0026#34; | sort -u model name : Intel(R) Core(TM) i3-4160 CPU @ 3.60GHz $ cat /proc/meminfo | grep \u0026#34;MemTotal\u0026#34; MemTotal: 8040588 kB Disk 확인 df 는 mount 된 것만 확인이 가능해서 별로고, lsblk 를 하면 마운트되지 않은 것까지 나온다.\n$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 477G 0 disk ├─sda1 8:1 0 468.8G 0 part / └─sda2 8:2 0 8.2G 0 part [SWAP] sdb 8:16 0 2.7T 0 disk ## df 는 sdb가 보이지 않는다. $ df -h Filesystem Size Used Avail Use% Mounted on /dev/sda1 462G 8.4G 430G 2% / tmpfs 79G 224K 79G 1% /dev/shm ","date":"2017-10-30T08:31:03Z","permalink":"https://interp.blog/linux-%EC%97%90%EC%84%9C-cpumemorydisk-%ED%99%95%EC%9D%B8/","title":"Linux 에서 CPU/Memory/Disk 확인"},{"content":"게임 \u0026lsquo;배틀그라운드\u0026rsquo; 에서, 어떻게 해야 상위 랭크에 도달할 수 있는지를 수학적인 접근으로 잘 풀어낸 네이버 블로그 글을 봤다. 누군가에겐 그저 즐기는 게임이 될 수 있지만, 누군가에게는 연구대상이 된다. 사물이나 현상을 어떻게 바라보느냐, 얼마나 관심있느냐에 따라서 통찰이 생겨난다. 이것은 모두에게 열려있다. 반대로 생각하면, 논문을 쓰는 사람들은 결단코 고상한 사람들이 아니다.\n\u0026lsquo;수학적인 접근\u0026rsquo;이라는 말 때문에 설득력이 떨어질 수는 있다. 하지만 어느 분야나 자신의 경험을 녹여 전혀 다른 곳에서 적응하는 사람들을 우리는 일상에서 많이 봤다. 그것이 상식이 될 수도 있고, 연륜이 될 수도 있다. (개인적으로는, \u0026lsquo;나이를 먹어감에 따라 현명해지는 것은 잘못된 생각이다\u0026rsquo; 라는 누군가의 말에 동의하지만…)\n그런 사람이 되어야 하지 않을까, 생각한다.\n","date":"2017-10-12T01:09:33Z","permalink":"https://interp.blog/%ED%98%84%EC%83%81%EC%9D%84-%ED%86%B5%EC%B0%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/","title":"현상을 통찰하는 방법"},{"content":"mmap 은 memory map 의 줄임말이다. 메모리의 특정 영역을 파일 디스크립터로 인식하게 만드는 것이다.\n map or unmap files or devices into memory\n(메모리 영역을 파일이나 디바이스로 인식하게 합니다)\n– manpage of mmap\n 사용 void * mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); 여기서 의미가 있는 건 Length, Prot (Protection), Flag 뿐이다.\n Start 는, Kernel이 아무 곳이나 지정해도 좋다면 NULL을 입력한다. Offset 은, 보통 0으로 둔다. (MAP_ANONYMOUS 또는 MAP_ANON Flag가 있는 경우엔 무시된다) Fd 는, 연결할 파일 디스크립터를 지정한다. (MAP_ANONYMOUS 또는 MAP_ANON Flag를 통해서 \u0026lsquo;파일로 사용하지 않는다\u0026rsquo; 라고 한다면 -1을 넣어줘야 한다. (사실 안 넣어주고 무시해도 되지만 몇몇 구현에서는 넣어야 한다 카더라)  Protection 매핑된 메모리 영역의 사용 권한 같은 것을 정하는 것이라고 이해하자. 리눅스 파일 시스템의 권한과 비슷한 분류로 이해하면 더욱 쉽다. (물론 똑같지는 않지만)\n PROT_NONE : 메모리 영역은 아무것도 할 수 없다. PROT_READ : 메모리 영역을 읽을 수 있다. PROT_WRITE : 메모리 영역을 쓸 수 있다. PROT_EXEC : 메모리 영역이 실행될 수 있다.  이 때, 연결된 파일 디스크립터의 모드와 절대 충돌해서는 안 된다. 예를 들어 파일 디스크립터를 획득할 때는 w+ 라고 해놓고 여기서 PROT_READ 라고 하면, 예상치 못한 무언가가 일어나지 않을까?\n메모리 영역의 보호에 관련된 자세한 내용은 여기를 참고하자.\nFlag    Flag 사용 가능 커널 설명     MAP_SHARED – 이 매핑을 다른 프로세스들이 공유할 수 있다. (실제 파일과 연결되어 반영된다. 하지만 자동으로 반영하지는 않고 msync 나 munmap 을 호출해야 반영된다.)   MAP_PRIVATE – 이 매핑을 다른 프로세스들과 공유하지 않는다. 실제 파일과도 연결되지 않으므로, mmap 이후에 파일에 반영되는 변경 내역이 매핑된 영역에 반영되는지는 확신할 수 없다.   MAP_32BIT ~2.4.20, 2.6 첫 2GB 안에서 영역을 잡는다. x86-64 프로그램에서만 사용이 가능하다.\n(초기 64-bit 프로세서에서는 context-switch 비용 절감을 위해 사용할 수 있는 옵션이겠지만, 지금은 그렇지 않으므로 굳이..)   MAP_ANONYMOUS\nMAP_ANON – 파일 디스크립터로 인식하지 않는다. fd와 offset은 무시되지만, 몇몇 구현에서는 fd를 반드시 -1로 입력해야 한다.  ※ SHARED와 같이 사용하려면 Kernel Version 이 2.4 이하여야 한다.    헉헉.. 아래에 더 있는데 여기까지만 해야겠다. 내가 사용하고자 하는건 사실 ANONYMOUS Flag 만 있으면 되는데 말이지.\n","date":"2017-09-20T13:29:57Z","permalink":"https://interp.blog/mmap-memory-block-like-file/","title":"mmap : 메모리를 파일처럼"},{"content":"pthread_yield() 와 sleep() 의 차이를 묻는 Stack Overflow 글 의 답을 발췌한다.\n pthread_yield() 는, 호출한 쓰레드가 프로세서 사용을 그만두고, 스케쥴링이 될 때 까지 작업 큐(run queue)에서 기다립니다. 만약 호출되었을 때 작업 큐가 비어 있다면, 즉시 스케쥴링이 되겠죠.\nsleep() 은 X초만큼 지나거나, 무시할 수 없는 시그널이 도착할 때 까지 (다른 쓰레드를 포함한) 호출 프로세스를 재웁니다.\n현재 쓰레드를 실제로 지연시키고 싶지 않지만 (호출 쓰레드 대신) 다른 쓰레드에게 실행권을 넘겨주고 싶은 경우라면, sleep() 보단 pthread_yield() 가 적합할 것 같습니다.\n sleep 자체가 프로세스를 아예 멈추게 하니까 pthread_yield 를 통해서 나는 잠시 빠져주는 상태로 만드는 거였다. 코드를 보면서 감으로만 \u0026lsquo;아 저건 sleep() 같진 않지만 뭔가 이럴 때 쓰는거야\u0026rsquo; 라고만 어렴풋이 알고 있었는데, 무엇이든 확실히 알아야 한다.\n","date":"2017-08-24T05:35:24Z","permalink":"https://interp.blog/pthread_yield-vs-sleep/","title":"pthread_yield vs. sleep"},{"content":"💡   2012년에 작성한 것을 각색했습니다. 1편의 리메이크와 더불어, 1편 제작진이 만드는 신작 \u0026lsquo;칼리스토 프로토콜\u0026rsquo; 역시 기대 중입니다.   EA에서 출시하고, 레드우드 쇼어에서 개발한 데드 스페이스(Dead Space) 를 플레이했다. SF 호러 FPS, 아니 TPS 장르로는 센세이셔널한 게임이 아닐 수 없다.\n문득, 하늘 위 우주에 나 혼자 둥둥 떠있으면 무슨 생각이 들까? 하는 생각을 했던 적이 있다. 공기가 없으니 소리도 안 들릴 것 같은데, 정말 아~무 것도 없는 곳에 혼자 있으면 미치지 않을까? 그런 경험을 조금이나마 간접 체험할 수 있는 게임이라고 생각한다.\n  공허하다\n  불행한 시작 주인공인 아이작은 먼 미래에, 우주에서 운석 채굴을 해 돈을 버는 거대 기업의 엔지니어이다. 사랑하는 여자친구인 니콜도 있다. 니콜은 잠시 \u0026lsquo;이시무라 호\u0026rsquo; 라는 채굴용 우주선에 출장을 간 상태.\n그런데, 니콜이 긴급 메시지를 보내는데 뭔가 이상하다. 도와달라고 하면서 여기 아무도 없다고 한다. 그 후 이시무라 호와의 교신이 완전이 끊기고, 기업은 이시무라 호에 아이작을 포함한 조사대를 보낸다.\n이시무라 호에 도착해 보니 사람은 온데간데 없고, 갑자기 괴물이! 후다다루ㅏ아우ㅜㅋ팇칰 나타나면서 상황은 긴박하게 흘러간다. 설상가상으로 그 괴물들이, 조사대가 타고 온 함선마저 부셔트렸다. 아… 망했어요. 괴물은 우글대는데, 조사대로 같이 온 동료 중 생존자인 대장 헤먼드와 켄드라는 튀어야 해! 싸워야 해! 라며 티격태격대질 않나.. 아이작은 거의 기능이 정지된 이시무라 호를 헤집어가며 하나씩 원상복구 시킨다. 그러면서 알게 되는 이 함선의 무서운 비밀과 음모를 맞딱뜨리게 되는데\u0026hellip;\n  혼자 왔니? oㅅO\n  비주얼에 한 번 공포의 요소 중 가장 큰 부분은 바로 \u0026lsquo;보이는 것\u0026rsquo;. 피가 튀고 살점이 날아가지 않아도 충분히 무서운 호러 게임도 있지만, 그래도 기본적으로 호러에 비주얼이 빠지면 섭하다. 작중 괴물 포지션인 네크로모프를 마주할 때, 그리고 싸울 때 이 게임의 잔인함을 그대로 느낄 수 있다.\n호러 액션게임, 아니 그냥 액션게임이라도 인간형 괴물 또는 인간인 적을 빨리 죽이려면 어떻게 해야 되던가? 우리가 흔히들 말하는 **\u0026lsquo;헤드샷\u0026rsquo;**을 날려 속전속결을 볼 수 있었다. 근데, 이 게임은 역발상으로, 사지를 끊어야 죽는다. 능지처참?! 반대로, 머리를 날리자! 하면서 헤드샷을 쏘면, 되려 머리없는 녀석이 뚜벅뚜벅 걸어와서 더 무섭다. ㅠㅠ\n주인공의 HP 가 다 되면, 그냥 풀썩 쓰러지고 게임 오버가 된다고? 이 게임은 그렇게 시시껄렁하게 주인공의 최후를 장식해주지 않는다. 주인공의 데드 씬이 너무 다양하고 잔인해서, 한 번 보게되면 \u0026lsquo;아\u0026hellip; 다시는 죽지 말아야지\u0026rsquo; 라는 생각이 들 정도이다. 네크로모프의 기다란 팔에 관통당하는 건 기본, 되려 주인공의 사지를 찢어 발기거나, 어떤 씬은 다리가 잘렸는데 그 다리를 주인공이 들고 \u0026lsquo;아니, 내가 다리가 잘리다니! 말도 안된다고..\u0026rsquo; 라며 울부짖다가 머리가 날아가기도 하고, 독에 중독되거나 기생수같은 놈한테 빨아먹혀 역으로 괴물이 되거나\u0026hellip; 생각만 해도 끔찍하다. 이런 비극적 요소도 비주얼적인 잔인함에 한 몫 한 셈.\n반대로, 함선에 널부러진 네크로모프의 유해를 다리로 짓이길 수 있다. 그러면 추가 아이템이 나온다. 와우! 그보다는 확인사살을 위한 액션이란 의미가 더 크다. 확인사살을 하지 않으면, 스멀스멀 등 뒤에서 일어나 기습하는 살떨리는 순간을 맞이해야 하기 때문이다.\n사운드에 또 한 번 혹시 공포영화를 볼 때, 소리를 죄다 끄고 영상만 본 기억이 있을까? 필자는 아마 \u0026lt;링\u0026gt;을 볼 때가 처음이었는데, 아무리 무서운 영화라도 음향 효과 없는 공포장면은 마치 귀신이 원맨쇼 하는 것 같은 우스꽝스러운 상황으로 보일 것이다. 그만큼 음향효과도 호러 게임에서는 무시할 수 없는 요소인데, 이 게임은 그 효과음도 아주 잘 살렸다.\n네크로모프가 나타나기만 하면, 위기감을 조성하는 효과음이 어김없이 등장한다. 노이로제가 걸릴 정도로 자주 들을 경고음인데, 어떤 경우는 방에 가둬두고 효과음만 내고 한동안 아무도 안 나오기도 하고 이럴 땐 참\u0026hellip; 어디서 뭐가 나오는지 모르니까. 소리 한 번으로 플레이어를 지배하게 되는 셈이다.\n배경음 뿐만 아니라 게임 안에서 들리는 사운드 역시 무섭다. 자동문이 끼익끼익 거리거나, 빈 복도에 미친 사람이 웃고 다니거나, 네크로모프 괴물이 괴성을 질러대기도 한다. 이 게임의 대표적인 씬 (scene) 인, 미친 사람이 벽에 머리를 찧는 장면. 그 쿵쿵 소리가 지금 생각해도 최고의 연출이라고밖엔 말 할 수가 없네요.\n게이머가 아닌 주인공을 위한 인터페이스 이 게임은 게임 인터페이스가 없다. 자세히 말하면, 인터페이스가 게임에 녹아 들어가 있어서 아이작이 조작하는 모습을 우리가 보는 것일 뿐. 체력 바는 아이작의 등 뒤에, 아이템 리스트나 기술 업그레이드표, 수집했던 것들은 아이작의 눈에서 나오는 빔으로 표시된다. 우리는 그저 아이작의 시선을 따라갈 뿐이다.\n이런 인터페이스를 시도한 이유가 과연 뭘까? 유저가 더욱 게임에 몰입할 수 있도록 하기 위해서이진 않을까? 그리고 인터페이스를 다각화하기 위해 FPS 가 아닌 TPS 를 선택한 이유도 여기에 있을 것 같다. FPS의 경우 총구만 보이기 때문에 앞의 적만 보이지만, TPS의 경우, 상호작용할 수 있는 포인트를 확대함과 동시에, 부가적으로 등 뒤의 네크로모프가 팔을 휘젓는 모습마저 플레이어가 볼 수 있으니까.\n  소지품을 확인하는 아이작\n  외톨이가 아니야 죽음의 우주선에서 홀로 남겨진 컨셉은 확실히 유저들을 공포에 몰아넣기 충분한 세계인 듯 하다. 게다가 싱글플레이 하나로 게임을 팔아야 했기 때문에 스토리의 짜임새도 무척 좋다. 이 게임의 프로모션을 위해 애니메이션과 그래픽 노블을 제작했을 정도로 스토리에 많은 신경을 썼으니까.\n이 게임은 속편이 이미 나와있다. 그리고 3편도 제작중이다. 아마 시나리오 상 사골곰탕이 될 가능성이 높지만, 끊임없이 나오는 네크로모프를 상대로 아이작은 살아남을 수 있을까?\n  ","date":"2012-11-07T16:31:36Z","image":"https://interp.blog/uploads/1/deadspace_title.jpg","permalink":"https://interp.blog/dead-space-2008/","title":"데드 스페이스 (Dead Space, 2008)"}]
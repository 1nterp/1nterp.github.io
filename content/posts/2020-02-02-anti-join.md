---
title: Anti Join
author: interp
type: post
date: 2020-02-02T12:59:10+00:00
draft: true
private: true
url: /anti-join/
mentions:
  - 'a:0:{}'
categories:
  - 미분류

---
<p style="text-align: justify;">
  Join Method의 일종으로, Driving Record와 조건을 만족하는 Driven Relation의 Record가 &#8221;&#8217;존재하지 않을 경우&#8221;&#8217; Driving Record가 결과가 되는 Join을 말한다. Anti Join에서 Driven Relation은 주로 NOT EXISTS, NOT IN 연산에 놓인 Subquery가 변형되어 지정된다.
</p>

### Oracle 에서

<p style="text-align: justify;">
  (참고로 Semi Join도 동일하다) Oracle에서 주목할 만한 처리 과정이 있는데, Subquery 내부에 Anti Join Predicate이 존재하지만 상위에 Transitive Predicate가 존재하거나 Filter가 존재해서 해당 Join Predicate이 Filter 화 되는 경우가 있다.
</p>

<pre class="brush: sql; title: ; notranslate" title="">CREATE TABLE T1(i1 int, i2 int);
CREATE TABLE T2(i1 int, i2 int);
CREATE TABLE T3(i1 int, i2 int);
CREATE INDEX T3_IDX ON T3(i1, i2);

SELECT * FROM T1, T2
WHERE  T1.i1 = 1
  AND  T1.i1 = T2.i1
  AND  NOT EXISTS ( SELECT /*+ NL_AJ */ * FROM T3
                    WHERE  T3.i1 = T2.i1
                      AND  T3.i2 = 2 );
</pre>

<p style="text-align: justify;">
  이런 쿼리라면 T3.i1 = T2.i1 때문에 T2 &#8211; T3 간 Anti Join이 만들어져야 한다. 그런데 Main Query의 Predicate을 보면 결국 T2.i1 = 1로 치환된다. 이 치환은 Subquery에도 적용되고, 결국 Subquery 안에는 Join Predicate은 없고 T3.i1 = 1 AND T3.i2 = 2 만 생긴다.
</p>

<p style="text-align: justify;">
  중요한 점은, T3는 결과로 낼 필요가 없으므로 TABLE ACCESS 를 할 필요 없이 인덱스만 참조해 결과가 있냐 없냐만 판단하면 된다. 따라서 실행 계획을 출력해 보면, T3에 대해 TABLE ACCESS Node가 생기지 않고 그냥 INDEX RANGE SCAN만 하고 있는 괴상한 모습을 하고 있다. 당연히 이게 더 효율적이기도 하고.
</p>

<pre style="text-align: justify;"><pre class="brush: plain; title: ; notranslate" title="">
------------------------------------------------------------------------------------
| Id  | Operation           | Name   | Rows    | Bytes   | Cost (%CPU)  | Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |        |       1 |      78 |       6   (0)| 00:00:01 |
|   1 |  NESTED LOOPS ANTI  |        |       1 |      78 |       6   (0)| 00:00:01 |
|*  2 |   HASH JOIN         |        |       1 |      52 |       6   (0)| 00:00:01 |
|*  3 |    TABLE ACCESS FULL| T1     |       1 |      26 |       3   (0)| 00:00:01 |
|*  4 |    TABLE ACCESS FULL| T2     |       1 |      26 |       3   (0)| 00:00:01 |
|*  5 |   INDEX RANGE SCAN  | T3_IDX |       1 |      26 |       0   (0)| 00:00:01 |
------------------------------------------------------------------------------------
</pre>
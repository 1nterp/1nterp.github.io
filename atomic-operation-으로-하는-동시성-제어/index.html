<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Atomic Operation 으로 하는 동시성 제어 &#183; InterP Ink</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link href rel=alternate type=application/rss+xml title="InterP Ink"></head><body><nav class=nav><div class=nav-container><a href=/><h2 class=nav-title>InterP Ink</h2></a><ul></ul></div></nav><main><div class=post><div class=post-info><time datetime="2018-04-24 02:31:38 +0000 UTC">2018년 4월 24일</time></div><h1 class=post-title>Atomic Operation 으로 하는 동시성 제어</h1><div class=post-line></div><h3 id=test-and-set-tas>Test-And-Set (TAS)</h3><p>TAS 를 이용해서 간단한 동시성 제어를 할 수 있다. testAndSet 이라는 function 을 가지고 아래의 <code>do...while</code> 문을 쓰레드 A, B 에서 동시에 호출한다고 해 보자. 이 때 lock 은 같은 변수이다.</p><p>우선 TestAndSet() 은 다음과 같은 일을 한다. 말 그대로 ‘지금 값이 무엇인지 검사하고, 값을 바꾼다’ 는 것이다.</p><ol><li>lock의 현재 값을 저장해 둔다.</li><li>lock의 값을 true 로 설정한다.</li><li>저장한 lock 의 값을 반환한다.</li></ol><p>그럼 이걸로 어떻게 아래 block 의 critical section 에 대한 동시성 제어를 할 수 있을까? Thread A 가 먼저 실행했다고 가정하면, 이런 시나리오가 된다.</p><ol><li>A : TestAndSet() 의 반환값이 false 이다. while 문을 빠져나온다.</li><li>B : TestAndSet() 의 반환값이 true 이다. (A가 true로 두고 나왔기 때문에) while 문에서 계속 돈다.</li><li>A : Critical Section 수행 후, lock 을 false 로 바꾼다.</li><li>B : 여러 번의 TestAndSet() 호출 후에, 드디어 반환값이 false 가 되었다</li></ol><pre><code>(A가 false 로 두고 나왔기 때문에) while 문을 빠져나온다.
</code></pre><p>자, 그런데 뭔가 이상하다. 이렇게 이상적으로 동작하지 않을 것 같다. TestAndSet() 함수를 라인별로 동시에 실행한다고 하면 이런 사단이 날 수 있다.</p><ol><li>A : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다.</li><li>B : TestAndSet() 에 진입해 lock 값을 저장한다. 이 값은 false 이다.</li><li>A : TestAndSet() 에서 lock 값을 true 로 바꾼다.</li><li>B : TestAndSet() 에서 lock 값을 true 로 바꾼다.</li><li>A : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다.</li><li>B : TestAndSet() 에서 저장한 값을 반환한다. 이 값은 false 이다.</li><li>A & B : 모두 동시에 critical section 을 수행한다.</li></ol><p>그럼 어떡하나? TestAndSet() 은 그래서 저런 함수만으로는 안 되고 Test-And-Set 의 연산이 일관되도록 조정해야 한다. 함수 안에 spinlock 을 쓰면 되겠네요? 싶겠지만 lock 구현하자고 lock 을 또 만드는 건 아닌 것 같다. 그래서 Test-And-Set 은 CPU에서 지원하는 Atomic Instruction 을 사용한다.</p><h3 id=fetch-and-add--ticket-lock>Fetch-And-Add : Ticket Lock</h3><p>Atomic Operation 으로 구현할 수 있는 Lock 중에 Ticket Lock 이 있는데, Fetch-And-Add 로 구현할 수 있는 방법을 알아보자.</p><p>TAS 의 케이스를 이해하고 본다면 별 다른 설명이 필요 없을 것 같다.</p><ol><li>Table Lock 초기화를 한다.</li><li>A : Table Lock 을 얻으려 한다. 이미 얻었던 <code>my_ticket (0)</code> 과 <code>now_serving (0)</code> 이 같은 값이므로 곧바로 빠져나온다.</li><li>B : Table Lock 을 얻으려 한다. 이미 얻었던 <code>my_ticket (1)</code> 과 <code>now_serving (0)</code> 이 다른 값이므로 while 문에서 대기한다.</li><li>C : Table Lock 을 얻으려 한다. 이미 얻었던 <code>my_ticket (2)</code> 과 <code>now_serving (0)</code> 이 다른 값이므로 while 문에서 대기한다.</li><li>A : Table Lock 을 해제한다. <code>now_serving (0)</code> 을 증가시켜 <code>now_serving (1)</code> 을 만든다.</li><li>B : 비로소 Table Lock 을 얻었다. (C는 여전히 대기 중이다.)</li></ol><p>여기서 핵심은 <code>fetch_and_inc</code> 인데, 마찬가지로 얻어오는 루틴과 값을 증가시키는 루틴이 따로 떨어져 있으면 중복된 티켓을 들고 기다리는 쓰레드들이 발생할 수 있다. 따라서 이것도 atomic operation 이 되어야 한다.</p></div><div class=pagination><a href=/timsort/ class="left arrow">&#8592;</a>
<a href=/%EC%95%94%EB%B3%B4%EC%8A%A4-ambos/ class="right arrow">&#8594;</a>
<a href=# class=top>Top</a></div></main><footer><span>&copy; <time datetime="2020-02-04 13:03:07.688730441 +0000 UTC m=+0.190603321">2020</time> InterP. 이 사이트는 <a href=https://gohugo.io>Hugo</a> 로 작성되었으며 <a href=https://github.com/EmielH/tale-hugo/>Tale</a> 테마를 사용합니다!</span></footer></body></html>
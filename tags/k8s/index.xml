<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>k8s on InterP Blog</title><link>https://interp.blog/tags/k8s/</link><description>Recent content in k8s on InterP Blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Thu, 22 Dec 2022 11:13:12 +0900</lastBuildDate><atom:link href="https://interp.blog/tags/k8s/index.xml" rel="self" type="application/rss+xml"/><item><title>K8s Headless Service, 왜 필요한가</title><link>https://interp.blog/k8s-headless-service-why/</link><pubDate>Thu, 22 Dec 2022 11:13:12 +0900</pubDate><guid>https://interp.blog/k8s-headless-service-why/</guid><description>&lt;p>K8s Resource 를 보거나 Helm Chart 를 보거나 헷갈리는 개념 중 하나가 바로 &lt;strong>&amp;lsquo;Headless Service&amp;rsquo;&lt;/strong> 이다.&lt;/p>
&lt;figure>
&lt;img loading="lazy" src="20221220_63a1afceb4826.jpg"
alt="흐라챠!" width="40%"/> &lt;figcaption>
&lt;p>흐라챠!&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>머리가 없는 서비스를 &lt;del>위 짤방처럼&lt;/del> 왜 만드는 건지부터 이해하려면, 먼저 서비스가 왜 필요한지 알아야 한다.&lt;/p>
&lt;h1 id="설명-먼저">설명 먼저&lt;/h1>
&lt;p>공식 문서 설명을 먼저 보자. &lt;a class="link" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="noopener"
>영어 원문&lt;/a>과 &lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/service/#%ED%97%A4%EB%93%9C%EB%A6%AC%EC%8A%A4-headless-%EC%84%9C%EB%B9%84%EC%8A%A4" target="_blank" rel="noopener"
>한국어 번역본&lt;/a>을 적절히 믹스했다.&lt;/p>
&lt;blockquote>
&lt;p>로드 밸런싱 (Load-balancing) 이나 단일 서비스 IP 가 필요하지 않은 경우엔, &amp;lsquo;헤드리스&amp;rsquo; 서비스라는 것을 만들 수 있다. &lt;code>.spec.clusterIP: None&lt;/code> 을 명시적으로 지정하면 된다.&lt;/p>
&lt;p>이 헤드리스 서비스를 통해, 쿠버네티스의 구현에 의존하지 않고도 다른 서비스 디스커버리 메커니즘과 인터페이스할 수 있다.&lt;/p>
&lt;p>헤드리스 서비스의 경우, 클러스터 IP가 할당되지 않고, kube-proxy가 이러한 서비스를 처리하지 않으며, 플랫폼에 의해 로드 밸런싱 또는 프록시를 하지 않는다. DNS가 자동으로 구성되는 방법은 서비스에 &lt;code>selector&lt;/code> 가 정의되어 있는지에 달려있다.&lt;/p>
&lt;/blockquote>
&lt;p>나름 의역을 섞어가며 최대한 쉽게 풀려고 노력했지만&amp;hellip; &lt;em>죄송합니다.&lt;/em> 지금 읽어봐도 무슨 소리를 하는지 잘 모르겠다.&lt;/p>
&lt;p>아마도, 영어 설명에서 함의된 내용이 너무나 많기 때문인 것 같다.&lt;/p>
&lt;hr>
&lt;p>내가 가장 마음에 들어하는 다른 설명을 가져와 봤다. 이번엔 &lt;a class="link" href="https://stackoverflow.com/questions/52707840/what-is-a-headless-service-what-does-it-do-accomplish-and-what-are-some-legiti" target="_blank" rel="noopener"
>스택 오버플로우 답변&lt;/a>이다.&lt;/p>
&lt;blockquote>
&lt;p>Service 로 향하는 네트워크 연결은 결국 서비스 아래에 존재하는 여러 Pod 중 하나로 가게 될 겁니다. 그런데, &lt;strong>클라이언트가 Pod 1개가 아니라 모든 Pod 들과 통신해야 한다면요&lt;/strong>? 만약 &lt;strong>같은 서비스 아래에 있는 Pod A 와 Pod B 가 서로 통신해야 한다면요&lt;/strong>?&lt;/p>
&lt;p>Service 를 통하는 건 확실한 방법은 아닙니다. 그럼 뭘까요?&lt;/p>
&lt;p>모든 Pod 들과 통신해야 하는 클라이언트를 위해, 개별 Pod 의 IP 주소를 알아내는 게 필요하겠죠. 그러면 클라이언트가 K8s API Server 에 접속해서 해당 Pod 들의 IP 리스트를 얻어내는 방법이 있습니다. 이상적인 방법은 아닙니다. &lt;strong>여러분이 개발 중인 어플리케이션을 K8s Cluster 가 있는지조차 모르게 (K8s-agnostic) 만들고 싶어 하잖아요.&lt;/strong>&lt;/p>
&lt;p>다행히도, Kubernetes 는 클라이언트에게 Pod IP 리스트를 알려주는 방법을 DNS Lookup 을 통해 제공합니다. 대개는, 어떤 Service 를 위한 DNS Lookup 를 수행하면 DNS 서버는 IP 주소 1개를 반환합니다. 바로 Service 의 Cluster IP 죠. 그런데 여러분이 Service 를 만들 때 Cluster IP 가 필요 없다고 알려주면, DNS 서버는 (해당 Service 를 위한 DNS Lookup 요청에) 소속된 Pod IP 주소 목록을 전부 반환합니다. 즉, DNS A 레코드 1개가 아니라, 각각의 Pod 과 통신할 수 있는 A 레코드 여러 개가 반환되는 것이죠. 그러면 클라이언트는 간단하게 이 A 레코드를 순회하면서 다시 DNS Lookup 을 할 수 있고 실제 Pod 들의 IP 를 얻을 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>보통 Service 의 역할은, Service 로 들어온 요청을 &lt;em>여러 개의 Pod 중 하나&lt;/em> 에만 전달하는 것이다. 하지만 이 요청이 &lt;strong>모든 Pod 에&lt;/strong> 전달되어야 하는 경우에는 적합하지 않다.&lt;/p>
&lt;p>이를 위해서 k8s-api-server 에 요청해서, Service 에 속한 Pod 의 IP 리스트를 얻어오도록 애플리케이션을 구성할 수는 있겠지만, 그 때부터 애플리케이션은 해당 API 서버 위치에 의존해야 하기 때문에 적절한 방법이 아닌 것이다.&lt;/p>
&lt;p>위의 설명대로라면, Cluster IP 를 없앤 Service 의 경우 DNS Server 가 모든 Pod 들의 A 레코드를 직접 알려주는 (resolving) 것이다. &lt;strong>요청을 수신받을 Cluster IP 가 없으니, 머리가 없는 Service 라고 부를 수 있겠다.&lt;/strong>&lt;/p>
&lt;h1 id="데모">데모&lt;/h1>
&lt;p>사실 데모는 다른 블로그에서 많이 찾아볼 수 있어서, 최소한으로 재현 할 수 있는 방법을 알아보도록 하자.&lt;/p>
&lt;h2 id="deployment-생성">Deployment 생성&lt;/h2>
&lt;p>우리는 &lt;code>nginx&lt;/code> 로 포트 오픈도 해 두고 &lt;code>curl&lt;/code> 이나 &lt;code>nslookup&lt;/code> 으로 Pod 간 통신을 체크해야 하니, &lt;code>praqma/network-multitool&lt;/code> 이미지로 replica 3개의 deployment 를 하나 만들도록 하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl create deployment test-deploy --image&lt;span class="o">=&lt;/span>praqma/network-multitool --replicas&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span> --port&lt;span class="o">=&lt;/span>&lt;span class="m">80&lt;/span>
kubectl get pods -lapp&lt;span class="o">=&lt;/span>test-deploy -o wide
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">NAME READY STATUS ...
test-deploy-7bff8c5f84-hxcfw 1/1 Running ...
test-deploy-7bff8c5f84-rjdm9 1/1 Running ...
test-deploy-7bff8c5f84-w5l8j 1/1 Running ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>첫 번째 Pod 의 IP 가 &lt;code>200.96.1.50&lt;/code> 이다. 두 번째 Pod 에서 첫 번째 Pod 으로 접속을 시도해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># connect to test-deploy-7bff8c5f84-hxcfw &lt;/span>
kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- curl 200.96.1.50:80
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Praqma Network MultiTool (with NGINX) - test-deploy-7bff8c5f84-hxcfw - ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>접속이 잘 된다. 하지만 여기 보이는 Pod IP 는 &lt;strong>언제든지 바뀔 수 있기 때문에&lt;/strong> 이런 식으로 쓰면 안 된다.&lt;/p>
&lt;h2 id="headless-service-생성">Headless Service 생성&lt;/h2>
&lt;p>이제 Headless Service 를 만들어보자. 이번에는 바로 만들지 말고 manifest 를 YAML 파일로 저장해 둔 다음에 수정이 좀 필요하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl create service clusterip test-cs-svc --clusterip&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;None&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --tcp&lt;span class="o">=&lt;/span>80:80 --dry-run&lt;span class="o">=&lt;/span>client -oyaml &amp;gt; test-cs-svc.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Headless 로 만드는 핵심 옵션이 바로 &lt;code>--clusterip=&amp;quot;None&amp;quot;&lt;/code> 라는 걸 알 수 있다. 여기서 출력되는 파일을 열어서, &lt;code>spec.selector&lt;/code> 를 deployment 의 것으로 바꿔줘야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-cs-svc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-cs-svc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">clusterIP&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">None&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80-80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-deploy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># test-deploy deployment 가 가지고 있던 app label&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterIP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">loadBalancer&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>저장해 주고, 해당 YAML 파일을 적용하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl apply -f test-cs-svc.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="dns-lookup-하기">DNS Lookup 하기&lt;/h2>
&lt;p>이제 남은 일은 Service 의 domain name 을 가지고 DNS Lookup 을 한 결과를 받아오는 일이다.&lt;/p>
&lt;p>그런데, domain name 을 어떻게 아냐고? 마지막 참고 자료에 있는 &lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener"
>K8s DNS&lt;/a> 를 읽어봐도 좋지만, 직접 알아보기 위해서는 아까 생성한 Pod 에서 &lt;code>/etc/resolv.conf&lt;/code> 가 어떻게 설정되어 있는지 확인하면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- cat /etc/resolv.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">search default.svc.cluster.local svc.cluster.local ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기 잘 보면, 해당 Pod 위치에서 요청하는 domain name 에 &lt;code>default.svc.cluster.local&lt;/code> 을 자동으로 붙여서 resolving 하려는 걸 볼 수 있다. (default namespace 에 있는 모든 Pod 들이 똑같을 것이다)&lt;/p>
&lt;p>즉, 우리는 전체 domain name 을 알 필요가 없이 Service Name 만 가지고도 DNS Lookup 을 할 수 있다.&lt;/p>
&lt;p>바로 Lookup 을 하러 가보자. 똑같이 &lt;code>kubectl exec&lt;/code> 를 할 텐데, 이번에는 &lt;code>nslookup&lt;/code> 을 해보도록 한다. domain name 은 그냥 Service Name 을 입력한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- nslookup test-cs-svc
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Server: 200.64.0.10
Address: 200.64.0.10#53
Name: test-cs-svc.default.svc.cluster.local
Address: 200.96.1.50
Name: test-cs-svc.default.svc.cluster.local
Address: 200.96.0.59
Name: test-cs-svc.default.svc.cluster.local
Address: 200.96.2.24
&lt;/code>&lt;/pre>&lt;/div>&lt;p>여러 개의 A 레코드로 이뤄진 Pod IP 목록을 얻을 수 있다. 그리고 &lt;code>test-cs-svc&lt;/code> 처럼 Service Name 만 입력했을 뿐인데 &lt;code>test-cs-svc.default.svc.cluster.local&lt;/code> 로 바뀐 것도 볼 수 있다.&lt;/p>
&lt;h2 id="head-를-달아주면요">Head 를 달아주면요?&lt;/h2>
&lt;p>이번에는 &lt;code>test-cs-svc-head&lt;/code> 라는 이름의 Service 를 하나 더 만들자. 단순히, &lt;code>spec.clusterIP: None&lt;/code> 부분만 없는 &lt;code>test-cs-svc&lt;/code> 나 다름없다. 아까 만들어 둔 파일에서 &lt;code>metadata.name&lt;/code> 부분과 &lt;code>spec.clusterIP&lt;/code> 부분만 바꿔서 &lt;code>kubectl apply -f&lt;/code> 로 적용해 보자.&lt;/p>
&lt;p>여기에 대고 똑같이 &lt;code>nslookup&lt;/code> 을 해보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- nslookup test-cs-svc-head
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Server: 200.64.0.10
Address: 200.64.0.10#53
Name: test-cs-svc-head.default.svc.cluster.local
Address: 200.68.238.114
&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 IP 는 어디서 왔을까? 바로 Service 의 Cluster IP 되시겠다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl get svc test-cs-svc-head
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
test-cs-svc-head ClusterIP 200.68.238.114 &amp;lt;none&amp;gt; 80/TCP 2m32s
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="주의할-점">주의할 점&lt;/h2>
&lt;p>&lt;code>test-cs-svc&lt;/code> 나 &lt;code>test-cs-svc-head&lt;/code> 는 DNS Lookup 에서는 차이를 보이지만, &lt;code>curl&lt;/code> 결과는 차이가 없다. 더 자세히 말하면, &lt;strong>두 요청 모두 3개의 Pod 중 1개에만 랜덤하게 전달된다는 것이다.&lt;/strong>&lt;/p>
&lt;p>다음 명령들을 반복적으로 실행해 보자. 목적지 Pod 주소가 매번 다를 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- curl test-cs-svc:80 &lt;span class="p">|&lt;/span> head -2
kubectl &lt;span class="nb">exec&lt;/span> test-deploy-7bff8c5f84-rjdm9 -it -- curl test-cs-svc-head:80 &lt;span class="p">|&lt;/span> head -2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>왜 이렇게 되는 것일까? Headless Service 의 경우, DNS Lookup 하는 A 레코드 순서가 랜덤으로 전달되고 &lt;code>curl&lt;/code> 은 그저 맨 위의 것을 쓰기 때문이다. &lt;code>nslookup&lt;/code> 을 반복적으로 해 보면 보다 더 확실해 질 것이다.&lt;/p>
&lt;h1 id="이해를-돕기-위한-기초자료">이해를 돕기 위한 기초자료&lt;/h1>
&lt;p>혹시 아직도 이해가 잘 안된다면, 기초자료로 다음을 참고해보자. &lt;del>혹은 &lt;a class="link" href="https://interp.blog/cka-exam-review/" >CKA 시험 준비&lt;/a>를 하는 것도 좋은 방법이다!&lt;/del>&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/service/" target="_blank" rel="noopener"
>K8s Service&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://kubernetes.io/ko/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener"
>K8s DNS&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>k8s Operator vs. Controller</title><link>https://interp.blog/kubernetes-operator-vs-controller/</link><pubDate>Tue, 15 Mar 2022 02:44:57 +0000</pubDate><guid>https://interp.blog/kubernetes-operator-vs-controller/</guid><description>&lt;p>쿠버네티스에서 서비스를 개발하거나 운영하다 보면 자주 접하게 될 개념 중 하나가, 바로 이 Controller 와 Operator 일 것이다. 어떤 경우에는, 동일한 서비스를 두고 &amp;lsquo;이건 Controller 야&amp;rsquo; 라고 말 할 때도 있고 &amp;lsquo;이 Operator 는&amp;hellip;&amp;rsquo; 이라고 불릴 때도 있어서 헷갈릴 수 있다. 심지어 공식 문서에서도 두 개념에 대한 비교는 하지 않고 있어서 명확한 구분이 필요한 것 같다.&lt;/p>
&lt;p>와중에 &lt;a class="link" href="https://blog.marcnuri.com/kubernetes-operator-vs-controller" target="_blank" rel="noopener"
>이 문서&lt;/a>를 발견했는데, 요약하자면 이렇다.&lt;/p>
&lt;h3 id="controller">Controller&lt;/h3>
&lt;blockquote>
&lt;p>So in the Kubernetes world, a controller will basically &lt;strong>monitor and measure the cluster resources state to adjust those resources that diverge from the desired state&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>더 줄여보면, Controller 는 (1) K8s 리소스 (중 일부) 의 상태를 체크하고 (2) 이 리소스들의 상태를 &amp;lsquo;목표 상태 (desired state)&amp;rsquo; 로 조정하는 역할을 한다.&lt;/p>
&lt;p>&lt;code>ReplicaSet&lt;/code>, &lt;code>StatefulSet&lt;/code>, &lt;code>DaemonSet&lt;/code> 이 대표적인 Controller 들이다. 속해 있는 Pod 들의 상태를 &amp;lsquo;목표한 상태&amp;rsquo; 로 조정하려고, Pod 을 추가하거나 삭제한다.&lt;/p>
&lt;h3 id="operator">Operator&lt;/h3>
&lt;p>CoreOS 에서 정의하는 Operator 는 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>An Operator is &lt;strong>a method of packaging, deploying and managing a Kubernetes application.&lt;/strong>&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>그런데 이 개념을 구현하기 위해서는 필연적으로 Controller 가 들어가게 된다. 그렇다면 Controller 와 비교했을 때 Operator 의 차이점은 무엇일까?&lt;/p>
&lt;p>저 &amp;lsquo;Kubernetes application&amp;rsquo; 에서 말하는 것은, 사용자가 직접 지정할 수 있는 CRD (Custom Resource Definition) 과 거기서 파생된 CR (Custom Resource) 까지 포함하고 있는 것이다. 아니면 정말 bare application 형태로 특정 microservice 를 관리할 때도 Operator 라고 부를 수 있겠다.&lt;/p>
&lt;p>예를 들면, Orange 라는 CRD 를 하나 만들었고, 이 Orange CR 에는 1개의 &lt;code>Service&lt;/code> 와 1개의 &lt;code>Pod&lt;/code> 이 만들어져야 한다고 해보자. 그러면 Orange CR 을 관리하는 application 을 가리킬 때는 Orange *&lt;strong>Operator*&lt;/strong> 라고 부를 수 있다. 하지만 내부에 구현된 Reconcile Loop Code 는 일종의 Orange *&lt;strong>Controller*&lt;/strong> 라고도 부를 수 있는 것이다. 실제로 Service 와 Pod 을 만드는 역할은 이 Controller 에서 이뤄지지만, 전체적으로 Orange CR 의 명세를 관리하는 것은 전체 Operator 가 담당하는 것이다.&lt;/p>
&lt;br/>
&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0712823212859607"
crossorigin="anonymous">&lt;/script>
&lt;ins class="adsbygoogle"
style="display:block"
data-ad-format="fluid"
data-ad-layout-key="-fx-q+4w-88+2u"
data-ad-client="ca-pub-0712823212859607"
data-ad-slot="1092971030">&lt;/ins>
&lt;script>
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script>
&lt;br/>
&lt;h3 id="정리하면">정리하면&lt;/h3>
&lt;p>나에게 Controller 는 기술적인 개념이고, Operator 는 좀 더 포괄적이면서 논리적인 개념으로 받아들여진다. &lt;a class="link" href="https://blog.marcnuri.com/kubernetes-operator-vs-controller" target="_blank" rel="noopener"
>문서&lt;/a>에서도 &amp;lsquo;모든 Operator 는 CR 을 관리하기 위해 쓰이는 Controller 라고 부를 수 있다.&amp;rsquo; 라고 하고 있으니까 말이다.&lt;/p>
&lt;p>그리고 Controller 나 Operator 모두 어떤 프레임워크일 뿐이지, 언어에 국한된 것은 아니라고 언급한다. Go 언어와 Python 으로 모두 구현해 본 경험이 있는 나 역시, 이 부분에 동의한다.&lt;/p>
&lt;p>다만 용어를 선택하거나 접할 때 좀 더 이해를 확실히 할 목적으로 정리하는게 더욱 낫지 않을까 하는 마음에, 이 비교글을 마친다.&lt;/p></description></item></channel></rss>
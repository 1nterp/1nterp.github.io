<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on InterP Blog</title><link>https://interp.blog/tags/linux/</link><description>Recent content in Linux on InterP Blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 30 Oct 2017 08:31:03 +0000</lastBuildDate><atom:link href="https://interp.blog/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 에서 CPU/Memory/Disk 확인</title><link>https://interp.blog/linux-%EC%97%90%EC%84%9C-cpumemorydisk-%ED%99%95%EC%9D%B8/</link><pubDate>Mon, 30 Oct 2017 08:31:03 +0000</pubDate><guid>https://interp.blog/linux-%EC%97%90%EC%84%9C-cpumemorydisk-%ED%99%95%EC%9D%B8/</guid><description>&lt;p>자주 쓰긴 하지만, 곧바로 생각나지 않을 것을 대비해서&amp;hellip; 서버실 서버 사양을 전부 체크하려다 보니 어쩔 수 없이 정리했다.&lt;/p>
&lt;h2 id="cpu--memory-확인">CPU / Memory 확인&lt;/h2>
&lt;p>CPU / Memory 는 사실 쉽다. &lt;code>/proc/cpuinfo&lt;/code> 와 &lt;code>/proc/meminfo&lt;/code> 안에 들어있기 때문이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat /proc/cpuinfo &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;model name&amp;#34;&lt;/span>  &lt;span class="p">|&lt;/span> sort -u
model name : Intel&lt;span class="o">(&lt;/span>R&lt;span class="o">)&lt;/span> Core&lt;span class="o">(&lt;/span>TM&lt;span class="o">)&lt;/span> i3-4160 CPU @ 3.60GHz
$ cat /proc/meminfo &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;MemTotal&amp;#34;&lt;/span>
MemTotal: &lt;span class="m">8040588&lt;/span> kB
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="disk-확인">Disk 확인&lt;/h2>
&lt;p>&lt;code>df&lt;/code> 는 mount 된 것만 확인이 가능해서 별로고, &lt;code>lsblk&lt;/code> 를 하면 마운트되지 않은 것까지 나온다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda 8:0 &lt;span class="m">0&lt;/span> 477G &lt;span class="m">0&lt;/span> disk
├─sda1 8:1 &lt;span class="m">0&lt;/span> 468.8G &lt;span class="m">0&lt;/span> part /
└─sda2 8:2 &lt;span class="m">0&lt;/span> 8.2G &lt;span class="m">0&lt;/span> part &lt;span class="o">[&lt;/span>SWAP&lt;span class="o">]&lt;/span>
sdb 8:16 &lt;span class="m">0&lt;/span> 2.7T &lt;span class="m">0&lt;/span> disk
&lt;span class="c1">## df 는 sdb가 보이지 않는다.&lt;/span>
$ df -h
Filesystem Size Used Avail Use% Mounted on
/dev/sda1 462G 8.4G 430G 2% /
tmpfs 79G 224K 79G 1% /dev/shm
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>mmap : 메모리를 파일처럼</title><link>https://interp.blog/mmap-memory-block-like-file/</link><pubDate>Wed, 20 Sep 2017 13:29:57 +0000</pubDate><guid>https://interp.blog/mmap-memory-block-like-file/</guid><description>&lt;p>&lt;code>mmap&lt;/code> 은 memory map 의 줄임말이다. 메모리의 특정 영역을 파일 디스크립터로 인식하게 만드는 것이다.&lt;/p>
&lt;blockquote>
&lt;p>map or unmap files or devices into memory&lt;br>
(메모리 영역을 파일이나 디바이스로 인식하게 합니다)&lt;/p>
&lt;p>– manpage of mmap&lt;/p>
&lt;/blockquote>
&lt;h2 id="사용">사용&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">mmap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">size_t&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">prot&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">off_t&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>여기서 의미가 있는 건 Length, Prot (Protection), Flag 뿐이다.&lt;/p>
&lt;ul>
&lt;li>Start 는, Kernel이 아무 곳이나 지정해도 좋다면 NULL을 입력한다.&lt;/li>
&lt;li>Offset 은, 보통 0으로 둔다. (MAP_ANONYMOUS 또는 MAP_ANON Flag가 있는 경우엔 무시된다)&lt;/li>
&lt;li>Fd 는, 연결할 파일 디스크립터를 지정한다. (MAP_ANONYMOUS 또는 MAP_ANON Flag를 통해서 &amp;lsquo;파일로 사용하지 않는다&amp;rsquo; 라고 한다면 -1을 넣어줘야 한다. (사실 안 넣어주고 무시해도 되지만 몇몇 구현에서는 넣어야 한다 카더라)&lt;/li>
&lt;/ul>
&lt;h2 id="protection">Protection&lt;/h2>
&lt;p>매핑된 메모리 영역의 사용 권한 같은 것을 정하는 것이라고 이해하자. 리눅스 파일 시스템의 권한과 비슷한 분류로 이해하면 더욱 쉽다. (물론 똑같지는 않지만)&lt;/p>
&lt;ul>
&lt;li>PROT_NONE : 메모리 영역은 아무것도 할 수 없다.&lt;/li>
&lt;li>PROT_READ : 메모리 영역을 읽을 수 있다.&lt;/li>
&lt;li>PROT_WRITE : 메모리 영역을 쓸 수 있다.&lt;/li>
&lt;li>PROT_EXEC : 메모리 영역이 실행될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이 때, 연결된 파일 디스크립터의 모드와 절대 충돌해서는 안 된다. 예를 들어 파일 디스크립터를 획득할 때는 &lt;code>w+&lt;/code> 라고 해놓고 여기서 PROT_READ 라고 하면, 예상치 못한 무언가가 일어나지 않을까?&lt;/p>
&lt;p>메모리 영역의 보호에 관련된 자세한 내용은 &lt;a class="link" href="http://man7.org/linux/man-pages/man2/mprotect.2.html" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/p>
&lt;h2 id="flag">Flag&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Flag&lt;/th>
&lt;th>사용 가능 커널&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MAP_SHARED&lt;/td>
&lt;td>–&lt;/td>
&lt;td>이 매핑을 다른 프로세스들이 공유할 수 있다. (실제 파일과 연결되어 반영된다. 하지만 자동으로 반영하지는 않고 &lt;code>msync&lt;/code> 나 &lt;code>munmap&lt;/code> 을 호출해야 반영된다.)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_PRIVATE&lt;/td>
&lt;td>–&lt;/td>
&lt;td>이 매핑을 다른 프로세스들과 공유하지 않는다. 실제 파일과도 연결되지 않으므로, &lt;code>mmap&lt;/code> 이후에 파일에 반영되는 변경 내역이 매핑된 영역에 반영되는지는 확신할 수 없다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_32BIT&lt;/td>
&lt;td>~2.4.20, 2.6&lt;/td>
&lt;td>첫 2GB 안에서 영역을 잡는다. x86-64 프로그램에서만 사용이 가능하다.&lt;br /> (초기 64-bit 프로세서에서는 context-switch 비용 절감을 위해 사용할 수 있는 옵션이겠지만, 지금은 그렇지 않으므로 굳이..)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAP_ANONYMOUS&lt;br /> MAP_ANON&lt;/td>
&lt;td>–&lt;/td>
&lt;td>파일 디스크립터로 인식하지 않는다. fd와 offset은 무시되지만, 몇몇 구현에서는 fd를 반드시 -1로 입력해야 한다. &lt;br/> ※ SHARED와 같이 사용하려면 Kernel Version 이 2.4 이하여야 한다.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>헉헉.. 아래에 더 있는데 여기까지만 해야겠다. 내가 사용하고자 하는건 사실 ANONYMOUS Flag 만 있으면 되는데 말이지.&lt;/p></description></item></channel></rss>
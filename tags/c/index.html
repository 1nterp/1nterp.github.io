<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>c &#183; InterP Blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link href=/tags/c/index.xml rel=alternate type=application/rss+xml title="InterP Blog"></head><body><nav class=nav><div class=nav-container><a href=/><h2 class=nav-title>InterP Blog</h2></a><ul></ul></div></nav><main><h1>Tag c</h1><div class=catalogue><a href=https://interp.blog/c-xunit-%EC%8B%A4%EC%8A%B5/ class=catalogue-item><div><time datetime="2017-11-29 03:28:03 +0000 UTC" class=catalogue-time>2017년 11월 29일</time><h1 class=catalogue-title>C# xUnit 실습</h1><div class=catalogue-line></div><p>졸업프로젝트도 아니고, 기말고사 대신 치룬 텀프로젝트의 마지막을 장식할 윈도우 어플리케이션을 만들기 위해 배우려 했으나 문 앞에서 서성이기만 했던 바로 그 언어, C#을 당장 써먹어야 하는 상황이 발생했다. (이런 상황이 발생한 것이 참 안타깝긴 하지만) 배움의 기회로 삼는 수 밖에 없다.
dotnet test 및 xUnit을 사용하여 .NET Core에서 C# 유닛 테스트라는 MS 문서를 기반으로 실습을 했는데, 여기서 중요한 것은, 내가 만들어야 하는 라이브러리의 Target Framework가 .NET Core 가 아니라 .NET Framework 4.</p></div></a><a href=https://interp.blog/mmap-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A5%BC-%ED%8C%8C%EC%9D%BC%EC%B2%98%EB%9F%BC/ class=catalogue-item><div><time datetime="2017-09-20 13:29:57 +0000 UTC" class=catalogue-time>2017년 9월 20일</time><h1 class=catalogue-title>mmap : 메모리를 파일처럼</h1><div class=catalogue-line></div><p>mmap은 memory map 의 줄임말이다. 메모리의 특정 영역을 파일 디스크립터로 인식하게 만드는 것이다.
map or unmap files or devices into memory
메모리 영역을 파일이나 디바이스로 인식하게 합니다
– manpage of mmap
사용 여기서 의미가 있는 건 Length, Prot (Protection), Flag 뿐이다.
Start 는, Kernel이 아무 곳이나 지정해도 좋다면 NULL을 입력한다. Offset 은, 보통 0으로 둔다. (MAP_ANONYMOUS 또는 MAP_ANON Flag가 있는 경우엔 무시된다) Fd 는, 연결할 파일 디스크립터를 지정한다.</p></div></a><a href=https://interp.blog/pthread_yield-vs-sleep/ class=catalogue-item><div><time datetime="2017-08-24 05:35:24 +0000 UTC" class=catalogue-time>2017년 8월 24일</time><h1 class=catalogue-title>pthread_yield vs. sleep</h1><div class=catalogue-line></div><p>pthread_yield() 와 sleep() 의 차이를 묻는 Stack Overflow 글을 가져와 봤다.
pthread_yield() 는, 호출한 쓰레드가 프로세서 사용을 그만두고, 스케쥴링이 될 때 까지 작업 큐(run queue)에서 기다립니다. 만약 호출되었을 때 작업 큐가 비어 있다면, 즉시 스케쥴링이 되겠죠.
sleep() 은 X초만큼 지나거나, 무시할 수 없는 시그널이 도착할 때 까지 (다른 쓰레드를 포함한) 호출 프로세스를 재웁니다.
현재 쓰레드를 실제로 지연시키고 싶지 않지만 (호출 쓰레드 대신) 다른 쓰레드에게 실행권을 넘겨주고 싶은 경우라면, sleep() 보단 pthread_yield() 가 적합할 것 같습니다.</p></div></a><a href=https://interp.blog/specify-value-to-unnamed-union-fields/ class=catalogue-item><div><time datetime="2017-05-11 01:30:36 +0000 UTC" class=catalogue-time>2017년 5월 11일</time><h1 class=catalogue-title>Specifying value to unnamed union fields</h1><div class=catalogue-line></div><p>구조체 내부에, 이름없는 union 타입의 필드에 값을 지정할 때 조심해야 할 점이 있다.
(확인해 본 건 두 버전 뿐이지만) gcc v4.7 에서는 성공적으로 컴파일이 된다. 그러나 gcc v4.4 에서는 아래와 같이 에러가 발생한다!
에러를 없애는 방법은, 내부 union을 향하는 것이라고 명시를 해 주는 수밖에 없다. 즉, union 필드에 값을 지정할 때는 중괄호로 한번 더 감싸주면 된다.</p></div></a></div><div class=pagination><span>1</span></div></main><footer><span>&copy; <time datetime="2020-07-15 22:18:58.04476534 +0000 UTC m=+0.256259541">2020</time> InterP. 이 사이트는 <a href=https://gohugo.io>Hugo</a> 로 작성되었으며 <a href=https://github.com/EmielH/tale-hugo/>Tale</a> 테마를 사용합니다!</span></footer></body></html>
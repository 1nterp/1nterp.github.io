<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BDD on InterP Blog</title><link>https://interp.blog/tags/bdd/</link><description>Recent content in BDD on InterP Blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Fri, 19 Aug 2022 09:00:36 +0900</lastBuildDate><atom:link href="https://interp.blog/tags/bdd/index.xml" rel="self" type="application/rss+xml"/><item><title>BDD in Python: Behave</title><link>https://interp.blog/bdd-in-python-behave/</link><pubDate>Fri, 19 Aug 2022 09:00:36 +0900</pubDate><guid>https://interp.blog/bdd-in-python-behave/</guid><description>&lt;p>&lt;a class="link" href="https://interp.blog/bdd-behavior-driven-development/" >지난 포스팅&lt;/a>으로 BDD 는 어떤 개발방법론이고, 어떤 면에서 이 방법이 필요한지를 정리해 봤다. &lt;/p>
&lt;p>이번 포스팅을 시작으로, 직접 다양한 언어에서 BDD 를 적용하는 방법을 정리해 볼 예정이다. 첫 시간으로는 &lt;strong>파이썬&lt;/strong> (Python) 언어를 가지고 할 것이다. Python 라이브러리 중 하나인 &lt;a class="link" href="https://behave.readthedocs.io/en/stable/" target="_blank" rel="noopener"
>behave&lt;/a> 를 통해, BDD 테스트 프레임워크를 구성하고, 예제 시나리오를 만들어서 테스트 자동화가 어떻게 이뤄질 수 있을지 알아보자.&lt;/p>
&lt;h1 id="예제-프로젝트-생성">예제 프로젝트 생성&lt;/h1>
&lt;div style="background-color: var(--body-background); width: 98%;padding: 10px;border-radius: 5px;font-size: .8em;display: flex;">
&lt;div style="width: 16px;margin-right: 7px; margin-left: 4px;">
💡
&lt;/div>
&lt;div>
모든 명령어는 리눅스 OS 또는 WSL 환경에서 실행한다고 가정한다.
&lt;/div>
&lt;/div>
&lt;p>파이썬이 설치된 환경에서 다음과 같이 디렉터리만 만들면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir behave-test &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">cd&lt;/span> behave-test
&lt;/code>&lt;/pre>&lt;/div>&lt;p>나는 virtualenv 를 이용해 환경을 분리해 두도록 하겠다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">virtualenv venv
&lt;span class="nb">source&lt;/span> venv/bin/activate
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="behave-설치">behave 설치&lt;/h1>
&lt;p>&lt;code>pip install behave&lt;/code> 만 하면 된다.&lt;/p>
&lt;h1 id="featuressteps-디렉터리-생성">&lt;code>features/steps&lt;/code> 디렉터리 생성&lt;/h1>
&lt;p>behave 는 &lt;code>features/steps&lt;/code> 를 필요로 한다. 만들어 주자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir -p features/steps
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>디렉터리만 만들고 곧장 &lt;code>behave&lt;/code> 를 실행하면, &lt;code>ConfigError: No feature files in $(pwd)/features&lt;/code> 라는 메시지가 뜰 것이다.&lt;/p>
&lt;h1 id="feature-파일-만들기">&lt;code>.feature&lt;/code> 파일 만들기&lt;/h1>
&lt;p>&lt;code>features/hotdog.feature&lt;/code> 라는 파일을 하나 만들어보자. 핫도그 12개에서 5개를 먹으면 반드시 7개가 남아야 한다는 내용이다. 단순 영어로 되어 있지만, 문법에 대해 더 자세히 알고 싶다면 &lt;a class="link" href="https://interp.tistory.com/entry/BDD-%EC%9D%98%EB%AF%B8%EC%99%80-%ED%95%84%EC%9A%94%EC%84%B1" target="_blank" rel="noopener"
>이전 포스팅&lt;/a>을 꼭 참고하고 오자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gherkin" data-lang="gherkin">&lt;span class="k">Feature:&lt;/span>&lt;span class="nf"> eat hotdogs
&lt;/span>&lt;span class="nf">
&lt;/span>&lt;span class="nf"> &lt;/span>&lt;span class="k">Scenario:&lt;/span>&lt;span class="nf"> Eat 5 out of 12
&lt;/span>&lt;span class="nf">&lt;/span>&lt;span class="k"> Given &lt;/span>&lt;span class="nf">there are &lt;/span>&lt;span class="s">12&lt;/span>&lt;span class="nf"> hotdogs
&lt;/span>&lt;span class="nf"> &lt;/span>&lt;span class="k">When &lt;/span>&lt;span class="nf">I eat &lt;/span>&lt;span class="s">5&lt;/span>&lt;span class="nf">
&lt;/span>&lt;span class="nf"> &lt;/span>&lt;span class="k">Then &lt;/span>&lt;span class="nf">there should be &lt;/span>&lt;span class="s">7&lt;/span>&lt;span class="nf"> remaining
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>이제 다시 &lt;code>behave&lt;/code> 를 실행하면, 아래 구조로 되어 있는 테스트 파일이 존재하지 않다고 하면서, 스니펫 (snippet) 을 출력해 주고 내부를 구현해 달라고 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># None&lt;/span>
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># None&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># None&lt;/span>
Failing scenarios:
features/hotdog.feature:3 Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span>
&lt;span class="m">0&lt;/span> features passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> scenarios passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> steps passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped, &lt;span class="m">3&lt;/span> undefined
Took 0m0.000s
You can implement step definitions &lt;span class="k">for&lt;/span> undefined steps with these snippets:
@given&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
def step_impl&lt;span class="o">(&lt;/span>context&lt;span class="o">)&lt;/span>:
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: Given there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
@when&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;I eat 5&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
def step_impl&lt;span class="o">(&lt;/span>context&lt;span class="o">)&lt;/span>:
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: When I eat 5&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
@then&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
def step_impl&lt;span class="o">(&lt;/span>context&lt;span class="o">)&lt;/span>:
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: Then there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="테스트-python-파일-만들기">테스트 Python 파일 만들기&lt;/h1>
&lt;p>방금 출력된 내용을 단순히 복사해서 &lt;code>features/steps/hotdog.py&lt;/code> 라는 파일을 만들었다. 참고로 파일 이름은 상관없지만 반드시 &lt;code>features/steps&lt;/code> 디렉터리에 위치해야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">behave&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="o">*&lt;/span>
&lt;span class="nd">@given&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">NotImplementedError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;STEP: Given there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@when&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;I eat 5&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">NotImplementedError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;STEP: When I eat 5&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">NotImplementedError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;STEP: Then there should be 7 remaining&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>시나리오의 각 구절 (&lt;em>GIVEN, WHEN, THEN&lt;/em>) 에 연결되는 기준은, 각 method 에 위치한 decorator 인 &lt;code>@given&lt;/code>, &lt;code>@when&lt;/code>, &lt;code>@then&lt;/code> 에 따라 달려있기 때문에, 파일 이름은 상관없고 해당 decorator 만 수정하지 않으면 된다. &lt;/p>
&lt;p>그리고 주의할 것은, 반드시 맨 위에 &lt;code>from behave import *&lt;/code> 와 같이 &lt;code>behave&lt;/code> 라이브러리를 import 해야 한다는 것이다.&lt;/p>
&lt;hr>
&lt;p>이렇게 하고 다시 &lt;code>behave&lt;/code> 를 실행하면, 예상대로 &lt;code>NotImplementedError&lt;/code> exception 이 발생하면서 traceback 이 출력되고, 테스트는 실패한 것으로 간주한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
Traceback &lt;span class="o">(&lt;/span>most recent call last&lt;span class="o">)&lt;/span>:
File &lt;span class="s2">&amp;#34;/home/behave-test/venv/lib/python3.6/site-packages/behave/model.py&amp;#34;&lt;/span>, line 1329, in run
match.run&lt;span class="o">(&lt;/span>runner.context&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;/home/behave-test/venv/lib/python3.6/site-packages/behave/matchers.py&amp;#34;&lt;/span>, line 98, in run
self.func&lt;span class="o">(&lt;/span>context, *args, **kwargs&lt;span class="o">)&lt;/span>
File &lt;span class="s2">&amp;#34;features/steps/hotdog.py&amp;#34;&lt;/span>, line 5, in step_impl
raise NotImplementedError&lt;span class="o">(&lt;/span>u&lt;span class="s1">&amp;#39;STEP: Given there are 12 hotdogs&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
NotImplementedError: STEP: Given there are &lt;span class="m">12&lt;/span> hotdogs
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># None&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># None&lt;/span>
Failing scenarios:
features/hotdog.feature:3 Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span>
&lt;span class="m">0&lt;/span> features passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> scenarios passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">0&lt;/span> steps passed, &lt;span class="m">1&lt;/span> failed, &lt;span class="m">2&lt;/span> skipped, &lt;span class="m">0&lt;/span> undefined
Took 0m0.000s
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="테스트-파일-구현하기">테스트 파일 구현하기&lt;/h1>
&lt;p>이제 테스트 파일 안의 method 를 구현해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">behave&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="o">*&lt;/span>
&lt;span class="nd">@given&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there are &lt;/span>&lt;span class="si">{num_hotdog}&lt;/span>&lt;span class="s1"> hotdogs&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_hotdog&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hotdogs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_hotdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@when&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;I eat &lt;/span>&lt;span class="si">{eaten_hotdog}&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">eaten_hotdog&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hotdogs&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">eaten_hotdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nd">@then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;there should be &lt;/span>&lt;span class="si">{remaining_hotdog}&lt;/span>&lt;span class="s1"> remaining&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">step_impl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">remaining_hotdog&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">assert&lt;/span> &lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hotdogs&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">remaining_hotdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>decorator 에서 숫자를 나타내는 부분을 &lt;code>num_hotdog&lt;/code> 같은 식으로 파라메터로 치환한 것을 주목해 달라. 이렇게 해 두면, 나중에 숫자만 바꾼 시나리오를 추가해도, 위의 세 개 method 를 재사용할 수 있는 장점이 있다.&lt;/p>
&lt;p>그리고 behave 는 &lt;a class="link" href="https://behave.readthedocs.io/en/stable/tutorial.html?highlight=eq_#context" target="_blank" rel="noopener"
>&lt;code>context&lt;/code> 라는 파라메터를 입력으로 받을 수 있도록&lt;/a> 지원한다. 해당 시나리오가 진행되는 동안 유효한 객체이며, 따라서 여기에 원하는 attribute 를 만들어 값을 저장하고 열람할 수 있다. 예제 시나리오에서는, 남은 핫도그 개수를 &lt;code>context.hotdogs&lt;/code> 로 보관한다.&lt;/p>
&lt;blockquote>
&lt;p>엄밀히 말하면, when 에 해당하는 method 에서 핫도그 개수를 차감하는 부분은 &lt;strong>여기서 구현하면 안 된다&lt;/strong>. 실제 업무에 사용하려면, 여기서 &lt;strong>&amp;lsquo;실제로 구현한 로직&amp;rsquo; 을&lt;/strong> &lt;strong>호출해야&lt;/strong> 한다. 그래야 검증을 할 수 있으니 말이다!&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>다시 &lt;code>behave&lt;/code> 를 실행하면, 이제야 모든 테스트가 통과되었음을 알 수 있다!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># features/steps/hotdog.py:8 0.000s&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># features/steps/hotdog.py:12 0.000s&lt;/span>
&lt;span class="m">1&lt;/span> feature passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">1&lt;/span> scenario passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">3&lt;/span> steps passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped, &lt;span class="m">0&lt;/span> undefined
Took 0m0.000s
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="숫자만-바꾼-시나리오를-추가하면">숫자만 바꾼 시나리오를 추가하면?&lt;/h1>
&lt;p>시나리오&lt;strong>만&lt;/strong> 추가하더라도 이미 재사용이 가능한 형태로 테스트 method 를 구현했기 때문에, 아래처럼 성공적으로 작동한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ behave
Feature: eat hotdogs &lt;span class="c1"># features/hotdog.feature:1&lt;/span>
Scenario: Eat &lt;span class="m">5&lt;/span> out of &lt;span class="m">12&lt;/span> &lt;span class="c1"># features/hotdog.feature:3&lt;/span>
Given there are &lt;span class="m">12&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
When I eat &lt;span class="m">5&lt;/span> &lt;span class="c1"># features/steps/hotdog.py:8 0.000s&lt;/span>
Then there should be &lt;span class="m">7&lt;/span> remaining &lt;span class="c1"># features/steps/hotdog.py:12 0.000s&lt;/span>
Scenario: Eat &lt;span class="m">10&lt;/span> out of &lt;span class="m">20&lt;/span> &lt;span class="c1"># features/hotdog.feature:8&lt;/span>
Given there are &lt;span class="m">20&lt;/span> hotdogs &lt;span class="c1"># features/steps/hotdog.py:3 0.000s&lt;/span>
When I eat &lt;span class="m">10&lt;/span> &lt;span class="c1"># features/steps/hotdog.py:8 0.000s&lt;/span>
Then there should be &lt;span class="m">10&lt;/span> remaining &lt;span class="c1"># features/steps/hotdog.py:12 0.000s&lt;/span>
&lt;span class="m">1&lt;/span> feature passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">2&lt;/span> scenarios passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped
&lt;span class="m">6&lt;/span> steps passed, &lt;span class="m">0&lt;/span> failed, &lt;span class="m">0&lt;/span> skipped, &lt;span class="m">0&lt;/span> undefined
Took 0m0.001s
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>이제 이 테스트 케이스를 구현할 때 mock 라이브러리를 통해 mocking 을 하면, 기능 검증을 충분히 할 수 있을 것이다. 시나리오를 추가하는 것은 개발자 뿐만이 아닌 비 개발자나 QA 도 할 수 있어야 하고, 개발자는 그렇게 푸시된 새로운 시나리오를 보고 커버리지를 달성하기 위해 테스트에 좀 더 집중할 수 있을 것이다.&lt;/p>
&lt;p>한 가지 맹점은, 기존 시나리오가 바뀌면 테스트 케이스 개발 과정에서 엄청난 고통이 뒤따를 수 있단 것이다. 따라서 (전에도 말했지만) 항상 시나리오는 합의 하에 신중히 추가되어야 한다.&lt;/p>
&lt;p>다음 시간에는 golang 으로 똑같은 시나리오를 테스트 해 볼 예정이다.&lt;/p></description></item><item><title>BDD (Behavior-driven Development) 소개</title><link>https://interp.blog/bdd-behavior-driven-development/</link><pubDate>Thu, 11 Aug 2022 16:31:36 +0000</pubDate><guid>https://interp.blog/bdd-behavior-driven-development/</guid><description>&lt;img src="https://interp.blog/bdd-behavior-driven-development/feature.jpg" alt="Featured image of post BDD (Behavior-driven Development) 소개" />&lt;p>작년 즈음에, 팀에 테스트 주도 개발 (Test-driven Development,TDD) 에 대해 어떤 강력한 합의 (?) 가 필요하지 않을까라고 팀장님께 주장했던 기억이 났다. &lt;del>일단 나부터 좀 잘 해야 할텐데&lt;/del> 그런데 그걸 언제 또 기억하셔서는, 올 초에 ‘TDD 말고 BDD 에 대해 조사해서 차기 프로젝트에 녹여보면 어떻겠냐’ 는 제안을 하셨다. 두 눈을 동그랗게 뜬 채 음성 채팅으로 ‘그것이… 무엇이죠?!’ 라고 되물었던 슬픈 기억이 난다.&lt;/p>
&lt;p>지금은 프로젝트를 진행 중인데 거의 설계 단계를 지났고, 프로토타이핑이 끝나간다. 바쁜 시간이 지나고서야 팀장님의 부름이 닿아, 뒤늦게나마 우리가 쥐고 있는 요구사항이 무엇인지, 어떻게 적용할 수 있는지 찾아보고 있다. 그런데 이 결과물을 팀원들에게 공유하려면 내가 먼저 ‘BDD 를 왜 써야 하는지’ 를 이해하고 설명할 수 있어야 하기에, 블로그에 정리해 보려고 한다.&lt;/p>
&lt;h2 id="bdd-란">BDD 란?&lt;/h2>
&lt;p>BDD 는 &lt;strong>Behavior-driven Development&lt;/strong>, 즉, 제품이나 서비스의 행동에 초점을 맞춘 개발 방법론이다. 소프트웨어가 어떤 일을 해내야하는지가 가장 중요하며, 개발과 테스팅이 거기에 맞춰 진행되어야 한다는 것이다. &lt;del>뭐, 당연한 소리 아닌가? 다들 이렇게 다 하잖아요, 그쵸?&lt;/del>&lt;/p>
&lt;p>&lt;a class="link" href="https://cucumber.io/docs/bdd/" target="_blank" rel="noopener"
>Cucumber 에서의 BDD 정의&lt;/a>는 다음과 같다.&lt;/p>
&lt;blockquote>
&lt;p>BDD is a way for software teams to work that closes the gap between business people and technical people by:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Encouraging collaboration&lt;/strong> across roles to build shared understanding of the problem to be solved&lt;/li>
&lt;li>Working in rapid, small iterations to increase feedback and the flow of value&lt;/li>
&lt;li>&lt;strong>Producing system documentation&lt;/strong> that is automatically checked against the system’s behavior&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://inviqa.com/blog/bdd-guide#what-is-it" target="_blank" rel="noopener"
>Inviqa 의 BDD 블로그 포스트&lt;/a>에서는 이렇게 정의했다.&lt;/p>
&lt;blockquote>
&lt;p>BDD is a process designed to aid the management and the delivery of software development projects by improving communication between engineers and business professionals. In so doing, BDD ensures all development projects remain focused on delivering what the business actually needs while meeting all requirements of the user.&lt;/p>
&lt;/blockquote>
&lt;p>잘 보면 collaboration, communication 이 겹쳐 보인다.&lt;/p>
&lt;h2 id="bdd-적용-방식">BDD 적용 방식&lt;/h2>
&lt;p>여기서 나는 BDD 의 Best Practice 나 심지어 Gherkin 문법에 대해서 자세히 조사해 정리하지 않을 것이다. 왜냐하면 나도 배우는 입장이고, 이 포스팅의 목적은 ‘BDD 가 정말 필요할까요?’ 를 밝히는 것이기 때문이다.&lt;/p>
&lt;p>정말 필요하다고 생각하면, 그때서야 더 깊이 찾아보면 될 일이다.&lt;/p>
&lt;h3 id="discovery">Discovery&lt;/h3>
&lt;p>User Story 에서 실제 예제를 만든다. 이 예제는 합의되어야 한다.&lt;/p>
&lt;p>이 과정은 협업 단계이다. 워크샵을 통해 아이디어를 모으고, 구체적인 예시를 들어야 한다. 이 과정을 통해 어떤 기능이 정말 필요한지 우선순위를 정할 수도 있다. User Story 의 범위를 조정하는 작업이기도 하다.&lt;/p>
&lt;p>이런 과정을 통해, 우리가 뭘 해야 할지 결정하기 위해 빠진 정보를 알아낼 수도 있다. 처음부터 모든 정보를 들고 요구사항을 구체화할 수 없기 때문이다. 다시 채워서, 다시 이야기해야 한다.&lt;/p>
&lt;p>다시 말하지만, 여기서 산출된 예제들은 합의된 것이어야만 한다. 그렇지 않으면 다음 사이클에 영향을 끼친다.&lt;/p>
&lt;h3 id="formulation">Formulation&lt;/h3>
&lt;p>예제를 자동화 가능한 형태로 문서화한다. 이 문서는 합의되어야 한다.&lt;/p>
&lt;p>문서는 Gherkin 문법 (GIVEN - WHEN - THEN) 으로 정형화한다. 이 문서 내용을 다시 모든 조직원들에게 공유해, 이렇게 테스트할 것이라고 검증받아야 한다. (다시 말하지만, 이 문서도 합의되어야 한다.)&lt;/p>
&lt;h3 id="automation">Automation&lt;/h3>
&lt;p>문서에 맞춰 구현하고 테스트한다.&lt;/p>
&lt;p>언어 별로 다양한 라이브러리/패키지가 지원되며, BDD 또는 Cucumber, Gherkin 으로 검색하면 관련 자료가 늘 나왔었다. 내가 확인한 건 일단 Java (&lt;a class="link" href="https://site.mockito.org/" target="_blank" rel="noopener"
>Mockito&lt;/a>), Python (&lt;a class="link" href="https://behave.readthedocs.io/en/stable/" target="_blank" rel="noopener"
>behave&lt;/a>), Go (&lt;a class="link" href="https://github.com/cucumber/godog" target="_blank" rel="noopener"
>godog&lt;/a>) 정도가 있다.&lt;/p>
&lt;p>Gherkin 문법으로 정형화된 문서를 입력으로, 코드 템플릿을 출력하거나 코드 템플릿과 일치하는 테스트 케이스가 존재하면 바로 테스트 결과를 출력한다. (behave, godog 만 테스트해 봤다) 각 언어 별 실제 사용 예제는 블로그에 따로 정리할 예정이다.&lt;/p>
&lt;h3 id="gherkin-format">Gherkin Format&lt;/h3>
&lt;p>그럼 도대체 Gherkin &lt;del>오이피클&lt;/del> 은 어떻게 쓰는가? 가장 간단한 방법은 세 문장으로 나타내는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">Given there are 12 cucumbers
When I eat 5 cucumbers
Then I should have 7 cucumbers
&lt;/code>&lt;/pre>&lt;/div>&lt;p>GIVEN 은 전제 조건이고, WHEN 은 액션, THEN 은 그 결과이다. 이 부분을 테스트 케이스로 만드려면,&lt;/p>
&lt;ul>
&lt;li>GIVEN : 전제조건이 되도록 환경을 구성하거나 mocking 한다.&lt;/li>
&lt;li>WHEN : 액션을 가한다. (함수를 호출하거나)&lt;/li>
&lt;li>THEN : 실제 결과가 명세에서 예상한 대로 나왔는지 검증하는 코드가 필요하다.&lt;/li>
&lt;/ul>
&lt;p>물론 세 가지 키워드 말고도 다양한 방법으로 ‘예제’ 를 표현할 수 있다. 자세한 문법 내용은 &lt;a class="link" href="https://cucumber.io/docs/gherkin/reference/" target="_blank" rel="noopener"
>여기&lt;/a>를 참고하자.&lt;/p>
&lt;h2 id="내가-생각하는-bdd">내가 생각하는 BDD&lt;/h2>
&lt;p>BDD 가 어떤 것인지 맛을 봤으니, 이제는 왜 이 방법론이 필요한지 내 생각과 경험을 얹어 설명해 보겠다.&lt;/p>
&lt;blockquote>
&lt;p>보통 프로젝트를 시작하거나 하면 TDD 를 기본으로 깔고 시작한다.&lt;/p>
&lt;p>우선 개발자는 요구사항에 맞는 테스트 케이스를 만든다. 그 요구사항은 프로젝트 안에서 개인에게 할당된 작업 내용에 관한 것일 수도 있고, 정말 고객이나 비즈니스에서 원하는 기능에 대한 요구사항 명세일 수도 있다.&lt;/p>
&lt;p>테스트 케이스를 먼저 만들고, 테스트 케이스는 물론 실패한다. 실패하지 않게 구현하고, 박수를 짝짝 치고 PR 을 연다. 리뷰를 받고 파이프라인을 통과해 프로덕션 브랜치로 기능 (또는 수정 내역) 이 반영된다.&lt;/p>
&lt;/blockquote>
&lt;p>문장 자체로만 보면 아주 당연하고 아름다운 순서이겠지만, 여기서 뭔가 꺼림칙한 부분이 생기게 된다. 나는 크게 두 가지가 걸리는데,&lt;/p>
&lt;ol>
&lt;li>&lt;strong>테스트 케이스가 요구사항을 온전히 반영했는지 검증이 가능한가?&lt;/strong> 사람은 오류와 상상의 동물이라서, 요구사항을 아무렇게나 해석해서 테스트 케이스를 만들어 둘 수 있다. 물론 코드 리뷰하면 다 나오는거, 맞다. 그런데 우리가 리뷰해야 할 것은 리펙터링과 모킹 (mocking) 이 복잡하게 뒤섞인 ‘코드’ 란 말이다. 정말 그 오류를 잘 찾아낼 수 있나?&lt;/li>
&lt;li>&lt;strong>요구사항은 대체 어떻게 만드는가?&lt;/strong> 이건 좀 더 근원적인 질문인데, 요구사항이라는 것은 언제나 ‘고객/비즈니스-개발 조직’ 또는 ‘프로젝트 리더-프로젝트 개발자’ 사이에 정량적으로 합의된 내용이어야 한다. 티켓에 적힌 내용, 회의록이 합의된 결과 아니냐고? 글쎄… 그걸 다 모아다가 볼 수 있나? UML 은 어떨까? UML 다이어그램에 대한 지식이 없는 사람은 그럼 요구사항 리뷰를 못 하는 걸까?
&lt;ul>
&lt;li>우리는 늘 이런 걸 겪지 않았던가? “&lt;em>그건 제가 하고 싶은 말이 아니었어요!&lt;/em>” “&lt;em>그건 제가 원하던 것이 아니었어요!&lt;/em>” 라는 말… 어정쩡하고 단방향의 요구사항은 늘 화를 불러오게 되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이런 방식대로라면 (1) 사용자가 정말 원하는 &lt;strong>요구사항을 ‘요구사항 명세’ 가 100% 커버하는지&lt;/strong> (결과물이 너무 다양하거나 복잡하기 때문에) 쉽게 알 수도 없고 (2) &lt;strong>요구사항 명세가 테스트 케이스로 변환되어 100% 기능하고 있는지&lt;/strong>도 쉽게 알 수 없다는 것이다. 내가 ‘쉽게’ 라는 말을 붙이긴 했지만, 현실에서는 거의 불가능하다고 본다.&lt;/p>
&lt;p>내가 봤을 때 BDD 는 두 가지 문제를 짚어 나가는데 효과적이다. 개발 외 조직으로부터 사용자 요구사항을 받는 것 말고도, 개발조직 내부에서 요구사항을 합의하고 기능을 검증할 때도 효과적이라는 점 역시 덧붙이고 싶다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>이렇게 설명해놓고 보니, 일선 개발자에겐 TDD 의 확장 개념이라고 여기게 될까 조심스럽다. 어차피 자연어로 된 문서를 소스로 한다는 점만 틀리지, 거기서 생성된 테스트 케이스의 코드를 구현하고 Regression 을 돌리는 작업이 기존에 하던 TDD 와 무엇이 다르냐고 할 수도 있겠다.&lt;/p>
&lt;p>하지만 TDD 를 시작하기 이전에 ‘어떻게 테스트 케이스를 만들죠’ 라는 부분에 대한 하나의 대안으로 생각해주면 좋겠다. 이 방법이 부상하기 전부터, 소프트웨어 공학에서 제시한 UML 명세나 수 많은 다이어그램에 기초해서 테스트 케이스를 만들지 않았던가. 조직에서 이런 방식으로 이미 명세-테스트 케이스 자동화가 되어 있다면 정말로 BDD 가 필요없을 순 있겠다. 하지만, UML 부터 무척 복잡하다고 느끼는 것은 비단 나 뿐일까?&lt;/p>
&lt;p>&lt;strong>BDD 는 확실히 사용자가 정말 원하는 예제를 찾고, 보완하는데 불편함이 적다.&lt;/strong> 누구나 읽을 수 있는 언어로 되어 있으니, 비즈니스를 다루는 직원은 뭔가를 더 배울 필요가 없다. 개발자는 나름 규격화된 문서를 가지고 테스트 케이스를 만들 수 있다. 즉, 이 방법론은 조직 전체에 걸쳐 광범위한 개발 방법론이라고 볼 수 있겠다.&lt;/p>
&lt;p>다음 포스팅은, 내가 실제로 구동해 본 behave 나 godog 예제가 될지, 아니면 현업에서 적용해보고 난 뒤 받은 피드백에 대해서 이야기할지 고민 중이다. 아직 이렇다 할 피드백이 없어서, 아마도 실제로 따라 써 볼 수 있는 글을 쓰는게 현실적이리라 본다.&lt;/p></description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>정렬 on InterP Ink</title><link>https://interp.ink/tags/%EC%A0%95%EB%A0%AC/</link><description>Recent content in 정렬 on InterP Ink</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 23 Apr 2018 01:36:57 +0000</lastBuildDate><atom:link href="https://interp.ink/tags/%EC%A0%95%EB%A0%AC/index.xml" rel="self" type="application/rss+xml"/><item><title>Timsort</title><link>https://interp.ink/timsort/</link><pubDate>Mon, 23 Apr 2018 01:36:57 +0000</pubDate><guid>https://interp.ink/timsort/</guid><description>학부에서 알고리즘 수업을 들으면, 가장 빠른 정렬 알고리즘이 뭐냐는 질문에 쉽게 Quicksort 라고 답할 수 있겠다. 실제로 현업에서도 적용하기 가장 편하기 때문에 많이 차용되는 편이다. 그런데 모든 문제를 쉽게 풀 수 있는 은탄은 세상에 존재하지 않듯, Quicksort 역시 특정 케이스에서는 성능이 낮게 나오는 경우가 있다. 더 심각한(?) 것은, 이 특정 케이스가 현실에서는 꽤나 자주 발생한다는 것이다.
그 케이스란 바로 ‘거의 정렬된 데이터’ 이다. 거의 정렬된 데이터라면 pivoting – partitioning 을 반복할 필요도 없이 Bubble Sort 나, 심지어는 Insertion Sort 를 해도 된다.</description></item></channel></rss>
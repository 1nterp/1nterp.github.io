<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lock on InterP Ink</title><link>https://interp.blog/tags/lock/</link><description>Recent content in lock on InterP Ink</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 24 Apr 2018 02:31:38 +0000</lastBuildDate><atom:link href="https://interp.blog/tags/lock/index.xml" rel="self" type="application/rss+xml"/><item><title>Atomic Operation 으로 하는 동시성 제어</title><link>https://interp.blog/atomic-operation-%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/</link><pubDate>Tue, 24 Apr 2018 02:31:38 +0000</pubDate><guid>https://interp.blog/atomic-operation-%EC%9C%BC%EB%A1%9C-%ED%95%98%EB%8A%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/</guid><description>Test-And-Set (TAS) TAS 를 이용해서 간단한 동시성 제어를 할 수 있다. testAndSet 이라는 function 을 가지고 아래의 do...while 문을 쓰레드 A, B 에서 동시에 호출한다고 해 보자. 이 때 lock 은 같은 변수이다.
우선 TestAndSet() 은 다음과 같은 일을 한다. 말 그대로 ‘지금 값이 무엇인지 검사하고, 값을 바꾼다’ 는 것이다.
lock의 현재 값을 저장해 둔다. lock의 값을 true 로 설정한다. 저장한 lock 의 값을 반환한다. 그럼 이걸로 어떻게 아래 block 의 critical section 에 대한 동시성 제어를 할 수 있을까?</description></item><item><title>pthread_mutex_unlock() 중복 호출</title><link>https://interp.blog/pthread_mutex_unlock-%EC%A4%91%EB%B3%B5-%ED%98%B8%EC%B6%9C/</link><pubDate>Mon, 07 Nov 2016 05:56:21 +0000</pubDate><guid>https://interp.blog/pthread_mutex_unlock-%EC%A4%91%EB%B3%B5-%ED%98%B8%EC%B6%9C/</guid><description>따라서, pthread_mutex가 이미 unlock되었다면 unlock() 함수를 호출하지 않도록 해야 한다.</description></item></channel></rss>